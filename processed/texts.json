[{"filePath":"https:--gama-platform.org--wiki-AttachingSkills.txt","text":"Attaching SkillsGAMA allows the modeler to increase the capabilities of the GAMA agents by attaching skills to them through the facet skills. Skills are built-in modules that provide a set of related built-in attributes and built-in actions (in addition to those already proposed by GAMA) to the species that declare them. The list of the available skills can be found on the dedicated page.\nIndex​\n\nThe moving skill\nOther skills\nExample of implementation\n\nSkills​\nA declaration of skill is done by filling the skills facet in the species definition:\nspecies my_species skills: [skill1,skill2] {}\nA very useful and common skill is the moving skill.\nspecies my_species skills: [moving] {}\nOnce your species has the moving skill, it earns automatically the following attributes: speed, heading, destination and the following actions: move, goto, follow, wander and wander_3D.\nAttributes:​\n\nspeed (float) designs the speed of the agent, in m/s.\nheading (int) designs the heading of an agent in degrees, which means that is the maximum angle the agent can turn around each step.\ndestination (point) is the updated destination of the agent, with respect to its speed and heading. It's a read-only attribute, you can't change its value.\n\nActions:​\nfollow​\nmoves the agent along a given path passed in the arguments.\n\nreturns: path\nspeed (float): the speed to use for this move (replaces the current value of speed)\npath (path): a path to be followed.\nmove_weights (map): Weights used for the moving.\nreturn_path (boolean): if true, return the path followed (by default: false)\n\ngoto​\nmoves the agent towards the target passed in the arguments.\n\nreturns: path\ntarget (agent,point,geometry): the location or entity towards which to move.\nspeed (float): the speed to use for this move (replaces the current value of speed)\non (graph): graph that restrains this move\nrecompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true)\nreturn_path (boolean): if true, return the path followed (by default: false)\nmove_weights (map): Weights used for the moving.\n\nmove​\nmoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.\n\nreturns: path\nspeed (float): the speed to use for this move (replaces the current value of speed)\nheading (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)\nbounds (geometry,agent): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\n\nwander​\nMoves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.\n\nreturns: void\nspeed (float): the speed to use for this move (replaces the current value of speed)\namplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)\nbounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\n\nwander_3D​\nMoves the agent towards a random location (3D point) at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.\n\nreturns: path\nspeed (float): the speed to use for this move (replaces the current value of speed)\namplitude (int): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)\nz_max (int): the maximum altitude (z) the geometry can reach\nbounds (agent,geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\n\nOther skills​\nA lot of other skills are available. Some of them can be built in skills, integrated by default in GAMA, other are linked to additional plugins.\nThis is the list of skills:\nAdvanced_driving, communication, driving, GAMASQL, graphic, grid, MDXSKILL, moving, moving3D, physical3D, skill_road, skill_road, skill_road_node, SQLSKILL\nExample​\nWe can now build a model using the skill moving. Let's design 2 species, one is \"species_red\", the other is \"species_green\".\nSpecies_green agents are moving randomly with a certain speed and a certain heading.\nSpecies_red agents wait for a species_green agent to be in a certain range of distance. Once it is the case, the agent move toward the species_green agent. A line link the red_species agent and its target.\n\nHere is an example of implementation:\nmodel green_and_red_speciesglobal{    float distance_to_intercept <- 10.0;    int number_of_green_species <- 50;    int number_of_red_species <- 50;\t    init {\tcreate speciesA number:number_of_green_species;\tcreate speciesB number:number_of_red_species;    }}species speciesA skills:[moving] {    init {\tspeed <- 1.0;    }    reflex move {\tdo wander amplitude: 90.0;    }    aspect default {\tdraw circle(1) color:#green border: #black;    }}species speciesB skills:[moving] {    speciesA target;    init {\tspeed <- 0.0;\theading <- 90.0;    }    reflex search_target when: target=nil {\task speciesA at_distance(distance_to_intercept) {\t    myself.target <- self;\t}    }    reflex follow when: target!=nil {\tspeed <- 0.8;\tdo goto target: target;    }    aspect default {\tdraw circle(1) color:#red border: #black;\tif (target!=nil) {\t    draw polyline([self.location,target.location]) color:#black;\t}    }}experiment my_experiment type: gui {    output{\tdisplay myDisplay {\t    species speciesA aspect:default;\t    species speciesB aspect:default;\t}    }}"},{"filePath":"https:--gama-platform.org--wiki-BDIAgents.txt","text":"BDI AgentsThis tutorial aims at presenting the use of BDI agents in GAMA. In particular, this tutorial shows how to define a BDI agents, then to add social relation between BDI agents, to add emotions and a personality to the agents and finally social norms, obligations and enforcements. These notions come from the BEN architecture, described in details in the page Using BEN architecture.\nIf you are not familiar with agent-based models or GAMA we advise you to have a look at the prey-predator model first.\nModel Overview​\nThe model built in this tutorial concerns gold miners that try to find and sell gold nuggets. More precisely, we consider that several gold mines containing a certain amount of gold nuggets are located in the environment. In the same way, a market where the miners can sell their gold nuggets is located in the environment. The gold miners try to find gold mines, to extract gold nuggets from them and to sell the gold extracted nuggets at the market.\nStep List​\nThis tutorial is composed of 5 steps corresponding to 5 models which are incremental representation of the same model, starting with the simplest model 1 and finishing with the latest one, model 5. For each step, we will present its purpose, an explicit formulation, and the corresponding GAML code.\n\nCreation of the basic model: gold mines and market\nDefinition of the BDI miners\nDefinition of social relations between miners\nUse of emotions and personality for the miners\nAdding norms, obligations and enforcement\n"},{"filePath":"https:--gama-platform.org--wiki-BDIAgents_step1.txt","text":"1. Skeleton modelThis first step consists in defining the skeleton model with the gold mines and the gold market.\nFormulation​\n\nDefinition of the gold mine species\nDefinition of the market species\nCreation of the gold mine and market agents\nDefinition of a display with the gold mines and the market\n\nModel Definition​\nspecies​\nIn this first model, we have to define two species of agents: the gold_mine agents and the market ones. These agents will not have a particular behavior, they will just be displayed.\nFor the gold mine species, we define a new attribute: quantity of type int, with for initial value a random integer between 1 and 20. We also define an aspect named default that displays the gold mine as a triangle with a gray color if the gold mine is empty, yellow otherwise. The size of the triangle depends on the quantity of gold nuggets in the mine.\nConcerning the market species, we define a new attribute: golds of type int. We define as well an aspect named default that displays the market as a blue square.\nspecies gold_mine {    int quantity <- rnd(1,20);    aspect default {\tdraw triangle(200 + quantity * 50) color: (quantity > 0) ? #yellow : #gray border: #black;\t    }}species market {    int golds;    aspect default {        draw square(1000) color: #black ;    }}\nglobal variables​\nWe define two global variables for the model: one called nb_mines that will be used to define the number of mines and that will be set to 10. One call the_market that will represent the market agent (that will be unique).\nIn addition, we define the duration of a simulation step to 10 minutes, and we define the shape of the environment by a square with a side size of 20 kilometers.\nglobal {    int nb_mines <- 10;     market the_market;    float step <- 10#mn;    geometry shape <- square(20 #km);}\nglobal init​\nAt the initialization of the model, we create a market agent and nb_mines gold mine agents. For the market agent, we set the value of the the_market agent with the created agent.\nglobal {    ...    init {        create market {\t    the_market <- self;\t}\tcreate gold_mine number: nb_mines;    }}\ndisplay​\nWe define a display to visualize the market and gold mine agents. We use for that the classic species keyword. In order to optimize the display, we use an OpenGL display (facet type: opengl).\nIn the experiment block:\noutput {    display map type: opengl {\tspecies market ;\tspecies gold_mine ;   }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%201.gaml"},{"filePath":"https:--gama-platform.org--wiki-BDIAgents_step2.txt","text":"2. BDI AgentsThis second step consists in defining the gold miner agents using the GAMA BDI architecture.\nFormulation​\n\nDefinition of global predicates\nDefinition of the gold miner species\nDefinition of the gold miner perceptions\nDefinition of the gold miner rules\nDefinition of the gold miner plans\nCreation and display of the gold miners\n\nBDI agents​\nA classic paradigm to formalize the internal architecture of cognitive agents in Agent-Oriented Software Engineering is the BDI (Belief-Desire-Intention) paradigm. This paradigm, based on the philosophy of action (Bratman, 1987), allows to design expressive and realistic agents.\nThe concepts of Belief-Desire-Intention can be summarized as follow for the Gold Miner: the Miner agent has a general desire to find gold. As it is the only thing it wants at the beginning, it is its initial intention (what it is currently doing). To find gold, it wanders around (its plan is to wander). When it perceives some gold nuggets, it stores this information (it has a new belief about the existence and location of this gold nugget), and it adopts a new desire (it wants to extract the gold). When it perceives a gold nugget, the intention to find gold is put on hold and a new intention is selected (to extract gold). To achieve this intention, the plan has two steps, i.e. two new (sub)intentions: to choose a gold nugget to extract (among its known gold nuggets) and to go and take it. And so on.\nIn GAMA, we propose a control architecture for agents based on this paradigm. This control architecture provides the agents with 3 databases linked to the agent cognition (that are 3 additional variables):\n\nbelief_base (what it knows): the internal knowledge the agent has about the world or about its internal state, updated during the simulation. A belief can concern any type of information (a quantity, a location, a boolean value, etc).\ndesire_base (what it wants): objectives that the agent would like to accomplish, also updated during the simulation. Desires can have hierarchical links (sub/super desires) when a desire is created as an intermediary objective.\nintention_base (what it is doing): what the agent has chosen to do. The current intention will determine the selected plan. Intentions can be put on hold (for example when they require a sub-intention to be achieved).\n\nIn addition, the BDI architecture provides agents with three types of behavior structures:\n\nPerception: a perception is a function executed at each iteration to update the agent's Belief base, to know the changes in its environment (the world, the other agents and itself). The agent can perceive other agents up to a fixed distance or inside a specific geometry.\nRule: a rule is a function executed at each iteration to infer new desires or beliefs from the agent's current beliefs and desires, i.e. a new desire or belief can emerge from the existing ones.\nPlan: the agent has a set of plans, which are behaviors defined to accomplish specific intentions. Plans can be instantaneous and/or persistent and may have a priority value (that can be dynamic), used to select a plan when several possible plans are available to accomplish the same intention.\n\nTo be more precise on the behavior of BDI agents (what the agent is going to do when activated), this one is composed of 10 steps (see (Caillou et al., 2017) and (Taillandier et al., 2016) for more details):\n\nPerceive: Perceptions are executed.\nRule: Rules are executed.\nIs one of my intentions achieved?: If one of my intentions is achieved, sets the current plan to nil and removes the intention from the intention base. If the achieved intention's super-intention is on hold, it is reactivated (its sub-intention just got completed).\nDo I keep the current intention?: To take into account the environment instability, an intention-persistence coefficient is applied: with this probability, the current intention is removed from the intention stack.\nDo I have a current plan?: If I have a current plan, just execute it. Similarly to intentions, a plan-persistence coefficient is defined: with this probability, the current plan is just dropped.\nChoose a desire as new current intention: If the current intention is on hold (or the intention base is empty), choose a desire as new current intention. The new selected intention is the desire with higher priority.\nChoose a plan as a new current plan: The new current plan is selected among the plans compatible with the current intention (and if their activation condition is checked) and with the highest priority.\nExecute the plan: The current plan is executed.\nIs my plan finished?: To allow persistent plans, a plan may have a termination condition. If it is not reached, the same plan will be kept for the next iteration.\nWas my plan instantaneous?: Most agent-based simulation frameworks (GAMA included) are synchronous frameworks using steps. One consequence is that it may be useful to apply several plans during one single step. For example, if a step represents a day or a year, it would be unrealistic for an agent to spend one step to apply a plan like \"choose a destination\". This kind of plans (mostly reasoning plans) can be defined as instantaneous: in this case a new thinking loop is applied during the same agent step.\n\nThe architecture introduces two new main types of variables related to cognition:\n\n\npredicate: a predicate unifies the representation of the information about the world. It can represent a situation, an event or an action.\n\n\nmental_state: it represents the element (belief, desire, intention) manipulated by the agent and the architecture to take a decision. A mental state is composed of a modality, a predicate or another mental state, a real value and a lifetime. The modality indicates the type of the mental state (e.g. a belief or a desire), the predicate indicates the fact about which is this mental state (a mental state can also be about another mental state like a belief about a belief, etc), the value has a different interpretation depending on the modality and finally, the lifetime indicates the duration of the mental state (it can be infinite).\n\n\nModel Definition​\npredicates​\nAs a first step of the integration of the BDI agents in our model, we define a set of global predicates that will represent all the information that will be manipulated by the miner agents:\n\nmine_location: represents the information about the location of a gold mine.\nchoose_gold_mine: represents the information that the miner wants to choose a gold mine.\nhas_gold: represents the information that the miner has a gold nugget.\nfind_gold: represents the information that the miner wants to find gold.\nsell_gold: represents the information that the miner wants to sell gold.\n\nWe define as well two global string (mine_at_location and empty_mine_location) for simplification purpose and to avoid misspellings.\nglobal {    ...    string mine_at_location <- \"mine_at_location\";    string empty_mine_location <- \"empty_mine_location\";\t    predicate mine_location <- new_predicate(mine_at_location) ;    predicate choose_gold_mine <- new_predicate(\"choose a gold mine\");    predicate has_gold <- new_predicate(\"extract gold\");    predicate find_gold <- new_predicate(\"find gold\") ;    predicate sell_gold <- new_predicate(\"sell gold\") ;    ...}\nskeleton of the miner species​\nWe then define a miner species with the moving skill and the simple_bdi control architecture. The miner agents have 5 variables:\n\nview_dist: distance of perception of the miner agent\nspeed: speed of the agent\nmy_color: the color of the agent (random color)\ntarget: where the agent wants to go\ngold_sold: the number of gold nuggets sold by the agent\n\nWe define the init block of the species such as to add at the creation of the agent the desire to find gold nuggets (find_gold predicate). we use for that the add_desire action provides with the BDI architecture.\nAt last, we define an aspect in which we draw the agent with its my_color color and with a depth that depends on the number of gold nuggets collected. We then add a circle around the miner of radius view_dist to visualize the distance of perception of each agent, we set the wireframe facet to true in order to draw only its border.\nspecies miner skills: [moving] control:simple_bdi {    float view_dist <- 1000.0;    float speed <- 2#km/#h;    rgb my_color <- rnd_color(255);    point target;    int gold_sold;\t    init {\tdo add_desire(find_gold);    }    aspect default {        draw circle(200) color: my_color border: #black depth: gold_sold;        draw circle(view_dist) color: my_color border: #black depth: gold_sold wireframe: true;    }}\nperception​\nWe add a perceive statement for the miner agents. This perceive will allow the agent to detect the gold mines that are not empty (i.e. the quantity of gold is higher than 0) at a distance lower or equal to view_dist. The use of the focus statement allows adding for each detected gold mine a belief corresponding to the location of this gold mine. The name of the belief will be mine_at_location and the location value of the gold_mine will be stored in the values (a map) variable of the belief at the key location_value.\nIn addition, we ask the miner agent to remove the intention to find gold, allowing the agent to choose a new intention. The boolean value of the remove_intention action is used to specify if the agent should or not remove the given intention from the desire base as well. In our case, we choose to keep the desire to find golds.\nspecies miner skills: [moving] control: simple_bdi {    ...\t    perceive target: gold_mine where (each.quantity > 0) in: view_dist {\tfocus id: mine_at_location var:location;\task myself {\t    do remove_intention(find_gold, false);\t}    }}\nNote that the perceive statement works as the ask statement: the instructions written in the statement are executed in the context of the perceive agents. It is for that that we have to use the myself keyword to ask the miner agent to execute the remove_intention action.\nrules​\nWe define two rules for the miner agents:\n\nif the agent believes that there is somewhere at least one gold mine with gold nuggets, the agent gets the new desire to has a gold nugget with a strength of 2.\nif the agent believes that it has a gold nugget, the agent gets the new desire to sell the gold nugget with a strength of 3.\n\nspecies miner skills: [moving] control:simple_bdi {    ...    rule belief: mine_location new_desire: has_gold strength: 2.0;    rule belief: has_gold new_desire: sell_gold strength: 3.0;}\nThe strength of a desire will be used when selecting a desire as a new intention: the agent will choose as new intention the one with the highest strength. In our model, if the agent has the desires to find gold, to has gold and to sell gold, it will choose as intention to sell gold as it is the one with the highest strength. It is possible to replace this deterministic choice by a probabilistic one by setting the probabilistic_choice built-in variable of the BDI agent to true (false by default).\nplans​\nThe last (and most important) part of the definition of BDI agents consists in defining the plans that the agents can carry out to achieve its intention.\nThe first plan called lets_wander is defined to achieve the find_gold intention. This plan will just consist of executing the wander action of the moving skill (random move).\nspecies miner skills: [moving] control: simple_bdi {    ...    plan lets_wander intention: find_gold {\tdo wander;    }    ...}\nThe second plan called get_gold is defined to achieve the has_gold intention. If the agent has no target (it does not know where to go), it adds a new sub-intention to choose a gold mine and puts the current intention on hold (the agent will wait to select a gold mine to go before executing again this plan). The add_subintention operator is used to this purpose and has 3 arguments: the sub-intention (choose_gold_mine), the super intention (has_gold) and a boolean that defines if the sub-intention should or not be added as well as a desire. The super intention (this is in fact the current intention) can be accessed with get_current_intention().\nIf the agent has already a target, it moves toward this target using the goto action of the moving skill. If the agent reaches its target (a gold mine) (target = location), the agent tries to extract gold nuggets from it. If the corresponding gold mine (that one located at the target location) is not empty, the agent extracts a gold nugget from it: the agent adds the belief that it has a gold nugget, then the quantity of golds in the gold mine is reduced. Otherwise, if the gold mine is empty, the agent adds the belief that this gold mine is empty and the target is set to nil.\nspecies miner skills: [moving] control:simple_bdi {    ...    plan get_gold intention:has_gold {\tif (target = nil) {\t    do add_subintention(get_current_intention(),choose_gold_mine, true);\t    do current_intention_on_hold();\t} else {\t    do goto target: target ;\t    if (target = location)  {\t\tgold_mine current_mine<- gold_mine first_with (target = each.location);\t\tif current_mine.quantity > 0 {\t\t    do add_belief(has_gold);\t\t    ask current_mine {quantity <- quantity - 1;}\t\t\t} else {\t\t    do add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\t\t}\t\ttarget <- nil;\t    }\t}\t    }    ...}\nThe third plan called choose_closest_gold_mine is defined to achieve the choose_gold_mine intention that is instantaneous. First, the agent defines the list of all the gold mines it knows (mine_at_location beliefs), then removes the gold mines that it knows that they are empty (empty_mine_location beliefs). If the list of the possible mines is empty, the agent removes the desire and the intention to extract_gold. We use for that the remove_intention action, that removes an intention from the intention base; the second argument allows to define if the intention should be removed as well from the desire base. If the agent knows at least one gold mine that is not empty, it defines as its new target the closest gold mine.\nspecies miner skills: [moving] control: simple_bdi {    ...    plan choose_closest_gold_mine intention: choose_gold_mine instantaneous: true {\tlist<point> possible_mines <- get_beliefs_with_name(mine_at_location) collect (point(get_predicate(mental_state (each)).values[\"location_value\"]));\tlist<point> empty_mines <- get_beliefs_with_name(empty_mine_location) collect (point(get_predicate(mental_state (each)).values[\"location_value\"]));\tpossible_mines <- possible_mines - empty_mines;\tif (empty(possible_mines)) {\t    do remove_intention(extract_gold, true); \t} else {\t    target <- (possible_mines with_min_of (each distance_to self)).location;\t}\tdo remove_intention(choose_gold_mine, true);     }    ...}\nThe last plan called return_to_base is defined to achieve the sell_gold intention. The agent moves in the direction of the market using the goto action. When the agent reaches the market, it sells its gold nugget to it: first, it removes the belief that it has a gold nugget, then it removes the intention and the desire to sell golds, at last, it increments its gold_sold variable.\nspecies miner skills: [moving] control: simple_bdi {    ...    plan return_to_base intention: sell_gold {\tdo goto target: the_market ;\tif (the_market.location = location)  {\t    do remove_belief(has_gold);\t    do remove_intention(sell_gold, true);\t    gold_sold <- gold_sold + 1;\t}    }    ...}\nGobal section​\nWe define two new global variables:\n\nnb_miners: number of gold miners.\ninequality: recomputed at each simulation step: standard deviation of the number of gold nuggets extracted per miners.\n\nIn the global init, after creating the gold mines and the market, we create the gold miner agents.\nAt last, we define a global reflex end_simulation that is activated when all the gold mines are empty and no more miner has a gold nugget and that pauses the simulation and display the gold sold by each miner.\nglobal {    ...    int nb_minerd <- 5;    float inequality <- 0.0 update:standard_deviation(miner collect each.gold_sold);    ...    init {\t...\tcreate miner number: nb_miner;    }\t    reflex end_simulation when: sum(gold_mine collect each.quantity) = 0 and empty(miner where each.has_belief(has_gold)){\tdo pause;        ask miner {\t\twrite name + \" : \" +gold_sold;\t}    }}\nMap display​\nWe add to the map display the miner species.\nWe also create a chart showing the gold sold of each miner.\nexperiment GoldBdi type: gui {    output {\tdisplay map type: opengl {\t    species market ;\t    species gold_mine ;\t    species miner;\t}        display chart {\t    chart \"Money\" type: series {\t\tdatalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color;\t\t}\t}    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%202.gaml"},{"filePath":"https:--gama-platform.org--wiki-BDIAgents_step3.txt","text":"3. Social relationThis third step consists in adding social relation between agents and the possibility to share information about the known gold mines.\nFormulation​\n\nDefinition of the gold miner perceptions with socialization\nDefinition of a new gold miner plan to share information\n\nSocial relationships​\nThe BDI architecture of GAMA allows the modeler to define explicit social relations between agents. Based on the work of (Svennevig, 2000), a social link with another agent is defined as a tuple <agent, liking, dominance, solidarity, familiarity, trust> with the following elements:\n\nAgent: the agent concerned by the link, identified by its name.\nLiking: a real value between -1 and 1 representing the degree of liking with the agent concerned by the link. A value of -1 indicates that the concerned agent is hated, a value of 1 indicates that the concerned agent is liked.\nDominance: a real value between -1 and 1 representing the degree of power exerted on the agent concerned by the link. A value of -1 indicates that the concerned agent is dominating, a value of 1 indicates that the concerned agent is dominated.\nSolidarity: a real value between 0 and 1 representing the degree of solidarity with the agent concerned by the link. A value of 0 indicates no solidarity with the concerned agent, a value of 1 indicates a complete solidarity with the concerned agent.\nFamiliarity: a real value between 0 and 1 representing the degree of familiarity with the agent concerned by the link. A value of 0 indicates no familiarity with the concerned agent, a value of 1 indicates a complete familiarity with the concerned agent.\nTrust: a real value between -1 and +1 representing the degree of trust with the agent concerned by th link. A value of -1 indicates a doubt about the agent concerned, a value of 1 indicates a complete trust with the concerned agent.\n\nWith this definition, a social relation is not necessarily symmetric. For example, let's take two agents, Alice and Bob, with a social link towards each other. The agent Bob may have a social link <Alice,1,-0.5,0.6,0.8,-0.2> (Bob likes Alice with a value of 1, he thinks he is dominated by Alice, he is solidary with Alice with a value of 0.6, he is familiar with Alice with a value of 0.8 and he doubts about her with a value 0.2) and Alice may have a social link <Bob,-0.2,0.2,0.4,0.5,0.8> (Alice dislikes Bob with a value of 0.2, she thinks she is dominating Bob, she is solidary with Bob with a value of 0.4, she is familiar with Bob with a value of 0.5 and she trusts Bob with a value of 0.5).\nModel Definition​\npredicates​\nWe add a new global predicate called share_information that represents the information that the miner wants to share information.\nglobal {    ...    predicate share_information <- new_predicate(\"share information\") ;    ...}\nperception​\nWe add a new perceive statement for the miner agents. This perceive will allow creating a social relation with the miners that are located at a distance lower or equal to view_dist to the agent.\nFor each of these miner agents, the agents create a new social relation using the socialize statement with a liking value that depends on the color of the agents: more the agents are close, higher will be the liking value.\nspecies miner skills: [moving] control: simple_bdi {    ...    perceive target: miner in: view_dist {\tsocialize liking: 1 -  point(my_color.red, my_color.green, my_color.blue) distance_to point(myself.my_color.red, myself.my_color.green, myself.my_color.blue) / 255;    }}\nWe also modify the perceive statement previously defined in order to add the desire to share information with a strength of 5 if the agent finds a gold mine.\nspecies miner skills: [moving] control:simple_bdi {    ...    perceive target: gold_mine where (each.quantity > 0) in: view_dist {\tfocus mine_at_location var:location;\task myself {\t    do add_desire(predicate:share_information, strength: 5.0);\t    do remove_intention(find_gold, false);\t}    }}\nplan​\nAt last, we add a new plan for the miner agents called share_information_to_friends to achieve the intention share_information that is instantaneous.\nIn this plan, the miner agent first defines its list of friends, i.e. the miners with which it has a social link and that it likes (liking higher than 0). then for each friend, it shares its list of known mines (beliefs about their location), then its knowledge about the mines that are empty (beliefs about their location). As these information are already beliefs, we use the add_directly_belief action. At last, it removes the desire and intention to share_information.\nspecies miner skills: [moving] control: simple_bdi {    ...    plan share_information_to_friends intention: share_information instantaneous: true{\tlist<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\tloop known_gold_mine over: get_beliefs_with_name(mine_at_location) {\t\task my_friends {\t\t\tdo add_directly_belief(known_gold_mine);\t\t}\t}\tloop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) {\t\task my_friends {\t\t\tdo add_directly_belief(known_empty_gold_mine);\t\t}\t}\t\t\tdo remove_intention(share_information, true);     }}\ndisplay​\nTo show the new social link, we propose to create a new agent used to display these links (the display is done in the global section):\nglobal{...reflex display_social_links{\t\tloop tempMiner over: miner{\t\t\t\tloop tempDestination over: tempMiner.social_link_base{\t\t\t\t\tif (tempDestination !=nil){\t\t\t\t\t\tbool exists<-false;\t\t\t\t\t\tloop tempLink over: socialLinkRepresentation{\t\t\t\t\t\t\tif((tempLink.origin=tempMiner) and (tempLink.destination=tempDestination.agent)){\t\t\t\t\t\t\t\texists<-true;\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t\tif(not exists){\t\t\t\t\t\t\tcreate socialLinkRepresentation number: 1{\t\t\t\t\t\t\t\torigin <- tempMiner;\t\t\t\t\t\t\t\tdestination <- tempDestination.agent;\t\t\t\t\t\t\t\tif(get_liking(tempDestination)>0){\t\t\t\t\t\t\t\t\tmy_color <- #green;\t\t\t\t\t\t\t\t} else {\t\t\t\t\t\t\t\t\tmy_color <- #red;\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t}\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t\t}\t\t\t}\t}}species socialLinkRepresentation{\tminer origin;\tagent destination;\trgb my_color;\t\taspect base{\t\tdraw line([origin,destination],50.0) color: my_color;\t}}experiment{...        display socialLinks type: opengl{\t\tspecies socialLinkRepresentation aspect: base;\t}...}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%203.gaml"},{"filePath":"https:--gama-platform.org--wiki-BDIAgents_step4.txt","text":"4. Emotions and PersonalityThis fourth step consists of adding emotions that will impact the gold miner agent behavior and defining the personality of the agents.\nFormulation​\n\nDefinition of global emotions\nModification of the miner species to integrate emotions and personality\n\nEmotions​\nThe BDI architecture of GAMA gives the possibility to generate emotions and to use them in the cognition. The definition of emotions in GAMA is based on the OCC theory of emotions. According to this theory, an emotion is a valued answer to the appraisal of a situation. In GAMA an emotion is represented by a set of 5 elements:\n\nE: the name of the emotion felt by agent i.\nP: the predicate that represents the fact about which the emotion is expressed.\nA: the agent causing the emotion.\nI: the intensity of the emotion.\nD: the decay of the emotion's intensity.\n\nThe BDI architecture of GAMA integrates a dynamic creation of emotions process that will create emotions according to the mental states of the agent. More precisely, twenty emotions can be created: eight emotions related to events, four emotions related to other agents and eight emotions related to actions.\nThe complete description of these emotions and their creation rules can be found in (Bourgais et al., 2017).\nPersonality​\nIn order to facilitate the parametrization of the BDI agents, we add the possibility to define all the parameters related to the BDI architecture through the OCEAN model, which proposes to represent the personality of a person according to five factors (corresponding to the 5 variables of the BDI agents):\n\nO: represents the openness of someone (open-minded/narrow-minded).\nC: represents the consciousness of someone (act with preparations/impulsive).\nE: represents the extroversion of someone (extrovert/shy).\nA: represents the agreeableness of someone (friendly/hostile).\nN: represent the degree of control someone has on its emotions (calm/neurotic)\n\nEach of these variables has a value between 0 and 1. 0.5 represents the neutral value, below 0.5, the value is considered negatively and above 0.5, it is considered positively. For example, someone with a value of 1 for N is considered as calm and someone with a value of 0 for A is considered as hostile.\nModel Definition​\nEmotions​\nWe add a new global emotion called joy that represents the joy emotion.\nglobal {    ...    emotion joy <- new_emotion(\"joy\");    ...}\nEmotions and personality​\nTo use emotions (and to activate the automatic emotion generation process), we just have to set the value of the built-in variable use_emotions_architecture to true (false by default). In our case, one of the possible desires concerns the predicate has_gold, and when an agent fulfill this desire and find a gold nugget (plan get_gold), it gets the belief has_gold, and the emotion engine automatically creates a joy emotion.\nTo be able to define the parameter of a BDI agent through the OCEAN model, we have to set the value of the built-in variable use_personality to true (false by default). In this model, we chose to use the default value of the O, C, E, A and N variables (default value: 0.5). The interest of using the personality in our case is to allow the emotion engine to give a lifetime to the created emotions (otherwise, the emotions would have an infinite lifetime).\nIn this model, we only use the emotions to define if the miner agents are going to share or not its knowledge about the gold mines. We consider that the miner only shares information if it has a joy emotion (and the agent tells that it is joyfous).\nspecies miner skills: [moving] control: simple_bdi {    ...    bool use_emotions_architecture <- true;    bool use_personality <- true;\t\t    perceive target: gold_mine where (each.quantity > 0) in: view_dist {\tfocus mine_at_location var:location;\task myself {\t    if (has_emotion(joy)) {                 write self.name + \" is joyous\";                do add_desire(predicate:share_information, strength: 5.0);            }\t    do remove_intention(find_gold, false);\t}    }    ...}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%204.gaml"},{"filePath":"https:--gama-platform.org--wiki-BDIAgents_step5.txt","text":"5. Norms, obligation, and enforcementThis last step consists of adding social norms, obligations, and enforcement into the agents' behavior.\nFormulation​\n\nDefinition of the policeman species\nDefinition of the enforcement done by policeman species\nDefinition of the law agents have to follow\nDefinition of a gold miner norm to fulfill its obligation and its social norms\nDefinition of the enforcement done by gold miners\n\nNorms, obligations, and enforcement​\nThe BDI architecture of GAMA allows defining explicit social norms, laws that lead to obligations and an enforcement process to sanction or reward the other agent depending on their behavior toward norms.\nA social norm is a set of actions executed under certain conditions which are known by the people as the right things to do in that condition. As it is, it can be assimilated into a plan. However, a norm can be violated which mean an agent chose to disobey and do not execute it while it should. To do this, each agent has an obedient value, between 0 and 1 and computed from its personality and each norm has a threshold. If the obedient value of the agent is above the threshold, the norm is executed.\nAn obligation is a mental state that can be assimilated with a desire. It is created by a law that indicates under which conditions the agent has to follow a particular obligation. Once again, the law can have a threshold value to be activated or not depending on the obedient value of the agent. If an agent has an obligation, it will give up its current intention and current plan to get this obligation as its intention. Then, it will choose a specific norm to answer this obligation, once again with a threshold on the obedient value.\nFinally, an enforcement mechanism can be defined during the perception process. Norms, laws, and obligation can be enforced. If a violation is detected, a sanction can be executed. If the norm/law/obligation is fulfilled, a reward can be executed.\nModel Definition​\nlaw​\nWe add a law to the gold miner species that will create the obligation to get gold if a gold nugget is perceived. This law replaces a rule and expresses the fact that miners are working or not, depending on their obedience value.\nspecies miner skills: [moving] control:simple_bdi {    ...    law working belief: mine_location new_obligation: has_gold        when:not has_obligation(has_gold) and not has_belief(has_gold) strength: 2.0 threshold: threshold_aw;\t        ...}\nnorms​\nThe miners will have two norms. A first one to answer the obligation to collect gold. This norm replaces the previous plan created for this purpose. However, a new plan is declared to get 3 pieces of gold at each time. This plan will be considered illegal by the policeman species.\nspecies miner skills: [moving] control: simple_bdi {    ...    norm doing_job obligation: has_gold finished_when: has_belief(has_gold) threshold: threshold_obligation {\tif (target = nil) {\t    do add_subintention(has_gold,choose_gold_mine, true);\t    do current_intention_on_hold();\t} else {\t    do goto target: target ;\t    if (target = location)  {\t\tgold_mine current_mine<- gold_mine first_with (target = each.location);\t\tif current_mine.quantity > 0 {\t\t    gold_transported <- gold_transported+1;\t\t    do add_belief(has_gold);\t\t    ask current_mine {quantity <- quantity - 1;}\t\t\t} else {\t\t    do add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\t\t    do remove_belief(new_predicate(mine_at_location, [\"location_value\"::target]));\t\t}\t\ttarget <- nil;\t    }\t}\t    }}\nThe second norm is a social norm to communicate the list of known mines to one's friends. It replaces the previous plan that did this action, while a new plan is added to give a wrong list of mines to one's friend.\nspecies miner skills: [moving] control: simple_bdi {    ...    norm share_information intention: share_information threshold: threshold_norm instantaneous: true {\tlist<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\tloop known_gold_mine over: get_beliefs_with_name(mine_at_location) {\t    ask my_friends {\t\tdo add_belief(known_gold_mine);\t    }\t}\tloop known_empty_gold_mine over: get_beliefs_with_name(empty_mine_location) {\t    ask my_friends {\t\tdo add_belief(known_empty_gold_mine);\t    }\t}\t\t\tdo remove_intention(share_information, true);     }}\nEnforcement of the social norm​\nFinally, for the gold-miner agent, an enforcement is defined about the social norm to communicate the location of mines to other agents. A sanction and a reward are declared to change the liking value with the agent controlled, depending on if the norm is violated or fulfilled.\nspecies miner skills: [moving] control:simple_bdi {    ...    perceive target: miner in: view_dist {\tmyself.agent_perceived <- self;\tenforcement norm:\"share_information\" sanction:\"sanction_to_norm\" reward:\"reward_to_norm\";    }\t\t    sanction sanction_to_norm{\tdo change_liking(agent_perceived,-0.1);    }\t\t    sanction reward_to_norm{\tdo change_liking(agent_perceived,0.1);    }}\nDefinition of policeman species​\nFinally, we define a policeman species that will wander through the map and enforce the miners about the law and the obligation. The sanctions will be a fine collected by policemen.\nspecies policeman skills: [moving] control:simple_bdi {    predicate patroling <- new_predicate(\"patrolling\");    float view_dist <- 1000.0;    miner agent_perceived <- nil;\t    init {\tdo add_desire(patroling);    }\t    perceive target:miner in: view_dist {\tmyself.agent_perceived <- self;\tenforcement law: \"working\" sanction: \"sanction_to_law\";\tenforcement obligation: has_gold sanction: \"sanction_to_obligation\" reward: \"reward_to_obligation\";    }\t    sanction sanction_to_law {\task agent_perceived{\t    threshold_law <- 0.0;\t    gold_sold <- gold_sold-5;\t}\tfine <- fine +5;    }\t    sanction sanction_to_obligation {\task agent_perceived{\t    gold_sold <- gold_sold-3;\t    do remove_intention(sell_gold,true);\t    thresholdObligation <- self.threshold_obligation - 0.1;\t}\tfine <- fine + 3;    }\t    sanction reward_to_obligation{\task agent_perceived{\t    gold_sold <- gold_sold+2;\t}\tfine <- fine - 2;    }\t    plan patrol intention: patroling{\tdo wander;    }\t    aspect base{\tdraw circle(view_dist) color: #blue depth:0.0;    }}\nModification of the chart​\nWe add to the output chart displayed the data coming from the policeman.\ndisplay chart {\t    chart \"Money\" type: series {\t\tdatalist legend: miner accumulate each.name value: miner accumulate each.gold_sold color: miner accumulate each.my_color;                data \"policeman\" value: fine color: #red;\t\t}\t}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gaml.architecture.simplebdi/models/BDI%20Architecture/models/Tutorial/BDI%20tutorial%205.gaml"},{"filePath":"https:--gama-platform.org--wiki-BasicProgrammingConceptsInGAML.txt","text":"Basic programming concepts in GAMLIn this part, we will focus on the very basic structures in GAML, such as how to declare a variable, how to use loops, or how to manipulate lists.\nWe will overfly quickly all those basic programming concepts, admitting that you already have some basics in coding.\nIndex​\n\nVariables\n\nBasic types\nThe point type\nA word about dimensions\n\n\nDeclare variables using facet\nOperators in GAMA\n\nLogical operators\nComparison operators\nType casting operators\nOther operators\n\n\nConditional structures\nLoop\nManipulate containers\nRandom values\n\nVariables​\nVariables are declared very easily in GAML, starting with the keyword for the type, following by the name you want for your variable.\nNB: The declaration has to be inside the global, the experiment, or the species scope.\ntypeName myVariableName;\nBasic types​\nAll the \"basic\" types are present in GAML:int, float, string, bool (see the data type page for information about all the available datatype).\nThe operator for the affectation in GAML is <- (the operator = is used to test the equality).\nint integerVariable <- 3;float floatVariable <- 2.5;string stringVariable <- \"test\"; // you can also write simple ' : <- 'test'bool booleanVariable <- true; // or false\nTo follow the behavior of a variable, we can write their value in the console. Let's go back to our basic skeleton of a model, and let's create a reflex in the global scope (to be short, a reflex is a procedure that is executed in each step. We will come back to this concept later). The write statement works very easily, simply writing down the keyword write and the name of the variable we want to be displayed.\nmodel firstModelglobal {    int integerVariable <- 3;    float floatVariable <- 2.5;    string stringVariable <- \"test\"; // you can also write simple ' : <- 'test'    bool booleanVariable <- true; // or false        reflex writeDebug {\t write integerVariable;\t write floatVariable;\t write stringVariable;\t write booleanVariable;    }}experiment myExperiment {}\nThe statement write is overloaded for each type of variable (even for the more complex type, such as containers).\nNote that before being initialized, a variable has the value nil.\nreflex update {    string my_string;    write my_string; // this will write \"nil\".    int my_int;    write my_int; // this will write \"0\", which is the default value for int.}\nnil is also a literal you can use to initialize your variables (you can learn more about the concept of literal in this page).\nreflex update {    string my_string <- \"a string\";    my_string <- nil;    write my_string; // this will write \"nil\".    int my_int <- 6;    my_int <- nil;    write my_int; // this will write \"0\", which is the default value for int.}\nThe point type​\nAnother variable type you should know is the point type. This type of variable is used to describe coordinates. It is in fact a complex variable, composed of two float variables (or three if you are working in 3D). To declare it, you have to use the curly bracket {:\npoint p <- {0.2,2.4};\nThe first field is related to the x value, and the second one to the y value. You can easily get this value as follows:\npoint p <- {0.2,2.4};write p.x; // the output will be 0.2write p.y; // the output will be 2.4\nYou cannot modify directly the value. But if you want, you can do a simple operation to get what you want:\npoint p <- {0.2,2.4};p <- p + {0.0,1.0};write p.y; // the output will be 3.4\nA world about dimensions​\nWhen manipulating float values, you can specify the dimension (also called unit) of your value. Dimensions are preceded by # or ° (exactly the same).\nfloat a <- 5°m;float b <- 4#cm;float c <- a + b; // c is equal to 5.0399999 (it's not equal to 5.04 because it is a float value, not as precise as int)\nDeclare variables using facet​\nFacets are used to describe the behavior of a variable during its declaration, by adding the keyword facet just after the variable name, followed by the value you want for the facet (or also just after the initial value). See the page related to the variable declaration for all the facets.\ntype variableName <- initialValue facet1:valueForFacet1 facet2:valueForFacet2;// or:type variableName facet1:valueForFacet1 facet2:valueForFacet2;variableName <- initialValue;\nYou can use the facet update if you want the value of your variable to change at every simulation step. For example, to increment your integer variable each step, you can do as follow:\nint integerVariable <- 3 min: 0 max: 10 update: integerVariable+1;// nb: the operator \"++\" doesn't exist in gaml.\nYou can use the facets min and max to constraint the value in a specific range of values:\nint integerVariable <- 3 min: 0 max: 10 update: integerVariable+1;// the result will be 3 - 4 - 5 - 6 - 7 - 8 - 9 - 10 - 10 - 10 - ...\nThe facet among can also be useful (that can be seen as an enum):\nstring fruits <- \"banana\" among: [\"pear\",\"apple\",\"banana\"];\nOperators in GAMA​\nIn GAML language, you can use a lot of different operators. An operator is a function, i.e. a way to get the result of a computation. All of them are listed in this page, but here are the most useful ones:\nMathematical operators​\nThe basic arithmetical operators, such as +(add), -(substract), *(multiply), /(divide), ^(power) are used this way:\n// FirstOperand BinaryOperator SecondOperand //   --> ex: 5 * 3; // return 15int fif <- 5 * 3;\nSome other operators, such as cos(cosinus), sin(sinus), tan(tangent), sqrt(square root), round(rounding) etc... are used this way:\n// UnaryOperator(Operand) //   --> ex: sqrt(49); // return 7.0float sq <- sqrt(49);\nLogical operators​\nLogical operators such as and(and), or(inclusive or) are used the same way as basic arithmetical operators. The operator !(negation) has to be placed just before the operand. They return a boolean result.\n// FirstOperand Operator SecondOperand //   --> ex: true or false; // return true// NegationOperator Operand //   --> ex: !(true or false); // return false\nComparison operators​\nThe comparison operators !=(different than), <(smaller than), <=(smaller of equal), =(equal), >(bigger than), >=(bigger or equal) are used the same way as basic arithmetical operators:\n// FirstOperand Operator SecondOperand //   --> ex: 5 < 3; // return falsebool cmp <- 5 < 3;\nType casting operators​\nYou can cast an operand to a special type using casting operator:\n// Operator(Operand); //  --> ex: int(2.1); // return 2int intTwo <- int(2.1);\nOther operators​\nA lot of other operators exist in GAML. The standard way to use those operators is as followed:\nOperator(FirstOperand,SecondOperand,...) --> ex: rnd(1,8);\nSome others are used in a more intuitive way:\nFirstOperand Operator SecondOperand --> ex: 2[6,4,5] contains(5);\nConditional structures​\nYou can write conditionals with if/else in GAML:\nif (integerVariable<0) {    write \"my value is negative !! The exact value is \" + integerVariable;}else if (integerVariable>0) {    write \"my value is positive !! The exact value is \" + integerVariable;}else if (integerVariable=0) {    write \"my value is equal to 0 !!\";}else {    write \"hey... This is not possible, right ?\";}\nGAML also accepts ternary operator:\nstringVariable <- (booleanVariable) ? \"booleanVariable = true\" : \"booleanVariable = false\";\nLoop​\nLoops in GAML are designed by the keyword loop. As for variables, a loop have multiple facets to determine its behavior:\n\nThe facet times, to repeat a fixed number of times a set of statements:\n\nloop times: 2 {    write \"helloWorld\";} // the output will be helloWorld - helloWorld\n\nThe facet while, to repeat a set of statements while a condition is true:\n\nloop while: true {}// infinity loop\n\nThe facet from / to, to repeat a set of statements while an index iterates over a range of values with a fixed step of 1:\n\nloop i from: 0 to: 5 {     write i;}// the output will be 0 - 1 - 2 - 3 - 4 - 5\n\nThe facet from / to combine with the facet step to choose the step:\n\nloop i from: 0 to: 5 step: 2 {    write i;}// the output will be 0 - 2 - 4\n\nThe facet over to browse containers, as we will see in the next part.\n\nloop i over: [0, 2, 4] {    write i;}// the output will be 0 - 2 - 4\nNb: you can interrupt a loop at any time by using the break statement.\nManipulate containers​\nWe saw in the previous parts \"simple\" types of variable. You also have multiple containers types, such as list, matrix, map, pair... In this section, we will only focus on the container list (you can learn the other by reading the section about datatypes).\nHow to declare a list?\nTo declare a list, you can either or not specify the type of the data of its elements:\nlist<int> listOfInt <- [5,4,9,8];list listWithoutType <- [2,4.6,\"oij\",[\"hoh\",0.0]];\nHow to know the number of elements of a list?\nTo know the number of elements of a list, you can use the operator length that returns the number of elements (note that this operator also works with strings).\nint numberOfElements <- length([12,13]); // will return 2int numberOfElements <- length([]); // will return 0int numberOfElements <- length(\"stuff\"); // will return 5\nThere is another operator, empty, that returns you a boolean telling you if the list is empty or not.\nbool isEmpty <- empty([12,13]); // will return falsebool isEmpty <- empty([]); // will return truebool isEmpty <- empty(\"stuff\"); // will return false\nHow to get an element from a list?\nTo get an element from a list by its index, you have to use the operator at (nb: it is indeed an operator and not a facet, so no \":\" after the keyword).\nint theFirstElementOfTheList <- [5,4,9,8] at 0; // this will return 5int theThirdElementOfTheList <- [5,4,9,8] at 2; // this will return 9\nHow to know the index of an element of a list?\nYou can know the index of the first occurrence of a value in a list using the operator index_of.\nYou can know the index of the last occurrence of a value in a list using the operator last_index_of.\nint result <- [4,2,3,4,5,4] last_index_of 4;  // result equals 5int result <- [4,2,3,4,5,4] index_of 4;  // result equals 0\nHow to know if an element exists in a list?\nYou can use the operator contains (return a boolean):\nbool result <- [{1,2}, {3,4}, {5,6}] contains {3,4};  // result equals true\nHow to insert/remove an element to/from a list?\nFor those operation, you can use dedicated statements. The statements add and put are used to insert/modify an element, while the statement remove is used to remove an element. Here are some examples of how to use those 3 statements with the most common facets:\nlist<int> list_int <- [1,5,7,6,7];remove from:list_int index:1; // remove the 2nd element of the listwrite list_int; // the output is : [1,7,6,7]remove item:7 from:list_int; // remove the 1st occurrence of 7write list_int; // the output is : [1,6,7]add item:9 to: list_int at: 2; // add 9 in the 3rd positionwrite list_int; // the output is : [1,6,9,7]add 0 to: list_int; // add 0 in the last positionwrite list_int; // the output is : [1,6,9,7,0]put 3 in: list_int at: 0; // put 3 in the 1st positionwrite list_int; // the output is : [3,6,9,7,0]put 2 in: list_int key: 2; // put 2 in the 3rd positionwrite list_int; // the output is : [3,6,2,7,0]\nNote that the + and - operators can be used to add an element at the end of a list and to remove the last element of a list:\nlist<int> list_int <- [1,5,7,6,7];list_int <- list_int + 8;write list_int;  // the output is : [1,5,7,6,7,8]list_int <- list_int - 7;write list_int;  // the output is : [1,5,7,6,8]\nHow to add 2 lists?\nYou can add 2 lists by creating a third one and browsing the 2 first one, but you can do it much easily by using the operator + :\nlist<int> list_int1 <- [1,5,7,6,7];list<int> list_int2 <- [6,9];list<int> list_int_result <- list_int1 + list_int2;\nHow to browse a list?\nYou can use the facet over of a loop:\nlist<int> exampleOfList <- [4,2,3,4,5,4];loop i over: exampleOfList {\twrite i;}// the output will be 4 - 2 - 3 - 4 - 5 - 4\nHow to filter a list?\nIf you want to get all the elements of a list that fulfill a particular condition, you need the operator where. In the condition, you can design all the elements of a particular list by using the pseudo-variable each as followed:\nlist<int> exampleOfList <- [4,2,3,4,5,4] where (each <= 3); // the list is now [2,3]\nOther useful operators for the manipulation of lists:\nHere are some other operators which can be useful to manipulate lists: sort, sort_by, shuffle, reverse, collect, accumulate, among. Please read the GAML Reference if you want to know more about those operators.\nRandom values​\nWhen you will implement your model, you will have to manipulate some random values quite often.\nTo get a random value in a range of value, use the operator rnd. You can use this operator in many ways:\nint var0 <- rnd (2);    // var0 equals 0, 1 or 2float var1 <- rnd (1000) / 1000;    // var1 equals a float between 0 and 1 with a precision of 0.001float var2 <- rnd(3.4);     // var4 equals a random float between 0.0 and 3.4point var3 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1);    // var2 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0float var4 <- rnd (2.0, 4.0, 0.5);  // var3 equals a float number between 2.0 and 4.0 every 0.5int var5 <- rnd (2, 4);     // var7 equals 2, 3 or 4int var6 <- rnd (2, 12, 4);     // var5 equals 2, 6 or 10point var7 <- rnd ({2.5,3, 0.0});   // var6 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0point var8 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0});   // var8 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0float var9 <- rnd (2.0, 4.0);   // var9 equals a float number between 2.0 and 4.0\nUse the operator flip if you want to pick a boolean value with a certain probability:\nbool result <- flip(0.2); // result will have 20% of chance to be true\nYou can use randomness in list, by using the operator shuffle, or also by using the operator among to pick randomly one (or several) element of your list:\nlist TwoRandomValuesFromTheList <- 2 among [5,4,9,8];// the list will be for example [5,9].\nYou can use probabilistic laws, using operators such as gauss, poisson, binomial, or truncated_gauss (we invite you to read the documentation for those operators)."},{"filePath":"https:--gama-platform.org--wiki-BatchSpecific.txt","text":"Batch Specific UIWhen an experiment of type Batch is run, a dedicated UI is displayed, depending on the parameters to explore and of the exploration methods.\nTable of contents​\n\nBatch Specific UI\n\nInformation bar\nBatch UI\n\n\n\nInformation bar​\nIn batch mode, the top information bar displays 3 distinct information (instead of only the cycle number in the GUI experiment):\n\nThe run number: One run corresponds to N executions of simulation with one given parameters values (N is an integer given by the facet repeat in the definition of a batch experiment. The number of runs is chosen by the exploration method).\nThe simulation number: the number of replications done (and the number of replications specified with the repeat facet);\nThe number of thread: the number of threads used for the simulation.\n\n\nBatch UI​\nThe parameters view is also a bit different in the case of a Batch UI:\n\nit shows both the parameters of the experiment, with a distinction between the ones that will be explored and the ones that will not.\nit also shows the state of the exploration. The provided information will depend on the exploration method.\n\nThe following interface is generated given the following experiment (the exploration method is here the exhaustive one):\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 400) {   parameter 'Size of the grid:' var: gridsize init: 75 unit: 'width and height';   parameter 'Number:' var: ants_number init: 200 unit: 'ants';   parameter 'Evaporation:' var: evaporation_per_cycle among: [0.1, 0.2, 0.5, 0.8, 1.0] unit: 'rate every cycle (1.0 means 100%)';   parameter 'Diffusion:' var: diffusion_rate min: 0.1 max: 1.0 unit: 'rate every cycle (1.0 means 100%)' step: 0.3;   method exhaustive maximize: food_gathered;}\n\nThe interface summarises all model parameters and the parameters given to the exploration method:\n\nEnvironment and Population: displays all the model parameters that should not be explored. Those parameters must be initialized with a fixed value when they are defined in the experiment.\nParameters to explore: the parameters to explore are the parameters defined in the experiment with a range of values (with among facet or min, max and step facets);\nExploration method: it displays information about the exploration method and the stop condition. It displays the size of the parameter space in the case of the exhaustive method, and different parameters (e.g. mutation or crossover probability...) for other methods. Finally, the best and the last fitnesses found are shown, along with the associated parameter sets.\n\nThe following interface corresponds to the same experiment as previously, but with the genetic exploration method.\nexperiment Batch type: batch repeat: 2 keep_seed: true until: (food_gathered = food_placed) or (time > 400) {   // [Parameters]   method genetic maximize: food_gathered;}\n"},{"filePath":"https:--gama-platform.org--wiki-BuiltInArchitectures.txt","text":"Built-in Architectures\nThis file is automatically generated from java files. Do Not Edit It.\n\nINTRODUCTION​\n\nTable of Contents​\nfsm, parallel_bdi, probabilistic_tasks, reflex, rules, simple_bdi, sorted_tasks, user_first, user_last, user_only, weighted_tasks,\n\nfsm​\nVariables​\n\nstate (string): Returns the name of the current state of the agent\nstates (list): Returns the list of all the states defined in the species\n\nActions​\n\nparallel_bdi​\ncompute the bdi architecture in parallel. This skill inherit all actions and variables from SimpleBdiArchitecture\nVariables​\nActions​\n\nprobabilistic_tasks​\nA control architecture, based on the concept of tasks, which are executed with a probability depending on their weight. This skill extends WeightedTasksArchitecture skills and have all his actions and variables\nVariables​\nActions​\n\nreflex​\nRepresents the default behavioral architecture attached to species of agents if none is specified. This skills extends AbstractArchitecture and have all his actions and variables\nVariables​\nActions​\n\nrules​\nA control architecture based on the concept of rules\nVariables​\nActions​\n\nsimple_bdi​\nthis architecture enables to define a behaviour using BDI. It is an implementation of the BEN architecture (Behaviour with Emotions and Norms)\nVariables​\n\nagreeableness (float): an agreeableness value for the personality\nbelief_base (list): the belief base of the agent\ncharisma (float): a charisma value. By default, it is computed with personality\nconscientiousness (float): a conscientiousness value for the personality\ncurrent_norm (any type): the current norm of the agent\ncurrent_plan (any type): thecurrent plan of the agent\ndesire_base (list): the desire base of the agent\nemotion_base (list): the emotion base of the agent\nextroversion (float): an extraversion value for the personality\nideal_base (list): the ideal base of the agent\nintention_base (list): the intention base of the agent\nintention_persistence (float): intention persistence\nlaw_base (list): the law base of the agent\nneurotism (float): a neurotism value for the personality\nnorm_base (list): the norm base of the agent\nobedience (float): an obedience value. By default, it is computed with personality\nobligation_base (list): the obligation base of the agent\nopenness (float): an openness value for the personality\nplan_base (list): the plan base of the agent\nplan_persistence (float): plan persistence\nprobabilistic_choice (boolean): indicates if the choice is deterministic or probabilistic\nreceptivity (float): a receptivity value. By default, it is computed with personality\nsanction_base (list): the sanction base of the agent\nsocial_link_base (list): the social link base of the agent\nthinking (list): the list of the last thoughts of the agent\nuncertainty_base (list): the uncertainty base of the agent\nuse_emotions_architecture (boolean): indicates if emotions are automaticaly computed\nuse_norms (boolean): indicates if the normative engine is used\nuse_persistence (boolean): indicates if the persistence coefficient is computed with personality (false) or with the value given by the modeler\nuse_personality (boolean): indicates if the personnality is used\nuse_social_architecture (boolean): indicates if social relations are automaticaly computed\n\nActions​\nadd_belief​\nadd the predicate in the belief base.\n\nreturns: bool\npredicate (predicate): predicate to add as a belief\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_belief_emotion​\nadd the belief about an emotion in the belief base.\n\nreturns: bool\nemotion (emotion): emotion to add as a belief\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_belief_mental_state​\nadd the predicate in the belief base.\n\nreturns: bool\nmental_state (mental_state): predicate to add as a belief\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_desire​\nadds the predicates is in the desire base.\n\nreturns: bool\npredicate (predicate): predicate to add as a desire\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\ntodo (predicate): add the desire as a subintention of this parameter\n\nadd_desire_emotion​\nadds the emotion in the desire base.\n\nreturns: bool\nemotion (emotion): emotion to add as a desire\nstrength (float): the stregth of the desire\nlifetime (int): the lifetime of the desire\ntodo (predicate): add the desire as a subintention of this parameter\n\nadd_desire_mental_state​\nadds the mental state is in the desire base.\n\nreturns: bool\nmental_state (mental_state): mental_state to add as a desire\nstrength (float): the stregth of the desire\nlifetime (int): the lifetime of the desire\ntodo (predicate): add the desire as a subintention of this parameter\n\nadd_directly_belief​\nadd the belief in the belief base.\n\nreturns: bool\nbelief (mental_state): belief to add in th belief base\n\nadd_directly_desire​\nadd the desire in the desire base.\n\nreturns: bool\ndesire (mental_state): desire to add in th belief base\n\nadd_directly_ideal​\nadd the ideal in the ideal base.\n\nreturns: bool\nideal (mental_state): ideal to add in the ideal base\n\nadd_directly_uncertainty​\nadd the uncertainty in the uncertainty base.\n\nreturns: bool\nuncertainty (mental_state): uncertainty to add in the uncertainty base\n\nadd_emotion​\nadd the emotion to the emotion base.\n\nreturns: bool\nemotion (emotion): emotion to add to the base\n\nadd_ideal​\nadd a predicate in the ideal base.\n\nreturns: bool\npredicate (predicate): predicate to add as an ideal\npraiseworthiness (float): the praiseworthiness value of the ideal\nlifetime (int): the lifetime of the ideal\n\nadd_ideal_emotion​\nadd a predicate in the ideal base.\n\nreturns: bool\nemotion (emotion): emotion to add as an ideal\npraiseworthiness (float): the praiseworthiness value of the ideal\nlifetime (int): the lifetime of the ideal\n\nadd_ideal_mental_state​\nadd a predicate in the ideal base.\n\nreturns: bool\nmental_state (mental_state): mental state to add as an ideal\npraiseworthiness (float): the praiseworthiness value of the ideal\nlifetime (int): the lifetime of the ideal\n\nadd_intention​\ncheck if the predicates is in the desire base.\n\nreturns: bool\npredicate (predicate): predicate to check\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_intention_emotion​\ncheck if the predicates is in the desire base.\n\nreturns: bool\nemotion (emotion): emotion to add as an intention\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_intention_mental_state​\ncheck if the predicates is in the desire base.\n\nreturns: bool\nmental_state (mental_state): predicate to add as an intention\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_obligation​\nadd a predicate in the ideal base.\n\nreturns: bool\npredicate (predicate): predicate to add as an obligation\nstrength (float): the strength value of the obligation\nlifetime (int): the lifetime of the obligation\n\nadd_social_link​\nadd the social link to the social link base.\n\nreturns: bool\nsocial_link (social_link): social link to add to the base\n\nadd_subintention​\nadds the predicates is in the desire base.\n\nreturns: bool\npredicate (mental_state): the intention that receives the sub_intention\nsubintentions (predicate): the predicate to add as a subintention to the intention\nadd_as_desire (boolean): add the subintention as a desire as well (by default, false)\n\nadd_uncertainty​\nadd a predicate in the uncertainty base.\n\nreturns: bool\npredicate (predicate): predicate to add\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_uncertainty_emotion​\nadd a predicate in the uncertainty base.\n\nreturns: bool\nemotion (emotion): emotion to add as an uncertainty\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nadd_uncertainty_mental_state​\nadd a predicate in the uncertainty base.\n\nreturns: bool\nmental_state (mental_state): mental state to add as an uncertainty\nstrength (float): the stregth of the belief\nlifetime (int): the lifetime of the belief\n\nchange_dominance​\nchanges the dominance value of the social relation with the agent specified.\n\nreturns: bool\nagent (agent): an agent with who I get a social link\ndominance (float): a value to change the dominance value\n\nchange_familiarity​\nchanges the familiarity value of the social relation with the agent specified.\n\nreturns: bool\nagent (agent): an agent with who I get a social link\nfamiliarity (float): a value to change the familiarity value\n\nchange_liking​\nchanges the liking value of the social relation with the agent specified.\n\nreturns: bool\nagent (agent): an agent with who I get a social link\nliking (float): a value to change the liking value\n\nchange_solidarity​\nchanges the solidarity value of the social relation with the agent specified.\n\nreturns: bool\nagent (agent): an agent with who I get a social link\nsolidarity (float): a value to change the solidarity value\n\nchange_trust​\nchanges the trust value of the social relation with the agent specified.\n\nreturns: bool\nagent (agent): an agent with who I get a social link\ntrust (float): a value to change the trust value\n\nclear_beliefs​\nclear the belief base\n\nreturns: bool\n\nclear_desires​\nclear the desire base\n\nreturns: bool\n\nclear_emotions​\nclear the emotion base\n\nreturns: bool\n\nclear_ideals​\nclear the ideal base\n\nreturns: bool\n\nclear_intentions​\nclear the intention base\n\nreturns: bool\n\nclear_obligations​\nclear the obligation base\n\nreturns: bool\n\nclear_social_links​\nclear the intention base\n\nreturns: bool\n\nclear_uncertainties​\nclear the uncertainty base\n\nreturns: bool\n\ncurrent_intention_on_hold​\nputs the current intention on hold until the specified condition is reached or all subintentions are reached (not in desire base anymore).\n\nreturns: bool\nuntil (any type): the current intention is put on hold (fited plan are not considered) until specific condition is reached. Can be an expression (which will be tested), a list (of subintentions), or nil (by default the condition will be the current list of subintentions of the intention)\n\nget_belief​\nreturn the belief about the predicate in the belief base (if several, returns the first one).\n\nreturns: mental_state\npredicate (predicate): predicate to get\n\nget_belief_emotion​\nreturn the belief about the emotion in the belief base (if several, returns the first one).\n\nreturns: mental_state\nemotion (emotion): emotion about which the belief to get is\n\nget_belief_mental_state​\nreturn the belief about the mental state in the belief base (if several, returns the first one).\n\nreturns: mental_state\nmental_state (mental_state): mental state to get\n\nget_belief_with_name​\nget the predicates is in the belief base (if several, returns the first one).\n\nreturns: mental_state\nname (string): name of the predicate to check\n\nget_beliefs​\nget the list of predicates in the belief base\n\nreturns: list<mental_state>\npredicate (predicate): predicate to check\n\nget_beliefs_metal_state​\nget the list of bliefs in the belief base containing the mental state\n\nreturns: list<mental_state>\nmental_state (mental_state): mental state to check\n\nget_beliefs_with_name​\nget the list of predicates is in the belief base with the given name.\n\nreturns: list<mental_state>\nname (string): name of the predicates to check\n\nget_current_intention​\nreturns the current intention (last entry of intention base).\n\nreturns: mental_state\n\nget_current_plan​\nget the current plan.\n\nreturns: BDIPlan\n\nget_desire​\nget the predicates is in the desire base (if several, returns the first one).\n\nreturns: mental_state\npredicate (predicate): predicate to check\n\nget_desire_mental_state​\nget the mental state is in the desire base (if several, returns the first one).\n\nreturns: mental_state\nmental_state (mental_state): mental state to check\n\nget_desire_with_name​\nget the predicates is in the belief base (if several, returns the first one).\n\nreturns: mental_state\nname (string): name of the predicate to check\n\nget_desires​\nget the list of predicates is in the desire base\n\nreturns: list<mental_state>\npredicate (predicate): name of the predicates to check\n\nget_desires_mental_state​\nget the list of mental states is in the desire base\n\nreturns: list<mental_state>\nmental_state (mental_state): name of the mental states to check\n\nget_desires_with_name​\nget the list of predicates is in the belief base with the given name.\n\nreturns: list<mental_state>\nname (string): name of the predicates to check\n\nget_emotion​\nget the emotion in the emotion base (if several, returns the first one).\n\nreturns: emotion\nemotion (emotion): emotion to get\n\nget_emotion_with_name​\nget the emotion is in the emotion base (if several, returns the first one).\n\nreturns: emotion\nname (string): name of the emotion to check\n\nget_ideal​\nget the ideal about the predicate in the ideal base (if several, returns the first one).\n\nreturns: mental_state\npredicate (predicate): predicate to check ad an ideal\n\nget_ideal_mental_state​\nget the mental state in the ideal base (if several, returns the first one).\n\nreturns: mental_state\nmental_state (mental_state): mental state to return\n\nget_intention​\nget the predicates in the intention base (if several, returns the first one).\n\nreturns: mental_state\npredicate (predicate): predicate to check\n\nget_intention_mental_state​\nget the mental state is in the intention base (if several, returns the first one).\n\nreturns: mental_state\nmental_state (mental_state): mental state to check\n\nget_intention_with_name​\nget the predicates is in the belief base (if several, returns the first one).\n\nreturns: mental_state\nname (string): name of the predicate to check\n\nget_intentions​\nget the list of predicates is in the intention base\n\nreturns: list<mental_state>\npredicate (predicate): name of the predicates to check\n\nget_intentions_mental_state​\nget the list of mental state is in the intention base\n\nreturns: list<mental_state>\nmental_state (mental_state): mental state to check\n\nget_intentions_with_name​\nget the list of predicates is in the belief base with the given name.\n\nreturns: list<mental_state>\nname (string): name of the predicates to check\n\nget_obligation​\nget the predicates in the obligation base (if several, returns the first one).\n\nreturns: mental_state\npredicate (predicate): predicate to return\n\nget_plan​\nget the first plan with the given name\n\nreturns: BDIPlan\nname (string): the name of the planto get\n\nget_plans​\nget the list of plans.\n\nreturns: list<BDIPlan>\n\nget_social_link​\nget the social link (if several, returns the first one).\n\nreturns: social_link\nsocial_link (social_link): social link to check\n\nget_social_link_with_agent​\nget the social link with the agent concerned (if several, returns the first one).\n\nreturns: social_link\nagent (agent): an agent with who I get a social link\n\nget_uncertainty​\nget the predicates is in the uncertainty base (if several, returns the first one).\n\nreturns: mental_state\npredicate (predicate): predicate to return\n\nget_uncertainty_mental_state​\nget the mental state is in the uncertainty base (if several, returns the first one).\n\nreturns: mental_state\nmental_state (mental_state): mental state to return\n\nhas_belief​\ncheck if the predicates is in the belief base.\n\nreturns: bool\npredicate (predicate): predicate to check\n\nhas_belief_mental_state​\ncheck if the mental state is in the belief base.\n\nreturns: bool\nmental_state (mental_state): mental state to check\n\nhas_belief_with_name​\ncheck if the predicate is in the belief base.\n\nreturns: bool\nname (string): name of the predicate to check\n\nhas_desire​\ncheck if the predicates is in the desire base.\n\nreturns: bool\npredicate (predicate): predicate to check\n\nhas_desire_mental_state​\ncheck if the mental state is in the desire base.\n\nreturns: bool\nmental_state (mental_state): mental state to check\n\nhas_desire_with_name​\ncheck if the prediate is in the desire base.\n\nreturns: bool\nname (string): name of the predicate to check\n\nhas_emotion​\ncheck if the emotion is in the belief base.\n\nreturns: bool\nemotion (emotion): emotion to check\n\nhas_emotion_with_name​\ncheck if the emotion is in the emotion base.\n\nreturns: bool\nname (string): name of the emotion to check\n\nhas_ideal​\ncheck if the predicates is in the ideal base.\n\nreturns: bool\npredicate (predicate): predicate to check\n\nhas_ideal_mental_state​\ncheck if the mental state is in the ideal base.\n\nreturns: bool\nmental_state (mental_state): mental state to check\n\nhas_ideal_with_name​\ncheck if the predicate is in the ideal base.\n\nreturns: bool\nname (string): name of the predicate to check\n\nhas_obligation​\ncheck if the predicates is in the obligation base.\n\nreturns: bool\npredicate (predicate): predicate to check\n\nhas_social_link​\ncheck if the social link base.\n\nreturns: bool\nsocial_link (social_link): social link to check\n\nhas_social_link_with_agent​\ncheck if the social link base.\n\nreturns: bool\nagent (agent): an agent with who I want to check if I have a social link\n\nhas_uncertainty​\ncheck if the predicates is in the uncertainty base.\n\nreturns: bool\npredicate (predicate): predicate to check\n\nhas_uncertainty_mental_state​\ncheck if the mental state is in the uncertainty base.\n\nreturns: bool\nmental_state (mental_state): mental state to check\n\nhas_uncertainty_with_name​\ncheck if the predicate is in the uncertainty base.\n\nreturns: bool\nname (string): name of the uncertainty to check\n\nis_current_intention​\ncheck if the predicates is the current intention (last entry of intention base).\n\nreturns: bool\npredicate (predicate): predicate to check\n\nis_current_intention_mental_state​\ncheck if the mental state is the current intention (last entry of intention base).\n\nreturns: bool\nmental_state (mental_state): mental state to check\n\nis_current_plan​\ntell if the current plan has the same name as tested\n\nreturns: bool\nname (string): the name of the plan to test\n\nremove_all_beliefs​\nremoves the predicates from the belief base.\n\nreturns: bool\npredicate (predicate): predicate to remove\n\nremove_belief​\nremoves the predicate from the belief base.\n\nreturns: bool\npredicate (predicate): predicate to remove\n\nremove_belief_mental_state​\nremoves the mental state from the belief base.\n\nreturns: bool\nmental_state (mental_state): mental state to remove\n\nremove_desire​\nremoves the predicates from the desire base.\n\nreturns: bool\npredicate (predicate): predicate to remove from desire base\n\nremove_desire_mental_state​\nremoves the mental state from the desire base.\n\nreturns: bool\nmental_state (mental_state): mental state to remove from desire base\n\nremove_emotion​\nremoves the emotion from the emotion base.\n\nreturns: bool\nemotion (emotion): emotion to remove\n\nremove_ideal​\nremoves the predicates from the ideal base.\n\nreturns: bool\npredicate (predicate): predicate to remove\n\nremove_ideal_mental_state​\nremoves the mental state from the ideal base.\n\nreturns: bool\nmental_state (mental_state): metal state to remove\n\nremove_intention​\nremoves the predicates from the intention base.\n\nreturns: bool\npredicate (predicate): intention's predicate to remove\ndesire_also (boolean): removes also desire\n\nremove_intention_mental_state​\nremoves the mental state from the intention base.\n\nreturns: bool\nmental_state (mental_state): intention's mental state to remove\ndesire_also (boolean): removes also desire\n\nremove_obligation​\nremoves the predicates from the obligation base.\n\nreturns: bool\npredicate (predicate): predicate to remove\n\nremove_social_link​\nremoves the social link from the social relation base.\n\nreturns: bool\nsocial_link (social_link): social link to remove\n\nremove_social_link_with_agent​\nremoves the social link from the social relation base.\n\nreturns: bool\nagent (agent): an agent with who I get the social link to remove\n\nremove_uncertainty​\nremoves the predicates from the uncertainty base.\n\nreturns: bool\npredicate (predicate): predicate to remove\n\nremove_uncertainty_mental_state​\nremoves the mental state from the uncertainty base.\n\nreturns: bool\nmental_state (mental_state): mental state to remove\n\nreplace_belief​\nreplace the old predicate by the new one.\n\nreturns: bool\nold_predicate (predicate): predicate to remove\npredicate (predicate): predicate to add\n\n\nsorted_tasks​\nA control architecture, based on the concept of tasks, which are executed in an order defined by their weight. This skill extends the WeightedTasksArchitecture skill and take all his actions and variables\nVariables​\nActions​\n\nuser_first​\nA control architecture, based on FSM, where the user is being given control before states / reflexes of the agent are executed. This skill extends the UserControlArchitecture skill and take all his actions and variables\nVariables​\nActions​\n\nuser_last​\nA control architecture, based on FSM, where the user is being given control after states / reflexes of the agent are executed. This skill extends the UserControlArchitecture skill and take all his actions and variables\nVariables​\nActions​\n\nuser_only​\nA control architecture, based on FSM, where the user is being given complete control of the agents. This skill extends the UserControlArchitecture skill and take all his actions and variables\nVariables​\nActions​\n\nweighted_tasks​\nThe class WeightedTasksArchitecture. A simple architecture of competing tasks, where one can be active at a time. Weights of the tasks are computed every step and the chosen task is simply the one with the maximal weight\nVariables​\nActions​"},{"filePath":"https:--gama-platform.org--wiki-BuiltInSkills.txt","text":"Built-in Skills\nThis file is automatically generated from java files. Do Not Edit It.\n\nIntroduction​\nSkills are built-in modules, written in Java, that provide a set of related built-in variables and built-in actions (in addition to those already provided by GAMA) to the species that declare them. A declaration of skill is done by filling the skills attribute in the species definition:\nspecies my_species skills: [skill1, skill2] {    ...}\nSkills have been designed to be mutually compatible so that any combination of them will result in a functional species. An example of skill is the moving skill.\nSo, for instance, if a species is declared as:\nspecies foo skills: [moving]{...}\nIts agents will automatically be provided with the following variables : speed, heading, destination and the following actions: move, goto, wander, follow in addition to those built-in in species and declared by the modeller. Most of these variables, except the ones marked read-only, can be customized and modified like normal variables by the modeller. For instance, one could want to set a maximum for the speed; this would be done by redeclaring it like this:\nfloat speed max:100 min:0;\nOr, to obtain a speed increasing at each simulation step:\nfloat speed max:100 min:0  <- 1 update: speed * 1.01;\nOr, to change the speed in a behavior:\nif speed = 5 {    speed <- 10;}\n\nTable of Contents​\nadvanced_driving, dynamic_body, fipa, messaging, moving, moving3D, network, pedestrian, pedestrian_road, skill_road, skill_road_node, SQLSKILL, static_body, thread,\n\nadvanced_driving​\nVariables​\n\nacc_bias (float): the bias term used for asymmetric lane changing, parameter 'a_bias' in MOBIL\nacc_gain_threshold (float): the minimum acceleration gain for the vehicle to switch to another lane, introduced to prevent frantic lane changing. Known as the parameter 'a_th' in the MOBIL lane changing model\nacceleration (float): the current acceleration of the vehicle (in m/s^2)\nallowed_lanes (list): a list containing possible lane index values for the attribute lowest_lane\ncurrent_index (int): the index of the current edge (road) in the path\ncurrent_lane (int): the current lane on which the agent is\ncurrent_path (path): the path which the agent is currently following\ncurrent_road (agent): the road which the vehicle is currently on\ncurrent_target (agent): the current target of the agent\ndelta_idm (float): the exponent used in the computation of free-road acceleration in the Intelligent Driver Model\ndistance_to_current_target (float): euclidean distance to the current target node\ndistance_to_goal (float): euclidean distance to the endpoint of the current segment\nfinal_target (agent): the final target of the agent\nfollower (agent): the vehicle following this vehicle\nignore_oneway (boolean): if set to true, the vehicle will be able to violate one-way traffic rule\nlane_change_cooldown (float): the duration that a vehicle must wait before changing lanes again\nlane_change_limit (int): the maximum number of lanes that the vehicle can change during a simulation step\nleading_distance (float): the distance to the leading vehicle\nleading_speed (float): the speed of the leading vehicle\nleading_vehicle (agent): the vehicle which is right ahead of the current vehicle.\nIf this is set to nil, the leading vehicle does not exist or might be very far away.\nlinked_lane_limit (int): the maximum number of linked lanes that the vehicle can use; the default value is -1, i.e. the vehicle can use all available linked lanes\nlowest_lane (int): the lane with the smallest index that the vehicle is in\nmax_acceleration (float): the maximum acceleration of the vehicle. Known as the parameter 'a' in the Intelligent Driver Model\nmax_deceleration (float): the maximum deceleration of the vehicle. Known as the parameter 'b' in the Intelligent Driver Model\nmax_safe_deceleration (float): the maximum deceleration that the vehicle is willing to induce on its back vehicle when changing lanes. Known as the parameter 'b_save' in the MOBIL lane changing model\nmax_speed (float): the maximum speed that the vehicle can achieve. Known as the parameter 'v0' in the Intelligent Driver Model\nmin_safety_distance (float): the minimum distance of the vehicle's front bumper to the leading vehicle's rear bumper, known as the parameter s0 in the Intelligent Driver Model\nmin_security_distance (float): the minimal distance to another vehicle\nnext_road (agent): the road which the vehicle will enter next\nnum_lanes_occupied (int): the number of lanes that the vehicle occupies\non_linked_road (boolean): is the agent on the linked road?\npoliteness_factor (float): determines the politeness level of the vehicle when changing lanes. Known as the parameter 'p' in the MOBIL lane changing model\nproba_block_node (float): probability to block a node (do not let other vehicle cross the crossroad), within one second\nproba_lane_change_down (float): probability to change to a lower lane (right lane if right side driving) to gain acceleration, within one second\nproba_lane_change_up (float): probability to change to a upper lane (left lane if right side driving) to gain acceleration, within one second\nproba_respect_priorities (float): probability to respect priority (right or left) laws, within one second\nproba_respect_stops (list): probability to respect stop laws - one value for each type of stop, within one second\nproba_use_linked_road (float): probability to change to a linked lane to gain acceleration, within one second\nreal_speed (float): the actual speed of the agent (in meter/second)\nright_side_driving (boolean): are vehicles driving on the right size of the road?\nsafety_distance_coeff (float): the coefficient for the computation of the the min distance between two vehicles (according to the vehicle speed - security_distance =max(min_security_distance, security_distance_coeff * min(self.real_speed, other.real_speed) )\nsecurity_distance_coeff (float): the coefficient for the computation of the the min distance between two vehicles (according to the vehicle speed - safety_distance =max(min_safety_distance, safety_distance_coeff * min(self.real_speed, other.real_speed) )\nsegment_index_on_road (int): current segment index of the agent on the current road\nspeed (float): the speed of the agent (in meter/second)\nspeed_coeff (float): speed coefficient for the speed that the vehicle want to reach (according to the max speed of the road)\ntargets (list): the current list of points that the agent has to reach (path)\ntime_headway (float): the time gap that to the leading vehicle that the driver must maintain. Known as the parameter 'T' in the Intelligent Driver Model\ntime_since_lane_change (float): the elapsed time since the last lane change\nusing_linked_road (boolean): indicates if the vehicle is occupying at least one lane on the linked road\nvehicle_length (float): the length of the vehicle (in meters)\nviolating_oneway (boolean): indicates if the vehicle is moving in the wrong direction on an one-way (unlinked) road\n\nActions​\nadvanced_follow_driving​\nmoves the agent towards along the path passed in the arguments while considering the other agents in the network (only for graph topology)\nReturned type: float  : the remaining time\nAdditional facets:​\n\npath (path): a path to be followed.\ntarget (point): the target to reach\nspeed (float): the speed to use for this move (replaces the current value of speed)\ntime (float): time to travel\n\nExamples:​\ndo osm_follow path: the_path on: road_network;\nchoose_lane​\nOverride this if you want to manually choose a lane when entering new road. By default, the vehicle tries to stay in the current lane. If the new road has fewer lanes than the current one and the current lane index is too big, it tries to enter the most uppermost lane.\nReturned type: int  : an integer representing the lane index\nAdditional facets:​\n\nnew_road (agent): the new road that's the vehicle is going to enter\n\ncompute_path​\nAction to compute the shortest path to the target node, or shortest path based on the provided list of nodes\nReturned type: path  : the computed path, or nil if no valid path is found\nAdditional facets:​\n\ngraph (graph): the graph representing the road network\ntarget (agent): the target node to reach\nsource (agent): the source node (optional, if not defined, closest node to the agent location)\nnodes (list): the nodes forming the resulting path\n\nExamples:​\ndo compute_path graph: road_network target: target_node; do compute_path graph: road_network nodes: [node1, node5, node10];\ndrive​\naction to drive toward the target\nReturned type: bool\nExamples:​\ndo drive;\ndrive_random​\naction to drive by chosen randomly the next road\nReturned type: bool\nAdditional facets:​\n\ngraph (graph): a graph representing the road network\nproba_roads (map): a map containing for each road (key), the probability to be selected as next road (value)\n\nExamples:​\ndo drive_random init_node: some_node;\nexternal_factor_impact​\naction that allows to define how the remaining time is impacted by external factor\nReturned type: float  : the remaining time\nAdditional facets:​\n\nnew_road (agent): the road on which to the vehicle wants to go\nremaining_time (float): the remaining time\n\nExamples:​\ndo external_factor_impact new_road: a_road remaining_time: 0.5;\nforce_move​\naction to drive by chosen randomly the next road\nReturned type: float\nAdditional facets:​\n\nlane (int): the lane on which to make the agent move\nacceleration (float): acceleration of the vehicle\ntime (float): time of move\n\nExamples:​\ndo drive_random init_node: some_node;\ngoto_drive​\nmoves the agent towards the target passed in the arguments.\nReturned type: path  : optional: the path followed by the agent.\nAdditional facets:​\n\ntarget (geometry): the entity towards which to move.\nspeed (float): the speed to use for this move (replaces the current value of speed)\non (any type): graph, topology, list of geometries or map of geometries that restrain this move\nrecompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true)\nreturn_path (boolean): if true, return the path followed (by default: false)\nfollowing (path): Path to follow.\n\nExamples:​\ndo goto_drive target: one_of road on: road_network;\nlane_choice​\naction to choose a lane\nReturned type: int  : the chosen lane, return -1 if no lane can be taken\nAdditional facets:​\n\nnew_road (agent): the road on which to choose the lane\n\nExamples:​\ndo lane_choice new_road: a_road;\non_entering_new_road​\noverride this if you want to do something when the vehicle enters a new road (e.g. adjust parameters)\nReturned type: void\npath_from_nodes​\naction to compute a path from a list of nodes according to a given graph\nReturned type: path  : the computed path, return nil if no path can be taken\nAdditional facets:​\n\ngraph (graph): the graph representing the road network\nnodes (list): the list of nodes composing the path\n\nExamples:​\ndo compute_path_from_nodes graph: road_network nodes: [node1, node5, node10];\nready_to_cross​\naction to test if the vehicle cross a road node to move to a new road\nReturned type: bool  : true if the vehicle can cross the road node, false otherwise\nAdditional facets:​\n\nnode (agent): the road node to test\nnew_road (agent): the road to test\n\nExamples:​\ndo is_ready_next_road new_road: a_road lane: 0;\nspeed_choice​\naction to choose a speed\nReturned type: float  : the chosen speed\nAdditional facets:​\n\nnew_road (agent): the road on which to choose the speed\n\nExamples:​\ndo speed_choice new_road: the_road;\ntest_next_road​\naction to test if the vehicle can take the given road\nReturned type: bool  : true (the vehicle can take the road) or false (the vehicle cannot take the road)\nAdditional facets:​\n\nnew_road (agent): the road to test\n\nExamples:​\ndo test_next_road new_road: a_road;\nunregister​\nremove the vehicle from its current roads\nReturned type: bool\nExamples:​\ndo unregister\n\ndynamic_body​\nVariables​\n\nangular_damping (float): Between 0 and 1. an angular decelaration coefficient that occurs even without contact\nangular_velocity (point): The angular velocity of the agent in the three directions, expressed as a point.\ncontact_damping (float): Between 0 and 1. a decelaration coefficient that occurs in case of contact. Only available in the native Bullet library (no effect on the Java implementation)\ndamping (float): Between 0 and 1. a linear decelaration coefficient that occurs even without contact\nvelocity (point): The linear velocity of the agent in the three directions, expressed as a point.\n\nActions​\napply​\nAn action that allows to apply different effects to the object, like forces, impulses, etc.\nReturned type: unknown\nAdditional facets:​\n\nclearance (boolean): If true clears all forces applied to the agent and clears its veolicity as well\nimpulse (point): An idealised change of momentum. Adds to the velocity of the object. This is the kind of push that you would use on a pool billiard ball.\nforce (point): Move (push) the object once with a certain moment, expressed as a point (vector). Adds to the existing forces.\ntorque (point): Rotate (twist) the object once around its axes, expressed as a point (vector)\n\n\nfipa​\nThe fipa skill offers some primitives and built-in variables which enable agent to communicate with each other using the FIPA interaction protocol.\nVariables​\n\naccept_proposals (list): A list of 'accept_proposal' performative messages in the agent's mailbox\nagrees (list): A list of 'agree' performative messages.\ncancels (list): A list of 'cancel' performative messages.\ncfps (list): A list of 'cfp' (call for proposal) performative messages.\nconversations (list): A list containing the current conversations of agent. Ended conversations are automatically removed from this list.\nfailures (list): A list of 'failure' performative messages.\ninforms (list): A list of 'inform' performative messages.\nproposes (list): A list of 'propose' performative messages .\nqueries (list): A list of 'query' performative messages.\nrefuses (list): A list of 'propose' performative messages.\nreject_proposals (list): A list of 'reject_proposal' performative messages.\nrequests (list): A list of 'request' performative messages.\nrequestWhens (list): A list of 'request-when' performative messages.\nsubscribes (list): A list of 'subscribe' performative messages.\n\nActions​\naccept_proposal​\nReplies a message with an 'accept_proposal' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\nagree​\nReplies a message with an 'agree' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\ncancel​\nReplies a message with a 'cancel' peformative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\ncfp​\nReplies a message with a 'cfp' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\nend_conversation​\nReply a message with an 'end_conversation' peprformative message. This message marks the end of a conversation. In a 'no-protocol' conversation, it is the responsible of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol. Please note that if the contents of the messages of the conversation are not read, then this command has no effect (i.e. it  must be read by at least one of the agents in the conversation)\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\nfailure​\nReplies a message with a 'failure' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\ninform​\nReplies a message with an 'inform' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\npropose​\nReplies a message with a 'propose' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\nquery​\nReplies a message with a 'query' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\nrefuse​\nReplies a message with a 'refuse' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The contents of the replying message\n\nreject_proposal​\nReplies a message with a 'reject_proposal' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\nreply​\nReplies a message. This action should be only used to reply a message in a 'no-protocol' conversation and with a 'user defined performative'. For performatives supported by GAMA (i.e., standard FIPA performatives), please use the 'action' with the same name of 'performative'. For example, to reply a message with a 'request' performative message, the modeller should use the 'request' action.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\nperformative (string): The performative of the replying message\ncontents (list): The content of the replying message\n\nrequest​\nReplies a message with a 'request' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\nsend​\nStarts a conversation/interaction protocol.\nReturned type: message\nAdditional facets:​\n\nto (list): A list of receiver agents\ncontents (list): The content of the message. A list of any GAML type\nperformative (string): A string, representing the message performative\nprotocol (string): A string representing the name of interaction protocol\n\nstart_conversation​\nStarts a conversation/interaction protocol.\nReturned type: message\nAdditional facets:​\n\nto (list): A list of receiver agents\ncontents (list): The content of the message. A list of any GAML type\nperformative (string): A string, representing the message performative\nprotocol (string): A string representing the name of interaction protocol\n\nsubscribe​\nReplies a message with a 'subscribe' performative message.\nReturned type: unknown\nAdditional facets:​\n\nmessage (message): The message to be replied\ncontents (list): The content of the replying message\n\n\nmessaging​\nA simple skill that provides agents with a mailbox than can be filled with messages\nVariables​\n\nmailbox (list): The list of messages that can be consulted by the agent\n\nActions​\nsend​\nAction used to send a message (that can be of any kind of object) to an agent or a server.\nReturned type: message\nAdditional facets:​\n\nto (any type): The agent, or server, to which this message will be sent to\ncontents (any type): The contents of the message, an arbitrary object\n\nExamples:​\ndo send to:dest contents:\"This message is sent by \" + name + \" to \" + dest;\n\nmoving​\nThe moving skill is intended to define the minimal set of behaviours required for agents that are able to move on different topologies\nVariables​\n\ncurrent_edge (geometry): Represents the agent/geometry on which the agent is located (only used with a graph)\ncurrent_path (path): Represents the path on which the agent is moving on (goto action on a graph)\ndestination (point): Represents the next location of the agent if it keeps its current speed and heading (read-only). ** Only correct in continuous topologies and may return nil values if the destination is outside the environment **\nheading (float): Represents the absolute heading of the agent in degrees.\nlocation (point): Represents the current position of the agent\nreal_speed (float): Represents the actual speed of the agent (in meter/second)\nspeed (float): Represents the speed of the agent (in meter/second)\n\nActions​\nfollow​\nmoves the agent along a given path passed in the arguments.\nReturned type: path  : optional: the path followed by the agent.\nAdditional facets:​\n\nspeed (float): the speed to use for this move (replaces the current value of speed)\npath (path): a path to be followed.\nmove_weights (map): Weights used for the moving.\nreturn_path (boolean): if true, return the path followed (by default: false)\n\nExamples:​\ndo follow speed: speed * 2 path: road_path;\ngoto​\nmoves the agent towards the target passed in the arguments.\nReturned type: path  : optional: the path followed by the agent.\nAdditional facets:​\n\ntarget (geometry): the location or entity towards which to move.\nspeed (float): the speed to use for this move (replaces the current value of speed)\non (any type): graph, topology, list of geometries or map of geometries that restrain this move\nrecompute_path (boolean): if false, the path is not recompute even if the graph is modified (by default: true)\nreturn_path (boolean): if true, return the path followed (by default: false)\nmove_weights (map): Weights used for the moving.\n\nExamples:​\ndo goto target: (one_of road).location speed: speed * 2 on: road_network;\nmove​\nmoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.\nReturned type: path\nAdditional facets:​\n\nspeed (float): the speed to use for this move (replaces the current value of speed)\nheading (float): the angle (in degree) of the target direction.\nbounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\n\nExamples:​\ndo move speed: speed - 10 heading: heading + rnd (30) bounds: agentA;\nwander​\nMoves the agent towards a random location at the maximum distance (with respect to its speed). The heading of the agent is chosen randomly if no amplitude is specified. This action changes the value of heading.\nReturned type: bool\nAdditional facets:​\n\nspeed (float): the speed to use for this move (replaces the current value of speed)\namplitude (float): a restriction placed on the random heading choice. The new heading is chosen in the range (heading - amplitude/2, heading+amplitude/2)\nbounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry)\non (graph): the graph that restrains this move (the agent moves on the graph\nproba_edges (map): When the agent moves on a graph, the probability to choose another edge. If not defined, each edge has the same probability to be chosen\n\nExamples:​\ndo wander speed: speed - 10 amplitude: 120 bounds: agentA;\n\nmoving3D​\nThe moving skill 3D is intended to define the minimal set of behaviours required for agents that are able to move on different topologies\nVariables​\n\ndestination (point): continuously updated destination of the agent with respect to its speed and heading (read-only)\nheading (float): the absolute heading of the agent in degrees (in the range 0-359)\npitch (float): the absolute pitch of the agent in degrees (in the range 0-359)\nroll (float): the absolute roll of the agent in degrees (in the range 0-359)\nspeed (float): the speed of the agent (in meter/second)\n\nActions​\nmove​\nmoves the agent forward, the distance being computed with respect to its speed and heading. The value of the corresponding variables are used unless arguments are passed.\nReturned type: path\nAdditional facets:​\n\nspeed (float): the speed to use for this move (replaces the current value of speed)\nheading (int): int, optional, the direction to take for this move (replaces the current value of heading)\npitch (int): int, optional, the direction to take for this move (replaces the current value of pitch)\nroll (int): int, optional, the direction to take for this move (replaces the current value of roll)\nbounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\n\nExamples:​\ndo move speed: speed - 10 heading: heading + rnd (30) bounds: agentA;\n\nnetwork​\nThe network skill provides new features to let agents exchange message through network. Sending and receiving data is done with the messaging skill's actions.\nVariables​\n\nnetwork_groups (list): The set of groups the agent belongs to\nnetwork_name (string): Net ID of the agent\nnetwork_server (list): The list of all the servers to which the agent is connected\n\nActions​\nconnect​\nAction used by a networking agent to connect to a server or to create a server.\nReturned type: bool\nAdditional facets:​\n\nprotocol (string): protocol type (MQTT (by default), TCP, UDP, websocket, arduino): the possible value ares 'udp_server', 'udp_emitter', 'tcp_server', 'tcp_client', 'websocket_server', 'websocket_client', 'http', 'arduino', otherwise the MQTT protocol is used.\nport (int): Port number\nraw (boolean): message type raw or rich\nwith_name (string): ID of the agent (its name) for the simulation\nlogin (string): login for the connection to the server\npassword (string): password associated to the login\nforce_network_use (boolean): force the use of the network even interaction between local agents\nto (string): server URL (localhost or a server URL)\nsize_packet (int): For UDP connection, it sets the maximum size of received packets (default = 1024bits).\n\nExamples:​\n do connect with_name:\"any_name\";  do connect to:\"localhost\" port:9876 with_name:\"any_name\";  do connect to:\"localhost\" protocol:\"MQTT\" port:9876 with_name:\"any_name\";  do connect to:\"localhost\" protocol:\"udp_server\" port:9876 with_name:\"Server\";  do connect to:\"localhost\" protocol:\"udp_client\" port:9876 with_name:\"Client\";  do connect to:\"localhost\" protocol:\"udp_server\" port:9877 size_packet: 4096;  do connect to:\"localhost\" protocol:\"tcp_client\" port:9876;  do connect to:\"localhost\" protocol:\"tcp_server\" port:9876 raw:true;  do connect to: \"https://openlibrary.org\" protocol: \"http\" port: 443 raw: true;  do connect protocol: \"arduino\";\nexecute​\nAction that executes a command in the OS, as if it is executed from a terminal.\nReturned type: string  : The error message if any\nAdditional facets:​\n\ncommand (string): command to execute\n\nfetch_message​\nFetch the first message from the mailbox (and remove it from the mailing box). If the mailbox is empty, it returns a nil message.\nReturned type: message\nExamples:​\nmessage mess <- fetch_message(); loop while:has_more_message(){ \tmessage mess <- fetch_message();\twrite message.contents;}\nfetch_message_from_network​\nFetch all messages from network to mailbox. Use this in specific case only, this action is done at the end of each step.\nReturned type: bool\nExamples:​\ndo fetch_message_from_network;//forces gama to get all the new messages since the begining of the cycleloop while: has_more_message(){ \tmessage mess <- fetch_message();\twrite message.contents;}\nhas_more_message​\nCheck whether the mailbox contains any message.\nReturned type: bool\nExamples:​\nbool mailbox_contain_messages <- has_more_message(); loop while:has_more_message(){ \tmessage mess <- fetch_message();\twrite message.contents;}\njoin_group​\nAllow an agent to join a group of agents in order to broadcast messages to other membersor to receive messages sent by other members. Note that all members of the group called : \"ALL\".\nReturned type: bool\nAdditional facets:​\n\nwith_name (string): name of the group\n\nExamples:​\ndo join_group with_name:\"group name\"; do join_group with_name:\"group name\";do send to:\"group name\" contents:\"I am new in this group\";\nleave_group​\nleave a group of agents. The leaving agent will not receive any message from the group. Overwhise, it can send messages to the left group\nReturned type: bool\nAdditional facets:​\n\nwith_name (string): name of the group the agent wants to leave\n\nExamples:​\n do leave_group with_name:\"my_group\";\n\npedestrian​\nVariables​\n\nA_obstacles_SFM (float): Value of A in the SFM model for obstacles - the force of repulsive interactions (classic values : mean = 4.5, std = 0.3)\nA_pedestrians_SFM (float): Value of A in the SFM model for pedestrians - the force of repulsive interactions (classic values : mean = 4.5, std = 0.3)\navoid_other (boolean): has the pedestrian to avoid other pedestrians?\nB_obstacles_SFM (float): Value of B in the SFM model for obstacles - the range (in meters) of repulsive interactions\nB_pedestrians_SFM (float): Value of B in the SFM model for pedestrians - the range (in meters) of repulsive interactions\ncurrent_index (int): the current index of the agent waypoint (according to the waypoint list)\ncurrent_waypoint (geometry): the current waypoint of the agent\nfinal_waypoint (geometry): the final waypoint of the agent\nforces (map): the map of forces\ngama_SFM (float): Value of gama in the SFM model  the amount of normal social force added in tangential direction. between 0.0 and 1.0 (classic values : mean = 0.35, std = 0.01)\nk_SFM (float): Value of k in the SFM model: force counteracting body compression\nkappa_SFM (float): Value of kappa in the SFM model: friction counteracting body compression\nlambda_SFM (float): Value of lambda in the SFM model - the (an-)isotropy (between 0.0 and 1.0)\nminimal_distance (float): Minimal distance between pedestrians\nn_prime_SFM (float): Value of n' in the SFM model (classic values : mean = 3.0, std = 0.7)\nn_SFM (float): Value of n in the SFM model (classic values : mean = 2.0, std = 0.1)\nobstacle_consideration_distance (float): Distance of consideration of obstacles (to compute the nearby obstacles, used as distance, the max between this value and (step * speed) - classic value: 3.5m\nobstacle_species (list): the list of species that are considered as obstacles\npedestrian_consideration_distance (float): Distance of consideration of other pedestrians (to compute the nearby obstacles, used as distance, the max between this value and (step * speed) - classic value: 3.5m\npedestrian_model (string): Model use for the movement of agents (Social Force Model). Can be either \"simple\" or \"advanced\" (default) for different versions of SFM Helbing model\npedestrian_species (list): the list of species that are considered as pedestrians\nproba_detour (float): probability to accept to do a detour\nrelaxion_SFM (float): Value of relaxion in the SFM model - the amount of delay time for an agent to adapt.(classic values : mean = 0.54, std = 0.05)\nroads_waypoints (map): for each waypoint, the associated road\nshoulder_length (float): The width of the pedestrian (in meters) - classic values: [0.39, 0.515]\ntolerance_waypoint (float): distance to a waypoint (in meters) to consider that an agent is arrived at the waypoint\nuse_geometry_waypoint (boolean): use geometries as waypoint instead of points\nvelocity (point): The velocity of the pedestrian (in meters)\nwaypoints (list): the current list of points/shape that the agent has to reach (path)\n\nActions​\ncompute_virtual_path​\naction to compute a path to a location according to a given graph\nReturned type: path  : the computed path, return nil if no path can be taken\nAdditional facets:​\n\npedestrian_graph (graph): the graph on wich compute the path\ntarget (geometry): the target to reach, can be any agent\n\nExamples:​\ndo compute_virtual_path graph: pedestrian_network target: any_point;\nrelease_path​\nclean all the interne state of the agent\nReturned type: bool\nAdditional facets:​\n\ncurrent_road (agent): current road on which the agent is located (can be nil)\n\nwalk​\naction to walk toward the final target using the current_path (requires to use the compute_virtual_path action before)\nReturned type: bool\nExamples:​\ndo walk;\nwalk_to​\naction to walk toward a target\nReturned type: bool\nAdditional facets:​\n\ntarget (geometry): Move toward the target using the SFM model\nbounds (geometry): the geometry (the localized entity geometry) that restrains this move (the agent moves inside this geometry\n\nExamples:​\ndo walk_to {10,10};\n\npedestrian_road​\nVariables​\n\nagents_on (list): for each people on the road\nexit_nodes (map): The exit hub (several exit connected to each road extremities) that makes it possible to reduce angular distance when travelling to connected pedestrian roads\nfree_space (geometry): for each people on the road\nintersection_areas (map): map of geometries to connect segments linked to this road\nlinked_pedestrian_roads (list): the close pedestrian roads\nroad_status (int): When road status equals 1 it has 2D continuous space property for pedestrian; when equal to 2 is simply a 1D road\n\nActions​\nbuild_exit_hub​\nAdd exit hub to pedestrian corridor to reduce angular distance between node of the network\nReturned type: bool\nAdditional facets:​\n\npedestrian_graph (graph): The pedestrian network from which to find connected corridors\ndistance_between_targets (float): min distances between 2 targets\n\nExamples:​\ndo build_exit_hub pedestrian_graph: pedestrian_network distance_between_targets: 10.0;\nbuild_intersection_areas​\nBuild intersection areas with connected roads\nReturned type: bool\nAdditional facets:​\n\npedestrian_graph (graph): The pedestrian network from which to find connected corridors\n\nExamples:​\ndo build_intersection_areas pedestrian_graph: pedestrian_network;\ninitialize​\naction to initialize the free space of roads\nReturned type: bool\nAdditional facets:​\n\ndistance (float): the maximal distance to the road\nobstacles (container): the list of species to consider as obstacles to remove from the free space\ndistance_extremity (float): the distance added to the extremimity to connect to other road (in meters)\nbounds (container): the geometries (the localized entity geometries) that restrains the agent movement (the agent moves inside this geometry\nmasked_by (container): if defined, keep only the part of the geometry that is visible from the location of the road considering the given obstacles\nmasked_by_precision (int): if masked_by is defined, number of triangles used to compute the visible geometries (default: 120)\nstatus (int): the status (int) of the road: 1 (default) for roads where agent move on a continuous 2D space and 0 for 1D roads with queu-in queu-out like movement\n\nExamples:​\ndo initialize distance: 10.0 obstacles: [building];\n\nskill_road​\nVariables​\n\nagents_on (list): for each lane of the road, the list of agents for each segment\nall_agents (list): the list of agents on the road\nlinked_road (agent): the linked road: the lanes of this linked road will be usable by drivers on the road\nmaxspeed (float): the maximal speed on the road\nnum_lanes (int): the number of lanes\nnum_segments (int): the number of road segments\nsegment_lengths (list): stores the length of each road segment. The index of each element corresponds to the segment index.\nsource_node (agent): the source node of the road\ntarget_node (agent): the target node of the road\nvehicle_ordering (list): provides information about the ordering of vehicle on any given lane\n\nActions​\nregister​\nregister the agent on the road at the given lane\nReturned type: bool\nAdditional facets:​\n\nagent (agent): the agent to register on the road.\nlane (int): the lane index on which to register; if lane index >= number of lanes, then register on the linked road\n\nExamples:​\ndo register agent: the_driver lane: 0;\nunregister​\nunregister the agent on the road\nReturned type: bool\nAdditional facets:​\n\nagent (agent): the agent to unregister on the road.\n\nExamples:​\ndo unregister agent: the_driver;\n\nskill_road_node​\nVariables​\n\nblock (map): define the list of agents blocking the node, and for each agent, the list of concerned roads\npriority_roads (list): the list of priority roads\nroads_in (list): the list of input roads\nroads_out (list): the list of output roads\nstop (list): define for each type of stop, the list of concerned roads\n\nActions​\n\nSQLSKILL​\nThis skill allows agents to be provided with actions and attributes in order to connect to SQL databases\nVariables​\nActions​\nexecuteUpdate​\nAction used to execute any update query (CREATE, DROP, INSERT...) to the database (query written in SQL).\nReturned type: int\nAdditional facets:​\n\nparams (map): Connection parameters\nupdateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark\nvalues (list): List of values that are used to replace question mark\n\nExamples:​\ndo executeUpdate params: PARAMS updateComm: \"DROP TABLE IF EXISTS registration\"; do executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\"; do executeUpdate params: PARAMS updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\" values: [101, 'Mr', 'Mme', 45];\ninsert​\nAction used to insert new data in a database\nReturned type: int\nAdditional facets:​\n\nparams (map): Connection parameters\ninto (string): Table name\ncolumns (list): List of column name of table\nvalues (list): List of values that are used to insert into table. Columns and values must have same size\n\nExamples:​\ndo insert params: PARAMS into: \"registration\" values: [102, 'Mahnaz', 'Fatma', 25]; do insert params: PARAMS into: \"registration\" columns: [\"id\", \"first\", \"last\"] values: [103, 'Zaid tim', 'Kha'];\nlist2Matrix​\nAction that transforms the list of list of data and metadata (resulting from a query) into a matrix.\nReturned type: matrix\nAdditional facets:​\n\nparam (list): Param: a list of records and metadata\ngetName (boolean): getType: a boolean value, optional parameter\ngetType (boolean): getType: a boolean value, optional parameter\n\nExamples:​\nlist<list> t <- list<list> (select(PARAMS, \"SELECT * FROM registration\"));write list2Matrix(t, true, true);\nselect​\nAction used to restrieve data from a database\nReturned type: list\nAdditional facets:​\n\nparams (map): Connection parameters\nselect (string): select string with question marks\nvalues (list): List of values that are used to replace question marks\n\nExamples:​\nlist<list> t <- list<list> (select(PARAMS, \"SELECT * FROM registration\"));\ntestConnection​\nAction used to test the connection to a database\nReturned type: bool\nAdditional facets:​\n\nparams (map): Connection parameters\n\nExamples:​\nif (!first(DB_Accessor).testConnection(PARAMS)) {\t\t\twrite \"Connection impossible\";\t\t\tdo pause;\t\t}\n\nstatic_body​\nVariables​\n\naabb (geometry): The axis-aligned bounding box. A box used to evaluate the probability of contacts between objects. Can be displayed as any other GAMA shapes/geometries in order to verify that the physical representation of the agent corresponds to its geometry in the model\nfriction (float): Between 0 and 1. The coefficient of friction of the agent (how much it decelerates the agents in contact with him). Default is 0.5\nmass (float): The mass of the agent. Should be equal to 0.0 for static, motionless agents\nrestitution (float): Between 0 and 1. The coefficient of restitution of the agent (defines the 'bounciness' of the agent). Default is 0\nrotation (pair): The rotation of the physical body, expressed as a pair which key is the angle in degrees and value the axis around which it is measured\n\nActions​\ncontact_added_with​\nThis action can be redefined in order for the agent to implement a specific behavior when it comes into contact (collision) with another agent. It is automatically called by the physics simulation engine on both colliding agents. The default built-in behavior does nothing.\nReturned type: unknown\nAdditional facets:​\n\nother (agent): represents the other agent with which a collision has been detected\n\ncontact_removed_with​\nThis action can be redefined in order for the agent to implement a specific behavior when a previous contact with another agent is removed. It is automatically called by the physics simulation engine on both colliding agents. The default built-in behavior does nothing.\nReturned type: unknown\nAdditional facets:​\n\nother (agent): represents the other agent with which a collision has been detected\n\nupdate_body​\nThis action must be called when the geometry of the agent changes in the simulation world and this change must be propagated to the physical world. The change of location (in either worlds) or the rotation due to physical forces do not count as changes, as they are already taken into account. However, a rotation in the simulation world need to be handled by calling this action. As it involves long operations (removing the agent from the physical world, then reinserting it with its new shape), this action should not be called too often.\nReturned type: unknown\n\nthread​\nThe thread skill is intended to define the minimal set of behaviours required for agents that are able to run an action in a thread\nVariables​\nActions​\nend_thread​\nEnd the current thread.\nReturned type: bool  : true if the thread was well stopped, false otherwise\nExamples:​\ndo end_thread;\nrun_thread​\nStart a new thread that will run the 'thread_action' either once if no facets are defined, of at a fixed rate if 'every:' is defined or with a fixed delay if 'interval:' is defined.\nReturned type: bool  : true if the thread was well created and started, false otherwise\nAdditional facets:​\n\nevery (float): Rate in machine time at which this action is run. Default unit is in seconds, use explicit units to specify another, like 10 #ms. If no rate (and no interval) is specified, the action is run once. If the action takes longer than the interval to run, it it run immediately after the previous execution\ninterval (float): Interval -- or delay -- between two executions of the action. Default unit is in seconds, use explicit units to specify another, like 10 #ms. If no interval (and no rate) is specified, the action is run once. An interval of 0 will make the action run continuously without delays\n\nExamples:​\ndo run_thread every: 10#ms;\nthread_action​\nA virtual action, which contains what to execute in the thread. It needs to be redefined in the species that implement the thread skill\nReturned type: unknown"},{"filePath":"https:--gama-platform.org--wiki-BuiltInSpecies.txt","text":"Built-in Species\nThis file is automatically generated from java files. Do Not Edit It.\n\nIt is possible to use in the models a set of built-in agents. These agents allow to directly use some advance features like clustering, multi-criteria analysis, etc. The creation of these agents are similar as for other kinds of agents:\ncreate species: my_built_in_agent returns: the_agent;\nSo, for instance, to be able to use clustering techniques in the model:\ncreate cluster_builder returns: clusterer;\nTable of Contents​\nagent, AgentDB, base_edge, experiment, graph_edge, graph_node, physical_world,\n\nagent​\nVariables​\n\nhost (agent): Returns the agent that hosts the population of the receiver agent\nlocation (point): Returns the location of the agent\nname (string): Returns the name of the agent (not necessarily unique in its population)\npeers (list): Returns the population of agents of the same species, in the same host, minus the receiver agent\nshape (geometry): Returns the shape of the receiver agent\n\nActions​\n_init_​\n\nReturned type: unknown\n_step_​\n\nReturned type: unknown\n\nAgentDB​\nAgentDB is an abstract species that can be extended to provide agents with capabilities to access databases\nVariables​\n\nagents (list): Returns the list of agents for the population(s) of which the receiver agent is a direct or undirect host\nmembers (container): Returns the list of agents for the population(s) of which the receiver agent is a direct host\n\nActions​\nclose​\nClose the established database connection.\nReturned type: unknown  : Returns null if the connection was successfully closed, otherwise, it returns an error.\nconnect​\nEstablish a database connection.\nReturned type: unknown  : Returns null if connection to the server was successfully established, otherwise, it returns an error.\nAdditional facets:​\n\nparams (map): Connection parameters\n\nexecuteUpdate​\n- Make a connection to DBMS - Executes the SQL statement in this PreparedStatement object, which must be an SQL\nINSERT, UPDATE or DELETE statement; or an SQL statement that returns nothing, such as a DDL statement.\nReturned type: int  : Returns the number of updated rows.\nAdditional facets:​\n\nupdateComm (string): SQL commands such as Create, Update, Delete, Drop with question mark\nvalues (list): List of values that are used to replace question mark\n\ngetParameter​\nReturns the list used parameters to make a connection to DBMS (dbtype, url, port, database, user and passwd).\nReturned type: unknown  : Returns the list of used parameters to make a connection to DBMS.\ninsert​\n- Make a connection to DBMS - Executes the insert statement.\nReturned type: int  : Returns the number of updated rows.\nAdditional facets:​\n\ninto (string): Table name\ncolumns (list): List of column name of table\nvalues (list): List of values that are used to insert into table. Columns and values must have same size\n\nisConnected​\nTo check if connection to the server was successfully established or not.\nReturned type: bool  : Returns true if connection to the server was successfully established, otherwise, it returns false.\nselect​\nMake a connection to DBMS and execute the select statement.\nReturned type: list  : Returns the obtained result from executing the select statement.\nAdditional facets:​\n\nselect (string): select string\nvalues (list): List of values that are used to replace question marks\n\nsetParameter​\nSets the parameters to use in order to make a connection to the DBMS (dbtype, url, port, database, user and passwd).\nReturned type: unknown  : null.\nAdditional facets:​\n\nparams (map): Connection parameters\n\ntestConnection​\nTo test a database connection .\nReturned type: bool  : Returns true if connection to the server was successfully established, otherwise, it returns false.\nAdditional facets:​\n\nparams (map): Connection parameters\n\ntimeStamp​\nGet the current time of the system.\nReturned type: float  : Current time of the system in millisecondes\n\nbase_edge​\nA built-in species for agents representing the edges of a graph, from which one can inherit\nVariables​\n\nsource (agent): The source agent of this edge\ntarget (agent): The target agent of this edge\n\nActions​\n\nexperiment​\nAn experiment is a declaration of the way to conduct simulations on a model. Any experiment attached to a model is a species (introduced by the keyword 'experiment' which directly or indirectly inherits from an abstract species called 'experiment' itself. This abstract species (sub-species of 'agent') defines several attributes and actions that can then be used in any experiment.\n'experiment' defines several attributes, which, in addition to the attributes inherited from agent, form the minimal set of knowledge any experiment will have access to.\nVariables​\n\nmaximum_cycle_duration (float): The maximum duration (in seconds) a simulation cycle should last. Default is 1. Units can be used to pass values greater than a second (for instance '10 #sec')\nminimum_cycle_duration (float): The minimum duration (in seconds) a simulation cycle should last. Default is 0. Units can be used to pass values smaller than a second (for instance '10 #msec')\nmodel_path (string): Contains the absolute path to the folder in which the current model is located\nparameters (map): A parameters set of this experiment agent\nproject_path (string): Contains the absolute path to the project in which the current model is located\nrng (string): The random number generator to use. Four different ones are at the disposal of the modeler: 'mersenne' represents the default generator, based on the Mersenne-Twister algorithm. Very reliable, fast and deterministic (that is, using the same seed and the same sequence of calls, it will return the same stream of pseudo-random numbers). This algorithm is however not safe to use in simulations where agents can behave in parallel; 'threaded' is a very fast generator, based on the DotMix algorithm, that can be safely used in parallel simulations as it creates one instance per thread. However, determinism cannot be guaranteed and this algorithm does not accept a seed as each instance will compute its own;'parallel' is a version of the Mersenne-Twister algorithm that can be safely used in parallel simulations by preventing a concurrent access to its internal state. Determinism is guaranteed (in terms of generation, but not in terms of execution, as the sequence in which the threads will access it cannot be determined) and it performs a bit slower than its base version.'java' invokes the standard generator provided by the JDK, deterministic and thread-safe, albeit slower than all the other ones\nrng_usage (int): Returns the number of times the random number generator of the experiment has been drawn\nseed (float): The seed of the random number generator. Each time it is set, the random number generator is reinitialized. WARNING: Setting it to zero actually means that you let GAMA choose a random seed\nsimulation (agent): Contains a reference to the current simulation being run by this experiment\nsimulations (list): Contains the list of currently running simulations\nworkspace_path (string): Contains the absolute path to the workspace of GAMA\n\nActions​\ncompact_memory​\nForces a 'garbage collect' of the unused objects in GAMA\nReturned type: unknown\nupdate_outputs​\nForces all outputs to refresh, optionally recomputing their values\nReturned type: unknown\nAdditional facets:​\n\nrecompute (boolean): Whether or not to force the outputs to make a computation step\n\n\ngraph_edge​\nA species that represents an edge of a graph made of agents. The source and the target of the edge should be agents\nVariables​\n\nsource (agent): The source agent of this edge\ntarget (agent): The target agent of this edge\n\nActions​\n\ngraph_node​\nA base species to use as a parent for species representing agents that are nodes of a graph\nVariables​\n\nmy_graph (graph): A reference to the graph containing the agent\n\nActions​\nrelated_to​\nThis operator should never be called\nReturned type: bool\nAdditional facets:​\n\nother (agent): The other agent\n\n\nphysical_world​\nThe base species for models that act as a 3D physical world. Can register and manage agents provided with either the 'static_body' or 'dynamic_body' skill. Inherits from 'static_body', so it can also act as a physical body itself (with a 'mass', 'friction', 'gravity'), of course without motion -- in this case, it needs to register itself as a physical agent using the 'register' action\nVariables​\n\naccurate_collision_detection (boolean): Enables or not a better (but slower) collision detection\nautomated_registration (boolean): If set to true (the default), makes the world automatically register and unregister agents provided with either the 'static_body' or 'dynamic_body' skill. Otherwise, they must be registered using the 'register' action, which can be useful when only some agents need to be considered as 'physical agents'. Note that, in any case, the world needs to manually register itself if it is supposed to act as a physical body.\ngravity (point): Defines the value of gravity in this world. The default value is set to -9.80665 on the z-axis, that is 9.80665 m/s2 towards the 'bottom' of the world. Can be set to any direction and intensity and applies to all the bodies present in the physical world\nlibrary (string): This attribute allows to manually switch between two physics library, named 'bullet' and 'box2D'. The Bullet library, which comes in two flavors (see 'use_native') and the Box2D libray in its Java version (https://github.com/jbox2d/jbox2d). Bullet is the default library but models in 2D should better use Box2D\nmax_substeps (int): If equal to 0 (the default), makes the simulation engine be stepped alongside the simulation (no substeps allowed). Otherwise, sets the maximum number of physical simulation substeps that may occur within one GAMA simulation step\nterrain (field): This attribute is a matrix of float that can be used to represent a 3D terrain. The shape of the world, in that case, should be a box, where thedimension on the z-axis is used to scale the z-values of the DEM. The world needs to be register itself as a physical object\nuse_native (boolean): This attribute allows to manually switch between the Java version of the Bullet library (JBullet, a modified version of https://github.com/stephengold/jbullet, which corresponds to version 2.72 of the original library) and the native Bullet library (Libbulletjme, https://github.com/stephengold/Libbulletjme, which is kept up-to-date with the 3.x branch of the original library).The native version is the default one unless the libraries cannot be loaded, making JBullet the default\n\nActions​\nregister​\nAn action that allows to register agents in this physical world. Unregistered agents will not be governed by the physical laws of this world. If the world is to play a role in the physical world,then it needs to register itself (i.e. do register([self]);\nReturned type: unknown\nAdditional facets:​\n\nbodies (container): the list or container of agents to register in this physical world\n"},{"filePath":"https:--gama-platform.org--wiki-CallingR.txt","text":"Calling R from GAMA modelsIntroduction​\nThe R language is a powerful tool for statistical computing and graphics, and its community is very large in the world (See the website). Adding a support for the R language is one of our strong endeavors to accelerate many statistical and data mining tools integration into the GAMA platform.\nInstalling R and rJava​\nInstall R on your computer​\nPlease refer to the R official website, or to RStudio if you want in addition a nice IDE.\ninstall the rJava library in R​\nIn the R (RStudio) console, write:\ninstall.packages(\"rJava\")\nto install the library. To check that the install is correct, you load the library using library(rJava) (in the R console). If no error message appears, it means the installation is correct.\nIn case of trouble​\nFor MacOSX​\nin recent versions you should first write in a terminal:\nR CMD javareconfsudo ln -f -s $(/usr/libexec/java_home)/jre/lib/server/libjvm.dylib /usr/local/lib\nFor Linux​\nmake sure you have the default-jdk and default-jre packages installed and then execute the command sudo R CMD javareconf\nFor Windows​\nmake sure you have a JAVA_HOME and a CLASSPATH environment variable setup, if not you need to create and set them, for example:\nJAVA_HOME=\"C:\\Program Files\\Java\\OpenJDK17\\\"CLASSPATH=\"C:\\Program Files\\Java\\OpenJDK17\\bin\\\"\nSet the environment variable R_HOME​\nOn Windows​\nset the environment variables as follows.\nR_HOME is the root directory where we can find the library folder in your R installation, so it should look like this:\nR_HOME=\"C:\\Program Files\\R\\R-4.2.2\\\" \nR_PATH should point to the folder containing your R interpreter, the variable should be set with something similar to this (adapting with your R version and R installation path):\nR_PATH=\"C:\\Program Files\\R\\R-4.2.0\\bin\\x64\" \nOn Linux​\nBy default it should be /usr/lib/R, you can thus just append the line R_HOME=/usr/lib/R to your /etc/environment file and reboot your computer\nOn macOS​\nYou need to create (or update) the file environment.plist in the folder: ~/Library/LaunchAgents/ (for the current user, note that this folder is a hidden folder) or in /Library/LaunchAgents/ (for all users)\nIt should look like:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"><plist version=\"1.0\">  <dict>    <key>Label</key>    <string>my.startup</string>    <key>ProgramArguments</key>    <array>      <string>sh</string>      <string>-c</string>      <string> launchctl setenv R_HOME /Library/Frameworks/R.framework/Resources/ </string>    </array>    <key>RunAtLoad</key>    <true/>  </dict></plist>\nRecommended​\nIf the rJava library doesn't appear in the R library directory, copy the installed rJava library from where it was installed (with install.packages(\"rJava\")) to the library folder in your R_HOME.\nUpdating the Path variable (Windows only)​\nIn addition, on Windows you also need to add to your Path environment variable the path to your R binaries, by default located in C:\\Program Files\\R\\R-4.2.2\\bin\\x64 for R-4.2.2 64bits.\nThe Path variable is a variable already created by Windows, so you just have to edit it to add a new path, no need to delete anything.\nConfiguration in GAMA​\nLinking the R connector​\nFrom GAMA 1.9.0, you need to specify the path to the R connector library in the GAMA launching arguments.\nTo this purpose, you need to add to either:\n\n\nthe GAMA.ini file if you use the release version of GAMA\n\n\nor the launching configuration (if you use the source code version) the following line: (replace PATH_TO_R by the path to R, i.e. the value in $R_HOME):\n\non macOS:    -Djava.library.path=PATH_TO_R/library/rJava/jri/rlibjri.jnilib\non Windows:  -Djava.library.path=PATH_TO_R\\library\\rJava\\jri\\\non Linux:    -Djava.library.path=PATH/TO/JRI\n\n\n\nAs an example, under macOS, you need to add:\n-Djava.library.path=/Library/Frameworks/R.framework/Resources/library/rJava/jri/\nOn Windows and Linux, the jri library could be in a different location than the R_HOME, for example on Linux by default it would be in:\n-Djava.library.path=/home/user_name/R/x86_64-pc-linux-gnu-library/3.6/rJava/jri/\nOn Windows it can be located in the user's AppData\\local or in Documents\\R.\nInstalling the R plugin​\nNext you need to install the R plugin from Gama. To do it, select \"Install new plugins...\" in the \"Help\" menu of Gama.\nIn the Work with drop down select the repository ending with \"experimental/\" followed by your Gama version.\nOnce done, you need to select the plugin rJava, click on next and then finish.\n\nAfter this, you could be asked to \"trust\" the plugin, simply select the first line and click on Trust selected\n\nFinally, you will be asked to restart Gama, click on Restart now.\nFor more details, readers can refer to the page dedicated to the installation of additional plugins.\nCalling R from GAML​\nBefore computation​\nAny agent aiming at using R for some computation needs to be provided with the RSkill.\nBefore calling any computation, this agent needs to start a connection with the R software.\nAs an example, if we want  that the global agent can use R, we need to have the following minimal model:\nglobal skills: [RSkill] {   init {      do startR;   }}\nComputation​\nEvaluate an R expression​\nThe R_eval operator can be used to evaluate any R expression. It can  also be used to initialize a variable or call any function. It can return any data type  (depending on the R output).\nAs in an R session, the various evaluations are dependent on the previous ones.\nExample:\nglobal skills: [RSkill] {\t\tinit{\t\tdo startR;\t\t\t\twrite R_eval(\"x<-1\");\t\twrite R_eval(\"rnorm(50,0,5)\");\t}}\nEvaluate an R script​\nTo evaluate an R script, stored in a (text) file, open the file and execute each of its lines.\nglobal skills:[RSkill]{\tfile Rcode <- text_file(\"../includes/rScript.txt\");\t\tinit{\t\tdo startR;\t\t// Loop that takes each line of the R script and execute it.\t \tloop s over: Rcode.contents{\t\t\tunknown a <- R_eval(s);\t\t\twrite \"R>\"+s;\t\t\twrite a;\t\t}\t}}\nConvert GAMA object to R object​\nTo use GAMA complex objects into R functions, we need to transform them using the to_R_data operator: it transforms any GAMA object into a R object.\nglobal skills:[RSkill] {\tinit {\t\tdo startR();\t\t\t\tstring s2 <- \"s2\";\t\tlist<int> numlist <- [1,2,3,4];   \t\twrite R_eval(\"numlist = \" + to_R_data(numlist));\t}}\nConvert a species to a dataframe​\nDataframe is a powerful R data type allowing to ease data manipulation...\nDataframe wan of course be defined at hand using R commands. But GAML provides the to_R_dataframe operator to directly transform a species of agents into a dataframe for future analysis.\nglobal skills: [RSkill] {\t\tinit{\t\tdo startR();\t\t\t\tcreate people number: 10;\t\t\t\tdo R_eval(\"df<-\" + to_R_dataframe(people));\t\twrite R_eval(\"df\");\t\twrite R_eval(\"df$flipCoin\");\t\t}}species people {\tbool flipCoin <- flip(0.5);}\nTroubleshooting​\nIt is possible that after installing everything, Gama works normally but crashes every time you try to use the skill RSkill without any error message. If that's the case, the problem is certainly that Gama is unable to load the jri library or its dependencies (other R packages). Make sure that the path you wrote in the .ini file is correct and that every environment variable is set with proper values.\nAlso on windows, check that the Path variable contains the path to your R installation.\nIf after checking everything the problem is still there, you can try copying the .dll files at the R_PATH location and the jri.dll and paste them into your JAVA_PATH directory (the bin folder of your jdk)."},{"filePath":"https:--gama-platform.org--wiki-ChangingWorkspace.txt","text":"Changing WorkspaceIt is possible, and actually common, to store different projects/models in different workspaces and to tell GAMA to switch between these workspaces. Doing so involves being able to create one or several new workspace locations (even if GAMA has been told to remember the current one) and being able to easily switch between them.\nTable of contents​\n\nChanging Workspace\n\nSwitching to another Workspace\nCloning the Current Workspace\n\n\n\nSwitching to another Workspace​\nThis process is similar to the choice of the workspace location when GAMA is launched for the first time. The only preliminary step is to invoke the appropriate command (\"Switch Workspace\") from the \"File\" menu.\n\nIn the dialog that appears, the current workspace location should already be entered. Changing it to a new location (or choosing one in the file selector invoked by clicking on \"Browse...\") and pressing \"OK\" will then either create a new workspace if none existed at that location or switch to this new workspace. Both operations will restart GAMA and set the new workspace location. To come back to the previous location, just repeat this step (the previous location is normally now accessible from the combo box).\n\nNotice that, when GAMA restarts and that you have not ticked \"Remember workspace\", GAMA will ask you again the workspace (just as when you launch GAMA).\nCloning the Current Workspace​\nAnother possibility, if you have models in your current workspace that you would like to keep in the new one (and that you do not want to import one by one after switching workspace), or if you change workspace because you suspect the current one is corrupted, or outdated, etc. but you still want to keep your models, is to clone the current workspace into a new (or existing) one.\nPlease note that cloning (as its name implies) is an operation that will make a copy of the files into a new workspace. So, if projects are stored in the current workspace, this will result in two different instances of the same projects/models with the same name in the two workspaces. However, for projects that are simply linked from the current workspace, only the link will be copied (which allows having different workspaces \"containing\" the same project)\nThis can be done by entering the new workspace location and choosing \"Clone current workspace\" in the previous dialog instead of \"Ok\".\n\nIf the new location does not exist, GAMA will ask you to confirm the creation and cloning using a specific dialog box. Dismissing it will cancel the operation.\n\nIf the new location is already the location of an existing workspace, another confirmation dialog is produced. It is important to note that all projects in the target workspace will be erased and replaced by the projects in the current workspace if you proceed. Dismissing it will cancel the operation.\n\nThere are two cases where cloning is not accepted. The first one is when the user tries to clone the current workspace into itself (i.e. the new location is the same as the current location).\n\nThe second case is when the user tries to clone the current workspace into one of its subdirectories (which is not feasible).\n"},{"filePath":"https:--gama-platform.org--wiki-Comodel.txt","text":"Using ComodelIntroduction​\nIn the trend of developing a complex system of multi-disciplinary, composing and coupling models are days by days becoming the most attractive research objectives.\nGAMA is supporting the co-modeling and co-simulation which are supposed to be a common coupling infrastructure.\nExample of a Comodel​\nA Comodel is a model, especially an agent-based model, composed of several sub-models, called micro-models. A comodel itself could be also a micro-model of another comodel. From the point of view of a micro-model, the comodel is called a macro-model.\nA micro-model must be imported, instantiated, and life-controlled by a macro-model.\n\nWhy and when can we use Comodel?​\nCo-models ca definitely be very useful when the whole model can be decomposed in several sub-models, each of them representing, in general, a dynamics of the whole model, and that interact through some entities of the model. In particular, it allows several modelers to develop the part of the model dedicated to their expertise field, to test it extensively, before integrating it inside the whole model (where integration tests should not be omitted!).\nUse of Comodel in a GAML model​\nThe GAML language has evolved by extending the import section. The old importation told the compiler to merge all imported elements into as one model, but the new one allows modelers to keep the elements coming from imported models separately from the caller model.\nDefinition of a micro-model​\nDefining a micro-model of comodel is to import an existing model with an alias name. The syntax is:\nimport <path to the GAML model> as <identifier>\nThe identifier is then become the new name of the micro-model.\nAs an example taken from the model library, we can write:\nimport \"Prey Predator Adapter.gaml\" as Organism\nInstantiation of a micro-model​\nAfter the importation and giving an identifier, micro-model must be explicitly instantiated. It could be done by the create statement.\ncreate <micro-model identifier> . <experiment name> [optional parameter];\nThe <exeperiment name> is an experiment inside micro-model. This syntax will generate some experiment agents and attach an implicit simulation.\nNote: The creation of several instances is not multi-simulation, but multi-experiment. Modelers could create an experiment with multi-simulation by explicitly do the init inside the experiment scope.\nAs an example taken from the model library, we can write:\nglobal {    init {        //instantiate three instant of micro-model PreyPredator        create Organism.Simple number: 3 with: [shape::square(100), preyinit::10, predatorinit::1] ;    }}\nControl micro-model life-cycle​\nA micro-model can be controlled as any normal agent by asking the corresponding identifier, and also be destroyed by the do die; statement. And it can be recreated any time we need.\nask (<micro-model identifier> . <experiment name>  at <number> ) . simulation {    ...}\nMore generally, to schedule all the created simulations, we can do:\nreflex simulate_micro_models {    // ask all simulation do their job    ask (Organism.Simple collect each.simulation) {        do _step_;    }}\nVisualization of the micro-model​\nThe micro-model species could display in comodel with the support of agent layer\nagents \"name of layer\" value: (<micro-model> . <experiment name> at <number>).<get List of agents>;\nAs an example:\ndisplay \"Comodel display\" {    agents \"agentprey\" value: (Organism.Simple accumulate each.get_prey());    agents \"agentpredator\" value: (Organism.Simple accumulate each.get_predator());}\nMore details​\nExample of the comodel​\nThe following illustrations are taken from the model library provided with the GAMA platform.\nUrbanization model with a Traffic model​\n\nFlood model with Evacuation model​\nThe aim of this model is to couple the two existing models: Flood Simulation and Evacuation.\nToy Models/Evacuation/models/continuous_move.gaml\n\nToy Models/Flood Simulation/models/Hydrological Model.gaml\n\nThe comodel explores the effect of a flood on an evacuation plan:\n\nSimulation results:\n"},{"filePath":"https:--gama-platform.org--wiki-ControlArchitecture.txt","text":"Control ArchitecturesGAMA allows the modeler to attach built-in control architecture to agents.\nThese control architectures will give the possibility to the modeler to use for a species a specific control architecture in addition to the common behavior structure. Note that only one control architecture can be used per species.\nThe attachment of a control architecture to a species is done through the facets control.\nFor example, the given code attaches the fsm control architecture to the dummy species.\nspecies dummy control: fsm {}\nGAMA integrates several agent control architectures that can be used in addition to the common behavior structure:\n\nfsm: finite state machine based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization)\nweighted_tasks: task-based control architecture. At any given time, only the task with the maximal weight is executed.\nsorted_tasks: task-based control architecture. At any given time, the tasks are all executed in the order specified by their weights (highest first).\nprobabilistic_tasks: task-based control architecture. This architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen at each step.\nrules: rules-based control architecture. This architecture uses a set of rules, that will be executed if a given condition is fulfilled and in an order defined by a priority.\nuser_only: allows users to take control over an agent during the course of the simulation. With this architecture, only the user control the agents (no reflexes).\nuser_first: allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed before the agent reflexes.\nuser_last: allows users to take control over an agent during the course of the simulation. With this architecture, the user actions are executed after the agent reflexes.\n\nAn exhaustive list of the architectures available with GAMA provides all the variables and additional actions provided by an architecture.\nIndex​\n\nFinite State Machine\n\nDeclaration\nstate statement\n\n\nTask Based\n\nDeclaration\ntask\n\n\nUser Control Architecture\n\nuser_only, user_first, user_last\nAdditional attribute\nuser_panel\n\n\nOther Control Architectures\n\nFinite State Machine​\nFSM (Finite State Machine) is a finite state machine-based behavior model. During its life cycle, the agent can be in several states. At any given time step, it is in one single state. Such an agent needs to have one initial state (the state in which it will be at its initialization).\nAt each time step, the agent will:\n\nfirst (only if he just entered in its current state) execute statement embedded in the enter statement,\nthen all the statements in the state statement,\nit will evaluate the condition of each embedded transition statements. If one condition is fulfilled, the agent executes the embedded statements.\n\nNote that an agent executes only one state at each step.\nDeclaration​\nUsing the FSM architecture for a species require to use the control facet:\nspecies dummy control: fsm {   ...}\nstate statement​\nFacets​\n\ninitial: a boolean expression, indicates the initial state of the agent (only one state with initial set to true is allowed in a species).\nfinal: a boolean expression, indicates the final state of the agent.\n\nSub Statements​\n\nenter: a sequence of statements to execute upon entering the state.\nexit: a sequence of statements to execute right before exiting the state. Note that the exit statement will be executed even if the fired transition points to the same state (the FSM architecture in GAMA does not implement 'internal transitions' like the ones found in UML statecharts: all transitions, even \"self-transitions\", follow the same rules).\ntransition: allows to define a condition that, when evaluated to true, will designate the next state of the life-cycle. Note that the evaluation of transitions is short-circuited: the first one that evaluates to true, in the order in which they have been defined, will be followed. I.e., if two transitions evaluate to true during the same time step, only the first one will be triggered.\n\nThings worth to be mentioned regarding these sub-statements:\n\nObviously, only one definition of exit and enter is accepted in a given state.\ntransition statements written in the middle of the state statements will only be evaluated at the end, so, even if it evaluates to true, the remaining of the statements found after the definition of the transition will be nevertheless executed. So, despite the appearance, a transition written somewhere in the sequence will \"not stop\" the state at that point (but only at the end).\n\nDefinition​\nA state can contain several statements that will be executed, at each time step, by the agent. There are three exceptions to this rule:\n\nstatements enclosed in enter will only be executed when the state is entered (after a transition, or because it is the initial state).\nThose enclosed in exit will be executed when leaving the state as a result of a successful transition (and before the statements enclosed in the transition).\nThose enclosed in a transition will be executed when performing this transition (but after the exit sequence has been executed).\n\nFor example, consider the following example:\nspecies dummy control: fsm {           state state1 initial: true { \twrite string(cycle) + \":\" + name + \"->\" + \"state1\";\ttransition to: state2 when: flip(0.5) {\t    write string(cycle) + \":\" + name + \"->\" + \"transition to state1\";\t}\ttransition to: state3 when: flip(0.2) ;     }    state state2 {\twrite string(cycle) + \":\" + name + \"->\" + \"state2\";\ttransition to: state1 when: flip(0.5) { \t    write string(cycle) + \":\" + name + \"->\" + \"transition to state1\";\t}\texit {\t    write string(cycle) + \":\" + name + \"->\" + \"leave state2\";\t}    }\t    state state3 {\twrite string(cycle) + \":\" + name + \"->\" + \"state3\";\ttransition to: state1 when: flip(0.5)  {\t    write string(cycle) + \":\" + name + \"->\" + \"transition to state1\";\t}\ttransition to: state2 when: flip(0.2)  ;    }   }\nThe dummy agents start at state1. At each simulation step, they have a probability of 0.5 to change their state to state2. If they do not change their state to state2, they have a probability of 0.2 to change their state to state3. In state2, at each simulation step, they have a probability of 0.5 to change their state to state1. At last, in step3, at each simulation step, they have a probability of 0.5 to change their state to state1. If they do not change their state to state1, they have a probability of 0.2 to change their state to state2.\nHere a possible result that can be obtained with one dummy agent:\n0:dummy0->state10:dummy0->transition to state11:dummy0->state22:dummy0->state22:dummy0->leave state22:dummy0->transition to state13:dummy0->state13:dummy0->transition to state14:dummy0->state25:dummy0->state25:dummy0->leave state25:dummy0->transition to state16:dummy0->state17:dummy0->state38:dummy0->state2\nTask-Based​\nGAMA integrated several task-based control architectures. Species can define any number of tasks within their body. At any given time, only one or several tasks are executed according to the architecture chosen:\n\nweighted_tasks: in this architecture, only the task with the maximal weight is executed.\nsorted_tasks: in this architecture, the tasks are all executed in the order specified by their weights (biggest first)\nprobabilistic_tasks: this architecture uses the weights as a support for making a weighted probabilistic choice among the different tasks. If all tasks have the same weight, one is randomly chosen each step.\n\nDeclaration​\nUsing one of the task architectures for a species requires to use the control facet:\nspecies dummy control: weighted_tasks {   ...}\nspecies dummy control: sorted_tasks {   ...}\nspecies dummy control: probabilistic_tasks {   ...}\ntask statement​\nFacets​\nBesides a sequence of statements like reflex, a task contains the following additional facet:\n\nweight: Mandatory. The priority level of the task.\n\nDefinition​\nAs reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.\nFor example, consider the following example:\nspecies dummy control: weighted_tasks {       task task1 weight: cycle mod 3 { \twrite string(cycle) + \":\" + name + \"->\" + \"task1\";    }    task task2 weight: 2 { \twrite string(cycle) + \":\" + name + \"->\" + \"task2\";    }}\nAs the weighted_tasks control architecture was chosen, at each simulation step, the dummy agents execute only the task with the highest behavior. Thus,  when cycle modulo 3 is higher to 2, task1 is executed; when cycle modulo 3 is lower than 2, task2 is executed. In case when cycle modulo 3 is equal 2 (at cycle 2, 5, ...), the only the first task defined (here task1) is executed.\nHere the result obtained with one dummy agent:\n0:dummy0->task21:dummy0->task22:dummy0->task13:dummy0->task24:dummy0->task25:dummy0->task16:dummy0->task2\nRules-based architecture​\nThe behavior of an agent with the rules-based architecture can contain reflex and rule statements. The reflex block will always be executed first. Then the rules are fired (executed) when their condition becomes true and in the order defined by their decreasing priorities.\nDeclaration​\nUsing the rules-based architectures for a species requires to use the control facet:\nspecies dummy control: rules {   ...}\nrule statement​\nfacets​\n\nwhen: (boolean), the condition that needs to be fulfilled to execute the rule.\npriority: (float), an optional priority for the rule, which is used to sort activable rules and run them in that order.\n\nDefinition​\nAs reflex, a rule is a sequence of statements that can be executed, at each time step, by the agent. They are executed if and only if their condition expression (when facet) is fulfilled. Among all the rules that fulfill their condition, the tasks are executed in the decreasing order of their priority (priority facet).\nFor example, consider the following example:\nspecies simple_rules_statements control: rules {\t    int priority_of_a <- 0 update: rnd(100);    int priority_of_b <- 0 update: rnd(100);\t    reflex show_priorities {\twrite \"Priority of rule a = \" + priority_of_a + \", priority of rule b = \" + priority_of_b;    }    rule a when: priority_of_a < 50 priority: priority_of_a {\twrite \"  Rule a fired with priority: \" + priority_of_a;    }\t    rule b when: priority_of_b > 25 priority: priority_of_b {\twrite \"  Rule b fired with priority: \" + priority_of_b;    }}\nAt each simulation step, first, the agents update the priority values associated with the rules. The reflex will first display these values. Then the conditions are evaluated and the rules that can be executed are executed in their priority order.\nHere a possible result:\nPriority of rule a = 38, priority of rule b = 32  Rule a fired with priority: 38  Rule b fired with priority: 32Priority of rule a = 91, priority of rule b = 32  Rule b fired with priority: 32Priority of rule a = 37, priority of rule b = 2  Rule a fired with priority: 37Priority of rule a = 77, priority of rule b = 90  Rule b fired with priority: 90Priority of rule a = 32, priority of rule b = 23  Rule a fired with priority: 32Priority of rule a = 18, priority of rule b = 7  Rule a fired with priority: 18Priority of rule a = 95, priority of rule b = 94  Rule b fired with priority: 94Priority of rule a = 20, priority of rule b = 5  Rule a fired with priority: 20Priority of rule a = 78, priority of rule b = 47  Rule b fired with priority: 47Priority of rule a = 77, priority of rule b = 76  Rule b fired with priority: 76\nUser Control Architecture​\nuser_only, user_first, user_last​\nA specific type of control architecture has been introduced to allow users to take control of an agent during the course of the simulation. When the user gets control of the agent, a control panel will appear in the interface. This architecture can be invoked using three different keywords: user_only, user_first, user_last.\nspecies user control: user_only {   ...}\nIf the control chosen is user_first, it means that the user-controlled panel is opened first, and then the agent has a chance to run its \"own\" behaviors (reflexes, essentially, or \"init\" in the case of a \"user_init\" panel).\nIf the control chosen is user_last, it is the contrary.\nAdditional attribute​\nEach agent provided with this architecture inherits a boolean attribute called user_controlled. If this attribute becomes false, no panels will be displayed and the agent will run \"normally\" unless its species is defined with a user_only control.\nuser_panel​\nThis control architecture is a specialization of the Finite State Machine Architecture where the \"behaviors\" of agents can be defined by using new constructs called user_panel (and one user_init), mixed with state or reflex. This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have an enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.\nuser_command can also accept inputs, in order to create more interesting commands for the user. This uses the user_input statement (and not operator), which is basically the same as a temporary variable declaration whose value is asked to the user.\nAs user_panel is a specialization of state, the modeler has the possibility to describe several panels and choose the one to open depending on some condition, using the same syntax than for finite state machines:\n\neither adding transitions to the user_panels,\nor setting the state attribute to a new value, from inside or from another agent.\n\nThis ensures great flexibility for the design of the user interface proposed to the user, as it can be adapted to the different stages of the simulation, etc...\nFollows a simple example, where, every 10 steps, and depending on the value of an attribute called \"advanced\", either the basic or the advanced panel is proposed. (The full model is provided in the GAMA model library.)\nspecies user control:user_only {   user_panel default initial: true {      transition to: \"Basic Control\" when: every (10 #cycles) and !advanced_user_control;      transition to: \"Advanced Control\" when: every(10 #cycles) and advanced_user_control;   }      user_panel \"Basic Control\" {      user_command \"Kill one cell\" {         ask (one_of(cell)){            do die;         }      }      user_command \"Create one cell\" {        create cell ;      }       transition to: default when: true;   }   user_panel \"Advanced Control\" {      user_command \"Kill cells\" {        user_input \"Number\" returns: number type: int <- 10;        ask (number among cell){           do die;        }      }      user_command \"Create cells\" {        user_input \"Number\" returns: number type: int <- 10;        create cell number: number ;      }       transition to: default when: true;   }}\nThe panel marked with the initial: true facet will be the one run first when the agent is supposed to run. If none is marked, the first panel (in their definition order) is chosen.\nA special panel called user_init will be invoked only once when initializing the agent if it is defined.\nIf no panel is described or if all panels are empty (i.e. no user_command), the control view is never invoked. If the control is said to be user_only, the agent will then not run any of its behaviors.\nOther Control Architectures​\nSome other control architectures are available in additional plugins. For instance, BDI (Belief, desire, intention) architecture is available. Feel free to read about it if you want to learn more.\nDo you need some other control architectures for your model? Feel free to make your suggestion to the team of developers through the mailing list. Remember also that GAMA is an open-source platform, you can design your own control architecture easily. Go to the section Community/contribute if you want to jump into coding!"},{"filePath":"https:--gama-platform.org--wiki-CreatingAReleaseOfGama.txt","text":"Product your own release of GAMAInstall Maven if not already installed​\nDownload the latest version of Maven here: <https://maven.apache.org/download.cgi>. Proceed to install it as explained on this page: <https://maven.apache.org/install.html>\nLocate the build.sh shell script​\nIt is located at the root of the gama Git repository on your computer. The easiest way to proceed is to select one of the GAMA projects in the Eclipse explorer and choose, in the contextual menu, Show in > System Explorer. Then open a shell with this path and cd ... Alternatively, you can open a shell and cd to your Git repository and then inside gama.\nLaunch the script​\nSimply type ../build.sh in your terminal and the build should begin and log its activity.\nLocate the applications built by the script​\nThey are in ummisco.gama.product/target/products/ummisco.gama.application.product in their binary form or alternatively in ummisco.gama.product/target/products in their zipped form.\nInstruction for Travis build (Continuous Integration)​\nGAMA is built by Travis-ci.org. There are some triggers for developers to control travis:\n\n\"ci skip\": skip the build for a commit\n\"ci deploy\": deploy the artifacts/features to p2 server (currently to the ovh server of gama, www.gama-platform.org/updates)\n\"ci clean\": used with ci deploy, this trigger remove all old artifacts/features in server's p2 repository\n\"ci docs\": tell travis  to regenerate the documentation of operators on wiki page, and update the website githubio\n\"ci release\": travis release zip package for OSs and place it on https://github.com/gama-platform/gama/releases/tag/latest\n\"ci ext\": The msi.gama.ext has big size, so it is not rebuilt every time, it will be compiled automatically only when it was changed, Or use this command to force travis to deploy msi.gama.ext\n\"ci fullbuild\": Full deploy all features/plugins\n\nThese instructions above can be used in 2 ways:\n\nPlace them anywhere in the commit message, i.e: \" fix bug #1111 ci deploy ci clean ci docs\", \" update readme ci skip \"\nIn Travis-ci, go to More Options -> Settings, add an environment variable named MSG, add the value as string, i.e.: \"ci fullbuild ci deploy ci clean ci docs\"\n"},{"filePath":"https:--gama-platform.org--wiki-DataTypes.txt","text":"TypesA variable's or expression's type (or data type) determines the values it can take, plus the operations that can be performed on or with it. GAML is a statically-typed language, which means that the type of an expression is always known at compile time, and is even enforced with casting operations.\nThere are 4 categories of types:\n\nprimitive types, declared as keyword in the language,\ncomplex types, also declared as keyword in the language,\nparametric types, a refinement of complex types (mainly children of container) that is dynamically constructed using an enclosing type, a contents type and a key type,\nspecies types, dynamically constructed from the species declarations made by the modeler (and the built-in species present).\n\nThe hierarchy of types in GAML (only primitive and complex types are displayed here, of course, as the other ones are model-dependent) is the following:\n\nPrimitive built-in types​\nbool​\n\nDefinition: primitive datatype providing two values: true or false.\nLitteral declaration: both true or false are interpreted as boolean constants.\nOther declarations: expressions that require a boolean operand often directly apply a casting to bool to their operand. It is a convenient way to directly obtain a bool value.\n\nbool (0) -> false\nTop of the page\nfloat​\n\nDefinition: primitive datatype holding floating point values, its absolute value is comprised between 4.9E-324 and 1.8E308.\nComments: this datatype is internally backed up by the Java double datatype.\nLitteral declaration: decimal notation 123.45 or exponential notation 123e45 are supported.\nOther declarations: expressions that require an integer operand often directly apply a casting to float to their operand. Using it is a way to obtain a float constant.\n\nfloat (12) -> 12.0\nTop of the page\nint​\n\nDefinition: primitive datatype holding integer values comprised between -2147483648 and 2147483647 (i.e. between -2^31 and 2^31 - 1.\nComments: this datatype is internally backed up by the Java int datatype.\nLitteral declaration: decimal notation like 1, 256790 or hexadecimal notation like #1209FF are automatically interpreted.\nOther declarations: expressions that require an integer operand often directly apply a casting to int to their operand. Using it is a way to obtain an integer constant.\n\nint (234.5) -> 234.\nTop of the page\nstring​\n\nDefinition: a datatype holding a sequence of characters.\nComments: this datatype is internally backed up by the Java String class. However, contrary to Java, strings are considered as a primitive type, which means they do not contain character objects. This can be seen when casting a string to a list using the list operator: the result is a list of one-character strings, not a list of characters.\nLitteral declaration: a sequence of characters enclosed in quotes, like 'this is a string' . If one wants to literally declare strings that contain quotes, one has to double these quotes in the declaration. Strings accept escape characters like \\n (newline), \\r (carriage return), \\t (tabulation), as well as any Unicode character (\\uXXXX).\nOther declarations: see string\nExample: see string operators.\n\nTop of the page\nComplex built-in types​\nContrarily to primitive built-in types, complex types have often various attributes. They can be accessed in the same way as attributes of agents:\ncomplex_type nom_var <- init_var;ltype_attr attr_var <- nom_var.attr_name;\nFor example:\nfile fileText <- file(\"../data/cell.Data\");bool fileTextReadable <- fileText.readable;\nagent​\n\nDefinition: a generic datatype that represents an agent whatever its actual species.\nBuilt-in attributes: these attributes are common to any agent of the simulation\n\nlocation (type = point): the location of the agent\nshape (type = geometry): the shape of the agent\nname (type = string): name of the agent (not necessarily unique in its population)\npeers (type = list of agents of the same species): the population of agents of the same species, in the same host, minus the receiver agent\nhost (type = agent): the agent that hosts the population of the agent\n\n\nComments: This datatype is barely used since species name can be directly used as datatypes themselves.\nDeclaration: the agent casting operator can be applied to any unknown object to cast it as an agent.\n\nTop of the page\ncontainer​\n\nDefinition: a generic datatype that represents a collection of data.\nComments:  a container variable can be a list, a matrix, a map... Conversely, each list, matrix, and map is a kind of container. In consequence, every container can be used in container-related operators.\nSee also: Container operators\nDeclaration:\n\ncontainer c  <- [1,2,3];container c  <- matrix [[1,2,3],[4,5,6]];container c  <- map [\"x\"::5, \"y\"::12];container c  <- list species1;\nTop of the page\nconversation​\n\nDefinition: a datatype that represents a conversation between agents in a  FIPA-ACL interaction. It contains in particular all the exchanged messages.\nBuilt-in attributes:\n\nmessages (type = list of messages): the list of messages that compose this conversation\nprotocol (type = string): the name of the protocol followed by the conversation\ninitiator (type = agent): the agent that has initiated this conversation\nparticipants (type = list of agents): the list of agents that participate to this conversation\nended (type = bool): whether this conversation has ended or not\n\n\n\nTop of the page\ndate​\n\n\nDefinition: a datatype that represents a date (day, month, year, and time). Any date variable can be created in the model. 2 built-in variables exist in a model: starting_date (containing the date at the start of the simulation), current_date (the date at the current step of the simulation, it is updated automatically from starting_date, step and time). In addition, the constant #now contains the current (real) date. Many operators can be used on dates (such as +, -, add_years...).\n\n\nBuilt-in attributes:\n\nyear (type = int): the year component of the date\nmonth (type = int): the month component of the date (1-12)\nday (type = int): the day component of the date (1-31)\nhour (type = int): the number of hours in the current day of this date (0-23)\nminute (type = int): the number of minutes in the current hour of this date (0-59)\nsecond (type = int): the number of seconds in the current minute of this date (0-59)\nday_of_year (type = int): the current day number in the year of this date (1-366)\nday_of_week (type = int): the index of the day in the current week (with Monday being 1)\nsecond_of_day (type = int): the index of seconds in the day of this date (0-86399)\nminute_of_day (type = int): the index of the minute in the day of this date  (0-1439)\nweek_of_year (type = int): the index of the week in the current year (1-52)\ndays_in_month (type = int): the number of days in the current month of this date (28-31)\ndays_in_year (type = int): the number of days in the current year of this date (365-366)\nleap (type = bool): returns true if the year is a leap year\ndate (type = date): returns a new date object with only the year-month-day components of this date\n\n\n\nDeclaration: a date can be created using different sets of information.\n\nThe simplest one consists in using a list of int values: [year, month of the year, day of the month, hour of the day, minute of the hour, second of the minute] or simply [year, month of the year, day of the month] (time is set to 0 in this case).\n\ndate my_date <- date([2010,3,23,17,30,10]); // the 23th of March 2010, at 17:30:10date my_date2 <- date([2010,3,23]); // the 23th of March 2010, at 00:00:00\n\nAnother way consists in using a string with the good format. The following one is perhaps the most complete, with year, month, day, hour, minute, second, and also the time zone.\n\ndate my_date <- date(\"2010-3-23T17:30:10+07:00\"); \n\nBut the following ones can also be used:\n\n// without time zone:my_date3 <- date(\"2010-03-23 17:30:10\"); //Dates (without time)my_date3 <- date(\"20100323\");my_date3 <- date(\"2010-03-23\");// Dates using some patterns:my_date3 <- date(\"03 23 2010\",\"MM dd yyyy\");my_date3 <- date(\"01 23 20\",\"HH mm ss\");\n\n\nNote: date creation format has been defined in an ISO norm. More examples can be found here: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns\n\n\nSee also: Date operators\n\n\nTop of the page\nfield​\n\nDefinition: Fields are two-dimensional matrices holding float values. They can be easily created from arbitrary sources (grid, raster or DEM files, matrices grids) and of course by hand. The values they hold are accessible by agents like grids are, using their current location. They can be the target of the 'diffuse' statement and can be displayed using the 'mesh' layer definition. As such, they represent a lightweight alternative to grids, as they hold spatialized discrete values without having to build agents, which can be particularly interesting for models with large raster data. Several fields can of course be defined, and it makes sense to define them in the global section as, for the moment, they cover by default the whole environment, exactly like grids, and are created alongside them.\nBuilt-in attributes: a field is a kind of matrix, it thus inherits from the matrix's attributes.\n\ndimension (type = point): the dimension (columns x rows) of the receiver matrix\ncolumns (type = int): the number of columns of the receiver matrix\nrows (type = int): the number of rows of the receiver matrix\ncell_size (type = point): the dimension of an individual cell as a point (width, height). Setting it will only change the interpretation made by the field of the values it contains, but not the values themselves.\nbands (type = list of field): The list of bands that are optionally present in the field. The first band is the primary field itself, and each of these bands is a field w/o bands\nno_data (type = float): the value that indicates the absence of data. Setting it will only change the interpretation made by the field of the values it contains, but not the values themselves.\n\n\nSee also: Field operators\nDeclaration: a field can be created from a raster datafile (such as .asc of .tif files), a matrix or be specifying its dimensions.\n\na field can be created from a raster datafile\n\n// Initialize a field from a asc simple raster filefield field_from_asc <- field(grid_file(\"includes/grid.asc\"));// initialize using a tiff raster filefield field_from_tiff  <-  field(grid_file(\"includes/Lesponne.tif\"));\n\na field can be created manually:\n\n// Init from a user defined matrixfield field_from_matrix  <- field(matrix([[1,2,3],[4,5,6],[7,8,9]]));//  init an empty field of a given sizefield empty_field_from_size <- field(10,10);// init a field for of a given valuefield full_field_from_size<- field(10,10,1.0);  // init a field of given size, with a given value and no datafield full_field_from_size_with_nodata <- field (1,1,1.0,0.0);\n\na field can be created from a grid of cells, the value stored will be the grid's grid_value attribute\n\nglobal {  field field_from_grid <- field(matrix(cell));}grid cell width: 100 height: 100 {  float grid_value <- rnd(1.0,self distance_to world.location);}\n\n\nfile​\n\nDefinition: a datatype that represents a file.\nBuilt-in attributes:\n\nname (type = string): the name of the represented file (with its extension)\nextension(type = string): the extension of the file\npath (type = string): the absolute path of the file\n\nreadable (type = bool, read-only): a flag expressing whether the file is readable\nwritable (type = bool, read-only): a flag expressing whether the file is writable\nexists (type = bool, read-only): a flag expressing whether the file exists\nis_folder (type = bool, read-only): a flag expressing whether the file is folder\ncontents (type = container): a container storing the content of the file\n\n\n\n\nComments: a variable with the file type can handle any kind of file (text, image or shape files...). The type of the content attribute will depend on the kind of file. Note that the allowed kinds of file are the followings:\n\ntext files: files with the extensions .txt, .data, .csv, .text, .tsv, .asc. The content is by default a list of string.\nimage files: files with the extensions .pgm, .tif, .tiff, .jpg, .jpeg, .png, .gif, .pict, .bmp. The content is by default a matrix of int.\nshapefiles: files with the extension .shp. The content is by default a list of geometry.\nproperties files: files with the extension .properties. The content is by default a map of string::string.\nfolders. The content is by default a list of string.\n\n\nRemark: Files are also a particular kind of container and can thus be read, written or iterated using the container operators and commands.\nSee also: File operators\nDeclaration: a file can be created using the generic file (that opens a file in read only mode and tries to determine its contents), folder or the new_folder (to open an existing folder or create a new one) unary operators. But things can be specialized with the combination of the read/write and image/text/shapefile/properties unary operators.\n\nfolder(a_string)  // returns a file managing a existing folderfile(a_string) // returns any kind of file in read-only moderead(text(a_string)) // returns a text file in read-only moderead(image(a_string)) // does the same with an image file.write(properties(a_string)) // returns a property file which is available for writing                             // (if it exists, contents will be appended unless it is cleared                             // using the standard container operations).\nTop of the page\ngeometry​\n\nDefinition: a datatype that represents a vector geometry, i.e. a list of georeferenced points.\nBuilt-in attributes:\n\nlocation (type = point): the centroid of the geometry\narea (type = float): the area of the geometry\nperimeter (type = float): the perimeter of the geometry\nholes (type = list of geometry): the list of the hole inside the given geometry\ncontour (type = geometry): the exterior ring of the given geometry and of his holes\nenvelope (type = geometry): the geometry bounding box\nwidth (type = float): the width of the bounding box\nheight (type = float): the height of the bounding box\npoints (type = list of point): the set of the points composing the geometry\n\n\nComments: a geometry can be either a point, a polyline or a polygon. Operators working on geometries handle transparently these three kinds of geometry. The envelope (a.k.a. the bounding box) of the geometry depends on the kind of geometry:\n\nIf this Geometry is the empty geometry, it is an empty point.\nIf the Geometry is a point, it is a non-empty point.\nOtherwise, it is a Polygon whose points are (minx, miny), (maxx, miny), (maxx, maxy), (minx, maxy), (minx, miny).\n\n\nSee also: Spatial operators\nDeclaration: geometries can be built from a point, a list of points, or by using specific operators (circle, square, triangle...).\n\ngeometry varGeom <- circle(5);geometry polygonGeom <- polygon([{3,5}, {5,6},{1,4}]);\nTop of the page\ngraph​\n\nDefinition: a datatype that represents a graph composed of vertices linked by edges.\nBuilt-in attributes:\n\nedges(type = list of agent/geometry): the list of all edges\nvertices(type = list of agent/geometry): the list of all vertices\ncircuit (type = path): an approximate minimal traveling salesman tour (hamiltonian cycle)\nspanning_tree (type = list of agent/geometry): minimum spanning tree of the graph, i.e. a sub-graph such as every vertex lies in the tree, and as much edges lies in it but no cycles (or loops) are formed.\nconnected(type = bool): test whether the graph is connected\n\n\nRemark:\n\ngraphs are also a particular kind of container and can thus be manipulated using the container operators and commands.\nThis algorithm used to compute the circuit requires that the graph be complete and the triangle inequality exists (if x,y,z are vertices then d(x,y)+d(y,z)>=d(x,z) for all x,y,z) then this algorithm will guarantee a hamiltonian cycle such that the total weight of the cycle is less than or equal to double the total weight of the optimal hamiltonian cycle.\nThe computation of the spanning tree uses an implementation of the Kruskal's minimum spanning tree algorithm. If the given graph is connected it computes the minimum spanning tree, otherwise it computes the minimum spanning forest.\n\n\nSee also: Graph operators\nDeclaration: graphs can be built from a list of vertices (agents or geometries) or from a list of edges (agents or geometries) by using specific operators. They are often used to deal with a road network and are built from a shapefile.\n\ncreate road from: shape_file_road;graph the_graph <- as_edge_graph(road);graph([1,9,5])        --: ([1: in[] + out[], 5: in[] + out[], 9: in[] + out[]], [])graph([node(0), node(1), node(2)]      // if node is a speciesgraph(['a'::345, 'b'::13])  --:  ([b: in[] + out[b::13], a: in[] + out[a::345], 13: in[b::13] + out[], 345: in[a::345] + out[]], [a::345=(a,345), b::13=(b,13)])graph(a_graph)  --: a_graphgraph(node1)    --: null\nTop of the page\nlist​\n\nDefinition: a composite datatype holding an ordered collection of values.\nComments: lists are more or less equivalent to instances of ArrayList in Java (although they are backed up by a specific class). They grow and shrink as needed, can be accessed via an index (see @ or index_of), support set operations (like union and difference), and provide the modeller with a number of utilities that make it easy to deal with collections of agents (see, for instance, shuffle, reverse,where,sort_by,...).\nRemark: lists can contain values of any datatypes, including other lists. Note, however, that due to limitations in the current parser, lists of lists cannot be declared literally; they have to be built using assignments. Lists are also a particular kind of container and can thus be manipulated using the container operators and commands.\nLitteral declaration: a set of expressions separated by commas, enclosed in square brackets, like [12, 14, 'abc', self]. An empty list is noted [].\nOther declarations: lists can be built literally from a point, or a string, or any other element by using the list casting operator.\n\nlist (1) -> [1]\nlist<int> myList <- [1,2,3,4]; myList[2] => 3\nTop of the page\nmap​\n\nDefinition: a composite datatype holding an ordered collection of pairs (a key, and its associated value).\nBuilt-in attributes:\n\nkeys (type = list): the list of all keys\nvalues (type = list): the list of all values\npairs (type = list of pairs): the list of all pairs key::value\n\n\nComments: maps are more or less equivalent to instances of Hashtable in Java (although they are backed up by a specific class).\nRemark: maps can contain values of any datatypes, including other maps or lists. Maps are also a particular kind of container and can thus be manipulated using the container operators and commands.\nLitteral declaration: a set of pair expressions separated by commas, enclosed in square brackets; each pair is represented by a key and a value separated by ::. An example of map is [agentA::'big', agentB::'small', agentC::'big']. An empty map is noted [].\nOther declarations: lists can be built literally from a point, or a string, or any other element by using the map casting operator.\n\nmap (1) -> [1::1]map ({1,5}) -> [x::1, y::5][]   // empty map \nTop of the page\nmatrix​\n\nDefinition: a composite datatype that represents either a two-dimension array (matrix) or a one-dimension array (vector), holding any type of data (including other matrices).\nBuilt-in attributes:\n\ndimension (type = point): the dimension (columns x rows) of the receiver matrix\ncolumns (type = int): the number of columns of the receiver matrix\nrows (type = int): the number of rows of the receiver matrix\n\n\nComments: Matrices are fixed-size structures that can be accessed by index (point for two-dimension matrices, integer for vectors).\nLitteral declaration: Matrices cannot be defined literally. One-dimension matrices can be built by using the matrix casting operator applied on a list. Two-dimensions matrices need to be declared as variables first, before being filled.\n\n//builds a one-dimension matrix, of size 5matrix mat1 <- matrix ([10, 20, 30, 40, 50]);//  builds a two-dimensions matrix with 10 columns and 5 rows, where each cell is initialized to 0.0matrix mat2 <- 0.0 as_matrix({10,5}); // builds a two-dimensions matrix with 2 columns and 3 rows, with initialized cellsmatrix mat3 <- matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]]);         -> c11;c21       c12;c22       c13;c23\nTop of the page\nmessage​\n\nDefinition: a datatype containing a message (sent during a communication, such as the one sent/received in a FIPA interaction).\nBuilt-in attributes:\n\ncontents (type = unknown): the contents of this message, as a list of arbitrary objects\nsender (type = unknown): the sender that has sent this message\nunread (type = bool): whether this message is unread or not\nemission_timestamp (type = int): the emission time stamp of this message (I.e. at what cycle it has been emitted)\nrecention_timestamp (type = int): the reception time stamp of this message (I.e. at what cycle it has been received)\n\n\n\npair​\n\nDefinition: a datatype holding a key and its associated value.\nBuilt-in attributes:\n\nkey (type = unknown, read-only): the key of the pair, i.e. the first element of the pair\nvalue (type = unknown, read-only): the value of the pair, i.e. the second element of the pair\n\n\nRemark: pairs are also a particular kind of container and can thus be manipulated using container operators and commands.\nLitteral declaration: a pair is defined by a key and a value separated by ::. The type of the key and value can also be specified.\n\npair testPair <- \"key\"::56;pair<string,int> pairWithType <- \"tot\"::23;\nTop of the page\npath​\n\nDefinition: a datatype representing a path linking two agents or geometries in a graph.\nBuilt-in attributes:\n\nsource (type = point): the source point, i.e. the first point of the path\ntarget (type = point): the target point, i.e. the last point of the path\ngraph (type = graph): the current topology (in the case it is a spatial graph), null otherwise\nedges (type = list of agents/geometries): the edges of the graph composing the path\nvertices (type = list of agents/geometries): the vertices of the graph composing the path\nsegments (type = list of geometries): the list of the geometries composing the path\nshape (type = geometry) : the global geometry of the path (polyline)\n\n\nComments: the path created between two agents/geometries or locations will strongly depend on the topology in which it is created.\nRemark: a path is immutable, i.e. it can not be modified after it is created.\nDeclaration: paths are very barely defined literally. We can nevertheless use the path unary operator on a list of points to build a path. Operators dedicated to the computation of paths (such as path_to or path_between) are often used to build a path.\n\npath([{1,5},{2,9},{5,8}]) // a path from {1,5} to {5,8} through {2,9}       geometry rect <- rectangle(5);geometry poly <- polygon([{10,20},{11,21},{10,21},{11,22}]);path pa <- rect path_to poly;  // built a path between rect and poly, in the topolopy                                  // of the current agent (i.e. a line in a& continuous topology,                                // a path in a graph  in a graph topology )a_topology path_between a_container_of_geometries // idem with an explicit topology and the possibility                                                   // to have more than 2 geometries                                                   // (the path is then built incrementally)path_between (a_graph, a_source, a_target) // idem with a the given graph as topology\nTop of the page\npoint​\n\nDefinition: a datatype normally holding two positive float values. Represents the absolute coordinates of agents in the model.\nBuilt-in attributes:\n\nx (type = float): coordinate of the point on the x-axis\ny (type = float): coordinate of the point on the y-axis\n\n\nComments: point coordinates should be positive, if a negative value is used in its declaration, the point is built with the absolute value.\nRemark: points are particular cases of geometries and containers. Thus they have also all the built-in attributes of both the geometry and the container datatypes and can be used with every kind of operator or command admitting geometry and container.\nLitteral declaration: two numbers, separated by a comma, enclosed in braces, like {12.3, 14.5}\nOther declarations: points can be built literally from a list, or from an integer or float value by using the point casting operator.\n\npoint ([12,123.45]) -> {12.0, 123.45} point (2) -> {2.0, 2.0}\nTop of the page\nrgb​\n\nDefinition: a datatype that represents a color in the RGB space.\nBuilt-in attributes:\n\nred(type = int): the red component of the color\ngreen(type = int): the green component of the color\nblue(type = int): the blue component of the color\ndarker(type = rgb): a new color that is a darker version of this color\nbrighter(type = rgb): a new color that is a brighter version of this color\n\n\nRemark: rgb is also a particular kind of container and can thus be manipulated using the container operators and commands.\nLitteral declaration: there exist a lot of ways to declare a color. We use the rgb casting operator applied to:\n\na string. The allowed color names are the constants defined in the Color Java class, i.e.: black, blue, cyan, darkGray, lightGray, gray, green, magenta, orange, pink, red, white, yellow.\na list. The integer value associated to the three first elements of the list are used to define the three red (element 0 of the list), green (element 1 of the list) and blue (element 2 of the list) components of the color.\na map. The red, green, blue components take the value associated to the keys \"r\", \"g\", \"b\" in the map.\nan integer <- the decimal integer is translated into a hexadecimal <- OxRRGGBB. The red (resp. green, blue) component of the color takes the value RR (resp. GG, BB) translated in decimal.\nSince GAMA 1.6.1, colors can be directly obtained like units, by using the ° or # symbol followed by the name in lowercase of one of the 147 CSS colors (see http://www.cssportal.com/css3-color-names/).\n\n\nDeclaration:\n\nrgb cssRed <- #red;   // Since 1.6.1rgb testColor <- rgb('white');                 // rgb [255,255,255]rgb test <- rgb(3,5,67);                     // rgb [3,5,67]rgb te <- rgb(340);                            // rgb [0,1,84]rgb tete <- rgb([\"r\"::34, \"g\"::56, \"b\"::345]); // rgb [34,56,255]\nTop of the page\nspecies​\n\nDefinition: a generic datatype that represents a species\nBuilt-in attributes:\n\ntopology (type=topology): the topology is which lives the population of agents\n\n\nComments: this datatype is actually a \"meta-type\". It allows to manipulate (in a rather limited fashion, however) the species themselves as any other values.\nLitteral declaration: the name of a declared species is already a literal declaration of species.\nOther declarations: the species casting operator, or its variant called species_of can be applied to an agent in order to get its species.\n\nTop of the page\nSpecies names as types​\nOnce a species has been declared in a model, it automatically becomes a datatype. This means that:\n\nIt can be used to declare variables, parameters or constants,\nIt can be used as an operand to commands or operators that require species parameters,\nIt can be used as a casting operator (with the same capabilities as the built-in type agent)\n\nIn the simple following example, we create a set of \"humans\" and initialize a random \"friendship network\" among them. See how the name of the species, human, is used in the create command, as an argument to the list casting operator, and as the type of the variable named friend.\nglobal {    init {         create human number: 10;         ask human {               friend <- one_of (human - self);         }     }}entities {    species human {        human friend <- nil;    }}\nTop of the page\ntopology​\n\nDefinition: a topology is basically on neighborhoods, distance,... structures in which agents evolves. It is the environment or the context in which all these values are computed. It also provides the access to the spatial index shared by all the agents. And it maintains a (eventually dynamic) link with the 'environment' which is a geometrical border.\nBuilt-in attributes:\n\nplaces(type = container): the collection of places (geometry) defined by this topology.\nenvironment(type = geometry): the environment of this topology (i.e. the geometry that defines its boundaries)\n\n\nComments: the attributes places depends on the kind of the considered topology.  For continuous topologies, it is a list with their environment. For discrete topologies, it can be any of the container supporting the inclusion of geometries (list, graph, map, matrix)\nRemark: There exist various kinds of topology: continuous topology and discrete topology (e.g. grid, graph...)\nDeclaration: To create a topology, we can use the topology unary casting operator applied to:\n\nan agent: returns a continuous topology built from the agent's geometry\na species name: returns the topology defined for this species population\na geometry: returns a continuous topology built on this geometry\na geometry container (list, map, shapefile): returns an half-discrete (with corresponding places), half-continuous topology (to compute distances...)\na geometry matrix (i.e. a grid): returns a grid topology which computes specifically neighborhood and distances\na geometry graph: returns a graph topology which computes specifically neighborhood and distances\nMore complex topologies can also be built using dedicated operators, e.g. to decompose a geometry...\n\n\n\nDefining custom types​\nSometimes, besides the species of agents that compose the model, it can be necessary to declare custom datatypes. Species serve this purpose as well, and can be seen as \"classes\" that can help to instantiate simple \"objects\". In the following example, we declare a new kind of \"object\", bottle, that lacks the skills habitually associated with agents (moving, visible, etc.), but can nevertheless group together attributes and behaviors within the same closure. The following example demonstrates how to create the species:\nspecies bottle {    float volume <- 0.0 max:1 min:0.0;    bool is_empty -> {volume = 0.0};    action fill {         volume <- 1.0;    }}\nHow to use this species to create new bottles:\ncreate bottle {    volume <- 0.5;}\nAnd how to use bottles as any other agent in a species (a drinker owns a bottle; when he gets thirsty, it drinks a random quantity from it; when it is empty, it refills it):\nspecies drinker {     ...    bottle my_bottle<- nil;    float quantity <- rnd (100) / 100;    bool thirsty <- false update: flip (0.1);    ...    action drink {         if condition: ! bottle.is_empty {              bottle.volume <-bottle.volume - quantity;              thirsty <- false;         }    }    ...    init {          create bottle return: created_bottle;              volume <- 0.5;          }          my_bottle <- first(created_bottle);    }    ...    reflex filling_bottle when: bottle.is_empty {         ask  my_bottle {              do fill;         }    }    ...    reflex drinking when: thirsty {         do drink;    }}"},{"filePath":"https:--gama-platform.org--wiki-Defining3DDisplays.txt","text":"Defining 3D DisplaysOpenGL display​\nThe use an OpenGL display, we have to define the attribute type of the display with type:opengl in the chosen display of your model (or use the preferences->display windows to use it by default):\noutput {    display DisplayName type: opengl {        species mySpecies;    }}\nThe OpenGL display shares most of the features that the java2D offers and that are described here. Using 3D display offers much more options to draw and show a simulation. A layer can be positioned and scaled in a 3D world. It is possible to superpose layers on different z value and display different information on the model at different positions on the screen.\nMost of the features offers by GAMA in 3D can be found as model example in the model library in the Visualization and User Interaction/3D Visualization\nSuch as:\n\n3D Model: Creating a simple model with building in 3D from a GIS file extruded in Building Elevation.gaml\n\n\n\nBuilt-in 3D shapes supported by GAMA are described in Built-In Shapes.gaml\n\n\n\nFeatures related to camera and the way to manipulate it are found in Camera Definitions.gaml\n\n\n\nDifferent point of view can be described on the same simulation and shared by different displays in Camera Shared Zoom.experiment\n\n\n\nAny GIS file can be visualized in 3D and a texture can be applied to the 3D shape in GIS Visualization.gaml\n\n\n\nGAMA is handling different kind of lighting such as spot lights and point lights as illustrated in Lighting.gaml\n\n\n\nMoving 3D object.gaml which shows how to draw a moving objet as a OBJ File and how to apply a 3D rotation on it\n\n\n\nSpecular light can also be defined as illustrated in Specular effects.gaml\n\n"},{"filePath":"https:--gama-platform.org--wiki-DefiningActionsAndBehaviors.txt","text":"Defining actions and behaviorsBoth actions and behaviors can be seen as methods in OOP. They can be defined in any species.\nIndex​\n\nAction\n\nDeclare an action\nCall an action\n\n\nBehavior\nExample\n\nAction​\nDeclare an action​\nAn action is a function or procedure run by an instance of species. An action can return a value (in that case, the type of return has to be specified just before the name of the action), or not (in that case, you just have to put the keyword action before the name of the action). The former ones are often named functions, whereas the latter ones are named procedures in many programming languages.\nspecies my_species {    int action_with_return_value {\t// statements...\treturn 1;    }    action action_without_return_value {\t// statements...    }}\nArguments can also be mandated in your action. You have to specify the type and the name of the argument:\naction action_without_return_value (int argA, float argB) {    // statements...}\nIf you want to have some optional arguments in the list, you can give some by default values to turn them optional. Nb: it is better to define the optional arguments at the end of the list of argument.\naction my_action (int argA, float argB <- 5.1, point argC <- {0,0}) {\t// statements...}\nCall an action​\nTo call an action, it depends whether you want to get the returned value of not:\n\nto call a procedure (without getting any returned value): you have to use the statement do.\nto call a function and thus get the returned value, you need to use any_agent action(arguments) and assigned this value to a variable.\n\nYou can use the statement do in different ways:\n\nWith facets: after specifying the name of your action, you can specify the values of your arguments as if the name of your arguments were facets:\n\ndo my_action argA: 5 argB: 5.1;\n\nWith parenthesis: after specifying the name of your action, you can specify the values of your arguments in the same order they were declared, between parenthesis (just as if you used an operator):\n\ndo my_action (5,5.1);\nWe encourage you to use the second way.\nTo catch the returned value, you have to skip the do statement, and store the value directly in a temporary variable:\nint var1 <- my_action(5,5.1);// orint var1 <- my_action(argA: 5, argB: 5.1);\nBehavior​\nA behavior, or reflex, is a set of statements which is called automatically at each time step by an agent.\nNote that, a behavior is linked to an architecture; the reflex-based architecture is the default one, others can be used with the controls facet of the species`.\nreflex my_reflex {    write (\"Executing the inconditional reflex\");    // statements...}\nWith the facet when, this reflex is only executed when the boolean expression evaluates to true. It is a convenient way to specify the behavior of agents.\nreflex my_reflex when: flip(0.5) {    write (\"Executing the conditional reflex\");    // statements...}\nReflex, unlike actions, cannot be called from another context. But a reflex can, of course, call actions.\nNB: Init is a special reflex, that occurs only when the agent is created.\nExample​\nTo practice a bit with those notions, we will build an easy example. Let's build a model with a species balloon that has 2 attributes: balloon_size (float) and balloon_color (rgb). Each balloon has a random position and color, his aspect is a sphere. Each step, a balloon has a probability to spawn in the environment. Once a balloon is created, its size is 10cm, and each step, the size increases by 1cm. Once the balloon size reaches 50cm, the balloon has a probability to burst. Once 10 balloons are destroyed, the simulation stops. The volume of each balloon is displayed in the balloon position.\n\nHere is one of the multiple possible implementations:\nmodel burst_the_baloonglobal{    float worldDimension <- 5#m;    geometry shape <- square(worldDimension);    int nbBaloonDead <- 0;    reflex buildBaloon when: (flip(0.1)) {\tcreate balloon number: 1;    }\t    reflex endSimulation when: nbBaloonDead>10 {\tdo pause;    }}species balloon {    float balloon_size;    rgb balloon_color;        init {\tballoon_size <- 0.1;\tballoon_color <- rgb(rnd(255),rnd(255),rnd(255));    }    reflex balloon_grow {\tballoon_size <- balloon_size + 0.01;\tif (balloon_size > 0.5) {\t    if (flip(0.2)) {\t\tdo balloon_burst;\t    }\t}    }\t    float balloon_volume (float diameter) {\tfloat exact_value <- 2/3 * #pi * diameter^3;\tfloat round_value <- round(exact_value*1000)/1000;\treturn round_value;    }\t    action balloon_burst {\twrite \"the baloon is dead !\";\tnbBaloonDead <- nbBaloonDead + 1;\tdo die;    }\t    aspect balloon_aspect {\tdraw circle(balloon_size) color: balloon_color;\tdraw string(balloon_volume(balloon_size)) color: #black;    }}experiment my_experiment type: gui {    output {\tdisplay myDisplay {\t    species balloon aspect: balloon_aspect;\t}    }}"},{"filePath":"https:--gama-platform.org--wiki-DefiningAdvancedSpecies.txt","text":"Defining advanced speciesIn the previous chapter, we saw how to declare and manipulate regular species and the global species (as a reminder, the instance of the global species is the world agent).\nWe will now see that GAMA provides you the possibility to declare some special species, such as grids or graphs, with their own built-in attributes and their own built-in actions. We will also see how to declare mirror species, which is a \"copy\" of a regular species, in order to give it an other representation. Finally, we will learn how to represent several agents through one unique agent, with multi-level architecture."},{"filePath":"https:--gama-platform.org--wiki-DefiningCharts.txt","text":"Defining ChartsTo visualize results and make analysis about your model, you will certainly have to use charts. You can define several types of charts in GAML among histograms, pie, series, radar, heatmap... For each type, you will have to determine the data you want to highlight.\nIndex​\n\nDefine a chart\nData definition\nVarious types of charts\n\npie\nseries\nhistogram\nxy\nheatmap\nradar\nscatter\nbox_whisker\n\n\nOther charts possibilities\n\nDefine a chart​\nTo define a chart, we have to use the chart statement. A chart has to be named (with the name facet), and the type has to be specified (with the type facet). The value of the type facet can be histogram, pie, series, scatter, xy, radar, heatmap or box_whisker. A chart has to be defined inside a display.\nexperiment my_experiment type: gui {    output {\tdisplay \"my_display\" {\t    chart \"my_chart\" type:pie {                        }\t}    }}\nchart can be configured by setting by facets: in particular the labels in x and y-axis can be set (x_serie_labels, y_serie_labels), axes colors (axes), a third axis can be added...\nAfter declaring your chart, you have to define the data you want to display in your chart.\nData definition​\nData can be specified with:\n\nseveral data statements to specify each series.\none datalist statement to give a list of series. It can be useful if the number of series is unknown, variable or too high.\n\nThe data statement is used to specify which expression will be displayed. You have to give your data a name (that will be displayed in your chart), the value of the expression you want to follow (using the value facet). You can add some optional facets such as color to specify the color of your data.\nglobal {    int numberA <- 2 update: numberA*2;    int numberB <- 10000 update: numberB-1000;}experiment my_experiment type: gui {   float minimum_cycle_duration <- 0.1;   output {\tdisplay \"my_display\" {\t    chart \"my_chart\" type: pie {\t\tdata \"numberA\" value: numberA color: #red;\t\tdata \"numberB\" value: numberB color: #blue;\t    }\t}    }}\n\nThe datalist statement is used to write several data statements in one statement.  Instead of giving simple values, datalist is expecting value lists. The previous chart is thus equivalent to the following one using the datalist statement:\ndisplay \"my_display2\" {    chart \"my_chart2\" type: pie {\tdatalist [\"numberA\",\"numberB\"] value:  [numberA,numberB] color: [#red,#blue] ;    }}\ndatalist is particularly suitable in the case where the number of data series to plot can change during the simulation. As an example, when we want to plot the evolution of an attribute value for each agent (and new agents are created), we need to use this statement. As an example, in the following model, we want to plot the energy of each people agent. Each simulation step one agent is created.\nglobal {        init {\tcreate people number:15;    \t    }        reflex population_growth when: length(people) < 50 {    \tcreate people number:1;    }}species people {\t        int energy \t<- rnd(100) min:0;\trgb color \t<- rnd_color(255);\t\treflex aging {\t    energy <- energy - 3;\t}}experiment my_experiment type: gui {    float minimum_cycle_duration <- 0.1;    output {    \tdisplay \"my_display\" {\t   \t\tchart \"my_chart\" type: series {\t\t\t\tdatalist people collect (each.name) value:  people collect (each.energy) color: people collect (each.color) ;\t\t    }\t\t}    }}\n\ndatalist provides you some additional facets you can use. If you want to learn more about them, please read the documentation.\nVarious types of charts​\nAs we already said, you can display several types of graphs: the histograms, the pies, the series, the radars, heatmap...\npie​\nThe pie chart shows on a single pie diagram the ratio of each data series over the sum of all the series.\nIt has already been illustrated above.\nseries​\nThe series type is perhaps the most basic plot: it displays in an x-y coordinates space the value of each data series over time (simulation step): the x-axis displays the simulation step, the y-axis represents the value of the data series. The previously defined pie chart, can be displayed using a series simply by changing the chart type.\nglobal {    int numberA <- 2 update: numberA*2;    int numberB <- 10000 update: numberB-1000;}experiment my_experiment type: gui {     float minimum_cycle_duration <- 0.1;     output {\tdisplay \"my_display\" {\t\tchart \"my_chart\" type: series {\t\t\tdata \"numberA\" value: numberA color: #red;\t\t\tdata \"numberB\" value: numberB color: #blue;\t\t}\t}    }}\n\nhistogram​\nThe histogram charts represent with bars the value of several data series. The previous example can be displayed with a histogram chart.\n\nHistograms are often used to display the distribution of a value inside a population. For example, let consider a population of agents representing human beings with an age attribute. The following model illustrates the plot of the age distribution over the population. We used the operator distribution_of to compute the distribution to plot: here we display the number of people agent in 20 ranges computed among the ages between 0 and 100.\nmodel NewModelglobal {    init {\tcreate people number: 10000;    }}species people {    float age <- gauss(40.0, 15.0);}experiment my_experiment type: gui {    float minimum_cycle_duration <- 0.1;    output {        display \"my_display\" {\t    chart \"my_chart\" type: histogram {\t\tdatalist (distribution_of(people collect each.age,20,0,100) at \"legend\") \t\t    value:(distribution_of(people collect each.age,20,0,100) at \"values\");\t\t\t    }\t}    }}\n\nNote that the facet reverse_axes (with true value) can be added to the chart statement to display horizontal bars.\nxy​\nThe xy displays are used when we want to display a value in function of another one (instead of plotting a value in function of the time): in this case, the x-axis does not represent the time in general. It can be used for example to plot a phase portrait, e.g. in the Lotka-Volterra model (prey-predator model) in which we want to plot the number of preys according to the number of predators. The code for the chart is then:\ndisplay PhasePortrait  {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     chart \"Lotka Volterra Phase Portrait\" type: xy {\t\t\t\t\t\t\t        data 'Preys/Predators' value: {first(LotkaVolterra_agent).nb_prey, first(LotkaVolterra_agent).nb_predator} color: #black ;\t\t    }}\n\nradar​\nA radar chart displays the evolution of expression over time in a kind of circular representation: the radar representation. If reuse the example describes previously and used in the previous types of charts, we get the following adapted model:\nglobal {    int numberA <- 2 update: numberA*2;    int numberB <- 10000 update: numberB-1000;}experiment my_experiment type: gui {    float minimum_cycle_duration <- 0.1;    output {\tdisplay \"my_display\" {\t    chart \"my_chart\" type: radar background: #white axes:#black {\t\tdata \"numberA\" value: numberA color: #red accumulate_values: true;\t\tdata \"numberB\" value: numberB color: #blue accumulate_values: true;\t    }\t}    }}\n\nheatmap​\nThe heatmap in GAMA is close to a stack of histograms charts (allowing to keep a view of the evolution of values over time), representing the height of the bars by color in a gradient.\nLet consider the model of a human population characterized by their age. We had a population dynamic: at each step, their age is incremented by 1. They also have a probability to die at each step (that increases with their age). When an agent dies, it creates a new agent with an age equals to 0.\nmodel NewModelglobal {    init {\tcreate people number: 10000;    }}species people {    float age <- gauss(40.0, 15.0);    reflex older {\tage <- age + 1;    }    reflex die when: flip(age / 1000) {\tcreate people {\t    age <- 0.0;\t}\tdo die;    }}experiment my_experiment type: gui {    output {\tdisplay \"my_display\" {\t    chart \"my_chart\" type: histogram {\t\tdatalist (distribution_of(people collect each.age, 20, 0, 100) at \"legend\")                     value: (distribution_of(people collect each.age, 20, 0, 100) at \"values\");\t    }\t}\tdisplay DistributionPosition {\t    chart \"Distribution of age\" type: heatmap                   x_serie_labels: (distribution_of(people collect each.age, 20, 0, 100) at \"legend\") {\t\tdata \"Agedistrib\" value: (distribution_of(people collect each.age, 20, 0, 100) at \"values\") color: #red; \t    }\t}    }}\nWe thus displayed the evolution of the age distribution using both a histogram chart (for the instantaneous distribution) and a heatmap display to key a track of the evolution over time. In the heatmap, the left Y-axis represents the time (the simulation step number); as a consequence 1 line represents the state at 1 simulation step. The x-axis represents the various ranges of the distribution (same meaning as for histograms). The right Y-axis shows the meaning of the color gradient.\n\nscatter​\nThe scatter chart allows us to represent in a 2D space the \"spatial distribution\" of a set of values. As an example, it allows us to plot the age of all the people agents: the X-axis represents the possible age value and not the time as in a series charts.\nHere is an example of a chart of type scatter on the previous model example:\nexperiment my_experiment type: gui {    output {\tdisplay \"my_display\" {\t    chart \"my_chart\" type: scatter {\t\tdata \"Avg age\" value: (people collect each.age) accumulate_values: true line_visible:false ;\t    }\t}\t\t    }}\n\nbox_whisker​\nThe box_whisker charts represent the distribution of a value. A circle for the average, a horizontal line for the median, a filled bar (the \"box\") for the top 75% and the bottom 25% and a line (the \"whisker\") for the maximum and minimum values.\nFor example, let consider again a population of agents representing human beings with an age attribute (with an aging mechanism). The following model illustrates the plot of the age distribution over the population.\nmodel NewModelglobal {    init {\tcreate people number: 100;    }}species people {    float age <- gauss(40.0, 15.0);    reflex older {\tage <- age + 1;    }    reflex die when: flip(age / 1000) {\tcreate people {\t    age <- 0.0;\t}\tdo die;\t}}experiment my_experiment type: gui {    float minimum_cycle_duration <- 0.1;    output {\tdisplay \"chart age\" {\t    chart \"age\" type: box_whisker \t    series_label_position:yaxis\t    {\t\tdata \"age\"\t\t   value: [mean(people collect each.age),median(people collect each.age),\t\t   \tquantile((people sort_by each.age) collect each.age,0.25),quantile((people sort_by each.age)collect each.age,0.75),\t\t   \tmin(people collect each.age),max(people collect each.age)]\t\t   \tcolor: #green\t\t\taccumulate_values: true;\t    } \t  }    }}\n\nNote that the facet series_label_position (with yaxis value) int the chart statement is used to display the serie label (\"age\") on the y axis. With more series, we can display the labels as a legend (with the 'legend' value).\nOther charts possibilities​\nThe chart, data and datalist come with a huge number of additional facets, allowing you to design advanced result display. We can mention here some of them.\nError values​\nJust as a box plot, drawing error values around a value, allows the user to visually identify a value (e.g. a mean value) and the distribution of this value around it. The y_err_values facet of data can be used to show in the data plot and a range around it (e.g. the min and max value of an expression in the agent population).\nIn this example, we plot the average age of agents in the population, with the minimum and maximum value. Here is only the experiment code related to the model shown in the previous parts.\nexperiment my_experiment type: gui {    float minimum_cycle_duration <- 0.1;    output {\tdisplay \"my_display\" {\t    chart \"my_chart\" type: series {\t\tdata \"average age\" value: people mean_of each.age color: #red                            y_err_values: [people min_of each.age,people max_of each.age];\t    }\t}    }}\n"},{"filePath":"https:--gama-platform.org--wiki-DefiningDisplaysGeneralities.txt","text":"Defining displays (Generalities)Index​\n\nDisplays and layers\nOrganize your layers\nExample of layers\n\nspecies layer\ngrid layer\nagents layer\nimage layer\ngraphics layer\n\n\n\nDisplays and layers​\nA display is one of the graphical outputs of your simulation. You can define several displays related to what you want to represent from your model execution. To define a display, use the keyword display inside the output scope, and specify a name (name facet).\nexperiment my_experiment type: gui {    output {\tdisplay \"display1\" {\t}\tdisplay name:\"display2\" {\t}    }}\nOther facets are available when defining your display:\n\nUse background to define a color for your background:\n\ndisplay \"my_display\" background: #red\n\nUse refresh if you want to refresh the display when a condition is true (to refresh your display every number of steps, use the operator every)\n\ndisplay \"my_display\" refresh:every(10)\n\n\nYou can choose between two types of displays, by using the facet type:\n\njava2D displays will be used when you want to have 2D visualization. It is used for example when you manipulate charts. This is the default value for the facet type.\nopengl displays allows you to have 3D visualization.\n\n\n\nYou can save the display on the disk, as a png file, in the folder name_of_model/models/snapshots, by using the facet autosave. This facet takes a boolean as argument (to allow or not to save each frame) or a point to define the size of your image (note that when no unit is provided, the unit is #px (pixel) ).\ndisplay my_display autosave: true type: java2D {}\nThe complete list of the display's facets are available in the documentation\nEach display can be decomposed in one or several layers. Most of the time, all the layers are superimposed and cover all the environment space. In a 3D (OpenGL) display the layers can be split in order to be visualized separately (cf the page about displays).\nOrganize your layers​\nIn one 2D display, you will have several types of layers, giving what you want to display in your model. You have a large number of layers available. You already know some of them, such as species, agents, grid, but other specific layers such as image (to display image) and graphics (to freely draw shapes/geometries/texts without having to define a species) are also available\nEach layer will be displayed in the same order as you declare them. The last declared layer will be above the others. As a consequence, any layer can hide elements of the lower levels.\nThus, the following code:\nexperiment expe type: gui {    output {        display my_display {            graphics \"layer1\" {                draw square(20) at: {10,10} color: #gold;            }            graphics \"layer2\" {                draw square(20) at: {15,15} color: #darkorange;            }            graphics \"layer3\" {                draw square(20) at: {20,20} color: #cornflowerblue;            }        }    }}\nWill have this output:\n\nMost of the layers have a transparency facet that you can use in order to see the layers which are under.\nexperiment expe type:gui {    output {\tdisplay my_display {\t    graphics \"layer1\" {\t\tdraw square(20) at:{10,10} color:#darkorange;\t    }\t    graphics \"layer2\" transparency:0.5 {\t\tdraw square(20) at:{15,15} color:#cornflowerblue;\t    }\t}    }}\n\nTo specify a position and a size for your layer, you can use the position and the size facets.\nThe position facet is used with a point type, between {0,0} and {1,1}, which corresponds to the position of the upper left corner of your layer in percentage of the display's dimensions. Thus, if you choose the point {0.5,0.5}, the upper left corner of your layer will be in the center of your display. By default, this value is {0,0} which corresponds to the top-left corner.\nThe size facet is used with a point type, between {0,0} and {1,1} also. It corresponds to the size occupied by the layer in percentage of the display's dimensions. By default, this value is {1,1} which represents 100% of the width and height available.\nexperiment expe type:gui {    output {\tdisplay my_display {\t    graphics \"layer1\" position:{0,0} size:{0.5,0.8} {\t\tdraw shape color:#darkorange;\t    }\t    graphics \"layer2\" position:{0.3,0.1} size:{0.6,0.2} {\t\tdraw shape color:#cornflowerblue;\t    }\t    graphics \"layer3\" position:{0.4,0.2} size:{0.3,0.8} {\t        draw shape color:#gold;\t    }\t}    }}\n\nNB: displays can have a background, while graphics can't. If you want to put a background for your graphics, a solution can be to draw the shape of the world (which is, by default, a square 100m*100m).\nA lot of other facets are available for the various layers. Please read the documentation of graphics for more information.\nExample of layers​\nspecies layer​\nspecies allows the modeler to display all the agents of a given species in the current display. In particular, the modeler can choose the aspect used to display them.\nPlease read the documentation about species statement if you are interested.\ngrid layer​\nSimilarly to species, grid allows the modeler to display all the agents of a given species in the current display, but only in the case where the species is a grid. The lines color can be specified. The inner color of the cells is determined by the color built-in attribute of grid agents. This is an optimized way of displaying the grid agents (compared to the species layers).\nPlease read the documentation about grid agents if you are interested.\nagents layer​\nagents allows the modeler to display only the agents that fulfill a given condition.\nPlease read the documentation about agents statement if you are interested.\nimage layer​\nimage allows the modeler to display an image (e.g. as the background of a simulation).\nPlease read the documentation about image statement if you are interested.\ngraphics layer​\ngraphics allows the modeler to freely draw shapes/geometries/texts without having to define a species.\nPlease read the documentation about graphics statement if you are interested."},{"filePath":"https:--gama-platform.org--wiki-DefiningExportFiles.txt","text":"Defining export filesThe Save Statement​\nAllows to save data in a file. The type of file can be \"shp\", \"json\" and \"kml\" for vector spatial data (agents and geometries), \"asc\" and \"geotiff\" for raster spatial data (grid), \"image\" for image, \"dimacs\", \"dot\", \"gexf\", \"graphml\", \"gml\" and \"graph6\" for graphs, \"text\" and \"csv\". The save statement can be use in an init block, a reflex, an action or in a user command.\nFacets​\n\nattributes, optional, expects any type in [map, list] - Allows to specify the attributes of a shape file or GeoJson file where agents are saved. Can be expressed as a list of string or as a literal map. When expressed as a list, each value should represent the name of an attribute of the shape or agent. The keys of the map are the names of the attributes that will be present in the file, the values are whatever expressions needed to define their value.\ncrs, optional, expects any type - the name of the projection, e.g. crs:\"EPSG:4326\" or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id)\ndata, optional, expects any type - the data that will be saved to the file\nheader, optional, expects bool - an expression that evaluates to a boolean, specifying whether the save will write a header if the file does not exist\nrewrite, optional, expects bool - a boolean expression specifying whether to erase the file if it exists or append data at the end of it. Only applicable to \"text\" or \"csv\" files. Default is true\nto, optional, expects string - an expression that evaluates to an string, the path to the file, or directly to a file\nformat, optional, a string representing the format of the output file (e.g. shp, asc, geotiff, png, text, csv). If the file extension is non ambiguous in facet 'to:', this format does not need to be specified. However, in many cases, it can be useful to do it (for instance, when saving a string to a .pgw file, it is always better to clearly indicate that the expected format is 'text').\ntype, optional, deprecated, use format instead.\n\nUsages​\n\nIts simple syntax is:\n\nsave data to: output_file format: a_type_file;\n\nTo save data in a text file:\n\nsave (string(cycle) + \"->\"  + name + \":\" + location) to: \"save_data.txt\" format: text;\n\nTo save the values of some attributes of the current agent in csv file:\n\nsave [name, location, host] to: \"save_data.csv\" format: csv;\n\nTo save the geometries of all the agents of a species into a shapefile or a geojson (with optional attributes):\n\nsave species_of(self) to: \"save_shapefile.shp\" format: shp attributes: [name::\"nameAgent\", location::\"locationAgent\"] crs: \"EPSG:4326\";save species_of(self) to: \"save_shapefile.geojson\" format: json attributes: [name::\"nameAgent\", location::\"locationAgent\"] ;\n\nTo save a grid into a geotiff or a asc file (the value considered will be the \"grid_value\" attribute of the cell):\n\nsave cell to:\"../results/grid.tif\" format:geotiff;save cell to:\"../results/grid.asc\" format:asc;\n\nTo save a grid into an image file:\n\nsave cell to:\"../results/grid.png\" format:image;\ninfoRelative path are processed from the gaml file where the experiment is located.This might lead to some issues explained in #137 where relative path set in an imported file will be based on the model you are running and not the file you defined it.\nExport files in an experiment​\nWhen the modeler wants to save data at each simulation step, it is recommended to use the save statement either in the model itself or in a reflex of the experiment (the syntax and the use are similar in all the cases).\nThe use of save in experiment is mandatory when we want to save a value related to several simulations running in parallel (e.g. the average of a value over several simulations). It is in particular in batch experiments to save a value at the end of simulations.\nAutosave​\nImage files can be exported also through the autosave facet of the display, as explained in this previous part."},{"filePath":"https:--gama-platform.org--wiki-DefiningGUIExperiment.txt","text":"Defining GUI ExperimentWhen you execute your simulation, you will often need to display some information. For each simulation, you can define some inputs, outputs and behaviors:\n\nThe inputs will be composed of parameters manipulated by the user for each simulation.\nThe behaviors will be used to define behavior executed at each step of the experiment.\nThe outputs will be composed of displays, monitors and inspectors. They will be defined inside the scope output. The definition of their layout can also be set with the layout statement.\n\nA typical GUI experiment code follows this pattern:\nexperiment exp_name type: gui {    [input]    [behaviors]    output {        layout [layout_option]        [display statements]        [monitor statements]    }}\nTypes of experiments​\nYou can define fours types of experiments (through the facet type):\n\ngui experiments (the default type) are used to play an experiment and displays its outputs. It is also used when the user wants to interact with the simulation.\nbatch experiments are used to play an experiment several times (usually with other input values), used for model exploration. We will come back to this notion a bit further in the tutorial.\ntest experiments are used to write unit tests on a model (used to ensure its quality).\nmemorize experiments are GUI experiments in which the simulation state is kept in memory and the user can backtrack to any previous step.\n\nExperiment attributes​\nInside experiment scope, you can access to some built-in attributes which can be useful, such as minimum_cycle_duration, to force the duration of one cycle.\nexperiment my_experiment type: gui {    float minimum_cycle_duration <- 2.0#minute;}\nIn addition, the attribute simulations contain the list of all the simulation agents that are running in the current experiment. Whereas the attribute simulation represents a single simulation, the last element of the simulation list.\nExperiment facets​\nFinally, in the case of a GUI experiment, the facets autorun and benchmark can be used as follows:\nexperiment name type: gui autorun: true benchmark: true { }\nWhen autorun is set to true the launch of the experiment will be followed automatically by its run. When benchmark is set to true, GAMA records the number of invocations and running time of the statements and operators of the simulations launched in this experiment. The results are automatically saved in a csv file in a folder called 'benchmarks' when the experiment is closed.\nOther built-ins are available, to learn more about, go to the page experiment built-in.\nDefining displays layout​\nA layout can be added to output to specify the layout of the various displays defined below (e.g. #none, #split, #stack, #vertical or #horizontal). It will also define which elements of the interface are displayed: parameters, navigator, editors, consoles, toolbars, tray, or tabs facets (expecting a boolean value). You will find more detailed information in the statement's documentation\nDefining elements of the GUI experiment​\nIn this part, we will focus on the gui experiments. We will start with learning how to define input parameters, then we will study the outputs, such as displays, monitors and inspectors, and export files. We will finish this part with how to define user commands."},{"filePath":"https:--gama-platform.org--wiki-DefiningMonitorsAndInspectors.txt","text":"Defining monitors and inspectorsOther outputs can be very useful to study better the behavior of your agents.\nIndex​\n\nDefine a monitor\nDefine an inspector\n\nDefine a monitor​\nA monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its refresh facet).\nDefinition of a monitor:\nmonitor monitor_name value: an_expression refresh: boolean_statement;\nwith:\n\nvalue: mandatory, the expression whose value will be displayed by the monitor.\nrefresh: bool statement, optional: the new value is computed if the bool statement returns true.\n\nExample:\nexperiment my_experiment type: gui {    output {\tmonitor monitor_name value: cycle refresh: every(1#cycle);    }}\nNB: you can also declare monitors during the simulation, by clicking on the button \"Add new monitor\", and specifying the name of the variable you want to follow.\nDefine an inspector​\nDuring the simulation, the user interface of GAMA provides the user the possibility to inspect an agent, or a group of agents. But you can also define the inspector you want directly from your model, as an output of the experiment.\nUse the statement inspect to define your inspector, in the output scope of your GUI experiment. The inspector has to be named (using the facet name), a value has to be specified (with the value facet).\ninspect \"inspector_name\" value: the_value_you_want_to_display;\nNote that you can inspect any type of species (regular species, grid species, even the world...) or agent.\nThe optional facet type is used to specify the type of your inspector. 2 values are possible:\n\nagent (default value) if you want to display the information as a regular agent inspector. Note that if you want to inspect a large number of agents, this can take a lot of time. In this case, prefer the other type table\ntable if you want to display the information as an agent browser.\n\nThe optional facet attributes is used to filter the attributes you want to display in your inspector.\nBeware: only one agent inspector (type: agent) can be used for an experiment. Besides, you can add as many agent browsers (type: table) as you want for your experiment.\nExample of implementation:\nmodel newglobal {    init {\tcreate my_species number:3;    }}species my_species {    int int_attr <- 6;    string str_attr <- \"my_value\";    string str_attr_not_important <- \"blabla\";}grid my_grid_species width: 10 height: 10 {    int rnd_value <- rnd(5);}experiment my_experiment type:gui {    output {\tinspect \"my_species_inspector\" value: my_species attributes: [\"int_attr\",\"str_attr\"];\tinspect \"my_species_browser\" value: my_species type: table;\tinspect \"my_grid_species_browser\" value: 5 among my_grid_species type: table;    }}\nAnother statement, browse, is doing a similar thing, but prefer the table type (if you want to browse an agent species, the default type will be the table type)."},{"filePath":"https:--gama-platform.org--wiki-DefiningParameters.txt","text":"Defining ParametersWhen playing a simulation, you have the possibility to define input parameters, in order to change them and replay the simulation. Defining parameters allows to make the value of a global variable definable by the user through the user graphic interface.\nIndex​\n\nDefining parameters\nAdditional facets\n\nDefining parameters​\nYou can define parameters inside the global scope when defining your global variables with the facet parameter (this way of defining parameters is not the recommended one, as it makes the variable a parameter of all the experiments that will be defined and does not offer the possibility to redefine its initial and possible values in several ways in each experiment):\nglobal {    int my_integer_global_value <- 5 parameter: \"My integer global value\";}\nWhen launching your experiment, the parameter will appear in your \"Parameters\" panel, with the name you chose for the parameter facet.\n\nYou can also define your parameter inside the experiment (recommended), using the statement parameter. You have to specify first the name of your parameter, then the name of the global variable through the facet var.\nglobal {    int my_integer_global_value <- 5;}experiment MyExperiment type: gui {    parameter \"My integer global value\" var:my_integer_global_value;}\nNB: This variable has to be initialized with a value. If you do not want to initialize your value in the global block, you can initialize the value directly in the parameter statement, using the facet init or <-.\nglobal {    int my_integer_global_value;}experiment MyExperiment type: gui {    parameter \"My integer global value\" var: my_integer_global_value init: 5;}\nAdditional facets​\nYou can use some facets to arrange your parameters. For example, you can categorize your parameters under a label, using the facet category:\nglobal {    int attr_1 <- 5 ;    int attr_2 <- 5 ;    int attr_3 <- 5 ;}experiment MyExperiment type: gui {    parameter \"attr 1\" category: \"Category 1\" var: attr_1 <- 5;    parameter \"attr 2\" category: \"Category 1\" var: attr_2 <- 5;    parameter \"attr 3\" category: \"Category 2\" var: attr_3 init: 5;}\n\nYou also can add some facets such as min, max, step or among to improve the declaration of the parameter (and define the possible values the parameter can take).\nglobal {    string fruit <- \"none\" ;    string vegetable <- \"none\";    int integer_variable <- 5;}experiment MyExperiment type: gui {    parameter \"fruit\" category:\"food\" var: fruit <- \"none\" among:[\"none\",\"apple\",\"banana\"] ;    parameter \"vegetable\" category:\"food\" var: vegetable <- \"none\" among:[\"none\",\"cabbage\",\"carrot\"];    parameter \"integer variable\" category:\"other\"var: integer_variable <- 5 min:0 max:100 step:5;}\nWe can notice that the parameters will not appear graphically in the same way if they are defined with a set of possible values (with among) or with a range of possible values (defined by a min, max and a step).\nThe definition of the initial value and of the possible values can be set in the global or in the experiment depending on the aim of this limitation: for example if a variable has a maximum value set to 1 in the global, this limitation can be used in the model in order that the variable value does not exceed this value. If the maximum boundary is set in the experiment, some executions of the model can be done without it...\n"},{"filePath":"https:--gama-platform.org--wiki-DefiningUserInteraction.txt","text":"Defining user interactionDuring the simulation, GAML provides you the possibility to define some function the user can execute during the execution. In this chapter, we will see how to define buttons to execute action during the simulation, how to catch click event, and how to use the user control architecture.\nIndex​\n\nCatch Mouse Event\nDefine User command\n\n... in the GUI Experiment scope\n... in global or regular species\nuser_location\nuser_input\n\n\nUser Control Architecture\n\nCatch Mouse Event​\nYou can catch mouse event during the simulation using the statement event. This statement has 2 required facets:\n\nname (identifier) : Specify which event do you want to trigger (among the following values : mouse_down, mouse_up, mouse_move, mouse_enter, mouse_exit or any alphanumeric symbol/key of the keyboard, such as, 'a', 'b'...).\naction (identifier) : Specify the name of the global action to call.\n\nevent mouse_down action: my_action;\nThe event statement has to be defined in the experiment/output/display scope. Once the event is triggered, the global action linked will be called. The action linked cannot have arguments. To get the location of the mouse click, the #user_location can be used; to get the agents on which the mouse has clicked, you can use spatial query (e.g. my_species overlapping #user_location).\nglobal{\taction my_action\t{\t\twrite \"do action\";\t}}species my_species{}experiment my_experiment type: gui{\toutput\t{\t\tdisplay my_display\t\t{\t\t\tspecies my_species;\t\t\tevent mouse_down action: my_action;\t\t}\t}}\nDefine User command​\nAnywhere in the global block, in a species or in an (GUI) experiment, user_command statements can be implemented. They can either call directly an existing action (with or without arguments) or be followed by a block that describes what to do when this command is run.\nTheir syntax can be (depending of the modeler needs) either:\nuser_command cmd_name action: action_without_arg_name;//oruser_command cmd_name action: action_name with: [arg1::val1, arg2::val2];//oruser_command cmd_name {   // statements}\nFor instance:\nuser_command kill_myself action: die;//oruser_command kill_myself action: some_action with: [arg1::5, arg2::3];//oruser_command kill_myself {    do die;}\nDefining User command in GUI Experiment scope​\nThe user command can be defined directly inside the GUI experiment scope. In that case, the implemented action appears as a button in the top of the parameter view.\nHere is a very short code example :\nmodel quick_user_command_modelglobal {\taction createAgent\t{\t\tcreate my_species;\t}}species my_species {\taspect base {\t\tdraw circle(1) color:#blue;\t}}experiment expe type:gui {\tuser_command cmd_inside_experiment action:createAgent;\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t}\t}}\nAnd here is screenshots of the execution :\n\nDefining User command in a global or regular species​\nThe user command can also be defined inside a species scope (either global or regular one). Here is a quick example of model :\nmodel quick_user_command_modelglobal {\tinit {\t\tcreate my_species number:10;\t}}species my_species {\tuser_command cmd_inside_experiment action:die;\taspect base {\t\tdraw circle(1) color:#blue;\t}}experiment expe type:gui {\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t}\t}}\nDuring the execution, you have 2 ways to access to the action:\n\nWhen the agent is inspected, they appear as buttons above the agents' attributes\n\n\n\nWhen the agent is selected by a right-click in a display, these commands appear under the usual \"Inspect\", \"Focus\" and \"Highlight\" commands in the pop-up menu.\n\n\nRemark: The execution of a command obeys the following rules:\n\nwhen the command is called from right-click pop-menu, it is executed immediately\nwhen the command is called from panels, its execution is postponed until the end of the current step and then executed at that time.\n\nuser_location​\nIn the special case when the user_command is called from the pop-up menu (from a right-click on an agent in a display), the location chosen by the user (translated into the model coordinates) is passed to the execution scope under the name user_location.\nExample:\nglobal {   user_command \"Create agents here\" {      create my_species number: 10 with: [location::user_location];   }}\nThis will allow the user to click on a display, choose the world (always present now), and select the menu item \"Create agents here\".\nNote that if the world is inspected (this user_command appears thus as a button) and the user chooses to push the button, the agent will be created at a random location.\nuser_input​\nAs it is also, sometimes, necessary to ask the user for some values (not defined as parameters), the user_input unary operator has been introduced. This operator takes a map [string::value] as argument (the key is the name of the chosen parameter, the value is the default value), displays a dialog asking the user for these values, and returns the same map with the modified values (if any). You can also add a text as first argument of the operator, which will be displayed as a title for your dialog popup. The dialog is modal and will interrupt the execution of the simulation until the user has either dismissed or accepted it. It can be used, for instance, in an init section like the following one to force the user to input new values instead of relying on the initial values of parameters.\nHere is an example of implementation:\nmodel quick_user_command_modelglobal {   init {      map values <- user_input(\"Choose a number of agent to create\",[\"Number\" :: 100]);      create my_species number: int(values at \"Number\");   }}species my_species {\taspect base {\t\tdraw circle(1) color:#blue;\t}}experiment expe type:gui {\toutput {\t\tdisplay my_display {\t\t\tspecies my_species aspect:base;\t\t}\t}}\nWhen running this model, you will first have to input a number:\n\nUser Control Architecture​\nThe other way to define user interaction is to use user control architecture. Please jump directly to the section user control architecture if you want to learn more about this point."},{"filePath":"https:--gama-platform.org--wiki-Developing-Plugins.txt","text":"Developing PluginsThis page details how to create a new plug-in in order to extend the GAML language with new skills, species, displays or operators.\nIt also details how to create a plug-in that can be  uploaded on an update site and can be installed into the GAMA release.\nWe consider here that the developer version of GAMA has been installed (as detailled in this page).\nI. Creation of a plug-in​\nHere are detailed steps to create and configure a new GAMA plug-in.\n\n\nFrom the Eclipse main menu tab, click on File, then New, then Project, then finally select plug-in project.\n\n\n\nIn the \"New plug-in Project\" / \"Plug-in project\" window:\n\nChoose as name « name_of_the_plugin » (or anything else)*\nCheck \"Use defaut location\"\nCheck \"Create a Java Project\"\nThe project should be targeted to run with Eclipse\nworking set is unchecked\nClick on \"Next\"\n\n\n\n\nIn the \"New plug-in Project\" / \"Content\" window:\n\nId : could contain the name of your institution and/or your project, e.g. « irit.maelia.gaml.additions »\nversion 1.0.0.qualifier (this latter mention is important if you plan on distributing the plugin on GAMA update site)\nName «This is my First Plugin.»\nUncheck \"Generate an activator, a Java class that controls the plug-in's life cycle\" ,\nUncheck \"This plug-in will make contributions to the UI\"\nCheck \"No\" when it asks \"Would you like to create a rich client application ?\"\nClick on \"Next\"\n\n\n\n\nIn the \"New plug-in Project\" / \"Templates\" window:\n\nUncheck \"Create a plug-in using one of the templates\"\nClick on \"Finish\"\n\n\n\nYour plug-in has been created.\n\n\n\nEdit the file \"Manifest.MF\":\n\nFrom the Project Explorer pane, expand your plugin folder.\nClick on the META-INF folder.\nClick on the MANIFEST.MF file.\n\n\n\n\nClick on the Overview tab to open the Overview pane:\n\n\nOn the Overview pane, check as shown « This plug-in is a singleton »\n\n\nDependencies pane:\n\nClick on the Dependencies tab to open the Dependencies Pane.\n\n\n\nadd (at least minimum) the two plug-ins \"msi.gama.core\" and \"msi.gama.ext\" in the \"Required Plug-ins\". When you click on \"Add\", a new window will appear without any plug-in. Just write the beginning of the plug-in name in the text field under \"Select a plug-in\"\n\n\n\n\nClick on the Runtime tab to open the Runtime pane:\n\n\nIn exported Packages: nothing (but when you will have implemented new packages in the plug-in you should add them there)\nAdd in the classpath all the additional libraries (.jar files) used in the project.\n\n\n\nClick on the Extension tab to open the Extensions pane:\n\nClick the Add button and add \"gaml.extension\"\n\n\n\n\n\n\nOn the main menu, click on File, then select, Save, to save the file. This should create a \"plugin.xml\" file.\n\n\n\n\n\nIn the Project Explorer pane, Select the plugin, right_click, and in the dropdown menu select Properties:\n\n\nThe Properties for myFIrstPlugin dialog opens as shown.\n\n\n\nIn the Properties dialog .. Go to Java Compiler, then Annotation Processing: check \"Enable project specific settings\", then in \"Generated Source Directory\", change \".apt_generated\" to \"gaml\",\n\n\n\nGo again to Java Compiler, then Annotation Processing, then Factory path: check \"Enable project specific settings\", then \"Add Jars\" and choose \"msi.gama.processor/processor/plugins/msi.gama.processor.1.4.0.jar\"\n\n\n\nClose the menu. Click on Yes in the succeeding dialogs (Annotation settings changed ..). After, this should compile the project and create the gaml directory.\n\n\n\n\nReturn to the Properties dialog of your plugin by clicking from the main menu bar, Project, then click on Properties. Go to Java Build Path, click on the Source Tab, and check that the gaml directory has been added.\n\n\n\nIf the gaml folder is not present, click on Add Folder and select the gaml directory. Right click on the project, then refresh it (F5 or from the File menu -> Refresh)\n\n\n\n\nNow, there should be a gaml directory. This gaml directory will later contain the package containing GamlAdditions.java, and other related files created after creating classes. If there is no package in the folder, try creating a class, then try to refresh or close the project and reopen it, or clean the projects by going into Project tabs, and clicking on clean.\n\nThe plug-in is ready to accept any addition to the GAML language, e.g. skills, actions, operators. To proceed to creating a skill click on this link.\nDo not forget to export the created packages that could be used by \"clients\", especially the packages containing the code of the additions (in the plugin.xml of the new project, tab \"Runtime\").\nTo test the plug-in and use it into GAMA, developers have to define a new feature project containing your plugin and its dependencies, and adds this feature to the existing product (or a new .product file of your own).\nThe use of feature is also mandatory to define a plug-in that can be uploaded on the update site and can be installed in the release of GAMA.\nCreation of a feature​\nA feature is an Eclipse project dedicated to gather one or several plug-ins to integrate them into a product or to deploy them on the update site and install them from the GAMA release (a feature is mandatory in this case).\nHere are detailled steps to create and configure a new feature.\n\nFile > New > Feature project (or File > New > Project... then  Plug-in Development > Feature Project)\nIn Feature properties\n\nChoose a project name (e.g. \"institution.gama.feature.pluginsName\")\nClick on \"Next\"\n\n\nIn Referenced Plug-ins and fragments\n\nCheck \"Initialize from the plug-ins list:\"\nChoose the plug-ins that have to be gathered in the feature\nClick on \"Finish\"\n\n\nA new project has been created. The \"feature.xml\" file will configure the feature.\n\nIn \"Information pane\":\n\nYou can add description of the various plug-ins of the feature, define the copyright notice and the licence.\n\n\nIn \"Plug-ins and Fragments\"\n\nIn the Plug-ins and Fragments, additional plug-ins can be added.\n\n\n\n\n\nAddition of a feature to the product​\nTo load the plugin into GAMA, go into the project ummisco.gama.product and open gama.product and go into the overview tab, under the section Testing, click Synchronize, go into the contents tab, click on Add, and add the features related to your plugin. Click the Run tab in the main menu bar, click on Run Configuration, then you should have the gama runtime product window open, click on the plugins tab, and check your plugin in the list. Click on Apply. Now your plugin is accessible in GAMA, now we can run the application. Click on Run.\nRemark: To check whether the new plug-in has been taken into account by GAMA, after GAMA launch, it should appear in the Eclipse console in a line beginning by \">> GAMA bundle loaded in \".\nIf you plan to deploy your plugin to be used by other users from the GAMA community, proceed with the succeeding steps. If not, we can proceed with the creation of skills and types.\nIn the product, e.g. gama.product in the ummisco.gama.product project:\n\nContents pane\n\nClick on Add button\nIn the window select the feature\nClick on OK.\n\n\n\nCreate examples model​\nIn order to make your plugin usable by everyone, it is very important to bring potential users model examples to introduce new gaml primitives, statements and operators. This way, modelers can easily get into the plugin you developed in a practical way.\nThe process is twofold:\n\nMount your plugin into your GAMA (see below or use the Git version)\nCreate a new project in the user model folder. Put your GAMA model examples there.\nMove your project into a folder called \"models\" at the root of the plugin\n\nHence this is done, you can update your Plugin models library folder and have access to the plugin models\nHow to make a plug-in available at GAMA update site for the GAMA release​\nConsidering a working GAMA plugin named institution.gama.pluginsName\nConfigure plugin to be available for Maven​\na/ Add pom.xml for plugin institution.gama.pluginsName:\n\nRight click -> Configure -> Convert to maven project to add pom.xml:\nSet:\n\nGroup id: institution.gama.pluginsName\nArtifact id: institution.gama.pluginsName\nVersion: 1.0.0-SNAPSHOT // must have -SNAPSHOT if the plugin version is x.x.x.qualifier\nPackaging: eclipse-plugin  // this element is not in the list (jar/pom/war) because of the incompatible of tycho, maven and eclipse, so just type it in although it will be a warning\n\n\nFinish\n\nb/ Configure pom.xml to recognize the parent pom.xml for Maven builds\n\nOpen pom.xml in institution.gama.pluginsName\nTab overview, Parent section, type in:\n\nGroup id: msi.gama\nArtifact id: msi.gama.experimental.parent\nVersion: 1.7.0-SNAPSHOT\nRelative path: ../msi.gama.experimental.parent\n\n\nSave\n\nc/ Update maven cache in eclipse (optional)\nIt will fix this compilation error \"Project configuration is not up-to-date with pom.xml. Select: Maven->Update Project... from the project context menu or use Quick Fix.\"\n\nRight click -> Maven -> Update project\n\nCreate a feature for the plugin​\na/ Create new feature\n\nNew -> Project -> type in : feature -> Select \"Feature Project\"\nSet:\n\nProject name: institution.gama.feature.pluginsName\nUncheck use default location, type in: {current git repository}\\aaa.bbb.feature.ccc\nFeature Version: 1.0.0.qualifier\nUpdate Site URL: http://updates.gama-platform.org/experimental\nUpdate Site Name: GAMA 1.7.x Experimental Plugins Update Site\n\n\nClick Next\n\nInitialize from the plugin list -> check all plugins needed:\ninstitution.gama.pluginsName (1.0.0.qualifier)\n\n\nFinish\n\nb/  Add pom.xml for feature institution.gama.feature.pluginsName:\n\nRight click -> Configure -> Convert to maven project (to add pom.xml)\nSet:\n\nGroup id: institution.gama.feature.pluginsName\nArtifact id: institution.gama.feature.pluginsName\nVersion: 1.0.0-SNAPSHOT\nPackaging: eclipse-feature\n\n\nFinish\n\nc/ Configure pom.xml to recognize the parent pom.xml for Maven builds\n\nOpen pom.xml in institution.gama.pluginsName\nTab overview, Parent section, type in:\n\nGroup id: msi.gama\nArtifact id: msi.gama.experimental.parent\nVersion: 1.7.0-SNAPSHOT\nRelative path: ../msi.gama.experimental.parent\n\n\nSave\n\nd/ Update maven cache in eclipse (optional)\nIt will fix this compilation error \"Project configuration is not up-to-date with pom.xml. Select: Maven->Update Project... from the project context menu or use Quick Fix.\"\n\nRight click -> Maven -> Update project\n\nUpdate p2updatesite category.xml (this step will be done automatically by travis, soon)​\nOpen msi.gama.experimental.p2updatesite\n\nTab Managing the Categories -> Add feature -> institution.gama.feature.pluginsName\n\nHow to make a plug-in available as an extension for the GAMA release (obsolete)​\nOnce the plug-in has been tested in the GAMA SVN version, it can be made available for GAMA release users.\nFirst, the update_site should be checked out from the SVN repository:\n\nFile > New > Other... > SVN > Project from SVN\nIn Checkout Project from SVN repository\n\nUse existing repository location (it is the same location as for the GAMA code)\nNext\n\n\nIn Select resource:\n\nBrowse\n\nchoose svn > update_site\n\n\nFinish\n\n\nFinish\n\nNow the update_site project is available in the project list (in Package Explorer).\nThe sequel describes how to add a new feature to the update site.\n\nOpen the site.xml file\nIn update site Map:\n\nClick on Extensions\nclick on the Add Feature... button\n\nChoose the feature to be added\nIt should appear in Extensions\n\n\nSelect the added feature and click on the Synchronize... button\n\nCheck Synchronize selected features only\nFinish\n\n\nSelect the added feature and click on the Build button\n\n\nAll the files and folder of the update_site project have been modified.\nCommit all the modifications on the SVN repository\n\nRicht-click on the project, Team > Update\nRicht-click on the project, Team > Commit...\n\n\n\nThe plug-in is now available as an extension from the GAMA release.\nMore details about the update of the GAMA release are available on the dedicated page."},{"filePath":"https:--gama-platform.org--wiki-DevelopingControlArchitectures.txt","text":"Developing architectureIn addition to existing control architectures, developers can add new ones.\nDefining a new control architecture needs to create new statements of type behavior and included in species statements and to define how to manage their execution.\nImplementation​\nA control architecture is a Java class, that:\n\nis annotated by the @skill annotation,\nextends the AbstractArchitecture class (to get benefits of everything from the reflex-based control architecture, the ReflexArchitecture class can be extended instead).\n\nThe AbstractArchitecture extends the ISkill and IStatement interfaces and add the 2 following methods:\n\npublic abstract boolean init(IScope scope) throws GamaRuntimeException;\npublic abstract void verifyBehaviors(ISpecies context);\n\nThe three main methods to implement are thus:\n\npublic void setChildren(final List<? extends ISymbol> children): this method will be called at the compilation of the model. It allows to manage all the embeded statements (in children) and for example separate the statements that should be executed at the initialization only from the ones that should be executed at each simulation step. Following example allows to test the name of the all the embedded statements:\n\nfor ( final ISymbol c : children ) {   if( IKeyword.INIT.equals(c.getFacet(IKeyword.KEYWORD).literalValue()) ) {\n\npublic abstract boolean init(IScope scope) throws GamaRuntimeException: this method is called only once, at the initialization of the agent.\npublic Object executeOn(final IScope scope) throws GamaRuntimeException: this method is executed at each simulation step. It should manage the execution of the various embedded behaviors (e.g. their order or choose which one will be executed...).\n"},{"filePath":"https:--gama-platform.org--wiki-DevelopingExtensions.txt","text":"Developing ExtensionsGAMA accepts extensions to the GAML language, defined by external programmers and dynamically loaded by the platform each time it is run. Extensions can represent new built-in species, types, file-types, skills, operators, statements, new control architectures or even types of displays. Other internal structures of GAML will be progressively \"opened\" to this mechanism in the future: display layers (hardwired for the moment), new types of outputs (hardwired for the moment), scheduling policies (hardwired for the moment), random number generators (hardwired for the moment).\nThe extension mechanism relies on two complementary techniques:\n\nthe first one consists in defining the GAML extensions in a plug-in (in the OSGI sense, see here) that will be loaded by GAMA at runtime and must \"declare\" that it is contributing to the platform.\nthe second one is to indicate to GAMA where to look for extensions, using Java annotations that are gathered at compile time (some being also used at runtime) and directly compiled into GAML structures.\n\nThe following sections describe this extension process.\n\n\n\nDeveloping Plugins\n\n\n\n\nDeveloping Skills\n\n\n\n\nDeveloping Statements\n\n\n\n\nDeveloping Operators\n\n\n\n\nDeveloping Types\n\n\n\n\nDeveloping Species\n\n\n\n\nDeveloping Control Architectures\n\n\n\n\nIScope\n\n\n\n\nIndex of annotations\n\n\n"},{"filePath":"https:--gama-platform.org--wiki-DevelopingIScope.txt","text":"IScope interfaceAn object of type IScope represents the context of execution of an agent (including experiments, simulations, and \"regular\" agents). Everywhere it is accessible (either passed as a parameter or available as an instance variable in some objects), it provides an easy access to a number of features: the current active agent, the shared random number generator, the global clock, the current simulation and experiment agents, the local variables declared in the current block, etc.\nIt also allows modifying this context, like changing values of local variables, adding new variables, although these functions should be reserved to very specific usages. Ordinarily, the scope is simply passed to core methods that allow to evaluate expressions, cast values, and so on.\nUse of an IScope​\nA variable scope of type IScope can be used to:\n\nget the current agent with: scope.getAgentScope()\n\nIAgent agent = scope.getAgentScope();\n\nevaluate an expression in the current scope:\n\nString mes = Cast.asString(scope, message.value(scope));\n\nknow whether the scope has been interrupted:\n\nboolean b = scope.interrupted();"},{"filePath":"https:--gama-platform.org--wiki-DevelopingIndexAnnotations.txt","text":"Index of annotationsAnnotations are used to link Java methods and classes to GAML language.\n@action​\nThis annotation is used to tag a method that will be considered as an action (or primitive) in GAML.\nThe method must have the following signature: Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface).\nThis annotation contains:\n\nname (String): the name of the variable as it can be used in GAML.\nvirtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.\nargs (set of @arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.\ndoc (set of @doc, empty by default): the documentation associated to the action.\n\n@arg​\nThis annotation describes an argument passed to an action.\nThis annotation contains:\n\nname (String, \"\" by default): the name of the argument as it can be used in GAML.\ntype (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).\noptional (boolean, true by default): whether this argument is optional or not.\ndoc (set of @doc, empty by default): the documentation associated to the argument.\n\n@constant​\nThis annotation is used to annotate fields that are used as constants in GAML.\nThis annotation contains:\n\ncategory (set of Strings, empty by default): an array of strings, each representing a category in which this constant can be classified (for documentation indexes).\nvalue (String): a string representing the basic keyword for the constant. Does not need to be unique throughout GAML.\naltNames (set of Strings, empty by default): an Array of strings, each representing a possible alternative name for the constant. Does not need to be unique throughout GAML.\ndoc (set of @doc, empty by default): the documentation attached to this constant.\n\n@doc​\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\nThis annotation contains:\n\nvalue (String, \"\" by default): a String representing the documentation of a GAML element.\nmasterDoc (boolean, false by default): a boolean representing the fact that this instance of the operator is the master one, that is whether its value will subsume the value of all other instances of it.\ndeprecated (String, \"\" by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.\nreturns (String, \"\" by default): the documentation concerning the value(s) returned by this element (if any)..\ncomment (String, \"\" by default): an optional comment that will appear differently from the documentation itself.\nspecial_cases (set of Strings, empty by default): an array of String representing the documentation of the \"special cases\" in which the documented element takes part.\nexamples (set of @example, empty by default): an array of String representing some examples or use-cases about how to use this element.\nusages (set of @usage, empty by default): An array of usages representing possible usage of the element in GAML.\nsee (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.\n\n@example​\nThis facet describes an example, that can be used either in the documentation, as unit test or as pattern.\nThis annotation contains:\n\nvalue (String, \"\" by default): a String representing the expression as example.\nvar (String, \"\" by default): The variable that will be tested in the equals, if it is omitted a default variable will be used.\nequals (String, \"\" by default): The value to which the value will be compared.\nreturnType (String, \"\" by default): The type of the value that should be tested.\nisNot (String, \"\" by default): The value to which the value will be compared.\nraises (String, \"\" by default): The exception or warning that the expression could raise.\nisTestOnly (boolean, false by default): specifies that the example should not be included in the documentation.\nisExecutable (boolean, true by default): specifies that the example is correct GAML code that can be executed.\ntest (boolean, true by default): specifies that the example is will be tested with the equals.\nisPattern (boolean, false by default): whether or not this example should be treated as part of a pattern (see @usage). If true, the developers might want to consider writing the example line (and its associated lines) using template variables (e.g. ${my_agent}).\n\n@facet​\nThis facet describes a facet in a list of facets.\nThis annotation contains:\n\nname (String): the name of the facet. Must be unique within a symbol.\ntype (set of int): the string values of the different types that can be taken by this facet.\nvalues (set of Strings, empty by default): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.\noptional (boolean, false by default): whether or not this facet is optional or mandatory.\ndoc (set of @doc, empty by default): the documentation associated to the facet.\n\n@facets​\nThis annotation describes a list of facets used by a statement in GAML.\nThis annotation contains:\n\nvalue (set of @facet): array of @facet, each representing a facet name, type..\nommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement).\n\n@file​\nThis annotation is used to define a type of file.\nThis annotation contains:\n\nname (String): a (human-understandable) string describing this type of files, suitable for use in composed operator names (e.g. \"shape\", \"image\"...). This name will be used to generate two operators: name+\"file\" and \"is\"+name. The first operator may have variants taking one or several arguments, depending on the @builder annotations present on the class.\nextensions (set of Strings): an array of extensions (without the '.' delimiter) or an empty array if no specific extensions are associated to this type of files (e.g. [\"png\",\"jpg\",\"jpeg\"...]). The list of file extensions allowed for this type of file. These extensions will be used to check the validity of the file path, but also to generate the correct type of file when a path is passed to the generic \"file\" operator.\nbuffer_content (int, ITypeProvider.NONE by default): the type of the content of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).\nbuffer_index (int, ITypeProvider.NONE by default): the type of the index of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).\nbuffer_type (int, ITypeProvider.NONE by default): the type of the buffer. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider).\ndoc (set of @doc, empty by default): the documentation attached to this operator.\n\n@getter​\nThis annotation is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).\nThis annotation contains:\n\nvalue (String): the name of the variable for which the annotated method is to be considered as a getter.\ninitializer (boolean, false by default): returns whether or not this getter should also be used as an initializer\n\n@inside​\nThis annotation is used in conjunction with @symbol. It provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.\nThis annotation contains:\n\nsymbols (set of Strings, empty by default): symbol names of the parents.\nkinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details).\n\n@operator​\nThis annotation represents an \"operator\" in GAML and is used to define its name(s) as well as some meta-data that will be used during the validation process.\nThis annotation contains:\n\nvalue (set of Strings, empty by default): names of the operator.\ncategory (set of string, empty by default): categories to which the operator belongs (for documentation purpose).\niterator (boolean, false by default): true if this operator should be treated as an iterator (i.e.requires initializing the special variable \"each\" of WorldSkill within the method).\ncan_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.\ncontent_type (int, ITypeProvider.NONE by default): the type of the content if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the content type is searched using this provider).\nindex_type (int, ITypeProvider.NONE by default): the type of the index if the returned value is a container. Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the index type is searched using this provider).\nexpected_content_type (set of int, empty by default): if the argument is a container, returns the types expected for its contents. Should be an array of IType.XXX.\ntype (int, ITypeProvider.NONE by default): the type of the expression if it cannot be determined at compile time (i.e. when the return type is \"Object\"). Can be directly a type in IType or one of the constants declared in ITypeProvider (in which case, the type is searched using this provider)..\ninternal (boolean, false by default): returns whether this operator is for internal use only.\ndoc (set of @doc, empty by default): the documentation attached to this operator.\n\n@serializer​\nIt allows to declare a custom serializer for Symbols (statements, var declarations, species, experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be subclasses of the SymbolSerializer class.\n\nvalue (Class): the serializer class.\n\n@setter​\nThis annotation is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).\nThis annotation contains:\n\nvalue (String): the name of the variable for which the annotated method is to be considered as a setter.\n\n@skill​\nThis annotation allows to define a new skill (class grouping variables and actions that can be used by agents).\nThis annotation contains:\n\nname (String): a String representing the skill name in GAML (must be unique throughout GAML).\nattach_to (set of strings): an array of species names to which the skill will be automatically added (complements the \"skills\" parameter of species).\ninternal (boolean, false by default): return whether this skill is for internal use only.\ndoc (set of @doc, empty by default): the documentation associated to the skill.\n\n@species​\nThis annotation represents a \"species\" in GAML. The class annotated with this annotation will be the support of a species of agents.\nThis annotation contains:\n\nname (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.\nskills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example:  @species(value=\"animal\" skills={\"moving\"})\ninternal (boolean, false by default): whether this species is for internal use only.\ndoc (set of @doc, empty by default): the documentation attached to this operator.\n\n@symbol​\nThis annotation represents a \"statement\" in GAML and is used to define its name(s) as well as some meta-data that will be used during the validation process.\nThis annotation contains:\n\nname (set of string, empty by default): names of the statement.\nkind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).\nwith_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.\nwith_sequence (boolean): indicates whether or not a sequence can or should follow the symbol denoted by this class.\nwith_args (boolean, false by default): indicates whether or not the symbol denoted by this class will accept arguments.\nremote_context (boolean, false by default): indicates that the context of this statement is actually a hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.\ndoc (set of @doc, empty by default): the documentation attached to this symbol.\ninternal (boolean, false by default): returns whether this symbol is for internal use only.\nunique_in_context (boolean, false by default): Indicates that this statement must be unique in its super context (for example, only one return is allowed in the body of an action)..\nunique_name (boolean, false by default): Indicates that only one statement with the same name should be allowed in the same super context.\n\n@type​\nIt provides information necessary to the processor to identify a type.\nThis annotation contains:\n\nname (String, \"\" by default): a String representing the type name in GAML.\nid (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPES and IType.SPECIES_TYPES (exclusive) (cf. IType.java).\nwraps (tab of Class, null by default): the list of Java Classes this type is \"wrapping\" (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).\nkind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.\ninternal (boolean, false by default): whether this type is for internal use only.\ndoc (set of @doc, empty by default): the documentation associated to the facet.\n\n@usage​\nThis replaces @special_cases and @examples, and unifies the doc for operators, statements, and others.\nAn @usage can also be used for defining a template for a GAML structure, and in that case, requires the following to be defined:\n\nA name (attribute \"name\"), optional, but better\nA description (attribute \"value\"), optional\nA menu name (attribute \"menu\"), optional\nA hierarchical path within this menu (attribute \"path\"), optional\nA pattern (attribute \"pattern\" or concatenation of the @example present in \"examples\" that define \"isPattern\" as true)\n\nThis annotation contains:\n\nvalue (String): a String representing one usage of the keyword. Note that for usages aiming at defining templates, the description is displayed on a tooltip in the editor. The use of the path allows to remove unnecessary explanations. For instance, instead of writing: description=\"This template illustrates the use of a complex form of the \"create\" statement, which reads agents from a shape file and uses the tabular data of the file to initialize their attributes\", choose: name=\"Create agents from shapefile\" menu=STATEMENT; path={\"Create\", \"Complex forms\"} description=\"Read agents from a shape file and initialize their attributes\". If no description is provided, GAMA will try to grab it from the context where the template is defined (in the documentation, for example).\nmenu (String, \"\" by default): Define the top-level menu where this template should appear. Users are free to use other names than the provided constants if necessary (i.e. \"My templates\"). When no menu is defined, GAMA tries to guess it from the context where the template is defined.\npath (set of Strings, empty by default): The path indicates where to put this template in the menu. For instance, the following annotation: \" menu = STATEMENT; path = {\"Control\", \"If\"} will put the template in a menu called \"If\", within \"Control\", within the top menu \"Statement\". When no path is defined, GAMA will try to guess it from the context where the template is defined (i.e. keyword of the statement, etc.)\nname (String, \"\" by default): The name of the template should be both concise (as it will appear in a menu) and precise (to remove ambiguities between templates).\nexamples (set of @example, empty by default): An array of String representing some examples or use-cases about how to use this element, related to the particular usage above.\npattern (String, \"\" by default): Alternatively, the contents of the usage can be described using a @pattern (rather than an array of @example). The formatting of this string depends entirely on the user (e.g. including \\n and \\t for indentation, for instance).\n\n@validator​\nIt allows to declare a custom validator for Symbols (statements, var declarations, species, experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be a subclass of IDescriptionValidator.\n\nvalue (Class): the validator class.\n\n@variable​\nThis annotation is used to describe a single variable or field.\nThis annotation contains:\n\nname (String): the name of the variable as it can be used in GAML.\ntype (int): The textual representation of the type of the variable (see IType).\nof (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).\nindex (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).\nconstant (boolean, false by default): returns whether or not this variable should be considered as non modifiable.\ninit (String, \"\" by default): the initial value of this variable as a String that will be interpreted by GAML.\ndepend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).\ninternal (boolean, false by default): return whether this var is for internal use only.\ndoc (set of @doc, empty by default): the documentation associated to the variable.\n\n@vars​\nThis annotation is used to describe a set of variables or fields.\nThis annotation contains:\n\nvalue (set of @var): an Array of var instances, each representing a variable.\n"},{"filePath":"https:--gama-platform.org--wiki-DevelopingOperators.txt","text":"Developing OperatorsOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function. Developing a new operator allows, then, to add a new function to GAML.\nImplementation​\nA new operator can be any Java method that:\n\nbegins by the @operator (other fields can be added to the annotation): @operator(value = \"name_of_the_operator_gaml\"),\n\n@operator(value = \"rgb\")public static GamaColor rgb(final int r, final int g, final int b, final double alpha) {\t\nThe method:\n\nmust return a value (that has to be one of the GAMA Type: Integer, Double, Boolean, String, IShape, IList, IGraph, IAgent...),\ncan define any number of parameters, defined using Java type,\ncan be either static or non-static:\n\nin the case it is static, the number of parameters (except an IScope attribute) of the method is equal to the number of operands of the GAML operator.\nin the case it is not static, a first operand is added to the operator with the type of the current class.\n\n\ncan have a IScope parameter, that will be taken into account as operand of the operator.\n\nAnnotations​\n@operator​\nThis annotation represents an \"operator\" in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.\nThis annotation contains:\n\nvalue (set of string, empty by default): names of the operator.\ncontent_type (integer) : if the operator returns a container, type of elements contained in the container\ncan_be_const (boolean, false by default): if true: if the operands are constant, returns a constant value.\ncategory (set of string, empty by default): categories to which the operator belong (for documentation purpose).\ndoc (set of @doc, empty by default): the documentation attached to this operator.\n\n@doc​\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\n\nvalue (String, \"\" by default): a String representing the documentation of a GAML element.\ndeprecated (String, \"\" by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.\nreturns (String, \"\" by default): the documentation concerning the value(s) returned by this element (if any)..\ncomment (String, \"\" by default): an optional comment that will appear differently from the documentation itself.\nspecial_cases (set of Strings, empty by default): an array of String representing the documentation of the \"special cases\" in which the documented element takes part.\nexamples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.\nsee (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.\n\nAll these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in."},{"filePath":"https:--gama-platform.org--wiki-DevelopingSkills.txt","text":"Developing SkillsDefining the class as a skill​\nIn this section we will be creating a class \"FirstClass\", that is included in a package named \"skill\".\n\n\nCreate Package\n\nFrom the Project Explorer pane, go to your plugin's folder, and then go to the src folder.\n\n\n\nRight click on the src folder. Click on New > Package.\n\n\n\nIn the New Java Package dialog, set the Name to \"skills\".\n\n\n\nClick on Finish. This will create the package \"skills\".\n\n\n\n\nCreate class in the Package\n\nIn the Project Explorer, go to the folder of the Plugin. We create the Java class in this package. To do this, right click on the package, then click on New, select Class.\n\n\n\nOn the New Java class dialog, set the Name to 'FirstSkill'. Click on Finish.\n\n\n\nNow we have an empty Java class named FirstSkill. Note as well that the GamlAdditions.java file was also automatically added into the gaml/gaml.additions.myFirstPlugin folder.\n\n\n\n\nUsing Annotations to define class as a skill​\nAnnotations are used to link Java methods and classes to GAML language. Note that GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class.\nWe need to tell GAMA that our class \"FirstSkill\" will be used as skill. To do that we will use Annotation in writing the code of the class. The annotations for skill is described as follows:\n@skill​\nThis annotations Allows to define a new skill (class grouping variables and actions that can be used by agents).\nThis annotation contains:\n\n\nname (String): a String representing the skill name in GAML (must be unique throughout GAML).\n\n\nattach_to (set of strings): an array of species names to which the skill will be automatically added (complements the \"skills\" parameter of species).\n\n\ninternal (boolean, false by default): return whether this skill is for internal use only.\n\n\ndoc (set of @doc, empty by default): the documentation associated to the skill.\n\nJust before the class declaration, add this line to indicate that this class is a skill named \"FirstSkill\"\n\n\n\n@skill(name = \"FirstSkill\")\n\nIn line 3, a red broken line under the skill word can be seen. This is an error since at this point in the code. Hover your mouse over the error, and the message box would indicate that the skill cannot be resolved to a type.\n\nTo correct this error, we take the suggestion of importing 'skill' (msi.gama.precompiler.GamaAnnotations). Click on this option.\n\nIt is a good practice to define all the names of plugins/actions/variables in the IKeyword class, which is located in the plugin msi.gama.common.interfaces.IKeyword.java.\nIn this class you can define a string variable which contain the name of your plugin.\nString FIRST_SKILL = \"FirstSkill\";\nNow that we have defined a global string containing the name of the plugin, we can use it in the annotation and in the code of the class.\n@skill(name = IKeyword.FIRST_SKILL)\nWe have now defined that our current class is a skill that can be used in GAMA.\nTo use our plugin in gaml model, we have to create a species using the skill:\nspecies tutorialSpecies skills:[FirstSkill]{}\nDefining new attributes for the skill​\nNow we have a skill that is empty. So we need to add some variable for the plugin to have a purpose.\nTo add new attributes to the species that declares this skill, we have to define them before the class using annotation like we did before.\n@variable​\nThis annotations is used to describe a single variable or field.\nThis annotation contains:\n\nname (String): the name of the variable as it can be used in GAML.\ntype (int): The textual representation of the type of the variable (see IType).\nof (int, 0 by default): The textual representation of the content type of the variable (see IType#defaultContentType()).\nindex (int, 0 by default): The textual representation of the index type of the variable (see IType#defaultKeyType()).\nconstant (int, false by default): returns whether or not this variable should be considered as non modifiable.\ninit (String, \"\" by default): the initial value of this variable as a String that will be interpreted by GAML.\ndepend_on (set of Strings, empty by default): an array of String representing the names of the variables on which this variable depends (so that they are computed before).\ninternal (boolean, false by default): return whether this var is for internal use only.\ndoc (set of @doc, empty by default): the documentation associated to the variable.\n\nThe @vars annotation contains a set of @variable elements.\nJust like we did before with the declaration of the name of our skill, we can declare globally the name of our incomming new variables, in the IKeyword class.\nString FIRST_VARIABLE = \"FirstVariable\";\nString SECOND_VARIABLE = \"SecondVariable\";\nNow that we have defined the names of our variables, we need to declare them in our skill class.\nHere is how to declare the variables:\n@vars({  @variable(name = IKeyword.FIRST_VARIABLE, type = IType.INT, init = \"1\"),  @variable(name = IKeyword.SECOND_VARIABLE, type = IType.FLOAT, init = \"1.0\")})\nIn order to access these new attributes, in the GAMA application, you need to define @getter and  @setter methods:\n@getter​\nThis annotations is used to indicate that a method is to be used as a getter for a variable defined in the class. The variable must be defined on its own (in vars).\nThis annotation contains:\n\nvalue (String): the name of the variable for which the annotated method is to be considered as a getter.\ninitializer (boolean, false by default): returns whether or not this getter should also be used as an initializer\n\n@setter​\nThis annotations is used to indicate that a method is to be used as a setter for a variable defined in the class. The variable must be defined on its own (in vars).\nThis annotation contains:\n\nvalue (String): the name of the variable for which the annotated method is to be considered as a setter.\n\n@getter(IKeyword.FIRST_VARIABLE)public int getFirstVariable(final IAgent agent) {    return (int) agent.getAttribute(IKeyword.FIRST_VARIABLE);}@setter(IKeyword.FIRST_VARIABLE)public void setFirstVariable(final IAgent agent, final int value) {    agent.setAttribute(IKeyword.FIRST_VARIABLE, value);}@getter(IKeyword.SECOND_VARIABLE)public double getFirstVariable(final IAgent agent) {    return (double) agent.getAttribute(IKeyword.SECOND_VARIABLE);}@setter(IKeyword.SECOND_VARIABLE)public void setFirstVariable(final IAgent agent, final double value) {    agent.setAttribute(IKeyword.SECOND_VARIABLE, value);}\nAt this point we can use the variable defined directly in our agent :\nspecies tutorialSpecies skills:[FirstSkill]{\tinit\t{\t\twrite(firstVariable);\t\twrite(SecondVariable);\t}}\nDefining new actions​\nAn action (also called primitive) is basically a Java method that can be called from the GAML language using the same syntax as the one used for calling actions defined in a model. The method should be annotated with @action, supplying the name of the action as it will be available in GAML.\n@action​\nThis annotations is used to tag a method that will be considered as an action (or primitive) in GAML.\nThe method must have the following signature: Object methodName(IScope) throws GamaRuntimeException and be contained in a class annotated with @species or @skill (or a related class, like a subclass or an interface).\nThis annotation contains:\n\nname (String): the name of the variable as it can be used in GAML.\nvirtual (boolean, false by default): if true the action is virtual, i.e. equivalent to abstract method in java.\nargs (set of arg, empty by default): the list of arguments passed to this action. Each argument is an instance of arg.\ndoc (set of @doc, empty by default): the documentation associated to the action.\n\nWe can also define parameters for this action using the annotation @arg will a set of parameters names.\n@arg​\nThis annotations describes an argument passed to an action.\nThis annotation contains:\n\nname (String, \"\" by default): the name of the argument as it can be used in GAML.\ntype (set of ints, empty by default): An array containing the textual representation of the types that can be taken by the argument (see IType).\noptional (boolean, true by default): whether this argument is optional or not.\ndoc (set of @doc, empty by default): the documentation associated to the argument.\n\nHere is an example of an empty action for our skill (dont forget to define every keywords like IKeyword.NUMBER_TO_ADD in the IKeyword class):\n@action(name = \"add\", \t\targs = {\t\t\t@arg(name = IKeyword.NUMBER_TO_ADD, type = IType.INT, optional = false)})@doc(\"Function to add a number to FirstVariable\")public int add(final IScope scope){\treturn 0;}\nNow that we have defined the action we can access the parameter IKeyword.NUMBER_TO_ADD and use it as we want.\nAccess to parameters in actions​\nTo get the value of the arguments passed in GAML to the Java code, two methods can be useful:\n\nscope.hasArg(\"name_of_argument\") returns a boolean value testing whether the argument \"name_of_argument\" has been defined by the modeler, since all the arguments to actions should be considered as optional.\ngetArg(name_arg,IType), getFloatArg(name_param_of_float), getIntArg(name_param_of_int) and their variants return the value of the given parameter using a given (or predefined) type to cast it.\n\nWarnings​\nDevelopers should notice that:\n\nthe method should have only one parameter: the scope (type IScope).\nthe method can only throw GamaRuntimeExceptions. Other exceptions should be caught in the method and wrapped in a GamaRuntimeException before being thrown.\n\nHere is the complete action code :\n@action(name = \"add\", \t\targs = {\t\t\t@arg(name = IKeyword.NUMBER_TO_ADD, type = IType.INT, optional = false)})@doc(\"Function to add a number to FirstVariable\")public int add(final IScope scope){\tint firstVariable = getVariable(scope.getAgent());\tint numberToAdd = (Integer) scope.getArg(IKeyword.NUMBER_TO_ADD);\tsetVariable(scope.getAgent(), firstVariable + numberToAdd);\treturn firstVariable + numberToAdd;}\nIt is called in GAMA models with:\nspecies tutorialSpecies skills:[FirstSkill]{\tinit\t{\t\tdo add(5);\t\tint result <- add(10);\t\t\t\twrite(firstVariable);\t\twrite(secondVariable);\t}}\nFor our action we used the annotation @doc to give a description of what the purpose of the action.\n@doc​\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\n\nvalue (String, \"\" by default): a String representing the documentation of a GAML element.\ndeprecated (String, \"\" by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.\nreturns (String, \"\" by default): the documentation concerning the value(s) returned by this element (if any)..\ncomment (String, \"\" by default): an optional comment that will appear differently from the documentation itself.\nspecial_cases (set of Strings, empty by default): an array of String representing the documentation of the \"special cases\" in which the documented element takes part.\nexamples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.\nsee (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.\n\nAll these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in.\nComplete java class​\npackage skills;import msi.gama.common.interfaces.IKeyword;import msi.gama.metamodel.agent.IAgent;import msi.gama.precompiler.GamlAnnotations.action;import msi.gama.precompiler.GamlAnnotations.arg;import msi.gama.precompiler.GamlAnnotations.doc;import msi.gama.precompiler.GamlAnnotations.getter;import msi.gama.precompiler.GamlAnnotations.setter;import msi.gama.precompiler.GamlAnnotations.skill;import msi.gama.precompiler.GamlAnnotations.variable;import msi.gama.precompiler.GamlAnnotations.vars;import msi.gama.runtime.IScope;import msi.gaml.skills.Skill;import msi.gaml.types.IType;@vars({\t  @variable(name = IKeyword.FIRST_VARIABLE, type = IType.INT, init = \"1\"),\t  @variable(name = IKeyword.SECOND_VARIABLE, type = IType.FLOAT, init = \"1.0\")\t})@skill(name = \"FirstSkill\")public class FirstSkill extends Skill{\t\t@getter(IKeyword.FIRST_VARIABLE)\tpublic int getFirstVariable(final IAgent agent) {\t    return (Integer) agent.getAttribute(IKeyword.FIRST_VARIABLE);\t}\t@setter(IKeyword.FIRST_VARIABLE)\tpublic void setFirstVariable(final IAgent agent, final int value) {\t\tagent.setAttribute(IKeyword.FIRST_VARIABLE, value);\t}\t@getter(IKeyword.SECOND_VARIABLE)\tpublic double getSecondVariable(final IAgent agent) {\t    return (double) agent.getAttribute(IKeyword.SECOND_VARIABLE);\t}\t\t@setter(IKeyword.SECOND_VARIABLE)\tpublic void setSecondVariable(final IAgent agent, final double value) {\t    agent.setAttribute(IKeyword.SECOND_VARIABLE, value);\t}\t\t@action(name = \"add\", \t\t\targs = {\t\t\t\t\t@arg(name = IKeyword.NUMBER_TO_ADD, type = IType.INT, optional = false)})\t@doc(\"Function to add a number to FirstVariable\")\tpublic int add(final IScope scope)\t{\t\tint firstVariable = getFirstVariable(scope.getAgent());\t\tint numberToAdd = (Integer) scope.getArg(IKeyword.NUMBER_TO_ADD);\t\t\t\tsetFirstVariable(scope.getAgent(), firstVariable + numberToAdd);\t\t\t\treturn firstVariable + numberToAdd;\t}}\nComplete gaml model​\n/*** Name: FirstSkill* First skill tutorial. * Author: Lucas Grosjean, Julius Bangate* Tags: tutorial, skill*/model FirstSkillglobal{\tinit {\t\tcreate tutorial;\t}}species tutorial skills:[FirstSkill] {\tinit {\t\tdo add(5);\t\tint result <- add(10);\t\t\t\twrite(firstVariable);\t\twrite(secondVariable);\t}}experiment main{}"},{"filePath":"https:--gama-platform.org--wiki-DevelopingSpecies.txt","text":"Developing SpeciesAdditional built-in species can be defined in Java in order to be used in GAML models. Additional attributes and actions can be defined. It could be very useful in order to define its behavior thanks to external libraries (e.g. database connection...).\nA new built-in species extends the GamlAgent class, which defines the basic GAML agents. As a consequence, new built-in species have all the attributes (name, shape, ...) and actions (die...) of regular species.\nImplementation​\nA new species can be any Java class that:\n\nextends the GamlAgent class,\nbegins by the @species: @species(name = \"name_of_the_species_gaml\"),\n\n@species(name = \"multicriteria_analyzer\")public class MulticriteriaAnalyzer extends GamlAgent {\nSimilarly to skills, a species can define additional attributes and actions.\nAdditional attributes​\nDefining new attributes needs:\n\nto add @vars (and one embedded @variable per additional attribute) annotation on top of the class,\nto define @setter and @getter annotations to the accessors methods.\n\nFor example, regular species are defined with the following annotation:\n@vars({ @variable(name = IKeyword.NAME, type = IType.STRING), @variable(name = IKeyword.PEERS, type = IType.LIST),\t@variable(name = IKeyword.HOST, type = IType.AGENT),\t@variable(name = IKeyword.LOCATION, type = IType.POINT, depends_on = IKeyword.SHAPE),\t@variable(name = IKeyword.SHAPE, type = IType.GEOMETRY) })\nAnd accessors are defined using:\n@getter(IKeyword.NAME)public abstract String getName();@setter(IKeyword.NAME)public abstract void setName(String name);\nAdditional actions​\nAn additional action is a method annotated by the @action annotation.\n@action(name = ISpecies.stepActionName)public Object _step_(final IScope scope) {\nAnnotations​\n@species​\nThis annotation represents a \"species\" in GAML. The class annotated with this annotation will be the support of a species of agents.\nThis annotation contains:\n\nname (string): the name of the species that will be created with this class as base. Must be unique throughout GAML.\nskills (set of strings, empty by default): An array of skill names that will be automatically attached to this species. Example:  @species(value=\"animal\" skills={\"moving\"})\ninternal (boolean, false by default): whether this species is for internal use only.\ndoc (set of @doc, empty by default): the documentation attached to this operator.\n\nAll these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in."},{"filePath":"https:--gama-platform.org--wiki-DevelopingStatements.txt","text":"Developing StatementsStatements are a fundamental part of GAML, as they represent both commands (imperative programming style) or declarations (declarative programming style). Developing a new statement allows, then, to add a new instruction to GAML.\nStatements can be used in any context unlike action that need to be used from an agent context.\nDefining the class​\nA new statement must be a Java class that:\n\neither implements the interface IStatement or extends an existing implementation of this interface (like AbstractStatement or AbstractSequenceStatement).\nbegins by the 2 following mandatory annotations:\n\n@symbol: @symbol(name = \"name_of_the_statement_gaml\", kind = \"kind_of_statement\", with_sequence = true/false),\n@inside: @symbol(kinds = {\"kind_of_statement_1\",\"kind_of_statement_2\",\"...\"}\n\n\n\nIn addition the 4 following optional annotations can be added:\n\n@facets: to describe the set of @facet annotations,\n@doc: to document the statement.\n@serializer: in addition, statements can benefit from a custom serializer, by declaring @serializer(CustomSerializer.class), with a class extending SymbolSerializer.\n@validator: in addition, statements can benefit from a custom validation during the validation process, by declaring @validator(CustomValidator.class) with a class implementing IDescriptionValidator as value. This class will receive the IDescription of the statement and be able to execute further validations on the type of expressions, etc. or even to change the IDescription  (by adding new information, changing the value of facets, etc.).\n\nNote: GAMA annotations are classes defined into the msi.gama.precompiler.GamlAnnotations class.\nExamples​\nThe write statement​\nThe write statement is an example of a SINGLE_STATEMENT (i.e. statement that does not embed a sequence of statements).\nIt can used inside a BEHAVIOR statement (i.e. reflex, init...), a SEQUENCE_STATEMENT (e.g. loop, ask, if...) or a LAYER statement.\nIt defines a single facet (\"message\") mandatory and omissible.\n@symbol(name = IKeyword.WRITE, kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false)@inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT, ISymbolKind.LAYER })@facets(value = {         @facet(name = IKeyword.MESSAGE, type = IType.NONE, optional = false)    }, omissible = IKeyword.MESSAGE)public class WriteStatement extends AbstractStatement {\nThe aspect statement​\nThe aspect statement defines an example of BEHAVIOR statement (i.e. a statement that can written at the same level as init, reflex...), containing a sequence of embedded statements. It can only be used inside a species statement (i.e. the definition of a new species) and the global block. It defines a single facet name mandatory and omissible.\n@symbol(name = { IKeyword.ASPECT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true)@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.MODEL })@facets(value = { @facet(name = IKeyword.NAME, type = IType.ID, optional = true)    }, omissible = IKeyword.NAME)public class AspectStatement extends AbstractStatementSequence {\nThe action statement​\nThe action statement defines an example of ACTION statement containing a sequence of embedded statements and that can have arguments.\nIt can be used (to define an action) in any species, experiment or global statement. It defines several facets and uses a custom validator and a custom serializer.\n@symbol(name = IKeyword.ACTION, kind = ISymbolKind.ACTION, with_sequence = true, with_args = true, unique_name = true)@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL })@facets(value = {\t@facet(name = IKeyword.NAME, type = IType.ID, optional = false),\t@facet(name = IKeyword.TYPE, type = IType.TYPE_ID, optional = true, internal = true),\t@facet(name = IKeyword.OF, type = IType.TYPE_ID, optional = true, internal = true),\t@facet(name = IKeyword.INDEX, type = IType.TYPE_ID, optional = true, internal = true),\t@facet(name = IKeyword.VIRTUAL, type = IType.BOOL, optional = true)     }, omissible = IKeyword.NAME)@validator(ActionValidator.class)@serializer(ActionSerializer.class)public class ActionStatement extends AbstractStatementSequenceWithArgs {\nImplementation​\nAll the statements inherit from the abstract class AbstractStatement. Statements with a sequence of embedded statements inherit from the class AbstractStatementSequence (which extends AbstractStatement).\nThe main methods of a statement class are:\n\nits constructor, that is executed at the compilation of the model.\nexecuteOn(final IScope scope), it executes the statement on a given scope. This method is executed at each call of the statement in the model,\nprivateExecuteIn(IScope scope): the executeOn(final IScope scope) method implemented in AbstractStatement does some verification and call the privateExecuteIn(IScope scope) method to perform the statement. The execution of any statement should be redefined in this method.\n\nDefine a SINGLE_STATEMENT statement​\nTo define a SINGLE_STATEMENT statement that can be executed in any behavior and sequence of statements and with 2 facets, we first define a new Java class that extends AbstractStatement such as:\n@symbol(name = \"testStatement\", kind = ISymbolKind.SINGLE_STATEMENT, with_sequence = false)@inside(kinds = { ISymbolKind.BEHAVIOR, ISymbolKind.SEQUENCE_STATEMENT})@facets(value = {         @facet(name = IKeyword.NAME, type = IType.NONE, optional = false),        @facet(name = \"test_facet\", type = IType.NONE, optional = true)        }, omissible = IKeyword.NAME)public class SingleStatementExample extends AbstractStatement {\nThe class should at least implement:\n\na constructor: the constructor is called at the compilation. It is usually used to get the expressions given to the facets (using the getFacet(String) method) and to store it into an attribute of the class.\n\nfinal IExpression name;public SingleStatementExample(final IDescription desc) {\tsuper(desc);\tname = getFacet(IKeyword.NAME);}\n\nthe method privateExecuteIn: this method is executed each time the statement is called in the model.\n\nprotected Object privateExecuteIn(IScope scope) throws GamaRuntimeException { \tIAgent agent = scope.getAgent();\tString nameStr = null;\tif (agent != null && !agent.dead()) {\t\tnameStr = Cast.asString(scope, name.value(scope));\t\tif (nameStr == null) {\t\t\tnameStr = \"nil\";\t\t}\t\tscope.getGui().getConsole().informConsole(nameStr, scope.getRoot());\t}\treturn nameStr;}  \nThe variable scope of type IScope can be used to:\n\nget the current agent with: scope.getAgent()\nevaluate an expression in the current scope: Cast.asString(scope, message.value(scope))\n\nDefine a statement with sequence​\nThis kind of statements includes SEQUENCE_STATEMENT (e.g. if, loop,...), BEHAVIOR (e.g. reflex,...)...\nSuch a statement is defined in a class extending the AbstractStatementSequence class, e.g.:\n@symbol(name = { IKeyword.REFLEX, IKeyword.INIT }, kind = ISymbolKind.BEHAVIOR, with_sequence = true, unique_name = true)@inside(kinds = { ISymbolKind.SPECIES, ISymbolKind.EXPERIMENT, ISymbolKind.MODEL })@facets(value = { @facet(name = IKeyword.WHEN, type = IType.BOOL, optional = true),\t@facet(name = IKeyword.NAME, type = IType.ID, optional = true) }, omissible = IKeyword.NAME)@validator(ValidNameValidator.class)public class ReflexStatement extends AbstractStatementSequence {\nThis class should only implement a constructor. The class AbstractStatementSequence provides a generic implementation for:\n\nprivateExecuteIn(IScope scope): it executes each embedded statement with the scope.\nexecuteOn(final IScope scope): it executes the statement with a given scope.\n\nAdditional methods that can be implemented​\nThe following methods have a default implementation, but can be overridden if necessary:\n\nthe String getTrace(final IScope scope) method is called to trace the execution of statements using trace statement.\n\npublic String getTrace(final IScope scope) {\t// We dont trace write statements\treturn \"\";} \n\nthe setChildren(final List<? extends ISymbol> commands) is used to define which are the statement children to the sequence statement. By default, all the embedded statements are taken as children\n\nAnnotations​\n@symbol​\nThis annotation represents a \"statement\" in GAML, and is used to define its name(s) as well as some meta-data that will be used during the validation process.\nThis annotation contains:\n\nname (set of string, empty by default): names of the statement.\nkind (int): the kind of the annotated symbol (see ISymbolKind.java for more details).\nwith_scope (boolean, true by default): indicates if the statement (usually a sequence) defines its own scope. Otherwise, all the temporary variables defined in it are actually defined in the super-scope.\nwith_sequence (boolean): indicates wether or not a sequence can or should follow the symbol denoted by this class.\nwith_args (boolean, false by default): indicates wether or not the symbol denoted by this class will accept arguments.\nremote_context (boolean, false by default): indicates that the context of this statement is actually an hybrid context: although it will be executed in a remote context, any temporary variables declared in the enclosing scopes should be passed on as if the statement was executed in the current context.\ndoc (set of @doc, empty by default): the documentation attached to this symbol.\n\n@inside​\nThis annotation is used in conjunction with symbol. Provides a way to tell where this symbol should be located in a model (i.e. what its parents should be). Either direct symbol names (in symbols) or generic symbol kinds can be used.\nThis annotation contains:\n\nsymbols (set of Strings, empty by default): symbol names of the parents.\nkinds (set of int, empty by default): generic symbol kinds of the parents (see ISymbolKind.java for more details).\n\n@facets​\nThis annotation describes a list of facets used by a statement in GAML.\nThis annotation contains:\n\nvalue (set of @facet): array of @facet, each representing a facet name, type..\nommissible (string): the facet that can be safely omitted by the modeler (provided its value is the first following the keyword of the statement).\n\n@facet​\nThis facet describes a facet in a list of facets.\nThis annotation contains:\n\nname (String): the name of the facet. Must be unique within a symbol.\ntype (set of Strings): the string values of the different types that can be taken by this facet.\nvalues (set of Strings): the values that can be taken by this facet. The value of the facet expression will be chosen among the values described here.\noptional (boolean, false by default): whether or not this facet is optional or mandatory.\ndoc (set of @doc, empty by default): the documentation associated to the facet.\n\n@doc​\nIt provides a unified way of attaching documentation to the various GAML elements tagged by the other annotations. The documentation is automatically assembled at compile time and also used at runtime in GAML editors.\n\nvalue (String, \"\" by default): a String representing the documentation of a GAML element.\ndeprecated (String, \"\" by default): a String indicating (if it is not empty) that the element is deprecated and defining, if possible, what to use instead.\nreturns (String, \"\" by default): the documentation concerning the value(s) returned by this element (if any)..\ncomment (String, \"\" by default): an optional comment that will appear differently from the documentation itself.\nspecial_cases (set of Strings, empty by default): an array of String representing the documentation of the \"special cases\" in which the documented element takes part.\nexamples (set of Strings, empty by default): an array of String representing some examples or use-cases about how to use this element.\nsee (set of Strings, empty by default): an array of String representing cross-references to other elements in GAML.\n\n@serializer​\nIt allows to declare a custom serializer for Symbols (statements, var declarations, species, experiments, etc.). This serializer will be called instead of the standard serializer, superseding this last one. Serializers must be subclasses of the SymbolSerializer class.\n\nvalue (Class): the serializer class.\n\n@validator​\nIt allows to declare a custom validator for Symbols (statements, var declarations, species, experiments, etc.). This validator, if declared on subclasses of Symbol, will be called after the standard validation is done. The validator must be a subclass of IDescriptionValidator.\n\nvalue (Class): the validator class.\n\nAll these annotations are defined in the GamlAnnotations.java file of the msi.gama.processor plug-in."},{"filePath":"https:--gama-platform.org--wiki-DevelopingTypes.txt","text":"Developing TypesGAML provides a given number of built-in simple types (int, bool...) and more complex ones (path, graph...).\nDeveloping a new type allows, then, to add a new data structure to GAML.\nImplementation​\nDeveloping a new type requires the implementation of 2 Java files:\n\nthe first one that describes the data structure (e.g.: GamaColor.java to define a type color)\nthe second one that implements the type itself, wrapping the data structure file (e.g.: GamaColorType.java), and providing accessors to data structure attributes.\n\nThe data structure file​\nThe class representing the data structure is a Java class annotated by:\n\na @vars annotation to describe the attributes of a complex type. The @vars annotation contains a set of @variable elements.\n\n@vars ({     @variable (\t\tname = \"red\",\t\ttype = IType.INT,\t\tdoc = { @doc (\"Returns the red component of the color (between 0 and 255)\") }),\t@variable (\t\tname = \"green\",\t\ttype = IType.INT,\t\tdoc = { @doc (\"Returns the green component of the color (between 0 and 255)\") }),\t@variable (\t\tname = \"blue\",\t\ttype = IType.INT,\t\tdoc = { @doc (\"Returns the blue component of the color (between 0 and 255)\") }),})\nIt is recommended that this class implements the IValue interface. It provides a clean way to give a string representation of the type and thus eases good serialization of the object. You will need to implement the stringValue method:\npublic class GamaColor implements IValue {\t@Override\tpublic String stringValue(IScope scope) throws GamaRuntimeException {\t\t...\t}}\nYou should also have some class attributes that correspond to your custom data type's attributes\npublic class GamaColor implements IValue {\tprivate int red;    private int green;    private int blue;    ...}\nand then you can create setters and/or getters for each of the attributes. Setters and getters are methods annotated by the @getter or @setter annotations.\n@getter(\"red\")public Integer getRed() {\treturn this.red;}@setter(\"red\")public void setRed(int red) {\tthis.red = red;}\nThe type file​\nThe class representing the type is a Java class such that:\n\nthe class should be annotated by the @type annotation,\nthe class should extend the class GamaType<DataStructureFile> (and thus implement its 3 methods),\n\nExample (from GamaFloatType.java):\n@type(\tname = IKeyword.FLOAT, \tid = IType.FLOAT, wraps = { Double.class,double.class }, \tkind = ISymbolKind.Variable.NUMBER, \tdoc = {\t\t@doc(\"Represents floating point numbers (equivalent to Double in Java)\") }, \tconcept = { IConcept.TYPE })public class GamaFloatType extends GamaType<Double> {\nInheritance from the GamaType<T> class​\nEach java class aiming at implementing a type should inherit from the GamaType abstract class.\nExample (from GamaColorType.java):\npublic class GamaColorType extends GamaType<GamaColor>\nThis class imposes to implement the three following methods (with the example of the GamaColorType):\n\npublic boolean canCastToConst()\npublic GamaColor cast(IScope scope, Object obj, Object param): the way to cast any object in the type,\npublic GamaColor getDefault(): to define the default value of a variable of the current type.\n\nRemark: for each type, a unary operator is created with the exact name of the type. It can be used to cast any expression in the given type.\nThis operator calls the previous cast method.\nAnnotations​\n@type​\nIt provides information necessary to the processor to identify a type.\nThis annotation contains:\n\nname (String, \"\" by default): a String representing the type name in GAML.\nid (int, 0 by default): the unique identifier for this type. User-added types can be chosen between IType.AVAILABLE_TYPE and IType.SPECIES_TYPE (exclusive) (cf. IType.java).\nwraps (tab of Class, null by default): the list of Java Classes this type is \"wrapping\" (i.e. representing). The first one is the one that will be used preferentially throughout GAMA. The other ones are to ensure compatibility, in operators, with compatible Java classes (for instance, List and GamaList).\nkind (int, ISymbolKind.Variable.REGULAR by default): the kind of Variable used to store this type. See ISymbolKind.Variable.\ninternal (boolean, false by default): whether this type is for internal use only.\ndoc (set of @doc, empty by default): the documentation associated to the facet.\n\nAll these annotations are defined in the file GamlAnnotations.java."},{"filePath":"https:--gama-platform.org--wiki-DifferentialEquations.txt","text":"Using Differential EquationsIntroduction​\nODEs (Ordinary Differential Equations) models are often used in physics, chemistry, biology, ecology and epidemiology. They allow tracking continuous changes of a system, and offer the possibility of a mathematical analysis. The possibility to find a numerical solution (for a given Cauchy problem) of first order differential equations has been implemented in Gama.\nIn population dynamics, systems of ODEs are used to describe the macroscopic evolution over time of a population, which is usually split into several compartments. The state of the population is described by the number of individuals in each compartment. Each equation of the ODE system describes the evolution of the number of individuals in a compartment. In such an approach, individuals are not taken into account individually, with own features and behaviors. On the contrary, they are aggregated and only the population density is considered.\nCompartmental models are widely used to represent the spread of a disease in a population, with a large variety of models derived from the classical Kermack-McKendrick model, often referred to as the SIR model. More information about compartmental models in epidemiology can be found here.\nIn SIR class models, the population is split into 3 (or more) compartments: S (Susceptible), I (Infected), R (Recovered). It is not usually possible to find an analytical solution of the ODE system, and an approximate solution has to be found, using various numerical schemes (such as Euler, Runge-Kutta, Dormand-Prince...)\nExample of a SIR model​\nIn the SIR model, the population is split into 3 compartments: S (Susceptible), I (Infected), R (Recovered). Susceptible individuals become infected (move from compartment S to I) at a rate proportional to the size of both S and I populations. People recover (are removed from compartment I) at a constant rate. This can be represented by the following Forrester diagram: boxes represent compartments and arrows are flows. Arrows hold the rate of a compartment population flowing to another compartment.\n\nThe corresponding ODE system contains one equation per compartment. For example, the I compartment evolution is influenced by an inner (so positive) flow from the S compartment and an outer (so negative) flow to the R compartment.\n\nGiven an initial condition (initial values) at time t=0, such as\n\nS = 499\nI = 1\nR = 0\nbeta = 0.4\ngamma = 0.1\nh = 0.1\n\none can obtain the evolution of the evolution of S, I and R over time, by integrating the ODE system using a numerical scheme.\n\nWhy and when can we use ODE in agent-based models?​\nODE models are often used when a system can be considered at a macro (population) level, i.e when the individual variability as little influence on dynamics at the aggregated level.\nIt is relevant to use ODE in agent-based models in several cases:\n\n\nLarge scale agent-based models require many resources to run and a very large computation time. For example, if we want to implement a model describing the worldwide epidemic spread and the impact of air traffic on it, we cannot simulate the 7 billion people. Instead we can represent only cities with airports and airplanes as agents. In this case, cities are entities are represented by a compartment, on which a SIR class epidemiological model can be run, using an ODE system. Such a model combines some advantages of agent-based models (detailed description of the disease spread from one city to another with the plane agents) and mathematical modeling (good description of an epidemiological dynamics at a city level, using fewer resources and less computation time).\n\n\nSome processes may be easier to manipulate at the aggregated level, for several reasons: 1) a global description of a system may turn sometimes more informative than a detailed one, 2) a detailed description may require to fit too many parameters for which there is no sufficient data, in that case it is easier to fit a global model with less parameters, and 3) when one wants to keep a low number of parameters, in order to avoid overfitting or to optimize Akaike Information Criterion.\n\n\nSome systems are better described with a continuous dynamics than with a discrete one. This is the case for many physical or biological systems (physics laws such as gravity or water dynamics, biological processes such as respiration or cell growth). Coupling ABM and ODE model allow considering individual/discrete processes along with continuous processes.\n\n\nSome models already exist in an ODE version, and could be coupled to another model in Gama without having to rewrite an Agent-Based version of the model.\n\n\nUse of ODE in a GAML model​\nA stereotypical use of ODE in a GAMA agent-based model is to describe species where some agents attribute evolution is described using an ODE system.\nAs a consequence, the GAML language has been increased by two main concepts (as two statements):\n\nequations can be written with the equation statement. An equation block is composed of a set of diff statement describing the evolution of species attributes.\nan equation can be numerically integrated using the solve statement\n\nAdditionnally, Gama provides an intuitive, flexible and natural framework to build ODE models, since an ODE system may be split among several entities. For example, if there are three species (resp. agent) involved in a common dynamics, it is possible to declare each equation inside the corresponding species (resp. agent) definition. An example is shown below.\nDefining and solving an ODE system​\nDefining an ODE system with equation​\nDefining a new ODE system needs to define a new equation block in a species. As an example, the following eqSI system describes the evolution of a population with 2 compartments (S and I) and the flow from S to I compartments:\nspecies userSI {    float t ;    float I ;     float S ;     int N ;    float beta<-0.4 ;    float h ;\t    equation eqSI {\tdiff(S,t) = -beta * S * I / N ;\tdiff(I,t) = beta * S * I / N ;    }}\t\t\t\nThis equation has to be defined in a species with t, S and I attributes. beta (and other similar parameters) can be defined either in the specific species (if it is specific to each agent) or in the global if it is a constant.\nNote: it is mandatory to declare a differenciation variable (here t) as an attribute in the species. It is automatically updated using the solve statement and contains the time elapsed in the equation integration.\nsolve an ODE system​\nOnce the equation or system of equations has been defined, it is necessary to execute a solve statement inside a reflex in order to numerically integrate the ODE system. The reflex is executed at each cycle, and the values of the attributes used in the equations (S and I in the previous example) are updated with the values obtained by integrating the system between the start time end and end time of the current cycle.\nreflex solving {    solve eqSI method: #rk4 step_size: h;}\nSeveral numerical schemes are available to solve the ODE system. More details about the numerical schemes and the solve syntax are provided below.\nAlternative way to define an ODE system​\nSplit a system into several agents​\nAn equation system can be split into several species and each part of the system are synchronized using the simultaneously facet of equation. The system split into several agents can be integrated using a single call to the solve statement. Notice that all the equation definition must have the same name.\nFor example, the SI system presented above can be defined in two different species S_agt (containing the equation defining the evolution of the S value) and I_agt (containing the equation defining the evolution of the I value). These two equations are linked using the simultaneously facet of the equation statement. This facet expects a set of agents. The integration is called only once in a simulation step, e.g. in the S_agt agent.\nglobal {\t    int N <- 1000;    float hRK4 <- 0.01;}species S_agt {    float t ;\t\t    float Ssize ;\t    equation evol simultaneously: [ I_agt ] {\tdiff(Ssize, t) = (- sum(I_agt accumulate [each.beta * each.Isize]) * self.Ssize / N);    }\t    reflex solving {solve evol method: #rk4 step_size: hRK4 ;}\t}species I_agt {    float t ;    float Isize ; // number of infected\t    float beta ;    equation evol simultaneously: [ S_agt ] {\tdiff(Isize, t) = (beta * first(S_agt).Ssize * Isize / N);    }}\nThe interest is that the modeler can create several agents for each compartment, which different values. For example in the SI model, the modeler can choose to create 1 agent S_agt and 2 agents I_agt. The beta attribute will have different values in the two agents, in order to represent 2 different strains.\nglobal {    int number_S <- 495 ; // The number of susceptible    int number_I <- 5   ; // The number of infected    int nb_I <- 2;    float gbeta  <- 0.3  ; // The parameter Beta\t    int N <- number_S + nb_I * number_I ;    float hRK4 <- 0.1 ;    init {\tcreate S_agt {\t    Ssize <- float(number_S) ;\t}\tcreate I_agt number: nb_I {\t    Isize <- float(number_I) ;\t    self.beta <- myself.gbeta + rnd(0.5) ;\t}    }}\nThe results are computed using the RK4 (Runge-Kutta 4) method with:\n\nnumber_S = 495\nnumber_I = 5\nnb_I = 2\ngbeta = 0.3\nhKR4 = 0.1\n\n\nImportant note: the solve statement must be called once and only once per cycle. In this example, is it executed in the 'solving' reflex of the only S_agt agent. There is no 'solving' reflex in the I_agt agents: since the equations definitions blocks are connected through the simultaneously facet, there equation blocks will be integrated by the S_agt agent. Note also that if they were several S_agt agents, with the same definition of the 'solving' reflex, the solve statement would be executed several times, which could result in wrong results. To ensure that it is called only once, the 'solving' reflex should be rewritten. For example, it is possible to write this:\n    reflex solving when: (int(self)=0) {solve evol method: #rk4 step_size: hRK4 ;}\t\nMore details​\nDetails about the solve statement​\nThe solve statement can have a huge set of facets (see this page for more details). The basic use of the solve statement requires only the equation identifier. By default, the integration method is Runge-Kutta 4 with a fixed integration step of 0.005*step, which means that each simulation step (cycle) is divided into 200 smaller integration steps that are used to simulate a continuous evolution of the system.\nFor fixed integration step numerical schemes such as Runge-Kutta 4, the length of the integration step is defined in the step_size facet. Increasing the integration step results in faster computation at the cost of accuracy.\nIntegration method with the method facet​\nSeveral integration methods can be used in the method facet. GAMA relies on the Apache Commons Math library to provide numerical schemes; it thus provides access to the various solvers integrated into the library. The list of all the solver is detailed in this page, section 15.4 Available integrators. The GAML constants associated with each of them (to use in the method statement) are:\n)\n\nFixed Step Integrators\n\n#Euler for Euler. It implements the Euler integration method, which is mainly used for academic illustration of numerical schemes. It should not be used outside of this purpose due to its lack of precision (a very small integration step is required for an acceptable precision).\n#Midpoint for Midpoint\n#rk4 for Runge-Kutta 4. It implements the Runge-Kutta 4 integration method. It provides a faster convergence than the Euler method, and thus does not require very small integration steps. However the user has to determine manually the ideal integration step. For that reason, it is recommended to try first an adaptative stepsize integrator such as the Dorman-Prince 5(4) integration method.\n#Gill for Gill\n#ThreeEighthes for 3/8\n#Luther for Luther\n\n\nAdaptive Stepsize Integrators\n\n#HighamHall54 for Higham and Hall\n#DormandPrince54 for Dormand-Prince 5(4) It implements the Dorman-Prince 5(4) integration method. It is similar to the ode45in Matlab. This method is based on the Runge-Kutta solvers family. It evaluates the error between the numerical solution and the analytic solution, and adapt the integration step in order to minimize it. It is recommended to try this method first, even it may not the best one in case of stiff problems.\n#dp853 for Dormand-Prince 8(5,3).\n#GraggBulirschStoer for Gragg-Bulirsch-Stoer\n#AdamsBashforth for Adams-Bashforth\n#AdamsMoulton for Adams-Moulton\n\n\n\nIntegration steps​\nThe length of the integration step has a huge impact on precision: a smaller integration step means more evaluation points, which results in a better precision but a longer computation time. In order to improve the precision of the integration or its speed, the integration step can be set using the step_size facet for fixed steps methods.\n\nstep_size (float): integration step, use with most fixed steps integrator methods (default value: 0.005*step)\n\nAdaptative stepsize integrators (e.g. #DormandPrince54) automatically determine and set the integration step according to a given error tolerance.\nSome of them also use different integration steps all over the computation, since parts of the solution that are stable enough do not require a very small integration step, while parts with high variations need more precision. Such integrators require thus more information, through the following mandatory facets:\n\nmin_step, max_step (float): these 2 values define the range of variation for the integration step. As an example, we can use: min_step:0.01 max_step:0.1.\nscalAbsoluteTolerance and scalRelativeTolerance (float): they defined the allowed absolute (resp. relative) error. As an example, we can use: scalAbsoluteTolerance:0.0001 scalRelativeTolerance:0.0001.\n\nSynchronization between simulation and integration​\nThe simulation and the integration are synchronized: if one simulation step represents 1 second, then one call of the solve statement will integrate over 1s in the ODE system. This means that the step attribute of the global has an impact on the integration. See below to observe this influence.\nIt is thus important to specify the unit of the parameters used in the ODE system (in particular relatively to time).\nIt is also important to notice that the integration step step_size will only control the precision of the integration. If step (of the global) is 1#s, then after 1 call of solve, 1#s has flowed in the equation system. If step_size is set to 1#s or to 0.01#s will not impact this fact. The only difference is that in the latter case, the solver made 100x more computations than in the former one (increasing the precision of the final result).\nAdditional facets​\nHere are additional facets that be added to the solve statement:\n\nt0 (float): the first bound of the integration interval (default value: cycle*step, the time at the beginning of the current cycle.)\ntf (float): the second bound of the integration interval. Can be smaller than t0 for a backward integration (default value: cycle*step, the time at the beginning of the current cycle.)\n\nThis might be useful more model coupling, when the sytem to integrate is not linked to the time evolution of the main simulation.\nIntermediate results​\nIn one simulation step, if the statement solve is called one time, several integration steps will be done internally. Intermediate computation results can be accessed using the notation: var[] that returns the list of intermediate values of the variable var involved in a differential equation. As an example, with a SIR equation:\nspecies agent_with_SIR_dynamic {    int N <- 1500 ;    int iInit <- 1;\t\t    float t;      float S <- N - float(iInit); \t          float I <- float(iInit);     float R <- 0.0; \t    float alpha <- 0.2 min: 0.0 max: 1.0;    float beta <- 0.8 min: 0.0 max: 1.0;    float h <- 0.01;       equation SIR{ \tdiff(S,t) = (- beta * S * I / N);\tdiff(I,t) = (beta * S * I / N) - (alpha * I);\tdiff(R,t) = (alpha * I);    }      reflex solving {        solve SIR method: #rk4 step_size: h ;    \t    \twrite S[];      \twrite I[];      \twrite R[];    \twrite t[];    }  }\nWe can use S[], I[], R[] and t[] to access the list of intermediate variables of these 4 variables. SinceS[] is a list the first element can be accessed with S[][0].\nNote that the current value of a variable, i.e. S, equals to the last value of the list S[]: S = last(S[]).\nAccessing the intermediate values can be useful to provide smooth continuous charts. A way to do so is to provide the display with the full list of integration times and values, such as:\nexperiment continuous_display type: gui {\toutput {\t\t\tdisplay display_charts axes: false{\t\t\tchart 'SIR' type: series x_serie: first(agent_with_SIR_dynamic).t[] y_range: {0,1000} background: #white {\t\t\t\tdata \"S\" value: first(agent_with_SIR_dynamic).S[] color: #green marker: false;\t\t\t\tdata \"I\" value: first(agent_with_SIR_dynamic).I[] color: #red marker: false;\t\t\t\tdata \"R\" value: first(agent_with_SIR_dynamic).R[] color: #blue marker: false;\t\t\t}\t\t}\t}}\nThe following picture illustrates the result: the top subfigure shows the dynamics with discrete visualization and the bottom one the continuous curves.\n\nExample of the influence of the integration step​\nThe step (of the global) and step_size (of solve) facets may have a huge influence on the results. step_size only has an impact on the result accuracy. The step facet changes the cycle duration and so the time scale and results in curves being horizontally scales.\nIn the following image, the stepfacet has been change from 1.0 (first simulation) to 2.0 (second simulation). The dynamics are exactly the same, but they are viewed at different time scales.\nThe following image illustrates this impact, by calling (with 3 different values of step):\n\nWhen changing this facet, be sure that the time scale of the ODE system remains consistent with the one of the other agents."},{"filePath":"https:--gama-platform.org--wiki-Diffusion.txt","text":"Implementing diffusionGAMA provides you the possibility to represent and simulate the diffusion of a variable through a grid topology.\nIndex​\n\nDiffuse statement\nDiffusion with matrix\n\nDiffusion matrix\nGradient matrix\nCompute multiple propagations at the same step\nExecuting several diffusion matrix\n\n\nDiffusion with parameters\nComputation methods\n\nConvolution\nDot Product\n\n\nUse mask\n\nGeneralities\nTips\n\n\nPseudo code\n\nDiffuse statement​\nThe statement to use for the diffusion is diffuse. It has to be used in a grid species. The diffuse uses the following facets:\n\nvar (an identifier), (omissible) : the variable to be diffused\non (any type in [container, species]): the list of agents (in general cells of a grid), on which the diffusion will occur\navoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restituted to the neighboring cells, multiplied by the variation value (no signal loss). If false, the value will be diffused in the masked cells, but masked cells won't diffuse the value afterward (loss of signal). (default value : false)\ncycle_length (int): the number of diffusion operation applied in one simulation step\nmask (matrix): a matrix masking the diffusion (matrix created from an image for example). The cells corresponding to the values smaller than \"-1\" in the mask matrix will not diffuse, and the other will diffuse.\nmatrix (matrix): the diffusion matrix (\"kernel\" or \"filter\" in image processing). Can have any size, as long as dimensions are odd values.\nmethod (an identifier), takes values in: {convolution, dot_product}: the diffusion method\nmin (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.\npropagation (a label), takes values in {diffusion, gradient} represents both the way the signal is propagated and the way to treat multiple propagations of the same signal occurring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbors with respect to 'proportion', 'variation' and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is S' = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbor receives the intensity: S / proportion - variation. If multiple propagations occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.\nproportion (float): a diffusion rate\nradius (int): a diffusion radius (in number of cells from the center)\nvariation (float): an absolute value to decrease at each neighbor\n\nTo write a diffusion, you first have to declare a grid and declare a special attribute for the diffusion. You will then have to write the diffuse statement in another scope (such as the global scope for instance), which will permit the values to be diffused at each step. There, you will specify which variable you want to diffuse (through the var facet), on which species or list of agents you want the diffusion (through the on facet), and how you want this value to be diffused (through all the other facets, we will see how it works with matrix and with special parameters just after).\nHere is the template of code we will use for the next following part of this page:\nglobal {    int size <- 64; // the size has to be a power of 2.    cells selected_cells;    // Initialize the emitter cell as the cell at the center of the word    init {\tselected_cells <- location as cells;    }    // Affecting \"1\" to each step    reflex new_Value {\task(selected_cells){\t    phero <- 1.0;\t}\t    }    reflex diff {\t// Declare a diffusion on the grid \"cells\" and on \"quick_cells\".         // The diffusion declared on \"quick_cells\" will make 10 computations at each step to accelerate the process. \t// The value of the diffusion will be store in the new variable \"phero\" of the cell.\tdiffuse var: phero on: cells /*HERE WRITE DOWN THE DIFFUSION PROPERTIES*/;\t\t\t    }}grid cells height: size width: size {    // \"phero\" is the variable storing the value of the diffusion    float phero  <- 0.0;    // The color of the cell is linked to the value of \"phero\".    rgb color <- hsb(phero,1.0,1.0) update: hsb(phero,1.0,1.0);}experiment diffusion type: gui {    output {\tdisplay a type: opengl {\t    // Display the grid with elevation\t    grid cells elevation: phero * 10 triangulation: true;\t}    }}\nThis model will simulate a diffusion through a grid at each step, affecting 1 to the center cell diffusing variable value. The diffusion will be seen during the simulation through a color code, and through the elevation of the cell.\nDiffusion with matrix​\nA first way of specifying the behavior of your diffusion is using diffusion matrix. A diffusion matrix is a 2-dimension matrix [n][m] with float values, where both n and m have to be odd values. The most often, diffusion matrices are square matrices, but you can also declare a rectangular matrix.\nExample of matrix:\nmatrix<float> mat_diff <- matrix([\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9]]);\nIn the diffuse statement, you then have to specify the matrix of diffusion you want in the facet matrix.\ndiffuse var: phero on: cells matrix:mat_diff;\nUsing the facet propagation, you can specify if you want the value to be propagated as a diffusion or as a gradient.\nDiffusion matrix​\nA diffusion (the default value of the facet propagation) will spread the values to the neighbors' cells according to the diffusion matrix, and all those values will be added together, as it is the case in the following example:\n\nNote that the sum of all the values diffused at the next step is equal to the sum of the values that will be diffused multiply by the sum of the values of the diffusion matrix. That means that if the sum of the values of your diffusion matrix is larger than 1, the values will increase exponentially at each step. The sum of the value of a diffusion matrix is usually equal to 1.\nHere are some matrix examples you can use, played with the template model:\n\n\nGradient matrix​\nA gradient (use facet : propagation:gradient) is another type of propagation. This time, only the larger value diffused will be chosen as the new one.\n\nNote that unlike the diffusion propagation, the sum of your matrix can be greater than 1 (and it is the case, most often !).\nHere are some matrix examples with gradient propagation:\n\n\nCompute multiple propagations at the same step​\nYou can compute several times the propagation you want by using the facet cycle_length. GAMA will compute for you the corresponding new matrix and will apply it.\n\nWriting those two things are exactly equivalent (for diffusion):\nmatrix<float> mat_diff <- matrix([\t\t[1/81,2/81,3/81,2/81,1/81],\t\t[2/81,4/81,6/81,4/81,2/81],\t\t[3/81,6/81,1/9,6/81,3/81],\t\t[2/81,4/81,6/81,4/81,2/81],\t\t[1/81,2/81,3/81,2/81,1/81]]);reflex diff {    diffuse var: phero on: cells matrix:mat_diff;\nand\nmatrix<float> mat_diff <- matrix([\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9]]);reflex diff {    diffuse var: phero on: cells matrix:mat_diff cycle_length:2;\nExecuting several diffusion matrix​\nIf you execute several times the statement diffuse with different matrix on the same variable, their values will be added (and centered if their dimensions are not equal).\nThus, the following 3 matrices will be combined to create one unique matrix:\n\nDiffusion with parameters​\nSometimes writing diffusion matrix is not exactly what you want, and you may prefer to just give some parameters to compute the correct diffusion matrix. You can use the following facets in order to do that: propagation, variation and radius.\nDepending on which propagation you choose, and how many neighbors your grid has, the propagation matrix will be computed differently. The propagation matrix will have the size: range*2+1.\nLet's note P for the propagation value, V for the variation, R for the range and N for the number of neighbors.\n\nWith diffusion propagation\n\nFor diffusion propagation, we compute following the following steps:\n(1) We determine the \"minimale\" matrix according to N (if N = 8, the matrix will be [[P/9,P/9,P/9][P/9,1/9,P/9][P/9,P/9,P/9]]. if N = 4, the matrix will be [[0,P/5,0][P/5,1/5,P/5][0,P/5,0]]).\n(2) If R != 1, we propagate the matrix R times to obtain a [2*R+1][2*R+1] matrix (same computation as for cycle_length).\n(3) If V != 0, we substract each value by V*DistanceFromCenter (DistanceFromCenter depends on N).\nEx with the default values (P=1, R=1, V=0, N=8):\n\nWith gradient propagation\n\nThe value of each cell will be equal to P/POW(N,DistanceFromCenter)-DistanceFromCenter*V. (DistanceFromCenter depends on N).\nEx with R=2, other parameters default values (R=2, P=1, V=0, N=8):\n\nNote that if you declared a diffusion matrix, you cannot use those 3 facets (it will raise a warning). Note also that if you use parameters, you will only have a uniform matrix.\nComputation methods​\nYou can compute the output matrix using two computation methods by using the facet method : the dot product and the convolution. Note that the result of those two methods is exactly the same (except if you use the avoid_mask facet, the results can be slightly different between the two computations).\nConvolution​\nconvolution is the default computation method for diffusion. For every output cells, we will multiply the input values and the flipped kernel together, as shown in the following image :\n\nPseudo-code (k the kernel, x the input matrix, y the output matrix) :\nfor (i = 0 ; i < y.nbRows ; i++)  for (j = 0 ; j < y.nbCols ; j++)    for (m = 0 ; m < k.nbRows ; m++)      for (n = 0 ; n < k.nbCols ; n++)        y[i,j] += k[k.nbRows - m - 1, k.nbCols - n - 1]             * x[i - k.nbRows/2 + m, j - k.nbCols/2 + n]\nDot Product​\ndot_product method will compute the matrix using a simple dot product between the matrix. For every input cells, we multiply the cell by the kernel matrix, as shown in the following image :\n\nPseudo-code (k the kernel, x the input matrix, y the output matrix) :\nfor (i = 0 ; i < y.nbRows ; i++)  for (j = 0 ; j < y.nbCols ; j++)    for (m = 0 ; m < k.nbRows ; m++)      for (n = 0 ; n < k.nbCols ; n++)        y[i - k.nbRows/2 + m, j - k.nbCols/2 + n] += k[m, n] * x[i, j]\nUsing a mask​\nGeneralities​\nIf you want to propagate some values in a heterogeneous grid, you can use some mask to forbid some cells to propagate their values.\nYou can pass a matrix to the facet mask. All the values smaller than -1 will not propagate, and all the values greater or equal to -1 will propagate.\nA simple way to use mask is by loading an image :\n\nNote that when you use the on facet for the diffuse statement, you can choose only some cells, and not every cell. In fact, when you restrain the values to be diffuse, it is exactly the same process as if you were defining a mask.\n\nWhen your diffusion is combined with a mask, the default behavior is that the non-masked cells will diffuse their values in all existing cells (that means, even the masked cells !). To change this behavior, you can use the facet avoid_mask. In that case, the value which was supposed to be affected to the masked cell will be redistributed to the neighboring non-masked cells.\nTips​\nMasks can be used to simulate a lot of environments. Here are some ideas for your models:\nWall blocking the diffusion​\nIf you want to simulate a wall blocking a uniform diffusion, you can declare a second diffusion matrix that will be applied only on the cells where your wall will be. This diffusion matrix will \"push\" the values outside from himself, but conserving the values (the sum of the values of the diffusion still have to be equal to 1) :\nmatrix<float> mat_diff <- matrix([\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9]]);\t\t\t\t\t\t\t\tmatrix<float> mat_diff_left_wall <- matrix([\t\t\t[0.0,0.0,2/9],\t\t\t[0.0,0.0,4/9],\t\t\t[0.0,0.0,2/9]]);reflex diff {     diffuse var: phero on: (cells where(each.grid_x>30)) matrix:mat_diff;    diffuse var: phero on: (cells where(each.grid_x=30)) matrix:mat_diff_left_wall;}\n\nNote that almost the same result can be obtained by using the facet avoid_mask: the value of all masked cells will remain at 0, and the value which was supposed to be affected to the masked cell will be distributed to the neighboring cells. Notice that the results can be slightly different if you are using the convolution or the dot_product method: the algorithm of redistribution of the value to the neighboring cells is a bit different. We advise you to use the dot_product with the avoid_mask facet, the results are more accurate.\nWind pushing the diffusion​\nLet's simulate a uniform diffusion that is pushed by a wind from \"north\" everywhere in the grid. A wind from \"west\" as blowing at the top side of the grid. We will here have to build 2 matrices: one for the uniform diffusion, one for the \"north\" wind and one for the \"west\" wind. The sum of the values for the 2 matrices meant to simulate the wind will be equal to 0 (as it will be added to the diffusion matrix).\nmatrix<float> mat_diff <- matrix([\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9],\t\t[1/9,1/9,1/9]]);\t\t\t\t\t\t\t\tmatrix<float> mat_wind_from_west <- matrix([\t\t[-1/9,0.0,1/9],\t\t[-1/9,0.0,1/9],\t\t[-1/9,0.0,1/9]]);\t\t\t\t\t\t\t\tmatrix<float> mat_wind_from_north <- matrix([\t\t[-1/9,-1/9,-1/9],\t\t[0.0,0.0,0.0],\t\t[1/9,1/9,1/9]]);reflex diff {     diffuse var: phero on: cells matrix:mat_diff;    diffuse var: phero on: cells matrix:mat_wind_from_north;    diffuse var: phero on: (cells where (each.grid_y>=32)) matrix:mat_wind_from_west;}\n\nEndless world​\nNote that when your world is not a torus, it has the same effect as a mask, since all the values outside from the world cannot diffuse some values back :\n\nYou can \"fake\" the fact that your world is endless by adding a different diffusion for the cells with grid_x=0 to have almost the same result :\n\nmatrix<float> mat_diff <- matrix([\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9],\t\t\t[1/9,1/9,1/9]]);\t\t\t\t\t\t\t\tmatrix<float> mat_diff_upper_edge <- matrix([\t\t\t[0.0,0.0,0.0],\t\t\t[1/9+7/81,2/9+1/81,1/9+7/81],\t\t\t[1/9,1/9,1/9]]);reflex diff {     diffuse var: phero on: (cells where(each.grid_y>0)) matrix:mat_diff;    diffuse var: phero on: (cells where(each.grid_y=0)) matrix:mat_diff_upper_edge;}\nPseudo-code​\nThis section is more for a better understanding of the source code.\nHere is the pseudo-code for the computation of diffusion :\n\n: Execute the statement diffuse, store the diffusions in a map (from class DiffusionStatement to class GridDiffuser) :\n\n- Get all the facet values- Compute the \"real\" mask, from the facet \"mask:\" and the facet \"on:\".  - If no value for \"mask:\" and \"on:\" all the grid, the mask is equal to null.- Compute the matrix of diffusion  - If no value for \"matrix:\", compute with \"nb_neighbors\", \"is_gradient\", \"proportion\", \"propagation\", \"variation\", \"range\".  - Then, compute the matrix of diffusion with \"cycle_length\".- Store the diffusion properties in a map  - Map : [\"method_diffu\", \"is_gradient\", \"matrix\", \"mask\", \"min_value\"] is value, [\"var_diffu\", \"grid_name\"] is key.  - If the key exists in the map, try to \"mix\" the diffusions    - If \"method_diffu\", \"mask\" and \"is_gradient\" equal for the 2 diffusions, mix the diffusion matrix.\n\n: At the end of the step, execute the diffusions (class GridDiffuser) :\n\n- For each key of the map,  - Load the couple \"var_diffu\" / \"grid_name\"  - Build the \"output\" and \"input\" array with the dimension of the grid.   - Initialize the \"output\" array with -Double.MAX_VALUE.  - For each value of the map for that key,    - Load all the properties : \"method_diffu\", \"is_gradient\", \"matrix\", \"mask\", \"min_value\"    - Compute :      - If the cell is not masked, if the value of input is > min_value, diffuse to the neighbors.        - If the value of the cell is equal to -Double.MAX_VALUE, remplace it by input[idx] * matDiffu[i][j].        - Else, do the computation (gradient or diffusion).    - Finish the diffusion :      - If output[idx] > -Double.MAX_VALUE, write the new value in the cell."},{"filePath":"https:--gama-platform.org--wiki-Displays.txt","text":"DisplaysGAMA allows modelers to define two kinds of displays in a GUI experiment:\n\njava 2D displays\nOpenGL displays\n\nThese 2 displays allow modeler to display the same objects (agents, charts, texts ...). However, the OpenGL display offers extended features in particular in terms of 3D visualization and provdies better performance for large scale simulation.\nClassical displays (java2D)​\nThe classical displays displaying any kind of content can be manipulated via the mouse (if no mouse event has been defined):\n\nthe mouse left press and move allows to move the camera (in 2D),\nthe mouse right click opens a context menu allowing the modeler to inspect displayed agents,\nthe wheel allows the modeler to zoom in or out.\n\n\nEach display provides several buttons to manipulate the display (from left to right):\n\nPause or resume the current view: when pressed, the display will not be displayed anymore while the simulation is still running,\nSynchronize, when pressed, the display and the execution of the model are synchronized. Most of the time, this will reduce the speed of the simulation.\nZoom in,\nZoom to fit view,\nZoom out,\nTake a snapshot: take a snapshot saved as a png image in the snapshots folder of the model folder.\nToggle antialias: Antialising produces smoother outputs, but comes with a cost in terms of speed and memory used.\nToggle fullscreen ESC: when pressed, the current view will be displayed in fullscreen. To exit this mode, press ESC key.\nBrowse through all displayed agents: when pressed a browse view will be open. Only the species displayed can be browsed.\n\n\nIn addition to these commands, the contextual menu on the display provides three more commands (in \"Presentation\"):\n\nToggle overlay: display/hide a semi-transparent toolbar on the bottom of the display, showing the coordinates of the mouse, the zoom, the number of fps (frame per second) of the simulation, and a scale (taking into account the zoom level).\nToggle toolbar: display/hide the toolbar on the top of the display.\nBackground: Change the background color.\n\nWhen the View is displayed in fullscreen mode, the toolbar is now located in the bottom of the View and contain in addition to the previously detailed toolbar, the toggle side-control, and overlay controls and controls of the experiment (run, pause, step...).\n\nOpenGL displays​\nThe OpenGL displays displaying offers all the feature provided by java2D but a 3D environnement:\n\nsame behaviors with left-click, right-click and wheel than in the Java2D displays.\ncommand pressed (on Mac OS) or Ctrl (on Windows and Linux) + Left-Click pressed + mouse move: it controls the camera and modify its location/target/orientation.\n\nIt opens many ways to visualize and understand your simulation(s) with most of the classical features provided by a 3D environment. More details and illustrations of those features can be found here\nAny OpenGL display has the same menu and buttons as the classical Java2D displays. Nevertheless, the sidebar provides more options to manage camera and other options related to OpenGL displays management.\n\nCamera commands​\nKeyFunctionDouble ClickZoom Fit+Zoom In-Zoom OutUpVertical movement to the topDownVertical movement to the bottomLeftHorizontal movement to the leftRightHorizontal movement to the rightCTRL or CMD + UpRotate the model up (decrease the phi angle of the spherical coordinates)CTRL or CMD + DownRotate the model down (increase the phi angle of the spherical coordinates)CTRL or CMD + LeftRotate the model left (increase the theta angle of the spherical coordinates)CTRL or CMD + RightRotate the model right (decrease the theta angle of the spherical coordinates)SPACEReset the pivot to the center of the envelopeKEYPAD 2,4,6,8Quick rotation (increase/decrease phi/theta by 30°)CTRL or CMD + LEFT_MOUSEMakes the camera rotate around the modelALT+LEFT_MOUSEBegins Agent Selection using an ROI (Region of Interest)SHIFT+LEFT_MOUSEDraws an ROI on the display, allowing to maintain it across framesSCROLLZoom-in/out to the current target (center of the sphere)WHEEL CLICKReset the pivot to the center of the envelope\n\nKeystone: the keystone allows to modify the location of the 4 corner points of the environment bounding box. It can be use to project a simulation on a physical model as the projector can introduce some image distortions. Press k to enter in keystone mode, ones the keystone is done repress k to copy the facet in the clipboard. You can now paste your keystone value as a facet in the display.\n"},{"filePath":"https:--gama-platform.org--wiki-Documentation.txt","text":"Generation of the documentationTable of contents​\n\nRequirements\n\nConfiguration\nGenerated files location\n\n\nWorkflow to generate wiki files\nWorkflow to generate PDF files\nWorkflow to generate unit tests\nMain internal steps\n\nGenerate wiki files\nGenerate pdf files\nGenerate unit test files\n\n\nHow to document\n\nThe @doc annotation\nthe @example annotation\nHow to document operators\nHow to document statements\nHow to document skills\n\n\nHow to change the processor\nGeneral workflow of file generation\n\nThe GAMA documentation comes in 2 formats: a set of wiki files availaible from the wiki section of the GitHub website and a PDF file. The PDF file is produced from the wiki files.\nIn the wiki files, some are hand-written by the GAMA community and some others are generated automatically from the Java code and the associated java annotations.\nThe section summarizes:\n\nhow to generate this wiki files,\nhow to generate the PDF documentation,\nhow to generate the unit tests from the java annotations,\nhow to add documentation in the java code.\n\nRequirements​\nTo generate automatically the documentation, the GAMA Git version is required. See Install Git version for more details.\nAmong all the GAMA plugins, the following ones are related to documentation generation:\n\nmsi.gama.processor: the java preprocessor is called during java compilation of the various plugins and extract information from the java code and the java annotations. For each plugin it produces the docGAMA.xml file in the gaml directory.\nmsi.gama.documentation: it contains all the java classes needed to gather all the docGAMA.xml files and generate wiki, pdf or unit test files.\n\nIn addition, the folder containing the wiki files is required. In the GitHub architecture, the wiki documentation is stored in a separate Git repository https://github.com/gama-platform/gama.wiki.git. A local clone of this repository should thus be created:\n\nOpen the Git perspective:\n\n\nWindows > Open Perspective > Other...\nChoose Git\n\n\nClick on \"Clone a Git repository\"\n\n\nIn Source Git repository window:\n\nFill in the URI label with: https://github.com/gama-platform/gama.wiki.git\nOther fields will be automatically filled in.\n\n\nIn Branch Selection windows,\n\ncheck the master branch\nNext\n\n\nIn Local Destination windows,\n\nChoose the directory in which the gama Git repository has been cloned\nEverything else should be unchecked\nFinish\n\n\n\n\nIn the Git perspective and the Git Repositories view, Right-Click on \"Working Directory\" inside the gama.wiki repository, and choose \"Import projects\"\n\n\nIn the Select a wizard to use for importing projects window:\n\n\"Import existing projects\" should be checked\n\"Working Directory\" should be selected\n\n\nIn Import Projects window:\n\n**Uncheck \"Search for nested project\" **\nCheck the project gama.wiki\nFinish\n\n\n\n\nGo back to the Java perspective: a gama.wiki plugin should have been added.\n\nIn order to generate the PDF file from the wiki files, we use an external application named Pandoc.\nFollow the Pandoc installation instructions to install it. Specify the path to the pandoc folder in the file \"Constants.java\", in the static constant CMD_PANDOC : \"yourAbsolutePathToPandoc/pandoc\".\nNote that Latex should be installed in order to be able to generate PDF files. Make sure you have already installed Miktex (for OS Windows and Mac). Specify the path to the miktex folder in the file \"Constants.java\", in the static constant CMD_PDFLATEX : \"yourAbsolutePathToMiktex/pdflatex\".\nConfiguration​\nThe location where the files are generated (and other constants used by the generator) are defined in the file msi.gama.documentation/src/msi/gama/doc/util/Constants.java.\nThe use of Pandoc (path to the application and so on) is defined in the file msi.gama.documentation/src/msi/gama/doc/util/ConvertToPDF.java. This should be changed in the future...\nGenerated files location​\nThe generated files are (by default) generated in various locations depending on their type:\n\nwiki files: they are generated in the plugin gama.wiki.\npdf file: they are generated in the plugin msi.gama.documentation, in the folder files/gen/pdf.\nunit test files: they are generated in the plugin msi.gama.models, in the folder models/Tests.\n\nWorkflow to generate wiki files​\nThe typical workflow to generate the wiki files is as follow:\n\nClean and Build all the GAMA projects,\nRun the MainGenerateWiki.java file in the msi.gama.documentation,\nThe wiki files are generated in the gama.wiki plugin.\n\nWorkflow to generate PDF files​\nThe typical workflow to generate the wiki files is as follow:\n\nClean and Build all the GAMA projects,\nIn the file mytemplate.tex, specify the absolute path to your \"gama_style.tex\" (it should be just next to this file)\nRun the MainGeneratePDF.java file in the msi.gama.documentation, accepting all the packages install of latex,\nThe wiki files are generated in the msi.gama.documentation plugin.\n\nNote that generating the PDF takes a lot of time. Please be patient!\nIf you want to update the file \"gama_style.sty\" (for syntax coloration), you have to turn the flag \"generateGamaStyle\" to \"true\" (and make sure the file \"keywords.xml\" is already generated).\nWorkflow to generate unit tests​\nThe typical workflow to generate the wiki files is as follow:\n\nClean and Build all the GAMA projects,\nRun the MainGenerateUnitTest.java file in the msi.gama.documentation,\nThe wiki files are generated in the msi.gama.models plugin.\n\nMain internal steps​\n\nClean and Build all the GAMA projects will create a docGAMA.xml file in the gaml directory of each plugin,\nThe MainGenerateXXX.java files then perform the following preparatory tasks:\n\nthey prepare the gen folder by deleting the existing folders and create all the folders that may contain intermediary generated folders\nthey merge all the docGAMA.xml files in a docGAMAglobal.xml file, created in the files/gen/java2xml folder. Only the plugins that are referred in the product files are merged.\n\n\n\nAfter these common main first steps, each generator (wiki, pdf or unit test) performs specific tasks.\nGenerate wiki files​\n\nThe docGamaglobal.xml is parsed in order to generate 1 wiki file per kind of keyword:\n\noperators,\nstatements,\nskills,\narchitectures,\nbuilt-in species,\nconstants and units.\nin addition an index wiki file containing all the GAML keywords is generated.\n\n\nOne wiki file is generated for each extension plugin, i.e. plugin existing in the Eclipse workspace but not referred in the product.\n\nGenerate pdf files​\nThe pdf generator uses the table of content (toc) file located in the files/input/toc folder (msi.gama.documetation plugin) to organize the wiki files in a pdf file.\n\nMainGeneratePDF.java file parsers the toc file and create the associated PDF file using the wiki files associated to each element of the toc. The generation is tuned using files located in the files/input/pandocPDF folder.\n\nGenerate unit test files​\n\nMainGenerateUnitTest.java creates GAMA model files for each kind of keyword from the docGAMAglobal.xml file.\n\nHow to document​\nThe documentation is generated from the Java code thanks to the Java additional processor, using mainly information from Java classes or methods and from the Java annotations. (see the list of all annotations for more details about annotations).\nThe @doc annotation​\nMost of the annotations can contain a @doc annotation, that can contain the main part of the documentation.\nFor example, the inter (inter) operator is commented using:\n@doc(  value = \"the intersection of the two operands\",  comment = \"both containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.\",  usages = {    @usage(value = \"if an operand is a graph, it will be transformed into the set of its nodes\"),    @usage(value = \"if an operand is a map, it will be transformed into the set of its values\", examples = {      @example(value = \"[1::2, 3::4, 5::6] inter [2,4]\", equals = \"[2,4]\"),      @example(value = \"[1::2, 3::4, 5::6] inter [1,3]\", equals = \"[]\") }),    @usage(value = \"if an operand is a matrix, it will be transformed into the set of the lines\", examples =      @example(value = \"matrix([[1,2,3],[4,5,4]]) inter [3,4]\", equals = \"[3,4]\")) },  examples = {     @example(value = \"[1,2,3,4,5,6] inter [2,4]\", equals = \"[2,4]\"),    @example(value = \"[1,2,3,4,5,6] inter [0,8]\", equals = \"[]\") },  see = { \"remove_duplicates\" })\nThis @docannotation contains 5 parts:\n\nvalue: describes the documented element,\ncomment: a general comment about the documented element,\nusages: a set of ways to use the documented element, each of them being in a @usage annotation. The usage contains mainly a description and set of examples,\nexamples: a set of examples that are not related to a particular usage,\nsee: other related keywords.\n\nthe @example annotation​\nThis annotation contains a particular use example of the documented element. It is also used to generate unit test and patterns.\nThe simplest way to use it:\n@example(value = \"[1::2, 3::4, 5::6] inter [2,4]\", equals = \"[2,4]\")\nIn this example:\n\nvalue contains an example of use of the operator,\nequals contains the expected results of expression in value.\n\nThis will become in the documentation:\nlist var3 <- [1::2, 3::4, 5::6] inter [2,4];    // var3 equals [2,4]\nWhen no variable is given in the annotation, an automatic name is generated. The type of the variable is determined thanks to the return type of the operator with these parameters.\nThis example can also generate a unit test model. In this case, the value in the variable will be compared to the equals part.\nBy default, the @example annotation has the following default values:\n\nisTestOnly = false, meaning that the example will be added to the documentation too,\nisExecutable = true, meaning that content of value can be added in a model and can be compiled (it can be useful to switch it to false, in a documentation example containing name of species that have not been defined),\ntest = true, meaning that the content of value will be tested to the content of equals,\nisPattern = false.\n\nHow to document operators​\nA GAML operator is defined by a Java method annoted by the @operator annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the operators are defined in the plugin msi.gama.core and in the package msi.gaml.operators.\nThe documentation generator will use information from:\n\nthe @operator annotation:\n\nvalue: it provides the name(s) of the operator (if an operator has several names, the other names will be considered as alternative names)\ncategory: it is used to classified the operators in categories\n\n\nthe @doc annotation,\nthe method definition:\n\nthe return value type\nparameters and their type (if the method is static, the IScope attribute is not taken into account)\n\n\n\nHow to document statements​\nA GAML statement is defined by a Java class annoted by the @symbol annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the statements are defined in the plugin msi.gama.core and in the package msi.gaml.statements.\nThe documentation generator will use information from:\n\n@symbol annotation,\n@facets annotation (each facet can contain a documentation in a @doc annotation),\n@inside annotation (where the statement can be used),\n@doc annotation\n\nHow to document skills​\nA GAML skill is defined by a Java class annoted by the @skill annotation (see the list of all annotations for more details about annotations). In the core of GAMA, most of the skills are defined in the plugin msi.gama.core and in the package msi.gaml.skills.\nThe documentation generator will use information from:\n\n@skill annotation,\n@vars annotation (each var can contain a documentation in a @doc annotation),\n@doc annotation\n\nHow to change the processor​\nIf you make some modifications in the plugin processor, you have to rebuild the .jar file associated to the processor to take into account the changes.\nHere are the several steps you have to do:\n\nIn the msi.gama.processor plugin, click on Generate Processor.jardesc (in processor)\nClick on Finish (you can check that msi.gama.processor and ummisco.gama.annotations are checked).\nAccept the warning popup.\nIt should have changed the processor / plugins / msi.gama.processor_1.4.0.jar file.\nRight-click on the folder processor to refresh.\n\nIn case some projects have errors after the update of the processor:\n\nClean and build the projects\nClose Eclipse and reopen it and clean and build the projects\nCheck that Eclipse has been launched with the same JVM as GAMA. To this purpose, have a look at Eclipse  / About Eclipse, Installation details and check the java version (i.e. after the -vm option). If it does not fit with the one used for eclipse  plugin, change it (in  the eclipse.ini file.\n\nThis following diagram explains roughly the workflow for the generation of the different files:\n"},{"filePath":"https:--gama-platform.org--wiki-EditingModels.txt","text":"Editing modelsEditing models in GAMA is very similar to editing programs in a modern IDE like Eclipse. After having successfully launched the program, the user has two fundamental concepts at its disposal: a workspace, which contains models or links to models organized like a hierarchy of files in a filesystem, and the workbench (aka, the main window), which contains the tools to create, modify and experiment these models.\nUnderstanding how to navigate in the workspace is covered in another section and, for the purpose of this section, we just need to understand that it is organized in projects, which contain models and their associated data. Projects are further categorized, in GAMA, into four categories: Models Library, Plugin models, Test models (built-in models shipped with GAMA and automatically linked from the workspace), and User Models.\nThis section covers the following sub-sections:\n\nGAML Editor Generalities\nGAML Editor Toolbar\nValidation of Models\nGraphical Editor\n"},{"filePath":"https:--gama-platform.org--wiki-Ensure-model-reproducibility.txt","text":"Ensure model's reproducibilityThere has been a huge effort made in GAMA development in order to ensure the reproducibility of the simulations, i.e. when several simulations of the same models are launched with the same random generator seed and same parameter values, they are supposed to provide the same results.\nNevertheless, GAMA provides several ways to speed up simulations runs, e.g. by making parallel the execution of some agents' behaviors. The use of parallelism may destroy the reproducibility of the simulations. More generally, there are many sources of uncertainty which can break this reproducibility.\nHow to ensure reproducibility of a model?​\nIf you aim at reproducibility, you need to reduce as much as possible all the sources of uncertainty.\n\nSet the random number generator seed (explicitly set a value to the model's seed global attribute).\nReduce the parallel execution of agents' behaviors.\n\nremove all the explicitly parallel execution, in particular remove / set to false all the parallel facets (e.g. in the loop, ask...).\nSet all of GAMA's settings regarding parallelization to false. You can find them in the Preferences menu, then under the tab Execution at the section Parallelism to disable them globally, or you can set them to false only in your experiment with the corresponding variables as shown belown:\n\n\n\nexperiment 'any exp' {  init {\t//Make grids schedule their agents in parallel\tgama.pref_parallel_grids <- false;\t//Make experiments run simulations in parallel\tgama.pref_parallel_simulations <- true;\t//Make species schedule their agents in parallel\tgama.pref_parallel_species <- false;  }}\n\nDisplays are computed independently of the simulation, and in parallel. Limit computation and model modifications in the aspects.\n\nRemove any modification of the model in the aspects.\nDo not use any random operators in the aspects (e.g. rnd, one_of, any ...).\n\n\nThe use of asynchronous communications (using network) with external applications, the use of files (in particular if they are changed  externally) can also modify the behavior of simulations\nAs a safety measure, you can also set your random number generator to mersenne as others may not have been as much tested for reproducibility\n"},{"filePath":"https:--gama-platform.org--wiki-ErrorsView.txt","text":"Errors ViewWhenever a runtime error, or a warning, is issued by the currently running experiment, a view called \"Errors\" is opened automatically. This view provides, together with the error/warning itself, some contextual information about who raised the error (i.e. which agent(s)) and where (i.e. in which portion of the model code). As with other \"status\" in GAMA, errors will appear in red color and warnings in orange.\nSince an error appearing in the code is likely to be raised by several agents at once, GAMA groups similar errors together, simply indicating which agent(s) raised them. Note that, unless the error is raised by the experiment agent itself, its message will indicate that at least 2 agents raised it: the original agent and the experiment in which it is plunged.\nWhen we unfold the error, to have an idea of its location in the code. In addition clicking on one of the lines should highlight the corresponding line in the code.\n\nOne of the most current (and sometimes the most mysterious) error is linked to an empty agent (with the value nil) on which we want to access to one of its attributes. It is expressed by Cannot evaluate ATTRIBUTE_NAME as the target agent is nil or Java nil. In this case, modelers have to check carefully their codes to be sure that all the agent variables have a not nil value.\n"},{"filePath":"https:--gama-platform.org--wiki-Exhaustive-list-of-GAMA-Keywords.txt","text":"Exhaustive list of GAMA Keywords\nThis file is automatically generated from java files. Do Not Edit It.\n\nOperators​\n-, :, ::, !, !=, ?, /, ., ., ^, @, *, *, +, <, <=, =, >, >=, abs, accumulate, acos, action, add_3Dmodel, add_days, add_edge, add_geometry, add_hours, add_icon, add_minutes, add_months, add_ms, add_node, add_point, add_seconds, add_values, add_weeks, add_years, adjacency, after, agent, agent_closest_to, agent_farthest_to, agent_file, agent_from_geometry, agent_intersecting, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, all_indexes_of, all_match, all_pairs_shortest_path, all_verify, alpha_index, among, and, and, angle_between, antialiased, any, any_location_in, any_point_in, append_horizontally, append_vertically, arc, around, as, as_4_grid, as_distance_graph, as_driving_graph, as_edge_graph, as_grid, as_hexagonal_grid, as_int, as_intersection_graph, as_json_string, as_map, as_matrix, as_path, as_spatial_graph, asin, at, at_distance, at_location, atan, atan2, attributes, auto_correlation, BDIPlan, before, beta, beta_index, between, betweenness_centrality, biggest_cliques_of, binomial, binomial_coeff, binomial_complemented, binomial_sum, blend, blend, blurred, bool, box, brewer_colors, brewer_palettes, brighter, buffer, build, capitalize, cartesian_product, ceil, cell_at, cells_in, cells_overlapping, centroid, char, chi_square, chi_square_complemented, choose, circle, clean, clean_network, clipped_with, closest_points_with, closest_to, collect, column_at, columns_list, command, cone, cone3D, connected_components_of, connectivity_index, container, contains, contains_all, contains_any, contains_edge, contains_key, contains_node, contains_value, contains_vertex, conversation, convex_hull, copy, copy_between, copy_file, copy_from_clipboard, copy_to_clipboard, copy_to_clipboard, correlation, cos, cos_rad, count, covariance, covering, covers, create_map, cropped_to, cross, crosses, crossing, crs, CRS_transform, csv_file, cube, curve, cylinder, darker, date, dbscan, dead, degree_of, delete_file, det, determinant, diff, diff2, directed, direction_between, direction_to, directory, disjoint_from, distance_between, distance_to, distinct, distribution_of, distribution2d_of, div, dnorm, dtw, durbin_watson, dxf_file, edge, edge_between, edge_betweenness, edges, eigenvalues, electre_DM, ellipse, elliptical_arc, emotion, empty, enlarged_by, enter, envelope, eval_gaml, eval_when, evaluate_sub_model, even, every, every_cycle, evidence_theory_DM, exp, exp_density, exp_rnd, fact, farthest_point_to, farthest_to, field, field_with, file, file_exists, first, first_of, first_with, flatten, flip, float, floor, folder, folder_exists, font, frequency_of, from, fuzzy_choquet_DM, fuzzy_kappa, fuzzy_kappa_sim, gaml_file, gaml_type, gamma, gamma_density, gamma_distribution, gamma_distribution_complemented, gamma_index, gamma_rnd, gamma_trunc_rnd, gauss, gauss_rnd, generate_barabasi_albert, generate_complete_graph, generate_pedestrian_network, generate_random_graph, generate_terrain, generate_watts_strogatz, geojson_file, geometric_mean, geometry, geometry_collection, get, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, gif_file, gini, girvan_newman_clustering, gml_file, gradient, graph, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grayscale, grayscale, grid_at, grid_cells_to_graph, grid_file, group_by, harmonic_mean, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, hexagon, hierarchical_clustering, horizontal, horizontal_flip, hsb, hypot, IDW, image, image_file, in, in_degree_of, in_edges_of, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, indented_by, index_by, index_of, inside, int, inter, interleave, internal_integrated_value, intersecting, intersection, intersects, inverse, inverse_distance_weighting, inverse_rotation, is, is_agent, is_csv, is_dxf, is_error, is_finite, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_number, is_obj, is_osm, is_pgm, is_property, is_reachable, is_shape, is_simulation, is_skill, is_svg, is_text, is_threeds, is_warning, is_xml, json_file, k_nearest_neighbors, k_spanning_tree_clustering, kappa, kappa_sim, kmeans, kml, kurtosis, label_propagation_clustering, last, last_index_of, last_of, last_with, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, length, lgamma, line, link, list, list_with, ln, load_shortest_paths, load_sub_model, log, log_gamma, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, lower_case, main_connected_component, map, masked_by, matrix, matrix, matrix_with, max, max_flow_between, max_of, maximal_cliques_of, mean, mean_deviation, mean_of, median, mental_state, message, milliseconds_between, min, min_of, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_seconds, minus_weeks, minus_years, mod, moment, months_between, moran, morrisAnalysis, mul, nb_cycles, neighbors_at, neighbors_of, new_emotion, new_folder, new_mental_state, new_predicate, new_social_link, node, nodes, none_matches, none_verifies, norm, Norm, normal_area, normal_density, normal_inverse, normalized_rotation, not, not, obj_file, of, of_generic_species, of_species, one_matches, one_of, one_verifies, or, or, osm_file, out_degree_of, out_edges_of, overlapping, overlaps, pair, palette, partially_overlapping, partially_overlaps, path, path_between, path_to, paths_between, pbinom, pchisq, percent_absolute_deviation, percentile, pgamma, pgm_file, plan, play_sound, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_seconds, plus_weeks, plus_years, pnorm, point, points_along, points_at, points_in, points_on, poisson, polygon, polyhedron, polyline, polyplan, predecessors_of, predicate, predict, product, product_of, promethee_DM, property_file, pValue_for_fStat, pValue_for_tStat, pyramid, quantile, quantile_inverse, range, rank_interpolated, read, rectangle, reduced_by, regex_matches, regression, remove_duplicates, remove_node_from, rename_file, replace, replace_regex, residuals, reverse, rewire_n, rgb, rgb, rms, rnd, rnd_choice, rnd_color, rotated_by, rotated_by, rotation_composition, round, row_at, rows_list, rSquare, sample, Sanction, scale, scaled_by, scaled_to, select, serialize, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, set_z, shape_file, sharpened, shuffle, signum, simple_clustering_by_distance, simple_clustering_by_envelope_distance, simplification, simulation_file, sin, sin_rad, since, skeletonize, skew, skew_gauss, skewness, skill, smooth, snapshot, sobolAnalysis, social_link, solid, sort, sort_by, source_of, spatial_graph, species, species_of, sphere, split, split_at, split_geometry, split_in, split_lines, split_using, split_with, sqrt, square, squircle, stack, standard_deviation, step_sub_model, strahler, string, student_area, student_t_inverse, subtract_days, subtract_hours, subtract_minutes, subtract_months, subtract_ms, subtract_seconds, subtract_weeks, subtract_years, successors_of, sum, sum_of, svg_file, t_test, tan, tan_rad, tanh, target_of, teapot, text_file, TGauss, threeds_file, tinted_with, to, to_GAMA_CRS, to_gaml, to_geojson, to_hsb, to_list, to_rectangles, to_segments, to_squares, to_sub_geometries, to_triangles, tokenize, topology, touches, touching, towards, trace, transformed_by, translated_by, translated_to, transpose, triangle, triangulate, truncated_gauss, type_of, undirected, union, unknown, until, unzip, upper_case, use_cache, user_confirm, user_input_dialog, using, values_in, variance, variance_of, vertical, vertical_flip, voronoi, weibull_density, weibull_rnd, weibull_trunc_rnd, weight_of, weighted_means_DM, where, with_height, with_k_shortest_path_algorithm, with_max_of, with_min_of, with_precision, with_shortest_path_algorithm, with_size, with_size, with_style, with_values, with_weights, with_width, without_holes, wizard, wizard_page, writable, xml_file, xor, years_between, zip,\n\nStatements​\n=, abort, action, add, agents, annealing, ask, aspect, assert, benchmark, betad, break, browse, camera, capture, catch, category, chart, conscious_contagion, continue, coping, create, data, datalist, default, diffuse, diffusion, display, display_grid, do, draw, else, emotional_contagion, enforcement, enter, equation, error, event, exit, experiment, exploration, focus, focus_on, genetic, global, graphics, grid, highlight, hill_climbing, if, image_layer, init, inspect, invoke, law, layout, let, light, loop, match, match_between, match_one, match_regex, mesh, migrate, monitor, morris, norm, output, output_file, overlay, parameter, perceive, permanent, plan, pso, put, reactive_tabu, reflex, release, remove, restore, return, rotation, rule, rule, run, sanction, save, set, setup, sobol, socialize, solve, species, species_layer, start_simulation, state, status, stochanalyse, switch, tabu, task, test, text, trace, transition, try, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write,\n\nArchitectures​\nfsm, parallel_bdi, probabilistic_tasks, reflex, rules, simple_bdi, sorted_tasks, user_first, user_last, user_only, weighted_tasks,\n\nConstants and colors​\n#µm (#micrometer,#micrometers), #AdamsBashforth, #AdamsMoulton, #ambient, #AStar, #BellmannFord, #Bhandari, #BidirectionalDijkstra, #bold, #bottom_center, #bottom_left, #bottom_right, #camera_location, #camera_orientation, #camera_target, #center, #CHBidirectionalDijkstra, #cl (#centiliter,#centiliters), #cm (#centimeter,#centimeters), #current_error, #custom, #cycle (#cycles), #day (#d,#days), #DeltaStepping, #Dijkstra, #direction, #display_height, #display_width, #dl (#deciliter,#deciliters), #dm (#decimeter,#decimeters), #DormandPrince54, #dp853, #e, #epoch, #Eppstein, #Euler, #flat, #FloydWarshall, #foot (#feet,#ft), #from_above, #from_front, #from_left, #from_right, #from_up_front, #from_up_left, #from_up_right, #fullscreen, #Gill, #GraggBulirschStoer, #gram (#grams), #h (#hour,#hours), #hidpi, #HighamHall54, #hl (#hectoliter,#hectoliters), #horizontal, #inch (#inches), #infinity, #iso_local, #iso_offset, #iso_zoned, #isometric, #italic, #kg (#kilo,#kilogram,#kilos), #km (#kilometer,#kilometers), #l (#liter,#liters,#dm3), #left_center, #longton (#lton), #Luther, #m (#meter,#meters), #m2, #m3, #max_float, #max_int, #Midpoint, #mile (#miles), #min_float, #min_int, #minute (#minutes,#mn), #mm (#milimeter,#milimeters), #month (#months), #msec (#millisecond,#milliseconds,#ms), #nan, #NBAStar, #NBAStarApprox, #nm (#nanometer,#nanometers), #none, #now, #ounce (#oz,#ounces), #pi, #pixels (#px), #plain, #point, #pound (#lb,#pounds,#lbm), #right_center, #rk4, #round, #sec (#second,#seconds,#s), #shortton (#ston), #split, #spot, #sqft (#square_foot,#square_feet), #sqin (#square_inch,#square_inches), #sqmi (#square_mile,#square_miles), #square, #stack, #stone (#st), #Suurballe, #ThreeEighthes, #to_deg, #to_rad, #ton (#tons), #top_center, #top_left, #top_right, #TransitNodeRouting, #user_location, #vertical, #week (#weeks), #yard (#yards), #year (#years,#y), #Yen, #zoom,\n\nSkills​\nadvanced_driving, dynamic_body, fipa, messaging, moving, moving3D, network, pedestrian, pedestrian_road, skill_road, skill_road_node, SQLSKILL, static_body, thread,\n\nSpecies​\nagent, AgentDB, base_edge, experiment, graph_edge, graph_node, physical_world,\nworld\n\nActions​\ninit, step, isConnected, close, timeStamp, connect, testConnection, select, executeUpdate, getParameter, setParameter, insert, update_outputs, compact_memory, related_to, register, advanced_follow_driving, ready_to_cross, test_next_road, compute_path, path_from_nodes, drive_random, drive, on_entering_new_road, external_factor_impact, unregister, speed_choice, lane_choice, choose_lane, force_move, goto_drive, apply, start_conversation, send, reply, accept_proposal, agree, cancel, cfp, end_conversation, failure, inform, propose, query, refuse, reject_proposal, request, subscribe, send, wander, move, follow, goto, move, execute, connect, fetch_message, has_more_message, join_group, leave_group, fetch_message_from_network, walk_to, compute_virtual_path, release_path, walk, initialize, build_intersection_areas, build_exit_hub, register, unregister, testConnection, executeUpdate, insert, select, list2Matrix, update_body, contact_added_with, contact_removed_with, run_thread, end_thread, thread_action,\n\nVariables​\nspeed, real_speed, acceleration, current_path, final_target, current_target, current_index, targets, security_distance_coeff, safety_distance_coeff, min_security_distance, min_safety_distance, current_lane, lowest_lane, num_lanes_occupied, vehicle_length, speed_coeff, max_speed, time_headway, max_acceleration, max_deceleration, delta_idm, politeness_factor, max_safe_deceleration, acc_gain_threshold, acc_bias, lane_change_cooldown, time_since_lane_change, ignore_oneway, violating_oneway, current_road, next_road, on_linked_road, using_linked_road, allowed_lanes, linked_lane_limit, lane_change_limit, proba_lane_change_up, proba_lane_change_down, proba_use_linked_road, proba_respect_priorities, proba_respect_stops, proba_block_node, right_side_driving, distance_to_goal, distance_to_current_target, segment_index_on_road, leading_vehicle, leading_distance, leading_speed, follower, damping, angular_damping, contact_damping, angular_velocity, velocity, conversations, accept_proposals, agrees, cancels, cfps, failures, informs, proposes, queries, refuses, reject_proposals, requests, requestWhens, subscribes, mailbox, location, speed, heading, current_path, current_edge, real_speed, destination, speed, heading, pitch, roll, destination, network_name, network_groups, network_server, shoulder_length, minimal_distance, pedestrian_consideration_distance, obstacle_consideration_distance, avoid_other, obstacle_species, pedestrian_species, proba_detour, A_pedestrians_SFM, A_obstacles_SFM, B_pedestrians_SFM, B_obstacles_SFM, k_SFM, kappa_SFM, relaxion_SFM, gama_SFM, lambda_SFM, n_SFM, n_prime_SFM, pedestrian_model, velocity, forces, final_waypoint, current_waypoint, current_index, waypoints, roads_waypoints, use_geometry_waypoint, tolerance_waypoint, agents_on, free_space, road_status, intersection_areas, linked_pedestrian_roads, exit_nodes, agents_on, all_agents, source_node, target_node, num_lanes, num_segments, linked_road, maxspeed, segment_lengths, vehicle_ordering, roads_in, priority_roads, roads_out, stop, block, mass, rotation, friction, restitution, aabb,\n\nPseudo-Variables​\nself, myself, each\n\nTypes​\naction, agent, attributes, BDIPlan, bool, container, conversation, date, directory, emotion, field, file, float, font, gaml_type, geometry, graph, image, int, kml, list, map, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, string, topology, unknown,\n\nthe world​\ntorus, Environment Size,\nworld, time\ncycle, step,\ntime, duration,\ntotal_duration\naverage_duration,\nmachine_time,\nagents, stop,\nhalt, pause,\nscheduling\n\nGrid​\ngrid_x, grid_y, agents,\ncolor, grid_value\n\nOther concepts​\nscheduling, step, Key concepts,\nObject-oriented paradigm to GAML, Correspondence GAML and Netlogo"},{"filePath":"https:--gama-platform.org--wiki-ExperimentsUserInterface.txt","text":"Experiments User InterfaceAs soon as an experiment is launched, the modeler is facing a new environment (with different menus and views) called the Simulation Perspective). The Navigator is still available in this perspective (below the parameter view), though, and it is still possible to edit models in it, but it is considered as good practice to use each perspective for what it has been designed for: editing models in the Modeling perspective and running simulations in the Simulation perspective. Switching perspectives is easy. The small button in the top-left corner of the window allows to switch back and forth the two perspectives.\n\nThe actual contents of the simulation perspective will depend on the experiment being run and the outputs it defines. The next sections will present the most common ones (inspectors, monitors and displays), as well as the views that are not defined in outputs, like the Parameters or Errors view. An overview of the menus and commands specific to the simulation perspective is also available."},{"filePath":"https:--gama-platform.org--wiki-ExploringModels.txt","text":"Exploring ModelsWe just learnt how to launch GUI Experiments from GAMA. A GUI Experiment will start with a particular set of input, compute several outputs, and will stop at the end (if asked).\nIn order to explore models (by automatically running the Experiment using several configurations to analyze the outputs), a first approach is to run several simulations from the same experiment, considering each simulation as an agent. A second approach, much more efficient for larger explorations, is to run an other type of experiment : the Batch Experiment.\nWe will start this part by learning how to run several simulations from the same experiment. Then, we will see how batch experiments work, and we will focus on how to use those batch experiments to explore models by using exploration methods."},{"filePath":"https:--gama-platform.org--wiki-Expressions.txt","text":"ExpressionsExpressions in GAML are the value part of the statements' facets. They represent or compute data that will be used as the value of the facet when the statement will be executed.\nAn expression can be either a literal, a unit, a constant, a variable, an attribute or the application of one or several operators to compose a complex expression."},{"filePath":"https:--gama-platform.org--wiki-FileTypes.txt","text":"File TypesGAMA provides modelers with a generic type for files called file. It is possible to load a file using the file operator:\nfile my_file <- file(\"../includes/data.csv\");\nHowever, internally, GAMA makes the difference between the different types of files.\nIndeed, for instance:\nglobal {\tinit {\t\tfile my_file <- file(\"../includes/data.csv\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nsepallengthsepalwidthpetallengthpetalwidthtype5.13.51.40.2Iris-setosa4.93.01.40.2Iris-setosa...\nIndeed, the content of CSV file is a matrix: each row of the matrix is a line of the file; each column of the matrix is value delimited by the separator (by default \",\").\nIn contrary:\nglobal {\tinit {\t\tfile my_file <- file(\"../includes/data.shp\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nPolygonPolygonPolygonPolygonPolygonPolygonPolygon\nThe content of a shapefile is a list of geometries corresponding to the objects of the shapefile.\nIn order to know how to load a file, GAMA analyzes its extension. For instance for a file with a \".csv\" extension, GAMA knows that the file is a csv one and will try to split each line with the , separator. However, if the modeler wants to split each line with a different separator (for instance ;) or load it as a text file, he/she will have to use a specific file operator.\nIndeed, GAMA integrates specific operators corresponding to different types of files.\nTable of contents​\n\nFile Types\n\nText File\n\nExtensions\nContent\nOperators\n\n\nCSV File\n\nExtensions\nContent\nOperators\n\n\nShapefile\n\nExtensions\nContent\nOperators\n\n\nOSM File\n\nExtensions\nContent\nOperators\n\n\nGrid File\n\nExtensions\nContent\nOperators\n\n\nImage File\n\nExtensions\nContent\nOperators\n\n\nSVG File\n\nExtensions\nContent\nOperators\n\n\nProperty File\n\nExtensions\nContent\nOperators\n\n\nR File\n\nExtensions\nContent\nOperators\n\n\n3DS File\n\nExtensions\nContent\nOperators\n\n\nOBJ File\n\nExtensions\nContent\nOperators\n\n\n\n\n\nText File​\nExtensions​\nHere the list of possible extensions for text file:\n\n\"txt\"\n\"data\"\n\"csv\"\n\"text\"\n\"tsv\"\n\"xml\"\n\nNote that when trying to define the type of a file with the default file loading operator (file), GAMA will first try to test the other type of file. For example, for files with \".csv\" extension, GAMA will cast them as csv file and not as text file.\nContent​\nThe content of a text file is a list of string corresponding to each line of the text file.\nFor example:\nglobal {\tinit {\t\tfile my_file <- text_file(\"../includes/data.txt\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nsepallength,sepalwidth,petallength,petalwidth,type5.1,3.5,1.4,0.2,Iris-setosa4.9,3.0,1.4,0.2,Iris-setosa4.7,3.2,1.3,0.2,Iris-setosa\nOperators​\nList of operators related to text files:\n\ntext_file(string path): load a file (with an authorized extension) as a text file.\ntext_file(string path, list content): load a file (with an authorized extension) as a text file and fill it with the given content.\nis_text(op): tests whether the operand is a text file\n\nCSV File​\nExtensions​\nHere the list of possible extensions for csv file:\n\n\"csv\"\n\"tsv\"\n\nContent​\nThe content of a csv file is a matrix of objects: each row of the matrix is a line of the file; each column of the matrix is values delimited by the separator. By default, the delimiter is the \",\" and the datatype depends on the dataset.\nFor example:\nglobal {\tinit {\t\tfile my_file <- csv_file(\"../includes/data.csv\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nsepallengthsepalwidthpetallengthpetalwidthtype5.13.51.40.2Iris-setosa4.93.01.40.2Iris-setosa...\nTo manipulate easily the data, we can consider the contents of the data file, that is a matrix.\nAs  an example, we can access the number of lines and columns of a data file named my_file with my_file.contents.dimension.\nOperators​\nThere are many operators available to load a csv_file.\n\ncsv_file(string path): load a file (with an authorized extension) as a csv file with default separator (\",\"), and no assumption on the type of data.\ncsv_file(string path,bool header)\": load a file as a CSV file with the default separator (coma), with specifying if the model has a header or not (boolean), and no assumption on the type of data.\ncsv_file(string path, string separator): load a file (with an authorized extension) as a csv file with the given separator, without making any assumption on the type of data. Headers should be detected automatically if they exist.\n\nfile my_file <- csv_file(\"../includes/data.csv\", \";\");\n\ncsv_file(string path, string separator, bool header): load a file (with an authorized extension) as a csv file, specifying (1) the separator used; (2) if the model has a header or not, without making any assumption on the type of data.\ncsv_file(string path, string separator, string text_qualifier, bool header): load a file as a csv file\tspecifying (1) the separator used; (2) the text qualifier used; (3) if the model has a header or not, without making any assumption on the type of data\",\ncsv_file(string path, string separator, type datatype): load a file as a csv file specifying a given separator, no header, and the type of data. No text qualifier will be used.\n\nfile my_file <- csv_file(\"../includes/data.csv\", \";\", int);\n\ncsv_file(string path, string separator, string text_qualifier, type datatype): load a file as a csv file specifying the separator, text qualifier to use, and the type of data to read.  Headers should be detected automatically if they exist.\ncsv_file(string path, string separator, type datatype, bool header): load a file as a csv file specifying the given separator, the type of data, with specifying if the model has a header or not (boolean). No text qualifier will be used\".\ncsv_file(string path, string separator, type datatype, bool header, point dimensions): load a file as a csv file specifying a given separator, the type of data, with specifying the number of cols and rows taken into account. No text qualifier will be used.\ncsv_file(string path, matrix content): This file constructor allows to store a matrix in a CSV file (it does not save it - just store it in memory)\n\nFinally, it is possible to check whether a file is a csv file:\n\nis_csv(op): tests whether the operand is a csv file\n\nShapefile​\nShapefiles are classical GIS data files. A shapefile is not simple file, but a set of several files (source: wikipedia):\n\nMandatory files :\n\n.shp - shape format; the feature geometry itself\n.shx - shape index format; a positional index of the feature geometry to allow seeking forwards and backwards quickly\n.dbf - attribute format; columnar attributes for each shape, in dBase IV format\n\n\nOptional files :\n\n.prj - projection format; the coordinate system and projection information, a plain text file describing the projection using well-known text format\n.sbn and .sbx - a spatial index of the features\n.fbn and .fbx - a spatial index of the features for shapefiles that are read-only\n.ain and .aih - an attribute index of the active fields in a table\n.ixs - a geocoding index for read-write shapefiles\n.mxs - a geocoding index for read-write shapefiles (ODB format)\n.atx - an attribute index for the .dbf file in the form of shapefile.columnname.atx (ArcGIS 8 and later)\n.shp.xml - geospatial metadata in XML format, such as ISO 19115 or other XML schema\n.cpg - used to specify the code page (only for .dbf) for identifying the character encoding to be used\n\n\n\nMore details about shapefiles can be found here.\nExtensions​\nHere the list of possible extension for shapefile:\n\n\"shp\"\n\nContent​\nThe content of a shapefile is a list of geometries corresponding to the objects of the shapefile.\nFor example:\nglobal {\tinit {\t\tfile my_file <- shape_file(\"../includes/data.shp\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nPolygonPolygonPolygonPolygonPolygonPolygonPolygon...\nNote that the attributes of each object of the shapefile are stored in their corresponding GAMA geometry. The operator \"get\" (or \"read\") allows to get the value of corresponding attributes.\nFor example:\nfile my_file <- shape_file(\"../includes/data.shp\");write \"my_file: \" + my_file.contents;loop el over: my_file {\twrite (el get \"TYPE\");}\nOperators​\nList of operators related to shapefiles:\n\nshape_file(string path): load a file (with an authorized extension) as a shapefile with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).\nshape_file(string path, string code): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)\nshape_file(string path, int EPSG_ID): load a file (with an authorized extension) as a shapefile with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)\n\nfile my_file <- shape_file(\"../includes/data.shp\", \"EPSG:32601\");\n\nshape_file(string path, list content): load a file (with an authorized extension) as a shapefile and fill it with the given content.\nis_shape(op): tests whether the operand is a shapefile\n\nOSM File​\nOSM (Open Street Map) is a collaborative project to create a free editable map of the world. The data produced in this project (OSM File)  represent physical features on the ground (e.g., roads or buildings) using tags attached to its basic data structures (its nodes, ways, and relations). Each tag describes a geographic attribute of the feature being shown by that specific node, way or relation (source: openstreetmap.org).\nMore details about OSM data can be found here.\nExtensions​\nHere the list of possible extension for shapefile:\n\n\"osm\"\n\"pbf\"\n\"bz2\"\n\"gz\"\n\nContent​\nThe content of an OSM data is a list of geometries corresponding to the objects of the OSM file.\nFor example:\nglobal {\tinit {\t\tfile my_file <- osm_file(\"../includes/data.gz\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nPointPointPointPointPointLineStringLineStringPolygonPolygonPolygon...\nNote that like for shapefiles, the attributes of each object of the osm file is stored in their corresponding GAMA geometry. The operator \"get\" (or \"read\") allows to get the value of corresponding attributes.\nOperators​\nList of operators related to osm file:\n\nosm_file(string path): load a file (with an authorized extension) as an osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, all the nodes and ways of the OSM file will become a geometry.\nosm_file(string path, string code): load a file (with an authorized extension) as an osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will become a geometry.\nosm_file(string path, int EPSG_ID): load a file (with an authorized extension) as an osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, all the nodes and ways of the OSM file will become a geometry.\n\nfile my_file <- osm_file(\"../includes/data.gz\", \"EPSG:32601\");\n\nosm_file(string path, map filter): load a file (with an authorized extension) as an osm file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference). In this case, only the elements with the defined values are loaded from the file.\n\n//map used to filter the object to build from the OSM file according to attributes. map filtering <- map([\"highway\"::[\"primary\", \"secondary\", \"tertiary\", \"motorway\", \"living_street\",\"residential\", \"unclassified\"], \"building\"::[\"yes\"]]);//OSM file to loadfile<geometry> osmfile <-  file<geometry (osm_file(\"../includes/rouen.gz\", filtering))  ;\n\nosm_file(string path, map filter, string code): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.\nosm_file(string path, map filter, int EPSG_ID): load a file (with an authorized extension) as a osm file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/). In this case, only the elements with the defined values are loaded from the file.\nis_osm(op): tests whether the operand is a osm file\n\nGrid File​\nEsri ASCII Grid files are classic text raster GIS data.\nMore details about Esri ASCII grid file can be found here.\nNote that grid files can be used to initialize a grid species. The number of rows and columns will be read from the file. Similarly, the values of each cell contained in the grid file will be accessible through the grid_value attribute.\ngrid cell file: grid_file {}\nExtensions​\nHere the list of possible extension for grid file:\n\n\"asc\"\n\nContent​\nThe content of a grid file is a list of geometries corresponding to the cells of the grid.\nFor example:\nglobal {\tinit {\t\tfile my_file <- grid_file(\"../includes/data.asc\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nPolygonPolygonPolygonPolygonPolygonPolygonPolygon...\nNote that the values of each cell of the grid file is stored in their corresponding GAMA geometry (grid_value attribute). The operator \"get\" (or \"read\") allows to get the value of this attribute.\nFor example:\nfile my_file <- grid_file(\"../includes/data.asc\");write \"my_file: \" + my_file.contents;loop el over: my_file {\twrite el get \"grid_value\";}\nOperators​\nList of operators related to shapefiles:\n\ngrid_file(string path): load a file (with an authorized extension) as a grid file with default projection (if a prj file is defined, use it, otherwise use the default projection defined in the preference).\ngrid_file(string path, string code): load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the code. For a list of the possible projections see: http://spatialreference.org/ref/)\ngrid_file(string path, int EPSG_ID): load a file (with an authorized extension) as a grid file with the given projection (GAMA will automatically decode the epsg code. For a list of the possible projections see: http://spatialreference.org/ref/)\n\nfile my_file <- grid_file(\"../includes/data.shp\", \"EPSG:32601\");\n\nis_grid(op): tests whether the operand is a grid file.\n\nImage File​\nExtensions​\nHere the list of possible extensions for image file:\n\n\"tif\"\n\"tiff\"\n\"jpg\"\n\"jpeg\"\n\"png\"\n\"gif\"\n\"pict\"\n\"bmp\"\n\nContent​\nThe content of an image file is a matrix of int: each pixel is a value in the matrix.\nFor example:\nglobal {\tinit {\t\tfile my_file <- image_file(\"../includes/DEM.png\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\n-9671572-9671572-9671572-9671572-9934744-9934744-9868951-9868951-10000537-10000537...\nOperators​\nList of operators related to csv files:\n\nimage_file(string path): load a file (with an authorized extension) as an image file.\nimage_file(string path, matrix content): load a file (with an authorized extension) as an image file and fill it with the given content.\nis_image(op): tests whether the operand is an image file\n\nSVG File​\nScalable Vector Graphics (SVG) is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation. Note that interactivity and animation features are not supported in GAMA.\nMore details about SVG file can be found here.\nExtensions​\nHere the list of possible extension for SVG file:\n\n\"svg\"\n\nContent​\nThe content of a SVG file is a list of geometries.\nFor example:\nglobal {\tinit {\t\tfile my_file <- svg_file(\"../includes/data.svg\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nPolygon\nOperators​\nList of operators related to svg files:\n\nshape_file(string path): load a file (with an authorized extension) as a SVG file.\nshape_file(string path, point size): load a file (with an authorized extension) as a SVG file with the given size:\n\nfile my_file <- svg_file(\"../includes/data.svg\", {5.0,5.0});\n\nis_svg(op): tests whether the operand is a SVG file\n\nProperty File​\nExtensions​\nHere the list of possible extensions for property file:\n\n\"properties\"\n\nContent​\nThe content of a property file is a map of string corresponding to the content of the file.\nFor example:\nglobal {\tinit {\t\tfile my_file <- property_file(\"../includes/data.properties\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwith the given property file:\nsepallength = 5.0sepalwidth = 3.0petallength = 4.0petalwidth = 2.5type = Iris-setosa\nwill give:\n3.04.05.0Iris-setosa2.5\nOperators​\nList of operators related to text files:\n\nproperty_file(string path): load a file (with an authorized extension) as a property file.\nis_property(op): tests whether the operand is a property file\n\nR File​\nR is a free software environment for statistical computing and graphics. GAMA allows to execute R script (if R is installed on the computer).\nMore details about R can be found here.\nNote that GAMA also integrates some operators to manage R scripts:\n\nR_compute\nR_compute_param\n\nExtensions​\nHere the list of possible extensions for R file:\n\n\"r\"\n\nContent​\nThe content of a R file corresponds to the results of the application of the script contained in the file.\nFor example:\nglobal {\tinit {\t\tfile my_file <- R_file(\"../includes/data.r\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\n3.0\nOperators​\nList of operators related to R files:\n\nR_file(string path): load a file (with an authorized extension) as a R file.\nis_R(op): tests whether the operand is a R file.\n\n3DS File​\n3DS is one of the file formats used by the Autodesk 3ds Max 3D modeling, animation and rendering software. 3DS files can be used in GAMA to load 3D geometries.\nMore details about 3DS file can be found here.\nExtensions​\nHere the list of possible extension for 3DS file:\n\n\"3ds\"\n\"max\"\n\nContent​\nThe content of a 3DS file is a list of geometries.\nFor example:\nglobal {\tinit {\t\tfile my_file <- threeds_file(\"../includes/data.3ds\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nPolygon\nOperators​\nList of operators related to 3ds files:\n\nthreeds_file(string path): load a file (with an authorized extension) as a 3ds file.\nis_threeds(op): tests whether the operand is a 3DS file\n\nOBJ File​\nOBJ file is a geometry definition file format first developed by Wavefront Technologies for its Advanced Visualizer animation package. The file format is open and has been adopted by other 3D graphics application vendors.\nMore details about Obj file can be found here.\nExtensions​\nHere the list of possible extension for OBJ files:\n\n\"obj\"\n\nContent​\nThe content of a OBJ file is a list of geometries.\nFor example:\nglobal {\tinit {\t\tfile my_file <- obj_file(\"../includes/data.obj\");\t\tloop el over: my_file {\t\t\twrite el;\t\t}\t}}\nwill give:\nPolygon\nOperators​\nList of operators related to obj files:\n\nobj_file(string path): load a file (with an authorized extension) as a obj file.\nis_obj(op): tests whether the operand is a OBJ file\n"},{"filePath":"https:--gama-platform.org--wiki-G__GraphicalEditor.txt","text":"The Graphical EditorThe graphical editor allows defining a GAMA model through a graphical interface (gadl files). It is based on the Graphiti Eclipse plugin. It allows as well to produce a graphical model (diagram) from a gaml model. A tutorial is available here.\n\nInstalling the graphical editor​\nUsing the graphical editor requires to install the graphical modeling plug-in. See here for information about plug-ins and their installation.\nThe graphical editor plug-in is called Graphical_modeling and is directly available from the GAMA update site http://updates.gama-platform.org/graphical_modeling/1.9.0\nNote that the graphical editor is still under development. Updates of the plug-in will be added to the GAMA website. After installing the plug-in (and periodically), check for updates for this plug-in: in the \"Help\" menu, choose \"Check for Updates\" and install the proposed updates for the graphical modeling plug-in.\nCreating a first model​\nA new diagram can be created in a new GAMA project. First, right-click on a project, then select \"New\" on the contextual menu.\nIn the New Wizard, select \"GAMA -> Model Diagram\", then \"Next>\"\n\nIn the next Wizard dialog, select the type of diagram (Empty, Skeleton or Example) then the name of the file and the author.\n\nSkeleton and Example diagram types allow to add to the diagram some basic features.\nStatus of models in editors​\nSimilarly to GAML editor, the graphical editor proposes a live display of errors and model statuses. A graphical model can actually be in three different states, which are visually accessible above the editing area: Functional (orange color), Experimentable (green color) and InError (red color). See the section on model validation for more precise information about these statuses.\nIn its initial state, a model is always in the Functional state, which means it compiles without problems, but cannot be used to launch experiments. The InError state occurs when the file contains errors (syntactic or semantic ones).\nReaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow the modeler to launch this experiment on your model.\nExperiment buttons are updated in real-time to reflect what's in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.\nDiagram definition framework​\nThe following figure presents the editing framework:\n\nFeatures​\nagents​\nspecies​\n\nThe species feature allows the modeler to define a species with a continuous topology. A species is always a micro-species of another species. The top-level (macro-species of all species) is the world species.\n\nsource: a species (macro-species)\ntarget: -\n\n\ngrid​\n\nThe grid feature allows the modeler to define a species with a grid topology. A grid is always a micro-species of another species.\n\nsource: a species (macro-species)\ntarget: -\n\n\nInheriting link​\nThe inheriting link feature allows the modeler to define an inheriting link between two species.\n\nsource: a species (parent)\ntarget: a species (child)\n\n\nworld​\n\nWhen a model is created, a world species is always defined. It represents the global part of the model. The world species, which is unique, is the top-level species. All other species are micro-species of the world species.\n\nagent features​\naction​\n\nThe action feature allows the modeler to define an action for a species.\n\nsource: a species (owner of the action)\ntarget: -\n\n\nreflex​\n\nThe reflex feature allows the modeler to define a reflex for a species.\n\nsource: a species (owner of the reflex)\ntarget: -\n\n\naspect​\n\nThe aspect feature allows the modeler to define an aspect for a species.\n\nsource: a species (owner of the aspect)\ntarget: -\n\n\n\nequation​\n\nThe equation feature allows the modeler to define an equation for a species.\n\nsource: a species (owner of the equation)\ntarget: -\n\nexperiment​\nGUI experiment​\n\nThe GUI Experiment feature allows the modeler to define a GUI experiment.\n\nsource: world species\ntarget: -\n\n\ndisplay​\n\nThe display feature allows the modeler to define a display.\n\nsource: GUI experiment\ntarget: -\n\n\n\nbatch experiment​\n\nThe Batch Experiment feature allows the modeler to define a Batch experiment.\n\nsource: world species\ntarget: -\n\nBDI Architecture​\nPlan​\n\nThe Plan feature allows the modeler to define a plan for a BDI species, i.e. a sequence of statements that will be executed in order to fulfill a particular intention.\n\nsource:  a species with a BDI architecture\ntarget: -\ns\n\nRule​\n\nThe Rule feature allows the modeler to define a rule for a BDI species, i.e. a function executed at each iteration to infer new desires or beliefs from the agent's current beliefs and desires.\n\nsource:  a species with a BDI architecture\ntarget: -\n\nPerception​\n\nThe Perception feature allows the modeler to define a perception for a BDI species, i.e. a function executed at each iteration that updates the agent's Belief base according to the agent perception.\n\nsource:  a species with a BDI architecture\ntarget: -\n\nFinite State Machine Architecture​\nState​\n\nThe State feature allows the modeler to define a state for a FSM species, i.e. sequence of statements that will be executed if the agent is in this state (an agent has a unique state at a time).\n\nsource:  a species with a finite state machine architecture\ntarget: -\n\nTask-based Architecture​\nTask​\n\nThe Task feature allows the modeler to define a task for a Tasked-based species, i.e. sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.\n\nsource:  a species with a task-based architecture\ntarget: -\n\nPictogram color modification​\nIt is possible to change the color of a pictogram.\n\nRight-click on a pictogram, then select the \"Chance the color\".\n\nGAML Model generation​\nIt is possible to automatically generate a Gaml model from a diagram.\n\nRight-click on the graphical framework (where the diagram is defined), then select the \"Generate Gaml model\".\nA new GAML model with the same name as the diagram is created (and open).\n"},{"filePath":"https:--gama-platform.org--wiki-GamaArchitecture.txt","text":"Architecture of GAMAGAMA is made of a number of Eclipse Java projects, some representing the core projects without which the platform cannot be run, others additional plugins adding functionalities or concepts to the platform.\nVocabulary:\nEach project is either designed as a plugin (containing an xml file \"plugin.xml\") or as a feature (containing an xml file \"feature.xml\").\n\nA plugin can be seen as a module (or bundle in the OSGI architecture), which can be necessary (the GAMA platform can't run without it) or optional (providing new functionalities to the platform). This decomposition between several plugins ensure the cohesion between functional blocks, each plugin has to be as independent as he can.\nA feature is a group of one or several modules (or plugin), which can be loaded. NB : Unlike a plugin, a feature does not include source code, but only two files : a build.properties and a feature.xml.\n\nTo see how to create a plugin and a feature, please read this page.\nTable of contents​\n\nArchitecture of GAMA\n\nThe minimal configuration\nOptional Plugins\n\nPlugins present in the release version\nPlugins not present by default in the release version\nPlugins not designated to be in the release version\n\n\nUnmaintained projects\nFeatures\nModels\nPlugins overview\n\n\n\nThe minimal configuration​\nHere is the list of projects which have to be imported in order to run the GAMA platform, and to execute a simple model in gaml language:\n\nmsi.gama.core : Encapsulates the core of the modeling and simulation facilities offered by the platform : runtime, simulation, meta-model, data structures, simulation kernel, scheduling, etc. It contains 2 main packages :\n\nmsi.gama\nmsi.gaml, wich defines the GAML modeling language: keywords, operators, statements, species, skills\n\n\nmsi.gama.application : Describes the graphical user interface (msi.gama.gui package). This project also contains the file gama1.7.Eclipse3_8_2.product, when you can configure the application (and also launch the application). It contains the following sub-packages :\n\nmsi.gama.gui.displays\nmsi.gama.gui.navigator\nmsi.gama.gui.parameters\nmsi.gama.gui.swt\nmsi.gama.gui.views\nmsi.gama.gui.wizards\nmsi.gama.gui.viewers\n\n\nmsi.gama.ext : Gathers all the external libraries upon which GAMA relies upon\n\nmsi.gama.lang.gaml : Contains the gaml.xtext file which defines the GAML grammar\nmsi.gama.lang.gaml.ui : Contains the GAML Editor (syntax highlighting, code completion)\n\n\nmsi.gama.processor : Is responsible for processing the annotations made in the Java source code and producing additions to GAML (Java, properties and documentation files), which are added into a source package called \"gaml.additions\" (containing two main generated files: GamlAdditions.java and GamlDocumentation.java). These additions are loaded automatically when GAMA launches, allowing extensions made by developers in other plugins to be recognized when their plugin is added to the platform.\nummisco.gaml.editbox : Project used to define the edit boxes in the gaml ui.\n\nMinimal configuration projects dependencies:\n\nOptional Plugins​\nPlugins present in the release version​\nFrom this minimal configuration, it is possible to add some features. Here is the list of the features installed by default in the release version:\n\nidees.gama.mapcomparison : Contains some useful tools to do map comparaison\nmsi.gaml.extensions.fipa : Provides some operators for communication between agents, using the FIPA standards\nmsi.gama.headless : Enables to run simulations in console mode\nsimtools.gaml.extensions.traffic : Provides operators and skills for traffic simulation\nsimtools.gaml.extensions.physics : Physics engine, collision modelling, using the library JBullet\nummisco.gaml.extensions.maths : Solving differential equation, using Euler methods and Runge Kutta.\nirit.gaml.extensions.database : Provides database manipulation tools, using SQL requests\nirit.gaml.extensions.test : Add unitary test statements\nummisco.gama.opengl : Provide a 3D visualization using OpenGL.\nsimtools.gamanalyzer.fr : Adding tools for the analysis of several execution result of a simulation (in order to find some correlations).\ndream.gama.opengis : Used to load some geographic information datas from online GIS server.\nsimtools.graphanalysis.fr : Advanced graph operators\n\nPlugins not present by default in the release version​\nSome other plugins are not present by default in the release version (because their use is very specific), but it's possible to install them through features.\nHere is the list of those plugins:\n\nidees.gama.weka : Data-mining operators, using the library Weka.\nmsi.gaml.architecture.simplebdi : Architecture for using the Belief-Desire-Intention software model.\nummisco.gaml.extensions.sound : Use of sound in simulations\nummisco.gaml.extensions.stats : Advanced statistics operators\nummisco.gama.communicator : Communication between several instances of GAMA\nummisco.gaml.extensions.rjava : Adding the R language into GAMA for data mining\n\nPlugins not designated to be in the release version​\nOther plugins will never be on the released version, and will never be loaded during the gama execution. They are just used in the \"developer\" version:\n\nmsi.gama.documentation : Generate automatically the documentation in the wiki form (and also a pdf file)\n\nUnmaintained projects​\nSome other projects are still in the git repository in case we need to work on it one day, but they are either unfinished, obsolete, or used in very rare situations (They are not delivered in release versions, of course). Here is the list:\n\ncenres.gaml.extensions.hydro : Provide some tools in order to create hydrology models\nmsi.gaml.extensions.traffic2d : Provide some tools for traffic in 2 dimensions (depreciated, now replace by msi.gaml.extensions.traffic)\nmsi.gaml.extensions.humainmoving : Provide a skill to represent human movement\nummisco.gama.gpu : Computation directly on the GPU for more efficiency. Results or not concluant, slower than using CPU.\nmsi.gama.hpc : \"High Power Computing\" to execute gama simulation in several computers.\nmsi.gaml.extensions.cplex : Originaly designed to be able to run CPLEX function in GAMA. The CPLEX is a proprietary library, we can't deliver it in the project. Instead, we use a stub, \"cplex.jar\", that you can replace by the real cplex.jar file.\nirit.maelia.gaml.additions : Used for the project \"Maelia\". Provide the possibility to represent the computing time in a simulation.\nmsi.gama.display.web : Originaly designed to run some GAMA simulation in a browser, inside gama application, using WebGL. Does not work for the moment\nummisco.miro.extension : Once used for the \"miro\" project, no longer used.\nummisco.miro.extension.traffic : Once used for the \"miro\" project, no longer used.\n\nFeatures​\n\nummisco.gama.feature.audio : sound plugin\nummisco.feature.stats : stats plugin\nummisco.gama.feature.opengl.jogl2 : gathers physics and opengl plugins\nsimtools.graphlayout.feature : gathers core, ext, processor and graphanalysis plugins\nummisco.gama.feature.core : gathers mapcomparison, database, test, application, core, ext, headless, gaml, gaml.ui, processor, fipa, traffic and maths plugins\nummisco.gama.feature.dependencies : a bunch of libraries and plugins\nother.gama.feature.plugins gathers hydro, opengis, addition, web, hpc, cplex, traffic2d, communicator, gpu, stats, extensions and traffic plugins\nummisco.gama.feature.models : model plugin\nidees.gama.features.weka : weka plugin\nummisco.gama.feature.jogl2.product : gathering of the following features : core, dependencies, models, jogl2\nummisco.gama.feature.product : gathering of the following features : core, dependencies, models, jogl1\n\nModels​\nBeside those plugins and features, a project dedicated to gather a bunch of examples is also in the git repository. It contains gaml code:\n\nmsi.gama.models\n\nPlugins overview​\nGlobal architecture of GAMA (nb: the features graphlayout, core, dependencies, plugins, jogl2.product and product are not represented here)\n"},{"filePath":"https:--gama-platform.org--wiki-GamlEditorGeneralities.txt","text":"The GAML Editor - GeneralitiesThe GAML Editor is a text editor that proposes several services to support the modeler in writing correct models: an integrated live validation system, a ribbon header that gives access to experiments, information, warning and error markers.\nTable of contents​\n\nThe GAML Editor - Generalities\n\nCreating a first model\n\nCreate a new model or test file\nCreate a new experiment file\n\n\nStatus of models in editors\nEditor Preferences\nAdditional information in the Editor\nMultiple editors\nLocal history\n\n\n\nCreating a first model​\nEditing a model requires that at least one project is created in User Models. If there is none, right-click on User Models and choose \"New... > Gama Project...\" (if you already have user projects and want to create a model in one of them, skip the next step).\n\nA dialog is then displayed, offering you to enter the name of the project. You can also choose whether you want to create at the same time a first model file and if you want the project contains test models. An error will be displayed if the project name already exists in the workspace, in which case you will have to change it. Two projects with similar names cannot coexist in the workspace (even if they belong to different categories).\n\nIf you want to create a new model file in your project, navigate to it and right-click on it and on the command \"New ...>\". You have a choice between three kinds of file:\n\nModel file: to create a normal .gaml model file used to define your model.\nExperiment file: to create a file containing only an experiment on an existing model.\nTest experiment file: to create unit test experiment. It is typically used to define some unit test on a given model, to ensure its quality and prevent regression bugs.\n\n\nCreate a new model or test file​\nA new dialog is displayed, which asks for several required or optional information:\n\nThe Container is normally the name of the project you have selected, but you can choose to place the file elsewhere. An error will be displayed if the container does not exist (yet) in the workspace.\nYou can then choose whether you want to create an empty file, a file with already a skeleton of model (with the main needed elements of a model file) or simply a test model.\nFinally, you are invited to give this file a name. An error is displayed if this name already exists in this project. The name of the model, which is by default computed with respect to the name of the file, can be actually completely different (but it may not contain white spaces or punctuation characters). The name of the author, as well as the textual description of the model and the creation of an HTML documentation, are optional.\n\n\nCreate a new experiment file​\nA new dialog is displayed, which asks for several required or optional information:\n\nThe Container is normally the name of the project you have selected, but you can choose to place the file elsewhere. An error will be displayed if the container does not exist (yet) in the workspace.\nYou can then choose the model you want to experiment on. Just type the path toward this gaml model, or browse and select one among all the models existing in the workspace.\nFinally, you are invited to give this file a name. An error is displayed if this name already exists in this project. The name of the model, which is by default computed with respect to the name of the file, can be actually completely different (but it may not contain white spaces or punctuation characters). The name of the author, as well as the textual description of the model and the creation of an HTML documentation, are optional.\n\n\nStatus of models in editors​\nOnce this dialog is filled and accepted, GAMA will display the new \"empty\" model.\n\nAlthough GAML files are just plain text files, and can, therefore, be produced or modified in any text processor, using the dedicated GAML editor offers many advantages, among which the live display of errors and model statuses. A model can actually be in four different states, which are visually accessible above the editing area: Functional (grey color), Experimentable (green color), InError (red color), InImportedError (red color). See the section on model compilation for more precise information about these statuses.\nIn its initial state, a model is always in the Functional state (when it is empty), which means it compiles without problems, but cannot be used to launch experiments. If the model is created with a skeleton, it is Experimentable. The InError state, depicted below, occurs when the file contains errors (syntactic or semantic ones).\n\nWhile the file is not saved, these errors remain displayed in the editor and nowhere else. If you save the file, they are now considered as \"workspace errors\" and get displayed in the \"Syntax errors\" view below the editor and explanation is available on the error icon in the GAML editor.\n\nReaching the Experimentable state requires that all errors are eliminated and that at least one experiment is defined in the model, which is the case now in our toy model. The experiment is immediately displayed as a button in the toolbar, and clicking on it will allow to launch this experiment on your model. See the section about running experiments for more information on this point.\n\nExperiment buttons are updated in real-time to reflect what is in your code. If more than one experiment is defined, corresponding buttons will be displayed in addition to the first one.\n\nThe toolbar on the top of the GAML editor displays, in addition to the green experiment buttons, a button to add an experiment in the current model.\n\nEditor Preferences​\nText editing in general, and especially in Eclipse-based editors, sports several options and preferences. You might want to turn off/on the numbering of the lines, change the fonts used, change the colors used to highlight the code, etc. All of these preferences are accessible from the \"Preferences...\" item of the editor contextual menu.\n\nExplore the different items present there, keeping in mind that these preferences will apply to all the editors of GAMA and will be stored in your workspace.\n\nAdditional information in the Editor​\nYou can choose to display or not some information in your Editor, from the Models menu available when the GAML editor is active.\n\nIn particular, this menu allows the user to activate/deactivate the additional information that can be displayed in the editor:\n\n\"Display line number\": the display of the line number in the left margin.\n\"Fold code sections\": the - and + icons on the left of each code section can fold/unfold the associated code section.\n\"Mark occurrence of symbols\": when the name of a variable or species is selected in the code, all its other occurrences will be also marked.\n\"Colorize code sections\": the code section can be colorized, improving the visualization of the model organization (see below).\n\"Show markers overview\": a right-click on the left margin of the editor allows the user to add either bookmarks or tasks to the editor (with a mark on the right margin.\n\n\nOne particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model, but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox.\n\nThe Default theme of EditBox might not suit everyone's tastes, so the preferences allow to entirely customize how the \"boxes\" are displayed and how they can support the modeler in better understanding \"where\" it is in the code. The \"themes\" defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.\n\nMultiple editors​\nGAMA inherits from Eclipse the possibility to entirely configure the placement of the views, editors, etc. This can be done by rearranging their position using the mouse (click and hold on an editor's title and move it around). In particular, you can have several editors side by side, which can be useful for viewing the documentation while coding a model.\n\nLocal history​\nAmong the various options present to work with models, which you are invited to try out and test at will, one, called Local history is particularly interesting and worth a small explanation. When you edit models, GAMA keeps in the background all the successive versions you save (the history duration is configurable in the preferences), whether or not you are using a versioning system like SVN or Git. This local history is accessible from the contextual menu on the chosen model.\n\nThis command invokes the opening of a new view, which you can see in the figure below, and which lists the different versions of your file so far. You can then choose one and, right-clicking on it, either open it in a new editor or compare it to your current version.\n\nThis allows you to precisely pinpoint the modifications brought to the file and, in case of problems, to revert them easily, or even revert the entire file to a previous version. Never lose your work again!\n\nThis short introduction to GAML editors is now over. You might want to take a look, now, at how the models you edit are parsed, validated and compiled, and how this information is accessible to the modeler."},{"filePath":"https:--gama-platform.org--wiki-GamlEditorToolbar.txt","text":"GAML Editor toolsThe GAML Editor provides some tools to make the editing easier, covering a lot of functionalities, such as tools for changes of visualization, tools for navigation through your model, tools to format your code, or also tools to help you to find the correct keywords to use in a given context. Some can be accessed directly from the toolbar on top of the editor, but most of the tools are available in the menu \"Model\", that is only available when the GAML editor is active (i.e. when the modeler is editing the model).\nTable of contents​\n\nGAML Editor tools\n\nNavigation tools in the editor\nVisualization tools in the menu\nVocabulary tools in the menu\nVocabulary tools in the toolbar\nFormatting tools in the contextual menu\nMini-map\n\n\n\nNavigation tools in the editor​\n\nIn the Editor toolbar, you have some tools for search and navigation through the code. Here are explanations for each functionality:\nPrevious/next edit locations​\nThe two arrow shape buttons that are coming first are used to jump from the current location of your cursor to the last position, even if the last position was in another file (and even if this file has been closed !).\nThe search engine​\nTo search an occurrence of a word (or the part of a word), you can type your search in the field, and the result will be highlighted automatically in the text editor.\n\nWith the left/right arrows, you can highlight the previous/next occurrence of the word. If you prefer the eclipse interface for the search engine, you can also access the tool by taping Ctrl+F.\nShow outline​\nThis last tool of this section is used to show the global architecture of your model, with explicit icons for each section. A search field is also available if you want to search for a specific section. By double-clicking one line of the outline, you can jump directly to the chosen section. This feature can be useful if you have a big model to manipulate.\n\nVisualization Tools in the menu​\nYou can choose to display or not some information in your Editor, from the Model menu. Here are the different features available.\n\nDisplay line number​\nThe first toggle is used to show/hide the number of lines.\nFold code sections​\nThe second toggle provides you the possibility to expand or collapse lines in your model depending on the indentation. This feature can be very useful for big models, to collapse the part you have already finished.\nMark occurrences of symbols​\nThis third toggle is used to show occurrences when your cursor is pointing on one word.\nColorize code sections​\nOne particular option, shipped by default with GAMA, is the possibility to not only highlight the code of your model but also its structure (complementing, in that sense, the Outline view). It is a slightly modified version of a plugin called EditBox, which can be activated by clicking on the \"green square\" icon in the toolbar.\n\nThe Default theme of EditBox might not suit everyone's tastes, so the preferences allow to entirely customize how the \"boxes\" are displayed and how they can support the modeler in better understanding \"where\" it is in the code. The \"themes\" defined in this way are stored in the workspace, but can also be exported for reuse in other workspaces, or sharing them with other modelers.\n\nShow markers overview​\nIt is possible to add two kinds of marker on the code: Bookmarks (a simple bookmark on a line of code that helps to go back to some lines of interest) and Tasks (in addition to a marker on a line, a Task expresses that something should be done, with a given priority, on the code line). The markers are also visible in the right margin of the editor. An additional view (named Tasks, that can be opened from the Views menu) gathers all the tasks, helping modelers to organize their work.\n\nVocabulary tools in the menu​\n\nThe second group of commands in the Model menu are used to search the correct way to write a certain keyword.\nTemplates​\nThe templates button is used to insert directly a code snippet in the current position of the cursor. Some snippets are already available, ordered by scope. You can custom the list of templates as much as you want, new templates can be added from the Preferences dialog.\nFor example, if the modeler clicks on Template > Species > grid > insert, the following code is generated:\ngrid name width:grid_w height:grid_h {}\nBuilt-in structures​\nWith this feature, you can easily know the list of built-in attributes and built-in actions you can use in such or such context. With this feature, you can also insert some templates to help you, for example, to insert a pre-made species using a particular skill, as it is shown it the following screenshot:\n\n... will generate the following code:\n\nAll the comments are generated automatically from the current documentation.\nOperators​\nOnce again, this powerful feature can be used to generate an example of structures for all the operators, ordered by categories.\nColors​\nHere is the list of the name for the different pre-made colors you can use. You can also add some custom colors.\n\nVocabulary tools in the toolbar​\nAll the information that is available in the \"Model\" menu can also be accessed, in another way, from the research engine located in the GAMA interface toolbar, named \"GAML reference\". Any word typed in this search engine will be searched in all the keyword of the GAML language: for example, if the word experiment is searched, the search engine retrieves its occurrence as a built-in species, a statement, an attribute or a type... This is definitely the easiest way to get information about any GAML keyword.\n\nFormatting tools in the contextual menu​\n\nSome other tools are available in the contextual menu to help for the formatting and refactoring of the model:\nRename element​\nOnce an element selected, this command allows the modeler to rename it. All the occurrences of this element name will be altered. This is particularly useful in a model when we want to refactor the model: e.g. rename an attribute and that this modification to be taken into account in all the model code.\nSource > Comment​\nThis command is used to comment a line (or a group of lines).\nSource > Format​\nThis useful feature re-indent automatically all your model.\nMini-map​\nThe mini-map provides a view of the whole model in a very tiny font. It helps to have an overview of the model. The mini-map is a View that needs to be shown, from the View menu.\n\nThe mini-map view can be moved close to the editor. The modeler can navigate in the mini-map to move quickly between the various parts of the model.\n"},{"filePath":"https:--gama-platform.org--wiki-GamlReference.txt","text":"GAML ReferencesThe GAML references describe in details all the keywords of the GAML language. In particular, they detail all the expressions (operators, units, literals...), statements, data types, file types, skills, architectures, built-in species...\nIndex of keywords​\nThe Index page contains the exhaustive list of the GAML keywords, with a link to a detailed description of each of them."},{"filePath":"https:--gama-platform.org--wiki-GlobalSpecies.txt","text":"The global speciesWe will start this chapter by studying a special species: the global species.\nIn the global species, you can define the attributes, actions, and behaviors that describe the world agent. There is one unique world agent per simulation: it is this agent that is created when a user runs an experiment and that initializes the simulation through its init scope. The global species is a species like others and can be manipulated as them. In addition, the global species automatically inherits from several built-in variables and actions. Note that a specificity of the global species is that all its attributes can be referred by all agents of the simulation.\nIndex​\n\nDeclaration\nEnvironment Size\nBuilt-in Attributes\nBuilt-in Actions\nThe init statement\n\nDeclaration​\nA GAMA model contains a unique global section that defines the global species.\nglobal {\t// definition of global attributes, actions, behaviours}\nglobal can use facets, such as the torus facet, to make the environment a torus or not (if it is a torus, all the agents going out of the environment will appear on the other side. If it's not, the agents won't be able to go out of the environment). By default, the environment is not a torus.\n\nglobal torus:true {\t// definition of global attributes, actions, behaviours}\nOther facets such as control or schedules are also available, but we will explain them later.\nDirectly in the global scope, you have to declare all your global attributes (can be seen as \"static members\" in Java or C++). To declare them, proceed exactly as for declaring basic variables. Those attributes are accessible wherever you want inside the species scope.\nEnvironment size​\nIn the global context, you have to define the size and shape for your environment. In fact, an attribute already exists for the global species (inherited from agent): it's called shape, and its type is a geometry. By default, shape is equal to a 100m*100m square. You can change the geometry of the shape by initializing it with another value:\ngeometry shape <- circle(50#mm);geometry shape <- rectangle(10#m,20#m);geometry shape <- polygon([{1°m,2°m},{3°m,50°cm},{3.4°m,60°dm}]);\nNote that the final shape of the world will always be a rectangle equal to the envelope of the geometry provided.\nnb: there are just examples. Try to avoid mixing dimensions! If no dimensions are specified, it will be meter by default.\nBuilt-in attributes​\nSome attributes exist by default for the global species. The attribute shape is one of them (refers to the shape of the environment). Here is the list of the other built-in attributes:\nLike the other attributes of the global species, global built-in attributes can be accessed (and sometimes modified) by the world agent and every other agent in the model.\nworld​\n\nrepresents the sole instance of the model species (i.e. the one defined in the global section). It is accessible from everywhere (including experiments) and gives access to built-in or user-defined global attributes and actions.\n\nexperiment​\n\ncontains the experiment agent that has created this simulation agent.\n\ncycle​\n\ninteger, read-only, designates the (integer) number of executions of the simulation cycles. Note that the first cycle is the cycle with number 0.\n\nTo learn more about time, please read the recipe about dates.\nstep​\n\nfloat,  is the length, in model time, of an interval between two cycles, in seconds. Its default value is 1 (second). Each turn, the value of time is incremented by the value of step. The definition of step must be coherent with that of the agents' variables like speed. The use of time units is particularly relevant for its definition.\n\nTo learn more about time, please read the recipe about dates.\nglobal {...    float step <- 10 #h;...}\ntime​\n\nfloat, read-only, represents the current simulated time in seconds (the default unit). It is the time in the model time. Begins at zero. Basically, we have:   time = cycle * step  .\n\nglobal {...    int nb_minutes function: { int(time / 60)};...}\nTo learn more about time, please read the recipe about dates.\nstarting_date and current_date​\n\ndate, represent the starting date (resp. the current date) of the simulation. The current_date is updated from the starting_date by the value step at each simulation step.\n\nTo learn more about time, please read the recipe about dates.\nduration​\n\nstring, read-only, represents the value that is equal to the duration in real machine time of the last cycle.\n\ntotal_duration​\n\nstring, read-only, represents the sum of duration since the beginning of the simulation.\n\naverage_duration​\n\nstring, read-only, represents the average of duration since the beginning of the simulation.\n\nmachine_time​\n\nfloat, read-only, represents the current machine time in milliseconds.\n\nseed​\n\nfloat, the seed of the random number generator. It will influence the set of random numbers that will be generated all over the simulation. 2 simulations of a model with the same parameters' values should behave identically when the seed is set to the same value. If it is not redefined by the modeler, it will be chosen randomly.\n\nagents​\n\nlist, read-only, returns a list of all the agents of the model that are considered as \"active\" (i.e. all the agents with behaviors, excluding the places). Note that obtaining this list can be quite time consuming, as the world has to go through all the species and get their agents before assembling the result. For instance, instead of writing something like:\n\nask agents of_species my_species {...}\none would prefer to write (which is much faster):\nask my_species {...}\nNote that any agent has the agents attribute, representing the agents it contains. So to get all the agents of the simulation, we need to access the agents of the world using: world.agents.\nBuilt-in Actions​\nThe global species is provided with two specific actions.\npause​\n\npauses the simulation, which can then be continued by the user.\n\nglobal {    ...    reflex toto when: time = 100 {        do pause;    }}\ndie​\n\nstops the simulation (in fact it kills the simulation).\n\nglobal {    ...    reflex halting when: empty (agents) {        do die;    }}\nBut beware, it will not kill the simulation, instead the simulation will continue running with a dead global species (so everything will close and nothing will happen except for the cycles still increasing). If you want to completely stop the simulation you will have to call the die action of the host of the global species.\nglobal {    ...    reflex halting when: empty (agents) {        ask host {            do die;        }    }}\nOther actions​\nOther built-in actions are defined for the model species, just as in any other regular species.\nThe init statement​\nAfter declaring all the global attributes and defining your environment size, you can define an initial state (before launching the simulation). Here, you normally initialize your global variables, and you instantiate your species. We will see in the next session how to initialize a regular species."},{"filePath":"https:--gama-platform.org--wiki-GraphSpecies.txt","text":"Graph SpeciesUsing a graph in a model enables to easily show and manage interactions between agents: this can be the link between 2 points in space linked by a road or (non-spatial) interactions that exist between friends agents. It can also be a powerful tool to compute the shortest path between 2 points in space.\nA graph is a concept that has several implementations in GAML: (i) it can be a  datatype (graph), that can be created from a road shapefile (e.g. using as_edge_graph), (ii) it can be implemented as node and edge species,and (iii) it is a topology, i.e. an organisation of agents that influences the way distance and neighborhood is computed.\nIndex​\n\nDeclaration\n\nDeclare a graph with handmade agents\nDeclare a graph by using an geometry file\nDeclare a graph with nodes and edges\n\n\nUseful operators with graph\n\nKnowing the degree of a node\nGet the neighbors of a node\nCompute the shortest path\nControl the weight in graph\n\n\nExample\n\nDeclaration​\nDeclare a graph with handmade agents​\nTo instantiate this graph, we rely on the two built-in species graph_node and base_edge. We need to define our own node and edge species as children species of the 2 built-in species. First, the node species must inherit from the abstract species graph_node, then the method related_to must be redefined and finally an auxiliary species that inherits from base_edge used to represent the edges of the generated graph must be declared.\nA graph node is an abstract species that must redefine one method called related_to.\nspecies my_node parent: graph_node edge_species: edge_agent{  bool related_to(my_node other){  \treturn true;  }}species edge_agent parent: base_edge {}\nThe method related_to returns a boolean and takes the agents from the current species as argument. If the method returns true, the two agents (the current instance and the one as argument) will be linked. The method is automatically called for each agent with each other agent of the given species in argument. Note that in the following example, related_to returns always true, so each agent will be linked to each other agent: we will get a complete graph.\nmodel NewModelglobal {    int number_of_agents <- 5;    init {\tcreate my_node number: number_of_agents;    }}species my_node parent: graph_node edge_species: edge_agent {    bool related_to (my_node other) {\treturn true;    }    aspect base {\tdraw circle(1) color: #green;    }}species edge_agent parent: base_edge {    aspect base {\tdraw shape color: #blue;    }}experiment MyExperiment type: gui {    output {\tdisplay MyDisplay type: java2D {\t    species my_node aspect: base;\t    species edge_agent aspect: base;\t}    }}\n\nYou can, for example, link 2 agents when they are closer than a certain distance.\nBeware: The topology used in graph species is the graph topology and not the continuous topology. You can force the use of the continuous topology with the action using as follow:\nbool related_to(my_node other){    using topology(world) {        return (self.location distance_to other.location < 20);    }}\n\nThe abstract mother species graph_node has an attribute my_graph, with the type graph. The graph type represents a graph composed of vertices linked with edges. This type has built-in attributes such as edges (the list of all the edges agents), or vertices (the list of all the vertices agents).\nDeclare a graph by using a geometry file​\nIn most cases, you will have to construct a graph from an existing file (example: a \"shp\" file). In that case, you will have to first instantiate a species from the shape file (with the create statement, using the facet from). Then, you will have to construct a graph from the agent, using one of the available operators such as as_edge_graph.\nmodel load_shape_file  global {    file roads_shapefile <- file(\"../includes/road.shp\");    geometry shape <- envelope(roads_shapefile);    graph road_network;    init {\tcreate road from: roads_shapefile;\troad_network <- as_edge_graph(road);    }}species road {    aspect geom {\tdraw shape color: #black;    }}experiment main_experiment type:gui{    output {\tdisplay map {\t    species road aspect:geom;\t\t\t}    }}\nDeclare a graph with nodes and edges​\nAnother way to create a graph is building it manually nodes by nodes, and then edges by edges, without using agent structures. Use the add_node operator and the add_edge operator to do so. Here is an example of how to do:\nlist<point> nodes <- [];graph my_graph <- graph([]);add point(0.0,0.0) to:nodes;add point(90.0,90.0) to:nodes;add point(20.0,20.0) to:nodes;add point(40.0,50.0) to:nodes;add point(100.0,0.0) to:nodes;loop nod over: nodes {    my_graph <- my_graph add_node(nod);}\t\tmy_graph <- my_graph add_edge (nodes at 0::nodes at 2);my_graph <- my_graph add_edge (nodes at 2::nodes at 3);my_graph <- my_graph add_edge (nodes at 3::nodes at 1);my_graph <- my_graph add_edge (nodes at 0::nodes at 4);my_graph <- my_graph add_edge (nodes at 4::nodes at 1);\nUsing this solution, my_graph can have two types: it can be an a-spatial graph, or a spatial graph. The spatial graph will have a proper geometry, with segments that follow the position of your graph (you can access to the segments by using the built-in \"segments\"). The a-spatial graph will not have any shape.\nglobal {    graph my_spatial_graph<-spatial_graph([]);    graph my_aspatial_graph<-graph([]);\t    init {\tpoint node1 <- {0.0,0.0};\tpoint node2 <- {10.0,10.0};\t        my_spatial_graph <- my_spatial_graph add_node(node1);\tmy_spatial_graph <- my_spatial_graph add_node(node2);\tmy_spatial_graph <- my_spatial_graph add_edge(node1::node2);\twrite my_spatial_graph.edges;\t\t\t// the output is [polyline ([{0.0,0.0,0.0},{10.0,10.0,0.0}])]\tmy_aspatial_graph <- my_aspatial_graph add_node(node1);\tmy_aspatial_graph <- my_aspatial_graph add_node(node2);\tmy_aspatial_graph <- my_aspatial_graph add_edge(node1::node2);\twrite my_aspatial_graph.edges;\t// the output is [{0.0,0.0,0.0}::{10.0,10.0,0.0}]    }}\nUseful operators with graph​\nKnowing the degree of a node​\nThe operator degree_of returns the number of edges attached to a node. To use it, you have to specify a graph (on the left side of the operator), and a node (on the right side of the operator).\nThe following code (to put inside the node species) displays the number of edges attached to each node:\naspect base {    draw string(my_graph degree_of node(5)) color:# black;}\nGet the neighbors of a node​\nTo get the list of neighbors of a node, you should use the neighbors_of operator. On the left side of the operator, specify the graph you are using, and on the right side, specify the node. The operator returns the list of nodes located at a distance inferior or equal to 1, considering the graph topology.\nspecies graph_agent parent: graph_node edge_species: edge_agent{  list<graph_agent> list_neighbors <- list<graph_agent>(my_graph neighbors_of (self));}\nHere is an example of a model using those two previous concepts (a random node is chosen each step, displayed in red, and his neighbors are displayed in yellow):\n\nmodel graph_modelglobal {    int number_of_agents <- 50;\t    init {\tcreate my_node number: number_of_agents;    }\t    reflex update {\task one_of(my_node) {\t    status <- 2;\t    do update_neighbors;\t}    }}species my_node parent: graph_node edge_species: edge_agent {    int status <- 0;    list<int> list_connected_index;\t    init {\tint i <- 0;\tloop g over: my_node {\t    if (flip(0.1)) {\t\tadd i to:list_connected_index;\t    }\t    i <- i+1;\t}    }\t    bool related_to(my_node other){        if (list_connected_index contains (my_node index_of other)) {\t    return true;\t}        return false;    }\t    action update_neighbors {\tlist<my_node> list_neighbors <- my_graph neighbors_of (self);\tloop neighb over: list_neighbors {\t    neighb.status <- 1;\t}    }    aspect base {\tif (status = 0) {\t    draw circle(2) color: #green border: #black;\t} else if (status = 1) {\t    draw circle(2) color: #yellow border: #black;\t} else if (status = 2) {\t    draw circle(2) color: #red border: #black;\t}\t        draw string(my_graph degree_of self) color: #black size: 4 at: {self.location.x-1, self.location.y-2};\tstatus <- 0;    }}species edge_agent parent: base_edge {    aspect base {\tdraw shape color: #blue;    }}experiment MyExperiment type: gui {    output {\tdisplay MyDisplay type: java2D {\t    species my_node aspect: base;\t    species edge_agent aspect: base;\t}    }}\nCompute the shortest path​\nTo compute the shortest path to go from a point to another one, pick a source and a destination among the vertices you have for your graph. Store those values as point type.\npoint source;point destination;source <- point(one_of(my_graph.vertices));destination <- point(one_of(my_graph.vertices));\nThen, you can use the operator path_between to return the shortest path. To use this operator, you have to give the graph, then the source point, and the destination point. This operator returns a path type object.\npath shortest_path;shortest_path <- path_between (my_graph, source,destination);\nAnother operator exists, paths_between, that returns a list of shortest paths between two points. Please read the documentation to learn more about this operator.\nHere is an example of code that shows the shortest path between two points of a graph:\n\nmodel graph_modelglobal {    int number_of_agents <- 50;    point source;    point target;    graph the_graph;    path shortest_path;    init {\tcreate my_node number: number_of_agents;    }    reflex pick_two_points {\tif (the_graph = nil) {\t    the_graph <- one_of(my_node).my_graph;\t}\tshortest_path <- nil;\tloop while: shortest_path = nil {\t    source <- (one_of(the_graph.vertices));\t    target <- (one_of(the_graph.vertices));\t    if (source != target) {\t\tshortest_path <- path_between(the_graph, source, target);\t    }\t}    }}species my_node parent: graph_node edge_species: edge_agent {    list<int> list_connected_index;    init {\tint i <- 0;\tloop g over: my_node {\t    if (flip(0.1)) {\t\tadd i to: list_connected_index;\t    }\t    i <- i + 1;\t}    }    bool related_to (my_node other) {\tusing topology(world) {\t    return (self.location distance_to other.location < 20);\t}    }    aspect base {\tdraw circle(2) color: #green border: #black;    }}species edge_agent parent: base_edge {    aspect base {\tdraw shape color: #blue;    }}experiment MyExperiment type: gui {    output {\tdisplay MyDisplay type: java2D {\t    species my_node aspect: base;\t    species edge_agent aspect: base;\t    graphics \"shortest path\" {\t\tif (shortest_path != nil) {\t\t    draw circle(3) at: source color: #yellow border: #black;\t\t    draw circle(3) at: target color: #cyan border: #black;\t\t    draw (shortest_path.shape + 1) color: #magenta;\t\t}\t    }\t}    }}\nControl the weight in graph​\nYou can add a map of weight for the edges that compose the graph. Use the operator with_weights to put weights in your graph. The graph has to be on the left side of the operator, and the map has to be on the right side. In the map, you have to put edges as key, and the weight for that edge as value. One common use is to put the distance as weight:\nmy_graph <- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));\nThe calculation of the shortest path can change according to the weight you choose for your edges. For example, here is the result of the calculation of the shortest path when all the edges have 1 as weight value (it is the default graph topology), and when the edges have their length as weight.\n\nHere is an example of implementation:\nmodel shortest_path_with_weightglobal {    graph my_graph<-spatial_graph([]);    path shortest_path;    list<point> nodes;\t\t    init {\tadd point(10.0,10.0) to:nodes;\tadd point(90.0,90.0) to:nodes;\tadd point(40.0,20.0) to:nodes;\tadd point(80.0,50.0) to:nodes;\tadd point(90.0,20.0) to:nodes;\tloop nod over: nodes {\t    my_graph <- my_graph add_node(nod);\t}\t\t\tmy_graph <- my_graph add_edge (nodes at 0::nodes at 2);\tmy_graph <- my_graph add_edge (nodes at 2::nodes at 3);\tmy_graph <- my_graph add_edge (nodes at 3::nodes at 1);\tmy_graph <- my_graph add_edge (nodes at 0::nodes at 4);\tmy_graph <- my_graph add_edge (nodes at 4::nodes at 1);\t\t\t// comment/decomment the following line to see the difference.\tmy_graph <- my_graph with_weights (my_graph.edges as_map (each::geometry(each).perimeter));\t\t\tshortest_path <- path_between(my_graph,nodes at 0, nodes at 1);    }}experiment MyExperiment type: gui {    output {\tdisplay MyDisplay type: java2D {\t    graphics \"shortest path\" {\t\tif (shortest_path != nil) {\t\t    draw circle(3) at: point(shortest_path.source) color: #yellow;\t\t    draw circle(3) at: point(shortest_path.target) color: #cyan;\t\t    draw (shortest_path.shape+1) color: #magenta;\t\t}\t\tloop edges over: my_graph.edges {\t\t    draw geometry(edges) color: #black;\t\t}\t    }\t}    }}"},{"filePath":"https:--gama-platform.org--wiki-GridSpecies.txt","text":"Grid SpeciesA grid is a particular species of agents. Indeed, a grid is a set of agents that share a grid topology (until now, we only saw species with continuous topology). Like other agents, a grid species can have attributes, attributes, behaviors, aspects.\nHowever, contrary to regular species, grid agents are created automatically at the beginning of the simulation. It is thus not necessary to use the create statement to create them.\nMoreover, in addition to classic built-in variables, grid comes with a set of additional built-in variables.\nIndex​\n\nDeclaration\nBuilt-in attributes\nAccess to a cell\nDisplay grid\nGrid from a matrix\nExample\n\nDeclaration​\nInstead of using the species keyword, use the keyword grid to declare a grid species. The grid species has exactly the same facets as the regular species, plus some others.\nTo declare a grid, you can specify the number of columns and rows first (another possibility to declare the grid is detailed below when (we create a grid from a matrix)[GridSpecies#grid-from-a-matrix]). You can do it in two different ways:\n\nUsing the two facets width and height to fix the number of cells (the size of each cell will be determined thanks to the environment dimension).\n\ngrid my_grid width: 8 height: 10 {    // my_grid has 8 columns and 10 rows}\n\nUsing the two facets cell_width and cell_height to fix the size of each cell (the number of cells will be determined thanks to the environment dimension).\n\ngrid my_grid cell_width: 3 cell_height: 2 {    // my_grid has cells with dimension 3m width by 2m height}\nBy default, a grid is composed of 100 rows and 100 columns.\nAnother facet exists for grid only, very useful. It is the neighbors facet, used to determine how many neighbors each cell has. You can choose among 3 values: 4 (Von Neumann), 6 (hexagon) or 8 (Moore).\n\nA grid can also be provided with specific facets that allow to optimize the computation time and the memory space, such as use_regular_agents, use_indivitual_shapes and use_neighbors_cache. Please refer to the GAML Reference for more explanation about those particular facets.\nBuilt-in attributes​\ngrid_x​\nThis variable stores the column index of a cell.\ngrid cell width: 10 height: 10 neighbors: 4 {    init {        write \"my column index is:\" + grid_x;    }}\ngrid_y​\nThis variable stores the row index of a cell.\ngrid cell width: 10 height: 10 neighbors: 4 {    init {        write \"my row index is:\" + grid_y;    }}\ncolor​\nThe color built-in variable is used by the optimized grid display. Indeed, it is possible to use for grid agents an optimized aspect by using in a display the grid keyword. In this case, the grid will be displayed using the color defined by the color variable. The border of the cells can be displayed with a specific color by using the lines facet.\nHere an example of the display of a grid species named cell with black border.\nexperiment main_xp type: gui{    output {\tdisplay map {\t    grid cell lines: #black ;\t}    }}\nneighbors​\nThe neighbors built-in variable returns the list of cells at a distance of 1. This list obviously depends on the neighbor type defined in the grid statement (4,6, or 8).\ngrid my_grid {  reflex writeNeighbors {    write neighbors;  }}\ngrid_value​\nThe grid_value built-in variable is used when initializing a grid from grid file (see later). It contains the value stored in the data file for the associated cell. It is also used for the 3D representation of DEM.\n\"Missing\" attribute​\nInformation that is commonly asked a cell agent is the set of agents located inside it.\nThis information is not stored in the agent, but can be computed using the inside operator:\n grid cell width: 10 height: 10 neighbors: 4 {         list<bug> bugs_inside -> {bug inside self};   }\nAccess to a cell​\nThere are several ways to access a specific cell:\n\nby a location: by casting a location variable (of type point) to a cell, GAMA will compute the cell that covers the given location:\n\nglobal {    init {        write \"cell at {57.5, 45} :\" + cell({57.5, 45});    }}grid cell width: 10 height: 10 neighbors: 4 { }\n\nby the row and column indexes: like matrix, it is possible to directly access to a cell from its indexes\n\nglobal {    init {\twrite \"cell [5,8] :\" + cell[5, 8];    }}grid cell width: 10 height: 10 neighbors: 4 { }\n\nThe operator grid_at also exists to get a particular cell. You just have to specify the index of the cell you want (in x and y):\n\nglobal {    init {\tagent cellAgent <- cell grid_at {5, 8};\twrite \"cell [5,8] :\" + cellAgent;    }}grid cell width: 10 height: 10 neighbors: 4 { }\nDisplay Grid​\nYou can easily display your grid in your experiment as followed:\nexperiment MyExperiment type: gui {    output {        display MyDisplay type: opengl {            grid MyGrid;        }    }}\nThe grid will be displayed, using the color you defined for each cell (with the color built-in attribute). You can also show the border of each cell by using the facet lines and choosing a color:\ndisplay MyDisplay type: opengl {    grid MyGrid lines: #black;}\nAnother way to display a grid will be to define an aspect in your grid agent (the same way as for a regular species), and add your grid as a regular species in the display of in your experiment and thus by specifying its aspect:\ngrid MyGrid {    aspect firstAspect {        draw square(1);    }    aspect secondAspect {        draw circle(1);    }}experiment MyExperiment type: gui {    output {        display MyDisplay type: opengl {            species MyGrid aspect: firstAspect;        }    }}\nBeware: do not use this second display when you have large grids: it is much slower.\nGrid from a matrix​\nAn easy way to load some values in a grid is to use matrix data. A matrix is a type of container (we invite you to learn some more about this useful type here). Once you have declared your matrix, you can set the values of your cells using the ask statement :\nglobal {    init {        matrix data <- matrix([[0,1,1],[1,2,0]]);        ask cell {            grid_value <- float(data[grid_x, grid_y]);        }     }}\nDeclaring larger matrix in GAML can be boring as you can imagine. You can load your matrix directly from a csv file with the operator matrix (used for the contruction of the matrix).\nfile my_file <- csv_file(\"path/file.csv\",\"separator\");matrix my_matrix <- matrix(my_file);\nYou can try to read the following csv :\n0,0,0,0,0,0,0,0,0,0,00,0,0,1,1,1,1,1,0,0,00,0,1,1,0,0,0,1,1,0,00,1,1,0,0,0,0,0,0,0,00,1,1,0,0,1,1,1,1,0,00,0,1,1,0,0,1,1,1,0,00,0,0,1,1,1,1,0,1,0,00,0,0,0,0,0,0,0,0,0,0\nWith the following model:\nmodel import_csvglobal {    file my_csv_file <- csv_file(\"../includes/test.csv\",\",\");    init {        matrix data <- matrix(my_csv_file);        ask my_gama_grid {            grid_value <- float(data[grid_x,grid_y]);            write data[grid_x,grid_y];        }    }}grid my_gama_grid width: 11 height: 8 {    reflex update_color {        write grid_value;        color <- (grid_value = 1) ? #blue : #white;    }}experiment main type: gui{    output {        display display_grid {            grid my_gama_grid;        }    }}\nFor more complicated models, you can read some other files, such as ASCII files (asc), DEM files. In this case, the creation of the grid is even easier as the dimensions of the grid can be read from the file with the file facet:\ngrid my_grid from: my_asc_file {   }\nExample​\nTo practice a bit those notions, we will build a quick model. A \"regular\" species will move randomly on the environment. A grid is displayed, and its cells becomes red when an instance of the regular species is waking inside this cell, and yellow when the regular agent is in the surrounding of this cell. If no regular agent is on the surrounding, the cell turns green.\n\nHere is an example of implementation:\nmodel my_grid_modelglobal{    float max_range <- 5.0;    int number_of_agents <- 5;    init {\tcreate my_species number: number_of_agents;    }        reflex update {\task my_species {\t    do wander amplitude: 180.0;\t\t    ask my_grid at_distance(max_range) {\t\tif(self overlaps myself) {\t\t    self.color_value <- 2;\t\t} else if (self.color_value != 2) {\t\t    self.color_value <- 1;\t\t}\t    }\t}\task my_grid {\t    do update_color;\t}\t    }}species my_species skills:[moving] {    float speed <- 2.0;    aspect default {\tdraw circle(1) color: #blue;    }}grid my_grid width:30 height:30 {    int color_value <- 0;    action update_color {\tif (color_value = 0) {\t    color <- #green;\t} else if (color_value = 1) {\t    color <- #yellow;\t} else if (color_value = 2) {\t    color <- #red;\t}\tcolor_value <- 0;    }}experiment MyExperiment type: gui {    output {        display MyDisplay type: java2D {            grid my_grid lines: #black;            species my_species aspect: default;         }    }}"},{"filePath":"https:--gama-platform.org--wiki-Headless-mode-for-dummies.txt","text":"Headless mode for dummiesOverview​\nThis tutorial presents the headless mode usage of GAMA. We will execute the Predator-Prey model, already presented in this tutorial.\nHeadless mode is documented in its dedicated part, here, we focus on the definition of an experiment plan, where the model is run several times. We only consider the shell script execution, not the java command execution.\nIn headless-mode, GAMA can be seen as any shell command, whose behavior is controlled by passing arguments to it.\nYou must provide 2 arguments :\n\nan **input experiment file **, used to describe the execution plan of your model, its inputs and the expected outputs.\nan ** output directory **, where the results of the execution are stored\n\nHeadless-mode is a little more technical to handle than the general GAMA use-case, and the following commands and code have been solely tested on a Linux Ubuntu 22.04 machine with the default GAMA 1.9.2 (installer version, with embedded JDK).\nYou may have to perform some adjustments (such as paths definition) according to your machine, OS, java and GAMA versions and so on.\nSetup​\nGAMA version​\nHeadless mode is frequently updated by GAMA developers, so you have to get the very latest build version of GAMA. You can download it here  https://github.com/gama-platform/gama/releases Be sure to pick the ** Continuous build **  version (The name looks like GAMA1.7_Linux_64_02.26.17_da33f5b.zip) and ** not ** the major release, e.g. GAMA1.7_Linux_64.zip.\nBig note on Windows OS (maybe on others), GAMA must be placed outside of several sensible folders (Program Files, Program Filesx64, Windows).  RECOMMENDED: Place GAMA in Users Folder of windows OS.\ngama-headless.sh script setup​\nThe gama-headless.sh script can be found under the headless directory, in GAMA installation directory e.g. : `~/GAMA/headless/\nModifying the script (a little bit)​\nThe original script looks like this :\n#! /bin/bashmemory=2048mdeclare -i i\ti=0echo ${!i}\tfor ((i=1;i<=$#;i=$i+1))doif test ${!i} = \"-m\"then    i=$i+1    memory=${!i}else    PARAM=$PARAM\\ ${!i}    i=$i+1    PARAM=$PARAM\\ ${!i}fidone\techo \"******************************************************************\"echo \"* GAMA version 1.9.2                                             *\"echo \"* http://gama-platform.org                                       *\"echo \"* (c) 2007-2023 UMI 209 UMMISCO IRD/UPMC & Partners              *\"echo \"******************************************************************\"passWork=.work$RANDOM\tjava -cp ../plugins/org.eclipse.equinox.launcher*.jar -Xms512m -Xmx$memory  -Djava.awt.headless=true org.eclipse.core.launcher.Main  -application msi.gama.headless.id4 -data $passWork $PARAM $mfull $outputFile\trm -rf $passWork\nNotice the final command of the script rm -rf $passWork. It is intended to remove the temporary file used during the execution of the script. For now, we should comment this commmand, in order to check the logs if an error appears: #rm -rf $passWork\nSetting the experiment file​\nHeadless mode uses a XML file to describe the execution plan of a model. An example is given in the headless mode documentation page.\nThe script looks like this :\n** N.B. this version of the script, given as an example, is deprecated**\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><Experiment_plan>\t<Simulation id=\"2\" sourcePath=\"./predatorPrey/predatorPrey.gaml\" finalStep=\"1000\" experiment=\"predPrey\">\t\t<Parameters>\t\t\t<Parameter name=\"nb_predator_init\" type=\"INT\" value=\"53\" />\t\t\t<Parameter name=\"nb_preys_init\" type=\"INT\" value=\"621\" />\t\t</Parameters>\t\t<Outputs>\t\t\t<Output id=\"1\" name=\"main_display\" framerate=\"10\" />\t\t\t<Output id=\"2\" name=\"number_of_preys\" framerate=\"1\" />\t\t\t<Output id=\"3\" name=\"number_of_predators\" framerate=\"1\" />\t\t\t<Output id=\"4\" name=\"duration\" framerate=\"1\" />\t\t</Outputs>\t</Simulation></Experiment_plan>\nAs you can see, you need to define 3 things in this minimal example:\n\nSimulation:  its id, path to the model, finalStep (or stop condition), and name of the experiment\nParameters name, of the model for this simulation (i.e. Simulation of id= 2)\nOutputs of the model: their id, name, type, and the rate (expressed in cycles) at which they are logged in the results file during the simulation\n\nWe now describe how to constitute your experiment file.\nExperiment File: Simulation​\nid​\nFor now, we only consider one single execution of the model, so the simulation id is not critical, let it unchanged.\nLater example will include different simulations in the same experiment file.\nSimulation id is a string. Don't introduce weird symbols into it.\nsourcePath​\nsourcePath is the relative (or absolute) path to the model file you want to execute headlessly.\nHere we want to execute the fourth model of the Predator Prey tutorial suite, located in ~/GAMA/plugins/msi.gama.models_1.7.0.XXXXXXXXXXXX/models/Tutorials/Predator Prey/models (with XXXXXXXXXXXX replaced by the number of the release you downloaded)\nSo we set sourcePath=\"../plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 07.gaml\"  (Remember that the headless script is located in ~/GAMA/headless/)\nDepending on the directory you want to run the gama-headless.sh script, sourcePath must me modified accordingly.\nAnother workaround for shell more advanced users is to define a  $GAMA_PATH, $MODEL_PATH and $OUPUT_PATH in gama-headless.sh script.\nDon't forget the quotes \" around your path.\nfinalStep​\nThe duration, in cycles, of the simulation.\nexperiment​\nThis is the name of (one of) the experiment statement at the end of the model code.\nIn our case there is only one, called prey_predator and  it looks like this :\nexperiment prey_predator type: gui {\tparameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;\tparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;\tparameter \"Prey max transfert: \" var: prey_max_transfert  category: \"Prey\" ;\tparameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\toutput {\t\tdisplay main_display {\t\t\tgrid vegetation_cell lines: #black ;\t\t\tspecies prey aspect: base ;\t\t}\t\tmonitor \"Number of preys\" value: nb_preys ;\t}}  \nSo we are now able to constitute the entire Simulation tag:\n<Simulation id=\"2\" sourcePath=\"~/GAMA/plugins/msi.gama.models_1.7.0.201702260518/models/Tutorials/Predator Prey/models/Model 01.gaml\" finalStep=\"1000\" experiment=\"prey_predator\">\nN.B. the numbers after msi.gama.models (the number of your GAMA release actually) have to be adapted to your own release of GAMA number.\nThe path to the GAMA installation directory has also to be adapted of course.\nExperiment File: Parameters​\nThe parameters section of the experiment file describes the parameters names, types and values to be passed to the model for its execution.\nLet's say we want to fix the number of preys and their max energy  for this simulation.\nWe look at the experiment section of the model code and use their ** title **.\nThe title of a parameter is the name that comes right after the parameter statement. In our case,  the strings \"Initial number of preys: \" and \"Prey max energy: \" (Mind the spaces, quotes and colon)\nThe parameters section of the file would look like :\n<Parameters>\t<Parameter name=\"Initial number of preys: \" type=\"INT\" value=\"621\" />\t<Parameter name=\"Prey max energy: \" type=\"FLOAT\" value=\"1.0\" /></Parameters>\nAny declared parameter can be set this way, yet you don't have to set all of them, provided they are initialized with a default value in the model (see the global statement part of the model code).\nExperiment File: Outputs​\nOutput section of the experiment file is pretty similar to the previous one, except for the id that have to be set for each of the outputs .\nWe can log some of the declared outputs  : main_display and number_of_preys.\nThe outputs section would look like the following:\n<Outputs>\t<Output id=\"1\" name=\"main_display\" framerate=\"10\" />\t<Output id=\"2\" name=\"Number of preys\" framerate=\"1\" /></Outputs>\nOutputs must have an id, a name, and a framerate.\n\nid is a number that identifies the output\nframerate is the rate at which the output is written in the result file. It's a number of cycle of simulation (integer). In this example the display is saved every 10 cycle\nname is either the \"title\" of the corresponding monitor. In our case, the second output's is the title of the monitor \"Number of preys\", i.e. \"Number of preys\"\n\nWe also save a **display ** output, that is an image of the simulation graphical display named main_display in the code of the model. Theses images is what you would have seen if you had run the model in the traditional GUI mode.\nExecution and results​\nOur new version of the experiment file is ready :\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><Experiment_plan>\t<Simulation id=\"2\" sourcePath=\"/absolute/path/to/your/model/file/Model 04.gaml\" finalStep=\"1000\" experiment=\"prey_predator\">\t\t<Parameters>\t\t\t<Parameter name=\"Initial number of preys: \" type=\"INT\" value=\"621\" />\t\t\t<Parameter name=\"Prey max energy: \" type=\"FLOAT\" value=\"1.0\" />\t\t</Parameters>\t\t<Outputs>\t\t\t<Output id=\"1\" name=\"main_display\" framerate=\"10\" />\t\t\t<Output id=\"2\" name=\"Number of preys\" framerate=\"1\" />\t\t</Outputs>\t</Simulation></Experiment_plan>\nExecution​\nWe have to launch the gama-headless.sh script and provide two arguments : the experiment file we just completed and the path of a directory where the results will be written.\n** Warning ** In this example ,we are lazy and define the source path as the absolute path to the model we want to execute. If you want to use a relative path, note that it has to be define relatively to the location of your ** ExperimentFile.xml location ** (and the location where you launched the script)\nIn a terminal, position yourself in the headless directory : `~/GAMA/headless/'.\nThen type the following command :\ngama-headless.sh -v ~/a/path/to/MyExperimentFile.xml  /path/to/the/desired/output/directory  \nAnd replace paths by the location of your ExperimentFile and output directory\nYou should obtain the following output in the terminal :\n******************************************************************* GAMA version 1.7.0 V7                                          ** http://gama-platform.org                                       ** (c) 2007-2016 UMI 209 UMMISCO IRD/UPMC & Partners              *******************************************************************>GAMA plugin loaded in 2927 ms: \tmsi.gama.core>GAMA plugin loaded in 67 ms: \tummisco.gama.network>GAMA plugin loaded in 56 ms: \tsimtools.gaml.extensions.traffic>GAMA plugin loaded in 75 ms: \tsimtools.gaml.extensions.physics>GAMA plugin loaded in 1 ms: \tirit.gaml.extensions.test>GAMA plugin loaded in 75 ms: \tummisco.gaml.extensions.maths>GAMA plugin loaded in 47 ms: \tmsi.gaml.extensions.fipa>GAMA plugin loaded in 92 ms: \tummisco.gama.serialize>GAMA plugin loaded in 49 ms: \tirit.gaml.extensions.database>GAMA plugin loaded in 2 ms: \tmsi.gama.lang.gaml>GAMA plugin loaded in 1 ms: \tmsi.gama.headless>GAMA plugin loaded in 103 ms: \tummisco.gama.java2d>GAMA plugin loaded in 189 ms: \tmsi.gaml.architecture.simplebdi>GAMA plugin loaded in 129 ms: \tummisco.gama.opengl>GAMA building GAML artefacts>GAMA total load time 4502 ms. in 714 mscpus :8Simulation is running.......................................................................................................Simulation duration: 7089ms\nResults​\nThe results are stored in the output directory you provided as the second argument of the script.\n3 items have appeared:\n\nA console_output.txt file, containing the output of the GAMA console of the model execution if any\na XML file simulation-outputXX.xml, where XX is the id number of your simulation. In our case it should be 2.\nthe folder snapshots containing the screenshots coming from the second declared output : main_display. image name format is main_display[id]_[cycle].png.\n\nThe values of the monitor \"Number of preys\" are stored in the xml file simulation-outputXX.xml\nCommon error messages​\nException in thread \"Thread-7\" No parameter named prey_max_energy in experiment prey_predator\nProbably a typo in the name or the title of a parameter. check spaces, capital letters, symbols and so on.\njava.io.IOException: Model file does not exist: /home/ubuntu/dev/tutoGamaHeadless/../plugins/msi.gama.models_1\nThis may be a relative path mistake; try with absolute path.\njava.lang.NumberFormatException: For input string: \"1.0\"\nThis may be a problem of type declaration in the parameter section.\nGoing further​\nExperiments of several simulation​\nYou can launch several simulation by replicating the simulation declaration in your ExperimentFile.xml and varying the values of the parameters.\nSince you will have to edit the experiment file by hand, you should do that only for a reasonable number of simulations (e.g. <10 )\nDesign of experiments plans​\nFor more systematic parameter values samples, you should turn towards a more adapted tool such as GAMAR, to generate a ExperimentFile.xml with a huge number of simulations."},{"filePath":"https:--gama-platform.org--wiki-HeadlessBatch.txt","text":"Headless BatchGetting started​\nThis headless mode is the Batch one.\nThe advantage of this mode is how easily it is to prepare and launch, contrarily to the Headless Legacy, this mode does not need any other file than the GAML file holding the experiment of type batch.\nYou can run your gama experiment with a command similar to this:\n./gama-headless.sh [option] -batch experimentName /path/to/file.gaml\n\nwith:\n\n-batch: the flag that indicates it is a batch exploration\nexperimentName: the name of your batch experiment in the following file\n/path/to/file.gaml: the path (relative or absolute) to the batch experiment\n\n\n\nSimulation Output​\nUnfortunatly, this mode can't save output data automatically, the actual way to do is saving wanted data inside CSV files from your model.\nCalling GAMA headless on Windows​\nThe example below assumes that your GAMA application is in folder D:\\software\\ and your project (model) file is in folder D:\\my_models\\\nWindows PowerShell​\n\nYou can open Windows PowerShell, change your directory to the headless folder and run gama-headless command:\n\ncd D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\\.\\gama-headless.bat -batch Optimization D:\\my_models\\predatorPrey\\predatorPrey.gaml\nCommand Prompt​\n\nYou can open Command Prompt, change your directory to the headless folder and run gama-headless command:\n\ncd D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\\gama-headless.bat -batch Optimization D:\\my_models\\predatorPrey\\predatorPrey.gaml\nPython Script​\n\nYour python script will have the following lines of code, mainly using the os package to run the native system commands\n\nimport osos.chdir(\"D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\")os.system(\"gama-headless.bat -batch Optimization D:\\my_models\\predatorPrey\\predatorPrey.gaml\") "},{"filePath":"https:--gama-platform.org--wiki-HeadlessLegacy.txt","text":"Headless LegacyGetting started​\nThis headless mode is the Legacy one. So, if you are already familiar with headless from version 1.8.1 or older, nothing changed.\nThis mode relies on writing an explicit simulation plan in XML file. Those simulations, mostly for legacy reason, have to be of type gui (which is pretty counterintuitive, but this type let you set the parameter value to each simulation independently), but you don't have to write it explicitly as it's the default type for an experiment.\nYou can generate a first XML file corresponding to an existing experiment with the following command:\n./gama-headless.sh -xml experimentName /path/to/inputFile.gaml /path/to/outputFile.xml\n\nwith:\n\n-xml: the flag asking the headless to generate a XML file well-formatted for our experiment\nexperimentName: the name of the experiment you want to run in headless\n/path/to/inputFile.gaml: the path (relative or absolute) to your GAML file containing the experiment you want to run\n/path/to/outputFile.xml: the path (relative or absolute) to the generated XML file\n\n\n\nYou can see more in details the content of the generated XML file (applied on the model Predator Prey) in the Experiment Input File part.\nOnce you finished preparing your XML file, you can run it with a command similar to the following one:\n./gama-headless.sh /path/to/file.xml /path/to/generated/outputFolder\n\nwith:\n\n/path/to/file.xml: the path (relative or absolute) to the XML file containing the full exploration plan to run by the headless\n/path/to/generated/outputFolder: the path (relative or absolute) which will be generated by GAMA and hold every output files (variables, snapshots, and console messages)\n\n\n\nYou can see result output folder in the Simulation Output part\nExperiment Input File​\nThe XML input file contains for example (you can find it next to the file gama-headless.sh at the path samples/predatorPrey.xml:\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><Experiment_plan>\t<Simulation experiment=\"prey_predatorExp\" finalStep=\"1000\" id=\"0\" seed=\"1.0\" sourcePath=\"./samples/predatorPrey/predatorPrey.gaml\">\t\t<Parameters>\t\t\t<Parameter name=\"Nb Preys: \" type=\"INT\" value=\"200\" var=\"nb_preys_init\"/>\t\t\t<Parameter name=\"Prey max energy: \" type=\"FLOAT\" value=\"1.0\" var=\"prey_max_energy\"/>\t\t\t<Parameter name=\"Prey max transfert: \" type=\"FLOAT\" value=\"0.1\" var=\"prey_max_transfert\"/>\t\t\t<Parameter name=\"Prey energy consumption: \" type=\"FLOAT\" value=\"0.05\" var=\"prey_energy_consum\"/>\t\t\t<Parameter name=\"Nb predators: \" type=\"INT\" value=\"20\" var=\"nb_predators_init\"/>\t\t\t<Parameter name=\"Predator max energy: \" type=\"FLOAT\" value=\"1.0\" var=\"predator_max_energy\"/>\t\t\t<Parameter name=\"Predator energy transfert: \" type=\"FLOAT\" value=\"0.5\" var=\"predator_energy_transfert\"/>\t\t\t<Parameter name=\"Predator energy consumption: \" type=\"FLOAT\" value=\"0.02\" var=\"predator_energy_consum\"/>\t\t</Parameters>\t\t<Outputs>\t\t\t<Output framerate=\"1\" id=\"0\" name=\"Number of preys\"/>\t\t\t<Output framerate=\"1\" id=\"1\" name=\"Number of predators\"/>\t\t\t<Output framerate=\"1\" id=\"2\" name=\"main_display\"/>\t\t</Outputs>\t</Simulation></Experiment_plan>\n\nNB: Several simulations can be determined in one experiment plan. These simulations are run in parallel according to the number of allocated cores.\n\nSimulation​\n<Simulation experiment=\"prey_predatorExp\" finalStep=\"1000\" id=\"0\" seed=\"1.0\" sourcePath=\"./samples/predatorPrey/predatorPrey.gaml\">\n\nwith:\n\nexperiment (required): determines which experiment should be run on the model. This experiment should exist, otherwise, the headless mode will exit.\nfinalStep (required): determines the number of simulation steps you want to run.\nid (required): permits to prefix output files for experiment plans with huge simulations.\nseed (optional): permits to set the seed value of the simulation.\nsourcePath (required): contains the relative or absolute path to read the gaml model.\nuntil (optional): defines a stop condition in GAML. It can be combined with the finalStep facet (in this case a simulation will finish when the stop condition is fulfilled or when the final step is reached).\n\n\n\nParameters​\nOne line per parameter you want to specify a value to:\n<Parameter name=\"Nb Preys: \" type=\"INT\" value=\"200\" var=\"nb_preys_init\"/>\n\nwith:\n\nname:  name of the parameter in the gaml model\ntype (required):  type of the parameter (INT, FLOAT, BOOLEAN, STRING)\nvalue (required): the chosen value\nvar:  name of the parameter variable in the gaml model\n\n\n\n\nNB: You need to set at least one of the attributes name or var in your Parameter tag)\n\nOutputs​\nOne line per output value you want to retrieve. Outputs can be the name of monitors or displays defined in the 'output' section of experiments, or the names of attributes defined in the experiment or the model itself (in the 'global' section).\n    ... with the name of a monitor defined in the 'output' section of the experiment...    <Output framerate=\"1\" id=\"1\" name=\"Number of predators\"/>    ... with the name of a (built-in) variable defined in the experiment itself...    <Output framerate=\"1\" id=\"2\" name=\"main_display\"/>\n\nwith:\n\nframerate (required): the frequency of the monitoring (each step, every 2 steps, every 100 steps...).\nid (optional): permits to prefix output files for simulation with huge outputs\nname (required): name of the output in the 'output'/'permanent' section in the experiment or name of the experiment/model attribute to retrieve\noutput_path (optional): change the output directory where snapshot images are saved (for display output only!)\n\n\n\n\nNB: the lower the framerate value is, the longer the experiment.\nNB2: if the chosen output is a display, an image is produced and the output file contains the path to access this image\n\nOutput Directory​\nDuring headless experiments, a directory is created with the following structure:\nOutputed-directory-path/out├── console-outputs-0.txt├── simulation-outputs0.xml└── snapshot    ├── main_display0-0.png    ├── main_display0-1.png    ├── main_display0-2.png    ├── main_display0-3.png    ├── main_display0-4.png    └── ...\n\nwith:\n\nconsole-outputs-<simulationId>.xml: containing every message written in GAMA's console\nsimulation-outputs<simulationId>.xml: containing variables' results in a XML format\nsnapshot: containing the snapshots (i.e. screenshots of gui displays) produced during the simulation\n\n\n\nSimulation Output​\nA file named simulation-output.xml is created with the following contents when the experiment runs.\n<?xml version=\"1.0\" encoding=\"UTF-8\"?><Simulation id=\"0\" >\t<Step id='0' >\t\t<Variable name='main_display' value='main_display2-0.png'/>\t\t<Variable name='number_of_preys' value='613'/>\t\t<Variable name='number_of_predators' value='51'/>                <Variable name='duration' value='6' />\t</Step>\t<Step id='1' >\t\t<Variable name='main_display' value='main_display2-0.png'/>\t\t<Variable name='number_of_preys' value='624'/>\t\t<Variable name='number_of_predators' value='51'/>                <Variable name='duration' value='5' />\t</Step>        <Step id='2'>...\n\nWith:\n\n<Simulation id=\"0\" >: tag containing results of the simulation. The id is set one set in the input file, in the heading part\n<Step id='0' >: one block per step done containing the value of outputs variables. The id corresponds to the step number\n\n<Variable /> with:\n\nname: name of the output\nvalue: the current value of the model variable at the given step.\n\n\n\n\n\n\n\n\nNB: The value of an output is repeated according to the framerate defined in the input experiment file.\nNB2: The value of an output display gives the relative path to the generated image saved in '.png' format.\n\nCalling GAMA headless legacy on Windows​\nThe example below assumes that your GAMA application is in folder D:\\software\\ and your project (model) file is in folder D:\\my_models\\\nThe data structure of the example model as in following. The example models can be found in the GAMA headless folder (GAMA_1.9.2_Windows_with_JDK\\headless\\samples\\predatorPrey)\npredatorPrey├── includes└── models    ├── ...    └── predatorPrey.gaml\nIn the predatorPrey model, we have a GUI experiment named prey_predator\nWindows PowerShell​\n\nYou can open Windows PowerShell, change your directory to the headless folder and run gama-headless command:\n\ncd D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\\.\\gama-headless.bat -xml prey_predator D:\\my_models\\predatorPrey\\models\\predatorPrey.gaml D:\\my_models\\predatorPrey\\models\\predatorPrey.xml.\\gama-headless.bat D:\\my_models\\predatorPrey\\models\\predatorPrey.xml D:\\my_models\\predatorPrey\\results\nCommand Prompt​\n\nYou can open Command Prompt, change your directory to the headless folder D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\\ then run the commands:\n\ngama-headless.bat -xml prey_predator D:\\my_models\\predatorPrey\\models\\predatorPrey.gaml D:\\my_models\\predatorPrey\\models\\predatorPrey.xmlgama-headless.bat D:\\my_models\\predatorPrey\\models\\predatorPrey.xml D:\\my_models\\predatorPrey\\results\nPython Script​\n\nYour python script will have the following lines of code, mainly using the os package to run the native system commands\n\nimport osos.chdir(\"D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\")os.system(\"gama-headless.bat -xml prey_predator D:\\my_models\\predatorPrey\\models\\predatorPrey.gaml D:\\my_models\\predatorPrey\\models\\predatorPrey.xml\")os.system(\"gama-headless.bat D:\\my_models\\predatorPrey\\models\\predatorPrey.xml D:\\my_models\\predatorPrey\\results\")"},{"filePath":"https:--gama-platform.org--wiki-HeadlessServer.txt","text":"Headless ServerRunning a Gama Headless server​\nBefore doing anything, make sure that you possess the rights to create files and directories at the location you are running gama-server because it will need it to create workspaces on the fly.\nFrom the release​\nGo to the headless directory in your Gama installation folder and run the script gama-headless.sh (or gama-headless.bat) with the argument -socket followed by the port number you want your Gama server to run on.\nFor example on Mac OS you could do:\ncd Gama.app/Contents/headless\nto move to the right directory, then run the script to listen on port 6868 with:\ngama-headless.sh -socket 6868\nFrom the command-line tool​\nThe users who installed gama through a .deb file or aur have access to the command gama-headless and thus only need to open a terminal and run\ngama-headless -socket 6868\nto run a Gama server on the port 6868.\nFrom the source code​\nIn Eclipse, instantiate a headless server by running msi.gama.headless.id4_full with the following argument -os ${target.os} -ws ${target.ws} -arch ${target.arch} -nl ${target.nl} -socket 6868 (you can specify any other port)\nFrom docker​\nFirst ensure to pull the official docker image\ndocker pull gamaplatform/gama:<version>\nThen, run the container with the image you just pulled.\nDo not forget to (1) expose the port you're starting your server on, and (2) mount your workspace inside the started container as below :\ndocker run -v <path/to/your/workspace>:/working_dir -p 6868:6868 gamaplatform/gama:<version> -socket 6868\nFor more informations, please refer to Docker's official documentation or GAMA image's repository.\nConnection​\nTo connect to gama-server as a client you just need to access the following address: ws://<ip>:<port>. For example if you try to connect to a gama-server running on your current computer and started with the command gama-headless -socket 6868, you will have to connect to ws://localhost:6868.\nOnce a client is connected, gama-server will send a json object of type ConnectionSuccessful.\nGeneral description of interactions​\nOnce connected, you can ask gama-server to execute different commands to control the execution of different simulations.\nIf you close your client application (or just close the socket on client-side) gama-server will destroy all running simulations of that client, so you have to keep your client alive.\nFor every command treated by gama-server, it will send back a json object describing if the command has been executed correctly or if there was a problem. If an unexpected exception is raised in gama-server, it will try to send the connected clients a json-object describing it.\nThe same goes if a simulation throws an exception/error while running, the client that asked for it to run will receive it as a json-object.\nIn addition, the client can ask gama-server to receive (or not) the different outputs of a simulation: write statements, dialogs, status-bar changes etc. they will be sent as they come, in a specific json wrapper.\nAvailable commands​\nAll the commands sent to gama-server must be formatted as a json object.\nThe available commands are:\nThe exit command​\nThis command is used to kill gama-server.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"exit\"}\nAnswer from gama-server​\nIt is the only command that won't send back a json object.\nThe load command​\nThis command is used to ask the server to initialize a specific experiment in a gaml file on the server's file-system.\nIt is triggered by sending a json object formatted as follows to the server:\n{  \"type\": \"load\",  \"model\": \"<gaml_file_path>\",  \"experiment\": \"<experiment_name>\",  \"console\": \"<console>\", //optional  \"status\": \"<status>\", //optional  \"dialog\": \"<dialog>\", //optional  \"runtime\": \"<runtime>\",//optional  \"parameters\": \"<params>\", //optional  \"until\": \"<end_condition>\", //optional}\nThe model parameter indicates the path of the experiment file on the server's file-system, and experiment is the actual name of the experiment to run.\nThe four parameters console, status, dialog and runtime are booleans used to determine if the messages from respectively the console, the status-bar, the dialogs and the runtime errors should be redirected to the client. They are optional as per default console and runtime are set to true and the two others to false.\nYou can add an array of parameters that will be used to initialize the experiment's variables with the values you picked.\nThe value of parameters should be formatted as follows:\n[  {    \"type\": \"<type of the first parameter>\",    \"value\": \"<value of the first parameter>\",    \"name\": \"<name of the first parameter in the gaml file>\"  },  {    \"type\": \"<type of the second parameter>\",    \"value\": \"<value of the second parameter>\",    \"name\": \"<name of the second parameter in the gaml file>\"  }, ...]\nYou can also add an ending condition to your simulation with the parameter until, the condition must be expressed in gaml.\nAnswer from gama-server​\nThe content field of the response json sent by gama-server after processing this command will directly contain the experiment_id value stored as a string.\nThe experiment id should be used in all the other commands to refer to that specific experiment in order to control it.\nThe play command​\nThis command is used to actually run an experimented already initialized.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"play\",  \"exp_id\": \"<experiment_id>\",  \"sync\": \"<synchronized>\", //optional}\nThe experiment_id is used to identify the experiment to play, and the optional sync is a boolean used in the case where there was an end condition defined in the load command, if it is true, gama-server will not send a response to the command, but only a end of simulation message once the condition is reached, if it's false gama-server will send both the response to the command and the SimulationEnded message.\nAnswer from gama-server​\nThis command has an empty content field in the response json sent by gama-server after processing it.\nIn case where the end condition is reached, a message of type SimulationEnded is sent to the client with an empty content.\nThe pause command​\nThis command is used to pause a running experiment.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"pause\",  \"exp_id\": \"<experiment_id>\"}\nAnswer from gama-server​\nThis command has an empty content field in the response json sent by gama-server after processing it.\nThe step command​\nThis command is used to process one (or a defined number of) step(s) of a simulation that has already been loaded.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"step\",  \"exp_id\": \"<experiment_id>\",  \"nb_step\": \"<number_of_steps>\", //optional  \"sync\": \"<synchronized>\", // optional}\nAs usual exp_id refers to the experiment you want to apply the command to. The nb_step parameter indicates how many steps you want to execute, if you do not give that parameter gama-server will execute one step. The sync parameter indicates whether gama-server must wait for the end of the step(s) to send back a success message (when its value is true), or just plan the step(s) and send one directly after (when its value is false), this parameter can be ignored and will be interpreted as if it were false.\nAnswer from gama-server​\nThis command has an empty content field in the response json sent by gama-server after processing it.\nThe stepBack command​\nThis command is used to rollback the simulation one (or a defined number of) step(s) back. This command only works on experiments of type memorize.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"stepBack\",  \"exp_id\": \"<experiment_id>\",  \"nb_step\": \"<number_of_steps>\", //optional  \"sync\": \"<synchronized>\", // optional}\nThe parameters are exactly the same as in the step command.\nAnswer from gama-server​\nThis command has an empty content field in the response json sent by gama-server after processing it.\nThe stop command​\nThis command is used to stop (kill) a running experiment.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"stop\",  \"exp_id\": \"<experiment_id>\",}\nAnswer from gama-server​\nThis command has an empty content field in the response json sent by gama-server after processing it.\nThe reload command​\nThis command is used to reload an experiment. The experiment will be stop and the initialization process run again. You can use this command to change the simulation parameters or the ending condition.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"reload\",  \"exp_id\": \"<experiment_id>\",  \"parameters\": \"<params>\", //optional  \"until\": \"<end_condition>\", //optional}\nJust like for the load command, the parameters and the until parameters are optional and must follow the same formatting.\nAnswer from gama-server​\nThis command has an empty content field in the response json sent by gama-server after processing it.\nThe expression command​\nThis command is used to ask the server to evaluate a gaml expression having an experiment as context.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"expression\",  \"exp_id\": \"<experiment_id>\",  \"expr\": \"<expression to evaluate>\"}\nFor example if you want to know the number of agents of species people currently present in the simulation represented by the id 123, you could send this command to gama-server:\n{  \"type\": \"expression\",  \"exp_id\": \"123\",  \"expr\": \"length(people)\"}\nAnswer from gama-server​\nIf the command is executed successfully by gama-server the content field of the response json will directly contain the result of the evaluated expression as a string.\nThe download command​\nThis command is used to download a file from the gama-server file system.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"download\",  \"file\": \"<path_to_file>\",}\nThe file parameter is mandatory, it represents the path of the file to download expressed in gama-server's file system.\nAnswer from gama-server​\nOn success, this command will trigger a json response message which content field will be filled with the file's content.\nThe upload command​\nThis command is used to upload a file to the gama-server file system.\nIt is triggered by sending a json object formatted as follows to the server\n{  \"type\": \"download\",  \"file\": \"<path_to_file>\",  \"content\": \"<file_content>\",}\nThe file and content parameters are mandatory, they represent respectively the path where the file will be uploaded on gama-server's file system and the content of the file as a string of characters.\nAnswer from gama-server​\nThis command has an empty content field in the response json sent by gama-server after processing it.\nGama-server messages​\nAll messages send by gama-server follow a json architecture that is formatted as follows:\n{  \"type\": \"some string describing the type of message\",  \"content\": \"a field containing everything additional information for the message\", //It can be a string, an int or a json object  \"exp_id\": \"contains the experiment id (as a string) to which this message is linked to\", //Optional, its presence depends on the message's type  \"command\": \"a json containing the original command to which gama is responding\",//Optional, is only present in messages responding directly to a command sent by the client}\nMessages types​\nAll messages have in common a type field that informs the client of the type of message sent.\nThe different types possibles are:\n\nConnectionSuccessful: Used when a client connected without any problem to gama-server\nSimulationStatus: Signals a message representing a simulation status\nSimulationStatusInform: Signals a message representing a simulation inform status\nSimulationStatusError: Signals a message representing a simulation error status\nSimulationStatusNeutral: Signals a message representing a simulation neutral status\nSimulationOutput: Signals a message as would be written in the console by a write statement in gama with an interface\nSimulationDebug: Signals a message as would be written in the console by a debug statement in gama with an interface\nSimulationDialog: Signals a message representing what would be a dialog in gama with an interface\nSimulationErrorDialog: Signals a message representing what would be an dialog in gama with an interface\nSimulationError: Signals a message representing an error raised in a running simulation\nRuntimeError: Signals a message representing an exception raised in gama-server while trying to process a command\nGamaServerError: Signals a message representing an unknown exception raised in gama-server (can be unrelated to any command)\nMalformedRequest: Signals that a command sent by the client doesn't follow the expected format (lack of parameter, wrong type etc.)\nCommandExecutedSuccessfully: Signals that a command sent by the client was executed without any problem on gama-server\nSimulationEnded: Signals that a running simulation reached its end condition and stopped. Beware if the simulation stops for another reason, this message won't be send.\nUnableToExecuteRequest: Signals that a command cannot be executed, though it may be formatted correctly. It mainly occurs when trying to execute a command on a simulation that is not currently running.\n\nConnection related answers​\nWhen your client is connected correctly to gama-server, a message is sent. Its type is ConnectionSuccessful with an empty content.\nIn case of problem, the client may receive a message of type GamaServerError or just get a timeout/broken connection message at the socket level.\nCommand answers​\nFor every command described in the commands section, the client will received a json answer formatted as follows:\n{  \"type\": \"some string describing the type of message\",  \"content\": \"a field containing every additional information for the message\", //It can be a string, an int or a json object, depending on the type of message, it could also be empty  \"command\": \"a json containing the original command to which gama is responding\"}\nSo for example if you send an expression command to gama, with an experiment_id of value 2 and you want to evaluate the expression length(people) to know the number of agent people in that simulation. You may receive an answer looking like this:\n{  \"type\": \"CommandExecutedSuccessfully\", //The type indicates that everything went normally  \"content\": 102, //There are 102 agents of the species people in your simulation at the time of evaluation  \"command\": //The description of the command you sent, as interpreted by gama-server and turned into a json  {    \"type\": \"expression\",    \"exp_id\": \"2\",    \"expr\": \"length(people)\",  }}\nThe command field is very useful for clients that run multiple simulations and commands at the same time, as it can be used to retrace which command the message responds to.\nNote: The command field contains all the parameters of the command sent by the client, including those that are not useful for GAMA to execute the command, you can thus use it to store more data, like an internal id used by the client, some kind of counter etc..\nIn case there is an error resulting from the processing of your command, you may receive an error message of type:\n\nMalformedRequest if you forgot a mandatory parameter to execute the command or gave objects that couldn't be de-serialized. The list of required parameters will be sent as a string in the content field.\nUnableToExecuteRequest if you are trying to execute a command on a simulation that is not currently running or some other problem of \"logic\". You will find more informations in the content field.\nRuntimeError and GamaServerError if while executing your command, an exception happens, either in gaml code for RuntimeError or in gama's code for GamaServerError. The exception's description will be given in the content field, as a json object containing the error message and the stack trace.\n\nThere is no exp_id field in those messages, because it is already included in all the command fields that are related to an experiment.\nErrors and exceptions​\nIn addition to the error messages you can receive when directly requesting to execute a command (MalformedRequest, UnableToExecuteRequest) described in the command answers section, or the network errors that can be raised for external problems, it is possible that gama-server encounters an exception while running. In that case gama-server will send a json message formatted as described in the Gama-server messages section, the two different types would either be GamaServerError, RuntimeError or SimulationError and the content field would be filled as follows:\n{  \"exception\": \"The java class of the exception\",  \"message\": \"The message describing the problem\",  \"stack\": [],//The stack trace of the exception given as a list of strings}\nthe exp_id and command fields would be present if possible, depending on where the exception happens.\nSimulations outputs​\nAs mentioned in the introduction and the description of the load command. You can ask gama-server to redirect the simulation's outputs. There are 3 different types of output produced by a simulation that you can chose to redirect or not:\n\nthe messages in the dialogs\nthe messages in the status-bar\nthe messages in the gama console\nEach has an associated boolean that you have to set to true in the load command in order to have it redirected to the client.\n\nThe output messages are sent directly to the client as soon as they are asked by the simulation. The format of the output messages follows the usual message format. The exp_id will always be filled with the current experiment id, the 'command' field won't be present.\nThe different types of messages possible are:\n\nfor dialog messages: SimulationDialog and SimulationErrorDialog respectively for normal dialogs and error dialogs\nfor status messages: SimulationStatusNeutral, SimulationStatusError, SimulationStatusInform, SimulationStatus\nfor console messages: SimulationOutput for the messages written with the write statement and SimulationDebug for the ones written with the debug statement.\n\nThe content field will be formatted as follows:\n\nfor dialog messages, it's directly a string containing the message\nfor status messages:\n\n{  \"message\": \"the status message\",  \"icon\": \"the name/path of the associated icon\", //only present for some SimulationStatus and SimulationStatusInform messages  \"color\":   {    \"r\": \"red value\",     \"g\": \"green value\",     \"b\": \"blue value\",  }, // The background color in the status-bar, only present in some SimulationStatus messages}\n\nfor console messages:\n\n{  \"message\": \"the message as it would be written in the console\",  \"color\":   {    \"r\": red_value,     \"g\": green_value,     \"b\": blue value,  }, // The text color  \"cycle\": simulation_cycle, // the cycle of the simulation at the moment the debug statement is executed, only for SimulationDebug messages}\nPython wrapper​\nA python package is available to interact with Gama server as a client, you can find it here. It will take care of formatting the queries to the server and receiving the answers. You simply have to install the package into your python environment with the command pip install gama-client and then import gama_client into your python files. For more information follow the README.md available on the package's github.\nJavascript Client​\nThere is also a javascript client being developed in this repository gama.client\nHello World Visualization in MapBox​\n\nClone the repository gama.client\nIn js/gama_client.js edit the following variable ABSOLUTE_PATH_TO_GAMA to your local path (e.g var ABSOLUTE_PATH_TO_GAMA = '/Users/arno/';)\nopen index.htmlin a browser\n\nHello World Message example​\n\nIn js/simple_syntax.js edit the following variable modelPath to your model's path\nopen syntax.htmlin a browser\n\nTroubleshooting​\ncrash on load command​\nIt is possible that gama-server starts and accepts connections, but crashes when receiving a load command with a message of the type:\njava.lang.Exception: java.lang.NoClassDefFoundError: org/eclipse/core/resources/ResourcesPlugin        at org.java_websocket.server.WebSocketServer$WebSocketWorker.run(WebSocketServer.java:1093)Caused by: java.lang.NoClassDefFoundError: org/eclipse/core/resources/ResourcesPlugin        at msi.gama.lang.gaml.indexer.GamlResourceIndexer.<clinit>(GamlResourceIndexer.java:54)        at msi.gama.lang.gaml.resource.GamlResource.doLinking(GamlResource.java:362)        at org.eclipse.xtext.resource.XtextResource.updateInternalState(XtextResource.java:304)        at org.eclipse.xtext.resource.XtextResource.updateInternalState(XtextResource.java:292)        at msi.gama.lang.gaml.resource.GamlResource.updateInternalState(GamlResource.java:308)        at org.eclipse.xtext.resource.XtextResource.doLoad(XtextResource.java:182)        at org.eclipse.xtext.linking.lazy.LazyLinkingResource.doLoad(LazyLinkingResource.java:115)        at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1563)        at org.eclipse.emf.ecore.resource.impl.ResourceImpl.load(ResourceImpl.java:1342)        at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.demandLoad(ResourceSetImpl.java:259)        at org.eclipse.emf.ecore.resource.impl.ResourceSetImpl.demandLoadHelper(ResourceSetImpl.java:274)        at org.eclipse.xtext.resource.XtextResourceSet.getResource(XtextResourceSet.java:266)        at org.eclipse.xtext.resource.SynchronizedXtextResourceSet.getResource(SynchronizedXtextResourceSet.java:33)        at msi.gama.lang.gaml.validation.GamlModelBuilder.buildModelDescription(GamlModelBuilder.java:111)        at msi.gama.lang.gaml.validation.GamlModelBuilder.compile(GamlModelBuilder.java:97)        at msi.gama.headless.core.HeadlessSimulationLoader.loadModel(HeadlessSimulationLoader.java:155)        at msi.gama.headless.core.HeadlessSimulationLoader.loadModel(HeadlessSimulationLoader.java:126)        at msi.gama.headless.job.JobListFactory.constructAllJobs(JobListFactory.java:46)        at msi.gama.headless.script.ExperimentationPlanFactory.buildExperiment(ExperimentationPlanFactory.java:183)        at msi.gama.headless.listener.LoadCommand.launchGamlSimulation(LoadCommand.java:74)        at msi.gama.headless.listener.LoadCommand.execute(LoadCommand.java:37)        at msi.gama.headless.listener.LoadCommand.execute(LoadCommand.java:1)        at msi.gama.headless.listener.CommandExecutor.process(CommandExecutor.java:43)        at msi.gama.headless.listener.GamaWebSocketServer.onMessage(GamaWebSocketServer.java:209)        at org.java_websocket.server.WebSocketServer.onWebsocketMessage(WebSocketServer.java:712)        at org.java_websocket.drafts.Draft_6455.processFrameText(Draft_6455.java:986)        at org.java_websocket.drafts.Draft_6455.processFrame(Draft_6455.java:910)...\nThis issue arises because gama-server tries to create a workspace for your experiment but does not have the appropriate rights to do it.\nIt can be the case in windows if you run gama-server directly from the headless directory from the installation folder (protected by default) and that you are not an Admin"},{"filePath":"https:--gama-platform.org--wiki-HeadlessTutorial.txt","text":"Calling gama from another programThis tutorial presents an example for using Headless. The tutorial shows how to use Headless Legacy mode, Headless batch and Headless server.\nAll the files related to this tutorial (images and models) are available in the Headless folder (headless/samples/predatorPrey).\n1. Example using python with Headless legacy​\nimport osGAMA_folder_with_SDK = r\"D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\"Model_file = GAMA_folder_with_SDK + r\"\\samples\\predatorPrey\\predatorPrey.gaml\"ExperimentName = \"prey_predator\"XML_file = GAMA_folder_with_SDK + r\"\\samples\\predatorPrey.xml\"Output_folder = GAMA_folder_with_SDK + r\"\\samples\\predatorPrey\"os.chdir(GAMA_folder_with_SDK)os.system(\"gama-headless.bat -xml \" + ExperimentName + \" \" + Model_file + \" \" + XML_file)os.system(\"gama-headless.bat \" + XML_file + \" \"+ Output_folder)print(\"Results of the model is in the folder:\" + Output_folder)print(\"Snapshot is store in the folder:\" + Output_folder + r\"\\snapshot\")\nThe results of the experiment is stored in the set folder. In which the snapshot for every step is also saved in the snapshot folder.\n\n2. Example on using python with Headless batch​\nimport osGAMA_folder_with_SDK = r\"D:\\software\\GAMA_1.9.2_Windows_with_JDK\\headless\"Model_file = GAMA_folder_with_SDK + r\"\\samples\\predatorPrey\\predatorPrey.gaml\"ExperimentName = \"Optimization\"os.chdir(GAMA_folder_with_SDK)os.system(\"gama-headless.bat -batch \" + ExperimentName + \" \" + Model_file)print(\"The result is store in the file:\" + GAMA_folder_with_SDK + r\"\\samples\\predatorPrey\\results.csv\")\n3. Example on using python with Headless server​\nThe legacy version allows you to access the headless feature of GAMA by controling the model parameters and experiment plan from oustide GAMA model file . The headless batch, allows you to access the headless feature of GAMA with the model parameters and experiment plans defined inside the GAMA model file. The headless server, allows you to not only to access the headless feature but also to interact with the currently running GAMA experiment. You can load, play, pause, reload, stop and exit an experiment with very specific commands as described here.\nThe general sequence of operations is:\n\nStart the server from a command line gama-headless.sh -socket 6868 , this opens the communication via port 6868 using websockets.\nConnect to the server from another application/script that supports interacting with websockets. e.g., python. See below to use a python wrapper.\nStart with the load command to load an experiment and then use one of the specific commands as described here to construct a sequence of operations as required by your workflow.\n\nStart the GAMA server​\nOn your command line, execute the following commmand, you will find the gama-headless.sh in the headless folder inside your GAMA installation.\ngama-headless.sh -socket 6868\nUse the Python wrapper instead​\nThe GAMA developers have made available an elegant python wrapper that simplifies using GAMA server with python scripts and is available here. However if you are not a serious programmer and just want to use this tool, the following bare minimum code shall get you started and you can slowly add one command after another to build your sequence of operations to interact with the GAMA server. Before you can start, you have to install the wrapper. In your python environment, install the gama-client package with the command:\npip install gama-client\nYou can check that everything went well by opening a python console and try the following line:\nfrom gama_client.base_client import GamaBaseClient\nIf you don't see any error messages, then the python wrapper has been installed correctly.\nBare minimum code​\nThe whole interaction with the GAMA server is facilitated using the asyncio library in Python and our wrapper that we installed in the previous step. The discussion on use of asyncio is beyond the scope of this tutorial, so just take it as granted. This whole interaction can be considered a dialouge (two way communication) between the client (you/ your script) and the server (GAMA server). You send a command to the server, and the server sends back a message. You parse this message and its contents and construct the next command to interact with the server. This back and forth continues untill you use the exit command or if an error occurs on the server.\nAmong all the messages sent by the server, as a beginner you should know about these four main messages: ConnectionSuccessful (you connected to the server), CommandExecutedSuccessfully (your command was well received and executed), UnableToExecuteRequest (something is wrong with your model), MalformedRequest (something is wrong with your command format)\nJust run the following python script and if all goes well, you are ready to use the GAMA server via python.\nimport asynciofrom gama_client.base_client import GamaBaseClientasync def message_handler(message):    print(\"received message:\", message)async def main():    client = GamaBaseClient(\"localhost\", 6868, message_handler)    await client.connect(False)    while True:        await asyncio.sleep(1)if __name__ == \"__main__\":    asyncio.run(main())\nIt gets even better !​\nA word of caution\nIt is recommended that you slowly build on to the above script by adding commands step by step. You may use the script below as guidance to learn and to stay on course and not having to search a lot through the documentation. Blindly copy-pasting  the code and changing the parameters without understanding is not advised.\nThe python wrapper makes it even easier for beginners. So easy that you just have to change values of the following 5 variables in the sample python script below to make use of GAMA server.\n    MY_SERVER_URL = \"localhost\"    MY_SERVER_PORT = 6868    GAML_FILE_PATH_ON_SERVER = r\"D:\\Gama\\headless\\samples\\predatorPrey\\predatorPrey.gaml\"      EXPERIMENT_NAME = \"prey_predatorExp\"    MY_EXP_INIT_PARAMETERS = [{\"type\": \"int\", \"name\": \"nb_preys_init\", \"value\": 100}]\nSample python script​\nimport asynciofrom asyncio import Futurefrom typing import Dictfrom gama_client.base_client import GamaBaseClientfrom gama_client.command_types import CommandTypesfrom gama_client.message_types import MessageTypesexperiment_future: Futureplay_future: Futurepause_future: Futureexpression_future: Futurestep_future: Futurestop_future: Futureasync def message_handler(message: Dict):    print(\"received\", message)    if \"command\" in message:        if message[\"command\"][\"type\"] == CommandTypes.Load.value:            experiment_future.set_result(message)        elif message[\"command\"][\"type\"] == CommandTypes.Play.value:            play_future.set_result(message)        elif message[\"command\"][\"type\"] == CommandTypes.Pause.value:            pause_future.set_result(message)        elif message[\"command\"][\"type\"] == CommandTypes.Expression.value:            expression_future.set_result(message)        elif message[\"command\"][\"type\"] == CommandTypes.Step.value:            step_future.set_result(message)        elif message[\"command\"][\"type\"] == CommandTypes.Stop.value:            stop_future.set_result(message)async def main():    global experiment_future    global play_future    global pause_future    global expression_future    global step_future    global stop_future    # Experiment and Gama-server constants    MY_SERVER_URL = \"localhost\"    MY_SERVER_PORT = 6868    GAML_FILE_PATH_ON_SERVER = r\"D:\\Gama\\headless\\samples\\predatorPrey\\predatorPrey.gaml\"    EXPERIMENT_NAME = \"prey_predatorExp\"    MY_EXP_INIT_PARAMETERS = [{\"type\": \"int\", \"name\": \"nb_preys_init\", \"value\": 100}]    client = GamaBaseClient(MY_SERVER_URL, MY_SERVER_PORT, message_handler)    print(\"connecting to Gama server\")    await client.connect()    print(\"initialize a gaml model\")    experiment_future = asyncio.get_running_loop().create_future()    await client.load(GAML_FILE_PATH_ON_SERVER, EXPERIMENT_NAME, True, True, True, MY_EXP_INIT_PARAMETERS)    gama_response = await experiment_future    try:        experiment_id = gama_response[\"content\"]    except Exception as e:        print(\"error while initializing\", gama_response, e)        return    print(\"initialization successful, running the model\")    play_future = asyncio.get_running_loop().create_future()    await client.play(experiment_id)    gama_response = await play_future    if gama_response[\"type\"] != MessageTypes.CommandExecutedSuccessfully.value:        print(\"error while trying to run the experiment\", gama_response)        return    print(\"model running, waiting a bit\")    await asyncio.sleep(2)    print(\"pausing the model\")    pause_future = asyncio.get_running_loop().create_future()    await client.pause(experiment_id)    gama_response = await pause_future    if gama_response[\"type\"] != MessageTypes.CommandExecutedSuccessfully.value:        print(\"Unable to pause the experiment\", gama_response)        return    expression_future = asyncio.get_running_loop().create_future()    await client.expression(experiment_id, r\"cycle\")    gama_response = await expression_future    print(\"asking simulation the value of: cycle=\", gama_response[\"content\"])    expression_future = asyncio.get_running_loop().create_future()    await client.expression(experiment_id, r\"nb_preys/nb_preys_init\")    gama_response = await expression_future    print(\"asking simulation the value of: nb_preys/nb_preys_init=\",  gama_response[\"content\"])    print(\"asking gama to run 10 more steps of the experiment\")    step_future = asyncio.get_running_loop().create_future()    await client.step(experiment_id, 10, True)    gama_response = await step_future    if gama_response[\"type\"] != MessageTypes.CommandExecutedSuccessfully.value:        print(\"Unable to execute 10 new steps in the experiment\", gama_response)        return    expression_future = asyncio.get_running_loop().create_future()    await client.expression(experiment_id, r\"cycle\")    gama_response = await expression_future    print(\"asking simulation the value of: cycle=\", gama_response[\"content\"])    print(\"killing the simulation\")    stop_future = asyncio.get_running_loop().create_future()    await client.stop(experiment_id)    gama_response = await stop_future    if gama_response[\"type\"] != MessageTypes.CommandExecutedSuccessfully.value:        print(\"Unable to stop the experiment\", gama_response)        returnif __name__ == \"__main__\":    asyncio.run(main())"},{"filePath":"https:--gama-platform.org--wiki-Home.txt","text":"GAMAGAMA is an easy-to-use open source modeling and simulation environment for creating spatially explicit agent-based simulations.\nIt has been developed to be used in any application domain: urban mobility, climate change adaptation, epidemiology, disaster evacuation strategy design, urban planning, are some of the application domains in which GAMA users are involved and for which they create models.\nThe generality of the agent-based approach advocated by GAMA is accompanied by a high degree of openness, which is manifested, for example, in the development of plugins designed to meet specific needs, or by the possibility of calling GAMA from other software or languages (such as R or Python).\nThis openness allows the more than 2000 users of GAMA to use it for a wide variety of purposes: scientific simulation, scenario exploration and visualization, negotiation support, serious games, mediation or communication tools, the possibilities are endless!\nThe latest version of GAMA, labeled 1.9.2, can be freely downloaded or built from source, and comes with hundreds of templates, tutorials, and extensive online documentation.\nData-driven models​\nThe relevance of agent-based models depends largely on the quality of the data on which they are built and the ease with which they can access it. GAMA offers the possibility to load and manipulate easily GIS (Geographic Information System) data in the models, in order to make them the environment of artificial agents. It is also possible to directly import and use directly in models a large number of data types, such as CSV files, Shapefiles, OSM data, grids, images, SVG files, but also 3D files, such as 3DS or OBJ. GAMA also offers models the possibility to connect directly to databases and to use external tools and environments such as R.\nGAML, a high-level, intuitive agent-based language​\nGAMA, although dedicated to providing a scientific approach to model building and exploration, was also developed to be used by non-computer scientists: it is possible to create a simulated world, declare agent species, assign behaviors to them and display them and their interactions in less than 10 minutes.\nGAML also offers all the power needed by advanced modelers: being an agent-oriented language coded in Java, it offers the possibility to build integrated models with several modeling paradigms, to explore their parameter space and calibrate them and to run virtual experiments with powerful visualization capabilities, all without leaving the platform.\nGAML can be learned easily by first following the step-by-step tutorial and then exploring the other tutorials and educational resources available on this site. Since 2007, the GAMA developers have also provided ongoing support via the active mailing list. Finally, in addition to this online support, training sessions for specialized audiences, on topics such as urban management, epidemiology, risk management, are also organized and delivered by GAMA developers and users.\nDeclarative user interface​\nThe user interface for writing models and running experiments is one of the strong points of GAMA. The platform offers the possibility to have several displays for the same model, to add as many visual representations as necessary for the agents and thus to highlight the elements of interest in the simulations easily and nicely.\nThe 3D displays are provided with all the necessary support for realistic rendering. A rich set of instructions makes it easy to define graphics for more dashboard-like presentations.\nDuring simulations, interactive features can be made available to inspect the population of agents, define user-controlled action panels, or interactions with the displays and external devices. GAMA also includes specific modules and plugins to handle the interactivity with the users through networks, handhelds, and other remote devices.\n\nDocumentation​\nBeyond these features, GAMA also offers:\n\nA large and extensible library of primitives (agent's movement, communication, mathematical functions, graphical features, ...)\nA cross-platform reproducibility of experiments and simulations\nA complete set of batch tools, allowing for a systematic or \"intelligent\" exploration of models parameters spaces\n\nand much more !\nAll the features of GAMA are documented online on this wiki. It is organized around a few central activities (installing GAMA, writing models, running experiments, developing new extensions to the platform) and provides complete references on both the GAML language, the platform itself, the scientific aspects behind GAMA (with a complete bibliography), and also all the communication around it, notably videos here and here. Several tutorials are also provided in the documentation in order to minimize the learning curve, allowing users to build, step by step, the models corresponding to these tutorials, which are of course shipped with the platform. The documentation can be accessed from the sidebar of this page. A good starting point for new users is the installation page.\nSource Code​\nGAMA can be downloaded as a regular application or built from source, which is necessary if you want to contribute to the platform. The source code is available from this GITHub repository:\nhttps://github.com/gama-platform/gama\nWhich you can also browse from here.\nIt is, in any case, recommended to follow the instructions on this page in order to build GAMA from source.\nCiting GAMA​\nIf you use GAMA in your research and want to cite it (in a paper, presentation, whatever), please use this reference:\n\nTaillandier, P., Gaudou, B., Grignard, A.,Huynh, Q.-N., Marilleau, N., P. Caillou, P., Philippon, D., & Drogoul, A. (2019). Building, composing and experimenting complex spatial models with the GAMA platform. Geoinformatica, (2019), 23 (2), pp. 299-322, [doi:10.1007/s10707-018-00339-6]\n\nor you can choose to cite the website instead:\n\nGAMA Platform website, http://gama-platform.org\n\nA complete list of references (papers and PhD theses on or using GAMA) is available on the references page.\nContact Us​\nTo get in touch with the GAMA developers team, please sign in for the gama-platform@googlegroups.com mailing list. If you wish to contribute to the platform, you might want, instead or in addition, to sign in for the gama-dev@googlegroups.com mailing list. On both lists, we generally answer quite quickly to requests.\nFinally, to report bugs in GAMA or ask for a new feature, please refer to  these instructions to do so.\nCopyright Information​\nThis is a free software (distributed under the GNU GPL v3 license), so you can have access to the code, edit it and redistribute it under the same terms. Independently of the licensing issues, if you plan on reusing part of our code, we would be glad to know it !\nAcknowledgement​\n\nYourKit supports open source projects with its full-featured Java Profiler.\nYourKit, LLC is the creator of YourKit Java Profiler\nand YourKit .NET Profiler,\ninnovative and intelligent tools for profiling Java and .NET applications.\nThis page is licensed under a Creative Commons Attribution 4.0 International License."},{"filePath":"https:--gama-platform.org--wiki-ImportingModels.txt","text":"Importing ModelsImporting a model refers to making a model file (or a complete project) available for edition and experimentation in the workspace. With the exception of headless experiments, GAMA requires that models be manageable in the current workspace to be able to validate them and eventually experiment them.\nThere are many situations where a model needs to be imported by the user: someone sent it to him/her by mail, it has been attached to an issue report, it has been shared on the web or a Git repository, or it belongs to a previous workspace after the user has switched workspace. The instructions below apply equally to all these situations.\nSince model files need to reside in a project to be managed by GAMA, it is usually preferable to import a whole project rather than individual files (unless, of course, the corresponding models are simple enough to not require any additional resources, in which case, the model file can be imported with no harm into an existing project). GAMA will then try to detect situations where a model file is imported alone and, if a corresponding project can be found (for instance, in the upper directories of this file), to import the project instead of the file. As the last resort, GAMA will import orphan model files into a generic project called \"Unclassified Models\" (which will be created if it does not exist yet).\nThe simplest, safest and most secure way to import a project into the workspace is to follow instructions from this section.\nTable of contents​\n\nImporting Models\n\nThe \"Import...\" Menu Command\n\nImport \"GAMA Project...\"\nImport \"External files from disk...\" and \"External files from archive...\"\n\"Other\" imports\n\n\nSilent import\nDrag'n Drop / Copy-Paste Limitations\nImport from GitHub repository\n\n\n\nThe \"Import...\" Menu Command​\nThe simplest, safest and most secure way to import a project into the workspace is to use the built-in \"Import...\" menu command, available in the contextual menu on the User models (the modeler can only import projects in this category).\n\nThe \"Import...\" command allows the modeler to choose between:\n\n\"GAMA Project...\": import a project in the workspace (from another folder or an archive),\n\"External files from disk...\": import any files in a project of the workspace (from a folder),\n\"External files from archive...\": import any files in a project of the workspace (from an archive),\n\"Other\": other ways of importation.\n\nImport \"GAMA Project...\"​\nWhen \"GAMA project...\" is chosen, a dialog box will pop-up where the user will be asked to:\n\nEnter a location (or browse to a location) containing the GAMA project(s) to import. This can be the folder of a single project or a folder containing several projects. 2 possibilities are available:\n\n\n\"Select root directory\": the user selects a folder containing the project,\n\"Select archive file\": the user selects an archive file (e.g. a .zipfile) containing the project.\n\n\nChoose among the list of available projects (computed by GAMA) the ones to effectively import. Only projects that are not already in the workspace can be imported.\nIndicate whether or not these projects need to be copied to or linked from the workspace (the latter is done by default). In the case of an import from an archive, the content will be automatically copied in the workspace.\n\n\nImport \"External files from disk...\" and \"External files from archive...\"​\nThese two commands allow the user to import some external files into an existing project of the workspace. These two commands are very similar, only the source of files is different: a folder or an archive. They allow to filter and select the files to import. The user will be asked to:\n\nEnter a location (or browse to a location) containing the files to import.\nSelect the files to import.\nSelect the project in the workspace where the files will be copied.\n\n\n\"Other\" imports​\nWhen invoked, this command will open a dialog asking the user to choose the source of the importation. It can be a directory in the filesystem (in which GAMA will look for existing projects), a zip file, etc. It is safer, in any case, to choose \"Existing Projects into Workspace\".\nIf some extensions have been installed, they could add some entries in this menu (e.g. the Git extension).\n\nSilent import​\nAnother (possibly simpler, but less controllable) way of importing projects and models is to either pass a path to a model when launching GAMA from the command line or to double-click on a model file (ending in .gaml) in the Explorer or Finder (depending on your OS).\nIf the file is not already part of an imported project in the current workspace, GAMA will:\n\nsilently import the project (by creating a link to it),\nopen an editor on the file selected.\n\nThis procedure may fail, however, if a project of the same name (but in a different location) already exists in the workspace, in which case GAMA will refuse to import the project (and hence, the file). The solution, in this case, is to rename the project to import (or to rename the existing project in the workspace).\nDrag'n Drop / Copy-Paste Limitations​\nCurrently, there is no way to drag and drop an entire project into GAMA Navigator (or to copy a project in the filesystem and paste it in the Navigator). Only individual model files, folders or resources can be moved this way (and they have to be dropped or pasted into existing projects).\nThis limitation might be removed sometime in the future, however, allowing users to use the Navigator as a project drop or paste target, but it is not the case yet.\nImport from GitHub repository​\nIn the case where the Git plugin is installed in GAMA, projects can be imported from a Git repository, as detailed in the recipes related to the use of Git in GAMA."},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel.txt","text":"Incremental ModelThis tutorial has for goal to give an overview all most of the capabilities of GAMA. In particular, it presents how to build a simple model and the use of GIS data, graphs, 3D visualization, multi-level modeling and differential equations. All the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Incremental Model).\nModel Overview​\nThe model built in this tutorial aim at simulating the spreading of a disease in a small city. Three type of entities are taken into account: the people, the buildings and the roads.\nWe made the following modeling choice:\n\nSimulation step: 1 minute.\nPeople are moving on the roads from building to building.\nPeople use the shortest path to move between buildings.\nAll people have the same speed and move at a constant speed.\nEach time, people arrived at a building they are staying a certain time.\nThe staying time depends on the current hour (lower at 9h - go to work - at 12h go to lunch - at 18h - go back home).\nInfected people are never cured.\n\n\nStep List​\nThis tutorial is composed of 7 steps corresponding to 7 models which are incremental representation of the same model, starting with the simplest model 1 and finishing with the latest one, model 7. For each step, we will present its purpose, an explicit formulation, and the corresponding GAML code.\n\nSimple SI Model\nCharts\nIntegration of GIS Data\nMovement on Graph\nVisualizing in 3D\nMulti-Level\nDifferential Equations\n"},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel_step1.txt","text":"1. Simple SI ModelThis first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - which are the key components of GAMA models.\nFormulation​\n\nDefinition of the people species with a variable (is_infected) , an aspect (default) and two behaviors (move and infect).\nDefinition of nb_infected_init, infection_distance and proba_infection parameters.\nCreation of 500 people agents randomly located in the environment (size: 500x500).\nDefinition a display to visualize the people agents.\n\n\nModel Definition​\nmodel structure​\nA GAMA model is composed of three types of sections:\n\nglobal: this section, which is unique, defines the \"world\" agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).\nspecies: these sections define the species of agents composing the model.\nexperiment: these sections define a context of the execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model.\n\nMore details about the different sections of a GAMA model can be found here.\nspecies​\nA species represents a «prototype» of agents: it defines their common properties.\nA species definition requires the definition of three different elements:\n\nthe internal state of its agents (attributes)\ntheir behavior\nhow they are displayed (aspects)\n\nInternal state​\nAn attribute is defined as follows: the type of the attribute and name. Numerous types of attributes are available: int (integer), float (floating-point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, species of agents, rgb (color), graph, path...\n\nOptional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max\n\nIn addition to the attributes the modeler explicitly defines, species \"inherits\" other attributes called \"built-in\" variables:\n\nA name (name): the identifier of the species.\nA shape (shape): the default shape of the agents to be constructed after the species. It can be a point, a polygon, etc..\nA location (location): the centroid of its shape.\n\nWe will give a variable to people agents: is_infected (bool):\nspecies people skills:[moving]{\t\t    bool is_infected <- false;}\nConcerning the display of an agent, aspects have to be defined. An aspect represents a possible way to display the agents of a species: aspect aspect_name {...}.\nIn the block of an aspect, it is possible to draw:\n\nA geometry: for instance, the shape of the agent.\nAn image: to draw icons.\nA text: to draw a text.\n\nWe define here one aspect of this species. In this model, we want to display for each people agent a circle of radius 5 and red or green according to the value of is_infected (if infected: red, green otherwise). We then use the keyword draw with a circle shape. To define the color that depends on is_infected, we use the tertiary operator condition ? val1 : val2. If the condition is true, this operator will return val1, otherwise val2. Note that it is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink...\nspecies people skills:[moving] {\t\t    ...    aspect default {\tdraw circle(5) color: is_infected ? #red : #green;    }}\nConcerning the behavior of agents, the simplest way to define it is through reflexes. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true. A reflex is defined as follows:\n    reflex reflex_name when: condition {...}\nThe when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.\nWe define a first reflex called move that allows the people agents to move using the wander action (provided by the moving skill) that allows to randomly move (with taking into account the agent speed).\nspecies people skills: [moving] {    ...    reflex move {\tdo wander;    }}\nNote that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the wander action defined in the moving skill.\n\nAn action can accept arguments. For instance, write takes an argument called message.\nAn action can return a result.\n\nThere are two ways to call an action: using a statement or as part of an expression\n\nfor actions that do not return a result:\n\ndo action_name arg1: v1 arg2: v2;\n\nfor actions that return a result:\n\nmy_var <- self action_name (arg1:v1, arg2:v2);\nThe second reflex we have to define is the infect one. This reflex will be activated only if is_infected is true. This reflex consists is asking all the people agents at a distance lower or equal to infection_distance to become infected with a probability proba_infection.\nspecies people skills:[moving]{\t\t    ...    reflex infect when: is_infected{\task people at_distance infection_distance {\t    if (flip(proba_infection)) {\t        is_infected <- true;\t    }\t}    }    ...}\nNote that we used the ask statement. This statement allows to make a remote agent executes a list of statements. We used as well the flip operator that allows to test a probability.\nglobal section​\nThe global section represents the definition of the species of a specific agent (called world).\nThe world agent represents everything that is global to the model: dynamics, variables...\nIt allows to init simulations (init block): the world is always created and initialized first when a simulation is launched. The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary. In the same way, the modeler can redefine the step variable that represents the duration of a simulation step and that is by default 1 second.\nglobal variables​\nFor our model, we define 5 global variables: nb_people (int, init value: 500), infection_distance (float value, init value: 2 meters), proba_infection (float, init value: 0.05), nb_infected_init (int, init value: 5) and agent_speed (float, init value: 5 #km/#h). In addition, we redefine the geometry of the world by a square of 500 meters size and a simulation step of 1 minute.\nglobal {     int nb_people <- 500;    float agent_speed <- 5.0 #km/#h;    float infection_distance <- 2.0 #m;    float proba_infection <- 0.05;    int nb_infected_init <- 5;    float step <- 1 #minutes;    geometry shape<-square(500 #m);}\nModel initialization​\nThe init section of the global block allows to initialize the model.\nThe statement create allows to create agents of a specific species: create species\\_name + :\n\nnumber: number of agents to create (int, 1 by default)\nfrom: GIS file to use to create the agents (string or file)\nreturns: list of created agents (list)\n\nFor our model, the definition of the init block in order to create nb_people people agents. We set the init value of the speed variable (given by the moving skill) to the value of the global variable agent_speed (i.e. 5km/h).\nIn addition, we ask nb_infected_init people to become infected (use of the nb among list to randomly draw nb elements of the list).\nglobal{     ...    init{\tcreate people number:nb_people {\t    speed <- agent_speed;\t}\task nb_infected_init among people {\t    is_infected <- true;\t}    }}\nexperiment​\nAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a model. They are defined using : experiment exp\\_name type: gui/batch {[input] [output]}.\n\ngui: experiment with a graphical interface, which displays its input parameters and outputs.\nbatch: Allows to setup a series of simulations (w/o graphical interface).\n\nIn our model, we define a gui experiment called main_experiment :\nexperiment main_experiment type: gui {}\ninput​\nExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.\nA parameter is defined as follows:\nparameter title var: global_var category: cat;\n\ntitle: string to display\nvar: reference to a global variable (defined in the global section)\ncategory: string used to «store» the operators on the UI - optional\n<-: init value - optional\nmin: min value - optional\nmax: min value - optional\n\nNote that the init, min and max values can be defined in the global variable definition.\nIn the experiment, we define three parameters from the global variables infection_distance, proba_infection and nb_infected_init:\nexperiment main_experiment type: gui{    parameter \"Infection distance\" var: infection_distance;    parameter \"Proba infection\" var: proba_infection min: 0.0 max: 1.0;    parameter \"Nb people infected at init\" var: nb_infected_init ;    ...}\noutput​\nThe output block is defined in an experiment and defines how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh (expecting a boolean expression, the display will be refreshed every time the expression is evaluated to true. This expression can be described in terms of nb of simulation, with e.g. every(5#cycle)).\nEach display can include different layers (like in a GIS):\n\nAll the agents of a species: species  my_species aspect: my_aspect;.\nAgents lists: agents layer_name value: agents_list aspect: my_aspect;.\nImages: image image_file_name;.\nCharts: see later.\n\nNote that it is possible to define a opengl display (for 3D display) by using the facet type: opengl.\nIn our model, we define a display to draw the people agents with their default aspect. (note that, if the aspect facet is omitted, the aspect named default will be used)\nexperiment main_experiment type: gui{    ...    output {\tdisplay map {\t    species people ; // 'default' aspect is used automatically\t\t\t\t}    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%201.gaml"},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel_step2.txt","text":"2. ChartsThis step Illustrates how to define monitors and charts in GAMA. In addition, it illustrates how to define a stopping condition for the simulation.\nFormulation​\n\nDefinition of new global variables: current_hour, nb_people_infected, nb_people_not_infected, infected_rate.\nDefinition of a monitor to follow the current hour and the nb of people infected.\nDefinition of a series chart to follow the number of people infected and not infected.\nDefinition of a stopping condition (when infected rate = 1).\n\n\nModel Definition​\nglobal variables​\nIn order to define dynamic variable able to update itself, we use the update facet of variable definition.\nIndeed, at each simulation step, all the agents (and the world agent) apply for each dynamic variable (in their definition order) its update expression.\nWe add 3 new global variables:\n\nnb_people_infected (int): nb of people with is_infected is true (use of the list count condition operator that count the number of elements of the list for which the condition is true)\nnb_people_not_infected (int): nb_people - nb_people_infected\ninfected_rate (float): nb_people_infected / nb_people\n\nglobal{    ...    int nb_people_infected <- nb_infected_init update: people count (each.is_infected);    int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;    float infected_rate update: nb_people_infected/nb_people;    ...}\nstopping condition​\nWe add a new reflex that stops the simulation when all the people agents are infected (i.e. if the infected_rate is equal to 1). To stop the simulation, we use the pause global action.\nglobal {    ...    reflex end_simulation when: infected_rate = 1.0 {\tdo pause;    }}\nmonitor​\nA monitor allows the modeler to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:\n    monitor monitor_name value: an_expression refresh:every(nb_steps);\nWith:\n\nvalue: mandatory, its value that will be displayed in the monitor.\nrefresh: bool, optional: if the expression is true, compute (default is true).\n\nIn this model, we define 2 monitors to follow: (i) the value of the variable infected_rate, and (ii) to follow the time in the simulation (we will display the hour day).\nAs detailed in the dedicated page, GAML language provides a datatype to manage date (with second, minute, hour, day, month and year), and compute automatically the date in the simulation from the global variable starting_date of the simulation and the step value: this value is stored in the current_date global variable. To monitor the current hour, we can access to the hour attribute of this variable (current_date.hour).\nexperiment main_experiment type: gui {    ...    output {\tmonitor \"Current hour\" value: current_date.hour;\tmonitor \"Infected people rate\" value: infected_rate;\t...    }}\nchart​\nGAMA can display various chart types, for example:\n\nTime series\nPie charts\nHistograms\n\nA chart must be defined in a display: it behaves exactly like any other layer.\nDefinition of a chart:\nchart chart_name type: chart_type  {     [data]}\nThe data to draw are defined inside the chart block with the data statement:\ndata data_legend value: data_value\nWe add a new display called \"chart\" and refreshed every 10 simulation steps.\nInside this display, we define a chart of type series:\n\n\"Disease spreading\"; background: white; of type series and style spline (no remove the markers)\n\ndata1: susceptible; color : green\ndata2: infected; color : red\n\n\n\nexperiment main_experiment type: gui{    ...    output {\t...\tdisplay chart refresh: every(10#cycles) {\t    chart \"Disease spreading\" type: series style: spline {\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\tdata \"infected\" value: nb_people_infected color: #red;\t    }\t}    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%202.gaml"},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel_step3.txt","text":"3. Integration of GIS DataThis step illustrates how to load and agentry GIS data.\nFormulation​\n\nLoad, agentify and display two layers of GIS data (building and road).\nModify the initialization of the people agents to put them inside buildings.\n\n\nModel Definition​\nspecies​\nTo integrate easily the two data layers, we have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior, they will just be displayed.\nWe define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use their geometry in the  draw statement. In order to draw the geometry of the agent, we use the attribute shape (which is a built-in attribute of all agents).\nspecies building {    aspect default {\tdraw shape color: #gray border: #black;    }}species road {    aspect default {\tdraw shape color: #black;    }}\nGlobal variables​\nGAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define two global variables. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile.\nDefinition of the two global variables of type file representing the GIS files:\nglobal {    file buildings_shapefile <- file(\"../includes/building.shp\");    file roads_shapefile <- file(\"../includes/road.shp\");}\nagentification of GIS data​\nIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet with the shapefile. Each object of the shapefile will be directly used to instantiate one agent of the specified species.\nWe modify the init section of the global block in order to create road and building agents from the shapefiles. Then, we define the initial location of people as a point inside one of the buildings.\nglobal {    ...    init {\tcreate road from: roads_shapefile;\tcreate building from: buildings_shapefile;\tcreate people number:nb_people {\t    speed <- agent_speed;\t    location <- any_location_in(one_of(building));\t}\task nb_infected_init among people {\t    is_infected <- true;\t}    }} \nNote that the name of a species can be used to obtain all the agents of a species (here building returns the list of all the buildings). We can thus use the one_of operator on building to pick a random building agent. The any_location_in operator returns a random point inside a geometry or an agent geometry.\nenvironment​\nBuilding a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use the road shapefile to define it.\nglobal {    ...    geometry shape <- envelope(roads_shapefile);     ...}\ndisplay​\nWe add to the map display the road and building agents. Again, as we named the aspects default we can omit to specify them in the species inside the display.\nIn the experiment block:\noutput {    display map {        species road;\tspecies building;\tspecies people;\t\t\t    }    ...}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%203.gaml"},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel_step4.txt","text":"4. Movement on GraphThis step illustrates how to load a graph and use it for the displacement of our agents.\nFormulation​\n\nDefinition of a global graph to represent the road network.\nDefinition of a new global variable: staying_coeff to represent the fact that people move more near 9h, 12h, and 18h.\nDefinition of two new variables for the people agents: target and staying_counter (to manage their mobility).\nDefinition of a new reflex for people agents: stay.\nModification of the move reflex of the people agents.\n\n\nModel Definition​\nglobal variables​\nWe define two new global variables:\n\nroad_network (graph): represents the graph built from the road network.\nstaying_coeff (float): represents the fact that people have more chance to move from their current building near 9h (go to work), 12h (lunchtime) and 18h (go home). This variable is updated at each simulation step (using the update facet).\n\nglobal{    ....    graph road_network;    float staying_coeff update: 10.0 ^ (1 + min([abs(current_date.hour - 9), abs(current_date.hour - 12), abs(current_date.hour - 18)]));    ....}\nInitialization​\nWe need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows doing that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry. The weight of each edge corresponds to the length of the road.\nglobal {    ...    init {        ...        create road from: roads_shapefile;        road_network <- as_edge_graph(road);\t        ...    }}\npeople agent​\nFirst, we add two new variables for the people agents:\n\ntarget (point): the target location that the people want to reach (a point inside a building).\nstaying_counter (int): the number of cycles since the agent arrived at its building.\n\nWe define a new reflex named stay that is activated when the agent has no target (target = nil), i.e. when the agent is inside a building. This reflex increments the staying_counter, then it tests the probability to leave that is computed from the staying_counter (longer the agent is inside the building, more it has a chance to leave) and the staying_coeff (closer to 9h, 12h, and 18h, more the agent has a chance to leave).\nIf the agents decide to leave, it computes a new target as a random point inside one of the buildings (randomly chosen).\nspecies people skills: [moving] {\t\t    ...    reflex staying when: target = nil {\tstaying_counter <- staying_counter + 1;\tif flip(staying_counter / staying_coeff) {\t    target <- any_location_in (one_of(building));\t}    }    ...}\nWe modify the move reflex. Now, this reflex is activated only when the agent has a target (target != nil). In this case, the agent moves toward its target using the built-in goto action. Note that we specified a graph (road_network) to constraint the moving of the agents on the road network with the facet on. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at destination (location = location), the target is set to nil (the agent will stop moving) and the staying_counter is set to 0.\nspecies people skills:[moving]{\t\t    ...    reflex move when: target != nil{\tdo goto target: target on: road_network;\tif (location = target) {\t    target <- nil;\t    staying_counter <- 0;\t}     }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%204.gaml"},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel_step5.txt","text":"5. Visualizing in 3DThis step Illustrates how to define a 3D display.\nFormulation​\n\nAdd a variable (height: int from 10m to 20m) and modify the aspect of buildings to display them in 3D.\nAdd a variable (display_shape: geometry; shape with a buffer of 2m) and modify the aspect of the roads to display them with this new shape.\nAdd a new global variable that indicate if it is night or not (bool: night before 7h and after 20h).\nDefine a new aspect (sphere3D) for people to display them as sphere.\nModify the display to use this new aspect.\n\n\nModel Definition​\nbuilding​\nFirst, we add a new variable for buildings (height) of type float from 10m to 20m. Then we modify the aspect in order to specify a depth for the geometry (using the depth facet).\nspecies building {    float height <- rnd(10#m, 20#m) ;    aspect default {\tdraw shape color: #gray border: #black depth: height;    }}\nroad​\nConcerning the road,  we add a new variable (display_shape) of type geometry that corresponds to the shape of the road with a buffer of 2 meters. Then we modify the aspect in order to display this geometry instead of the shape of the agent. In order to avoid \"z-fighting\" problems, we add depth to the geometry (of 3 meters).\nspecies road {    geometry display_shape <- shape + 2.0;    aspect default {\tdraw display_shape color: #black depth: 3.0;    }}\nglobal variable​\nWe define a new global variable called is_night of type bool to indicate if it is night or not. This variable will be updated at each simulation step and will be true if the current hour is lower than 7h or higher than 20h. It will be used in the display to change the light of the scene (to set it darker in the night).\nglobal{    ...    bool is_night <- true update: current_date.hour < 7 or current_date.hour > 20;    ...}\npeople​\nWe define a new aspect for the people agent called sphere3D. This aspect draws people agent as a 3m sphere. In order to avoid to cut the sphere in half, we translate the centroid of the drawn sphere to 3m along the z-axis.\nspecies people skills:[moving]{\t\t    ...    aspect sphere3D{\tdraw sphere(3) at: {location.x,location.y,location.z + 3} color:is_infected ? #red : #green;    }}\ndisplay​\nThe element that we have to modify is the display. We change its name to map_3D to better reflect its visual aspect.\nIn order to get a 3D aspect, we specify that this display will be an OpenGL one. For that, we just have to add the facet type: opengl. In addition,\nwe first add an ambient light with a light statement inside the display with the id #ambient and an intensity set to 20. To get a different light between night and day, we add one more light statement with the #default id and to have a nice effect night/day, we will set the intensity of the light to 50 during the night, and 127 for the day. To learn more about light, please read this page.\nThen, we add a new layer that consists of an image (soil.jpg) by using the image statement.\nIn order to see the people inside the building, we add transparency to the building (0.5). The transparency of a layer is a float value between 0 (solid) and 1 (totally transparent). In order to be able to manage this transparency aspect, OpenGL has to draw the people agents before the building, thus we modify the order of drawing of the different layers (people agents before building agents). At last, we modify the displayed aspect of the people agents by the new one: sphere3D.\nexperiment main_experiment type:gui{    ...    output {\t...\tdisplay map_3D type: opengl {\t\tlight #ambient intensity: 20;\t\tlight #default intensity:(is_night ? 0 : 127);\t\timage \"../includes/soil.jpg\";\t\tspecies road ;\t\tspecies people aspect:sphere3D;\t\t\t\t\tspecies building  transparency: 0.5;\t}\t...    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%205.gaml"},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel_step6.txt","text":"6. Multi-LevelThis step illustrates how to define a multi-level model.\nFormulation​\nWe propose to let the buildings manage what happens when the people are inside buildings. In this context, we will use the multi-level properties of GAMA: when a people agent will be inside a building, it will be captured by it and its species will be modified. It will be not anymore the people agent that will decide when to leave the building, but the building itself that will release it.\nWe will need to:\n\nDefine a micro-species of people inside the building species (people_in_building).\nDefine two new behaviors for building: let_people_leave and let_people_enter.\nModify the aspect of the building.\nModify some global variables for counting the number of infected people.\n\n\nModel Definition​\nbuilding​\nFirst, we define a new species called people_in_building inside the building species. Thus, a building could have agents of this species as members and control them. The people_in_building species has for parent the people species, which means that a people_in_building agent has all the attributes, aspects and behaviors of a people agent.\nIn our case, we want a people agent inside a building does not do anything. Thus, we use the schedules facet of the species to remove the people_in_building from the scheduler.\nspecies building {    ...    species people_in_building parent: people schedules: [] {    }    ...}\nWe define a first reflex for the buildings that will be activated at each simulation step and that will allow the building to capture all the people that are inside its geometry and that are not moving (target = nil). Capturing agents means putting them inside its members list and changing their species: here the people agents become people_in_building agents.\nspecies building {    ...    reflex let_people_enter {\tcapture (people inside self where (each.target = nil)) as: people_in_building;    }    ....}\nWe define a second reflex for the buildings that will be activated at each simulation step and that will allow the building to release some of the people_in_building agents. First, it increments the staying counter of all the people_in_building agents. Then it builds the list of leaving people by testing the same probability as before for all the people_in_building agents. Finally, if this list is not empty, it releases them as people agents (and gives them a new target point).\nspecies building {    ...    reflex let_people_leave {\task people_in_building {\t    staying_counter <- staying_counter + 1;\t}\trelease people_in_building where (flip(each.staying_counter / staying_coeff)) as: people in: world {\t    target <- any_location_in(one_of(building));\t}    }    ....}\nAt last, we refine the aspect of the buildings: if there are no people inside the building, we draw it with gray color. If the number of people_in_building infected is higher than the number of people_in_building not infected, we draw it in red; otherwise in green. The number of infected people_in_building and its total number will be computed once a step (through the update facet of building attribute).\nspecies building {    int nb_infected <- 0 update: self.people_in_building count each.is_infected;    int nb_total <- 0 update: length(self.people_in_building);    aspect default {\tdraw shape color: nb_total = 0 ? #gray : (float(nb_infected) / nb_total > 0.5 ? #red : #green) border: #black depth: height;    }}\nglobal variables​\nIn order to take into account the people that are inside the buildings for the computation of nb_people_infected, we first build the list of people_in_building. As people_in_building is microspecies of building, we cannot compute it directly like for the other species, we then aggregate all the list people_in_building of all building in a single list (list_people_in_buildings). Then, we compute the number of infected people as the number of people infected outside the building + the number of people infected inside them.\nglobal  {    ...    list<people_in_building> list_people_in_buildings update: (building accumulate each.people_in_building);    int nb_people_infected <- nb_infected_init update: (people + list_people_in_buildings) count (each.is_infected);    ...}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%206.gaml"},{"filePath":"https:--gama-platform.org--wiki-IncrementalModel_step7.txt","text":"7. Differential EquationsThis step illustrates how to use differential equations.\nFormulation​\nWe are interested in the spreading of the disease inside the buildings. In order to model it, we will use differential equations. So, we will need to:\n\nAdd two global variables to define the building epidemic properties (beta) and numerical integration parameter (h).\nAdd new variables for the buildings (I, S, T, t, I_to1) to manage epidemic;\nDefine differential equations for disease spreading inside buildings.\nAdd one behavior for buildings for the spreading of the disease.\n\n\nModel Definition​\nglobal variables​\nWe define two new global variables used in the disease spreading dynamic inside the buildings: (i) beta is the contamination rate,  and h is the integration step (used in the solve statement).\nglobal  {    ...    float beta <- 0.01;    float h <- 0.1;    ...}\nbuilding​\nIn order to define the disease spread dynamics, we define several variables that will be used by the differential equations:\n\nI: float, number of people infected in the building.\nS: float, number of people not infected in the building.\nT: float, the total number of people in the building.\nt: float, the current time of the equation system integration.\nI_to1: float, the remaining number of people infected (float number lower between 0 and 1 according to the differential equations).\n\nspecies building {    ...    float I;    float S;    float T;    float t;       float I_to1;     ...}\nThen, we define the differential equations system that will be used for the disease spreading dynamic. Note that to define a differential equation system we use the block equation + name. These equations are the classic ones used by SI mathematical models.\nspecies building {    ....    equation SI{ \tdiff(S,t) = (- beta * S * I / T) ;\tdiff(I,t) = (  beta * S * I / T) ;    }    ...}\nAt last, we define a new reflex for the building called epidemic that will be activated only when there is someone inside the building. This reflex first computes the number of people inside the building (T), then the number of not infected people (S) and finally the number of infected ones (I).\nIf there is at least one people infected and one people not infected, the differential equations is integrated (according to the integration step value h) with the method Runge-Kutta 4 to compute the new value of infected people. We then sum the old value of I_to1 with the number of people newly infected (this value is a float and not an integer). Finally, we cast this value as an integer, ask the corresponding number of not infected people to become infected, and decrement this integer value to I\\_to1.\nspecies building {    ...    reflex epidemic when: nb_total > 0 {\tT <- float(nb_total);\tS <- float(nb_total - nb_infected);\tI <- T - S;\tfloat I0 <- I;\tif (I > 0 and S > 0) {\t    solve SI method: #rk4 step_size: h;\t    I_to1 <- I_to1 + (I - I0);\t    int I_int <- min([int(S), int(I_to1)]);\t    I_to1 <- I_to1 - I_int;\t    ask (I_int among (people_in_building where (!each.is_infected))) {\t\tis_infected <- true;\t    }\t}    }    ...}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Incremental%20Model/models/Incremental%20Model%207.gaml"},{"filePath":"https:--gama-platform.org--wiki-Inheritance.txt","text":"InheritanceAs for many object-oriented programming languages, inheritance can be used in GAML. It is used to structure better your code when you have some complex models. It is, for example, useful when you have defined two different species with many attributes and behaviors in common: you can factorize everything in common in a parent species, and let in the child species only the differences between these 2 species. Notice that behaviors and actiond defined in a parent species can be redefined in a children species, in order to code a difference in terms of behavior, or simply execute the action of the parent and complete it with some other statements.\nIndex​\n\nMother species / child species\nVirtual actions\nGet all the subspecies from a species\n\nMother species/child species​\nTo make a species inherit from a mother species, you have to add the facet parent, and specify the mother species.\nspecies mother_species { }species child_species parent: mother_species { }\nThus, all the attributes, actions and reflex of the mother species are inherited to the child species.\nspecies mother_species {    int attribute_A;    action action_A {}}species child_species parent: mother_species {    init {\tattribute_A <- 5;\tdo action_A;    }}\nIf the mother species has a particular skill, its children will inherit all the attributes and actions.\nspecies mother_species skills:[moving] { }species child_species parent:mother_species {    init {\tspeed <- 2.0;    }    reflex update {\tdo wander;    }}\nYou can redefine an action or a reflex by declaring an action or a reflex with the same name.\nIn the redefined action, it is common to call the action of the mother species with some specific parameters or to add more computations. To this purpose, you need to use:\n\ninvoke instead of do to call an action (procedure) of the mother species.\nsuper.action_name() to call  an action (function) of the mother species.\n\nspecies animal {    int age <- 0;\t    action grow {\tage <- age + 1;    }\t    int get_age {\treturn age;    }}species cat parent: animal {    action grow {\tinvoke grow();   // call the action growth of the mother species animal\twrite \"I am a cat and I grow up\";    }\t    int get_age {\treturn super.get_age() * 7;  // call the action get_age from the mother species animal                                     // 1 year is 7 year for cats    }}\nVirtual action​\nYou have also the possibility to declare a virtual action in the mother species, which means an action without implementation, by using the facet virtual. Note that, when using virtual facet, the statement has to start by action and not a return type. If the action is expecting to return a value you need to add the type facet:\naction virtual_action virtual: true;action vistual_action_with_return_value virtual: true type: any_type;\nWhen you declare an action as virtual in a species, this species becomes abstract, which means you cannot instantiate agent from it. All the children of this species have to implement this virtual action.\nspecies virtual_mother_species {    action my_action virtual:true;}species child_species parent: virtual_mother_species {    action my_action {\t// some statements    }}\nGet all the subspecies from a species​\nIf you declare a mother species, you create a child agent, then mother will return the population of agents mother and not the population of agents child, as it is shown in the following example:\nglobal {    init {        create child number: 2;        create mother number: 1;    }    reflex update {        write length(mother); // will write 1 and not 3    }}species mother {}species child parent: mother {}\nWe remind you that subspecies is a built-in attribute of the agent. Using this attribute, you can easily get all the subspecies agents of the mother species by writing the following GAML function:\nglobal{    init {        create child number: 2;        create mother number: 1;    }    reflex update {        write length(get_all_instances(mother)); // will write 3 (1+2)    }    list<agent> get_all_instances(species<agent> spec) {        return spec.population +  spec.subspecies accumulate (get_all_instances(each));    }}species mother {}species child parent: mother {}\nThe operator of_generic_species can also be used to filter a list of agents and get all the agents of a given species or of its children species. As a consequence, in the previous example, to count all the agents of mother and child species you can only write:\nwrite length(agents of_generic_species mother);"},{"filePath":"https:--gama-platform.org--wiki-InspectorsAndMonitors.txt","text":"Inspectors and monitorsGAMA offers some tools to obtain information about one or several agents. There are two kinds of tools:\n\nagent browser\nagent inspector\n\nGAMA offers as well a tool to get the value of a specific expression: monitors.\nTable of contents​\n\nInspectors and monitors\n\nAgent Browser\nAgent Inspector\nMonitor\n\n\n\nAgent Browser​\nThe species browser provides information about all or a selection of agents of a species.\nThe agent browser is available through the Agents menu.\n\nIt displays in a table all the values of the agent variables of the considered species; each line corresponding to an agent. The list of attributes is displayed on the left side of the view, and you can select the attributes you want to be displayed, simply by clicking on it (Ctrl + Click for multi-selection).\n\nBy clicking on the right mouse button on a line, it is possible to perform some actions on the corresponding agent (the same actions as when we right-click on it in a display).\nThe Browse view provides also two interesting additional features:\n\nBrowse a species: change the population displayed in the table.\nSave the agents and their attributes in a .csv file: this allows the modeler to manipulate and analyze the agent population at will in external software.\n\n\nAgent Inspector​\nThe agent inspector provides information about one specific agent. It also allows the modeler to change the values of its variables during the simulation. The agent inspector is available from the Agents menu, by right_clicking on a display, in the species inspector or when inspecting another agent.\n\nIt is possible to \"highlight\" the selected agent, to focus on it in all the displays, or to kill it.\n\nTo change the color of the highlighted agent, go to Preferences/Display.\n\nMonitor​\nMonitors allow the user to follow the value of a GAML expression. For instance, the following ones monitor the number of prey and predator agents during the simulation (the model is available in the Prey Predator tutorial). The monitor is updated at each simulation step.\n\nIt is possible to define a monitor inside a model (see this page). It is also possible to define a monitor through the graphical interface.\nTo define a monitor, first choose Add Monitor in the Views menu (or by clicking on the icon in the Monitor view), then define the display legend and the expression to monitor. The expression is compiled when it is written in the text field: as long as the text field is surrounded by a red rectangle, it is incorrect. When the surrounding color becomes green, GAMA has accepted the expression and its value can be displayed in the monitor.\n\nIn the following example, we defined a monitor with the legend \"Total number of agents\" and its value is defined by the GAML expression computing the sum of the number of agents in each population: length(prey) + length(predator).\n\nThe expression should be written with the GAML language. See this page for more details about the GAML language."},{"filePath":"https:--gama-platform.org--wiki-Installation.txt","text":"InstallationWe made efforts to make the last release of GAMA (1.9.2) as easy as possible to install, by providing a version with an embedded Java JDK, limiting the installation to a 3-steps procedure: download, install and launch.\nDownload GAMA​\nGAMA 1.9.2 (the latest release) comes in a version for each 3 environments Windows, macOS and Linux packaged in easy to use installers. You simply have to go on the downloads page and pick the one for your system.\n\nFor advanced users :\n\nGAMA provide also some versions without embedded JDK allowing you to download a lighter archive\n\nThis version requires Java 17 JDK to be installed on your computer (at least 17.0.3+7)\n\n\nIt's also possible to download these 2 kinds of releases in simple zip archive (i.e. without installers), if you do so, please refer to the post-installation procedure at the end of this page\n\nYou'll find them on the Github Release page\n\nInstall procedure​\nAfter downloading the chosen GAMA version from the Downloads page for your computer, you only have run the installer, follow steps, and launch GAMA.\nStep-by-step Windows​\nOn windows, in addition to running GAMA from the zip file, we have to ways of installing it: the standard installer that you can get from our website, or the winget command.\nInstaller from the website​\nThis is the standard way of installing GAMA on windows.\n\nDownload the installer .exe for Windows\nDouble-click on the downloaded .exe file\nAccept to run the app\n\n\n\nFollow the installer with the onscreen steps\nDone, you can start GAMA from your computer now.\n\n\nNB: If you need to launch GAMA Headless, GAMA is installed under C:\\Program Files\\Gama by default\n\nFrom winget​\nFor advanced users, you may want to install GAMA from winget, the process is very simple:\n\nOpen PowerShell\nRun the command\n\nwinget.exe install GamaPlatform.Gama\nThat's it, GAMA is installed on your computer!\nStep-by-step macOS​\nIn macOS we have two ways of installing gama: either the regular and user friendly .dmg installer, or the command line way with the homebrew package manager.\nDMG version​\n\nDownload the installer .dmg for macOS\n\nThere is a built specifically for Macintosh M1 (also called with Apple silicon). You can check by clicking on the top-left apple, About this Mac: the pop-up window will give details about the processor. If you're not sure and your Macintosh is from 2021 (or earlier) you probably need this specific version\n\n\nDouble-click on the downloaded .dmg file\nDrag'n'drop GAMA icon to your computer (Applications folder or Desktop for instance)\n\n\n\nDone, you can start GAMA from your computer now. At the first launch of GAMA, a popup window will appear warning you that GAMA is a software downloaded from internet and asking whether you want to open it. Click on the Open button.\n\n\n\nNB: Note that the first launch of GAMA should be made in GUI mode (clicking on the icon) and not in headless mode.\nNB2: If you need to launch GAMA Headless after, GAMA is installed where you dragged and dropped the Gama.app\n\nbrew version​\n\nInstall brew on your computer: just follow the instruction from the website.\nOpen a terminal\nRun the command brew install gama or brew install gama-jdk for the JDK version\n\nStep-by-step Linux​\nDebian/Ubuntu based​\n\nDownload the installer .deb for Ubuntu (and any Debian-based systems)\nDouble-click on the downloaded .deb file\nClick on install\n\n\n\nYou could be asked for your password\nDone, you can start GAMA from your computer now\n\n\nNB: If you need to launch GAMA Headless, GAMA is installed under /opt/gama-platform\n\nArch Linux based​\nAUR packages with latest version of GAMA exists for both version with and without embedded JDK. You can download them with a command as follows:\nyay -S gama-platform{-jdk}\nStep-by-step Docker​\nA Docker image of GAMA exists to execute GAMA Headless inside a container.\n\nInstall docker on your system following the official documentation\nPull the GAMA's docker you want to use (e.g. docker pull gamaplatform/gama:1.9.2)\nRun this GAMA's docker with your headless command (e.g. docker run gamaplatform/gama:1.9.2 -help)\n\nYou can found all the tags and more detailed documentation on the Docker Hub or on the corresponding Github's Repository\nSystem Requirements​\nGAMA 1.9.2 requires approximately 540MB of disk space and a minimum of 2GB of RAM (to increase the portion of memory usable by GAMA, please refer to these instructions).\nWindows post-installation setting (only for zip install)​\nIf you decided to install gama yourself from the zip file, it is important that you change the Windows HDPI compatibility settings.\nTo do so, go to your Gama.exe file, right click and it and select properties, then go to the Compatibility tab and click on the Change high DPI settings button:\n\nIn the new window, check the Override high DPI scaling behavior option and select the System value.\n\nThese options are necessary to avoid most graphical problem using gama on Windows"},{"filePath":"https:--gama-platform.org--wiki-InstallationAndLaunching.txt","text":"Installation and LaunchingThe GAMA platform can be easily installed on your machine: Windows, macOS or Ubuntu. Depending on user needs, GAMA can then be extended by using a number of additional plugins.\nThis part is dedicated to explain how to install GAMA, launching GAMA and extend the platform by installing additional plugins. All the known issues concerning installation are also explained. The GAMA team provides you a continuous support by proposing corrections to some serious issues through updating patchs. In this part, we will also briefly present another way to launch GAMA without any GUI : the headless mode.\n\nInstallation\nLaunching GAMA\nHeadless Mode\nUpdating GAMA\nInstalling Plugins\n"},{"filePath":"https:--gama-platform.org--wiki-InstallingGitVersion.txt","text":"Installing the GIT versionImportant note: the current Git version contains 1 main branch:\n\nGAMA_1.9.2: that contains the code of the GAMA alpha(GAMA 1.9.2) (it works with JDK 17 LTS and Eclipse 2022-12).\n\nChanges made to other branches won't be added to the next gama release\nThe following tutorial describes the installation for this version.\nInstall Eclipse 2022-12​\nDownload the \"Installer of 2022-12\" and choose to install the Eclipse IDE for Java and DSL Developers version. This is the latest version under which GAMA is certified to work.\nNote: Regarding Java, Eclipse embeds the Adoptium (ex Adopt-OpenJDK) 17 LTS (HotSpot), which is the recommanded version for GAMA, you may be able to use another one, but we won't fix any related issue.\nInstall GAMA source code​\nThe source is to be downloaded from GitHub in two steps: by creating a local clone of the GitHub repository and then importing the different projects that constitute GAMA into the Eclipse workspace.\n\nOpen the Git perspective:\n\n\nWindows > Perspective > Open Perspective > Other...\nChoose Git\n\n\n\nClick on \"Clone a Git repository\"\n\n\n\nIn Source Git repository window:\n\nFill in the URI label with: https://github.com/gama-platform/gama.git\nOther fields will be automatically filled in.\n\n\n\nIn Branch Selection windows,\n\ncheck the GAMA_1.9.2 branch\nNext\n\n\n\n\n\nIn Local Destination windows,\n\nChoose a Directory (where the source files will be downloaded).\nEverything else should be unchecked\nFinish\n\n\n\n\nThis can take a while...\nImport projects into workspace​\nYou have now to import projects into the workspace (notice that the folders downloaded during the clone will neither be copied nor moved).\nNote: contrarily to previous Eclipse versions, import project from the Git perspective does not work properly for GAMA.\n\nIn the Java perspective, choose:\n\n\nFile / Import...,\n\n\n\nIn the install window, select Git / Projects from Git,\nClick on Next,\nIn the Project from Git window, select Existing local repository.,\n\n\n\nClick on Next,\nIn the new window, select your Git repository,\nClick on Next,\nIn the Select a wizard to used to import projects, check that\n\nImport existing Eclipse projects is selected\nWorking Tree is selected\n\n\n\n\n\n\nClick on Next,\n\n\nIn the Import project window,\n\nUncheck Search for nested projects\nSelect all the projects\n\n\n\n\nFinish\n\n\n\nClean project (Project menu > Clean ...)\n\nIf you have errors...​\nIf errors continue to show on in the different projects, be sure to correctly set the JDK used in the Eclipse preferences. GAMA (version 1.9.2) is targeting JDK 17, and Eclipse could produce errors if it did not find in your environment. So, either you set the compatibility to 17 by default (in Preferences > Java > Compiler > Compiler Compliance Level) or you change the error produced by Eclipse to a warning only (in Preferences > Java > Compiler > Building > \"No strictly compatible JRE for execution environment available).\nOn Windows : if the project still don't compile, try to add the vm argument in eclipse.ini files (inside the directory where your eclipse is installed)\nbefore the -startup line\nExample :\n-vmC:\\Program Files\\Java\\JDK17\\bin-startup .....\nRun GAMA​\n\nBe sure to be in the Java Perspective (top right button)\nIn the ummisco.gama.product plugin, open the gama.product file (gama.headless.product is used to produce the headless).\nGo to \"Overview\" tab and click on Synchronize\nClick on \"Launch an Eclipse Application\"\n\nGIT Tutorials​\nFor those who want to learn more about Git and Egit, please consult the following tutorials/papers\n\nEGIT/User Guide http://wiki.eclipse.org/EGit/User_Guide\nGit version control with Eclipse (EGIT) - Tutorial http://www.vogella.com/tutorials/EclipseGit/article.html\n10 things I hate about Git http://stevebennett.me/2012/02/24/10-things-i-hate-about-git/\nLearn Git and GitHub Tutorial https://www.youtube.com/playlist?list=PL1F56EA413018EEE1\n"},{"filePath":"https:--gama-platform.org--wiki-InstallingPlugins.txt","text":"Installing PluginsBesides the plugins delivered by the developers of the GAMA platform, there are a number of additional plugins that can be installed to add new functionalities to GAMA or enhance the existing ones. GAMA being based on Eclipse, a number of plugins developed for Eclipse are then available (a complete listing of Eclipse plugins can be found in the so-called Eclipse MarketPlace).\nThere are, however, three important restrictions:\n\nThe current version of GAMA is based on Eclipse 2022-12 (version number 4.26.0), which excludes de facto all the plugins targeting solely a specific different version of Eclipse. These will refuse to install anyway.\nThe Eclipse foundations in GAMA are only a subset of the complete Eclipse platform, and a number of libraries or frameworks (for example the Java Development Toolkit) are not (and will never be) installed in GAMA. So plugins relying on their existence will refuse to install as well.\nSome components of GAMA rely on a specific version of other plugins and will refuse to work with other versions, essentially because their compatibility will not be ensured anymore. For instance, the parser and validator of the GAML language in GAMA 1.9.2 require XText v. 2.29.0 to be installed.\n\nWith these restrictions in mind, it is, however, possible to install interesting additional plugins. We propose here a list of some of these plugins (known to work with GAMA), but feel free to either add a comment if you have tested plugins not listed here or create an issue if a plugin does not work, in order for us to see what the requirements to make it work are and how we can satisfy them (or not) in GAMA.\nTable of contents​\n\nInstalling Plugins\n\nInstallation\nSelected plugins provided by GAMA community\n\nToward participative simulations with Remote.Gui and Gaming plugins\nRJava plugin\nWeka and Matlab plugins\n\n\nSelected Plugins\n\nGit\nCSV Edit\nQuickimage\nRSS/Atom Feed View\nCKEditor\nStartexplorer\nPathtools\n\n\n\n\n\nInstallation​\nInstalling new plugins is a process identical to the one described when updating GAMA, with one exception: the update site to enter is normally provided by the vendor of the additional plugin and must be entered instead of GAMA's one in the dialog.\nLet suppose that we want to install a GAMA plugin developed in order to allow GAMA to ask R to do some computations. This plugin is developed by the GAMA community, but the installation of any plugin will be similar, only the address of the update site will change. To install this plugin, open the pane to install new plugins: \"Help > Install new plugins ... \".\nChoose in the \"Work with...\" text field:\nmsi.gama.experimental.p2updatesite - http://updates.gama-platform.org/experimental\nIf it is not available, you can simply type the address of the update site in the text field:\nhttp://updates.gama-platform.org/experimental/<GAMA-VERSION>\n\nNote: The <GAMA-VERSION> should be replaced by the version of GAMA you are using.\nFor example, current latest version is GAMA 1.9.2, then the address is this : http://updates.gama-platform.org/experimental/1.9.2\n\nAmong all the plugins, select RJava in the category \"Optional components of GAMA\" and click on \"Next >\" button.\n\nThe initial dialog is followed by two other ones, a first to report that the plugin satisfies all the dependencies, a second to ask the user to accept the license agreement.\n\n\nOnce we dismiss the warning that the plugin is not signed and accept to restart GAMA, we can test the new plugin.\nIn the case of plugins extending the features of GAMA, some example models are often provided with the new plugins to illustrate its use (and it is the case for RJava). These new models are accessible in GAMA from Plugin models in a dedicated folder (GAMA to Rjava in the case of RJava). We may need to refresh the model library to let it appear. Notice that you need to configure GAMA to access R before running these models.\n\nSelected plugins provided by the GAMA community​\nThe update site located at the address http://updates.gama-platform.org/experimental contains new plugins for GAMA mainly developed by the GAMA community (its Github repository is available here). As the name of the repository highlights it, these plugins are most of them still in development, before integration in the kernel of GAMA.\nToward participative simulations with Remote.Gui and Gaming plugins​\nThere are more and more applications of GAMA for participative simulations (LittoSim, MarakAir, HoanKiemAir...). There was thus a need for new features to improve the possible interactions with simulations and the definition of the Graphical User Interface. The two plugins Remote.Gui and Gaming (available in the \"Participative simulation\" category) attempts to fill this need.\n\nRemote.Gui allows exposing some model parameters, in order that they can be modified through a network. This allows, for example, to develop a remote application (e.g. Android application) to control the parameters' values during the simulation.\nGaming allows the modeler to define displays that are much more interactive. This is used to define serious games in which the users can have a wide range of possible interactions with the simulation.\n\nRJava plugin​\nThis plugin allows the modeler to launch some computation on the R software. To this purpose, R should be installed on your computer and GAMA should be properly configured.\nThis possible connection to R opens thus the possibility for the modeler to use all the statistical functions and libraries developed in this tool of reference. In addition, R scripts defined by the modeler can also be used directly from his/her GAMA model.\nWeka and Matlab plugins​\nSimilarly to RJava, Matlab and Weka plugins allow the modeler to run computations on the Matlab and Weka software, taking advantages of all the possibilities of these softwares and of scripts defined by him/herself.\nNotice that the Matlab plugin requires that MATLAB 2019a is installed and activated on your computer."},{"filePath":"https:--gama-platform.org--wiki-InteractionBetweenAgents.txt","text":"Interaction between agentsIn this part, we will learn how interactions between agents works. We will also present you a bunch of operators useful for your modelling.\nIndex​\n\nThe ask statement\nPseudo variables\nSome useful interaction operators\nExample\n\nThe ask statement​\nThe ask statement can be used in any reflex or action scope. It is used to specify the interaction between the instances of your species and the other agents. You only have to specify the species of the agents you want to interact with. Here are the different ways of calling the ask statement:\n\nIf you want to interact with one particular agent (for example, defined as an attribute of your species):\n\nspecies my_species {    agent target;        reflex update {\task target {\t    // statements\t}    }}\n\nIf you want to interact with a group of agents:\n\nspecies my_species {    list<agent> targets;    reflex update {\task targets {\t    // statements\t}    }}\n\nIf you want to interact with agents, as if they were instance of a certain species (can raise an error if it's not the case!):\n\nspecies my_species {    list<agent> targets;    reflex update {\task targets as:my_species {\t    // statements\t}    }}\n\nIf you want to interact with all the agents of a species (note that the name of the species can be used in the ask, and in many other situations, as the population of this species, i.e. the list of agents instance of this species):\n\nspecies my_species {    reflex update {\task other_species {\t    // statements\t}    }}species other_species { }\nNote that you can use the attribute population of species if you find it more explicit:\nask other_species.population\n\nIf you want to interact with all the agents of a particular species from a list of agents (for example, using the global variable \"agents\"):\n\nspecies my_specie {    reflex update {\task agents of_species my_specie {\t    // statements\t}    }}\nPseudo-variables​\nOnce you are in the ask scope, you can use some pseudo-variables to refer to the receiver agent (the one specified just after the ask statement) or the transmitter agent (the agent which is asking).\nWe use the pseudo-variable self to refer to the receiver agent, and the pseudo-variable myself to refer to the transmitter agent. The pseudo variable self can be omitted when calling actions or attributes.\nspecies speciesA {    init {\tname <- \"speciesA\";    }\t    reflex update {\task speciesB {            write name; // output : \"speciesB\"\t\t\t            write self.name; // output : \"speciesB\"\t    write myself.name; // output : \"speciesA\"        }    }}species speciesB {    init {\tname <- \"speciesB\";    }}\nNow, if we introduce a third species, we can write an ask statement inside another.\nspecies speciesA {    init {\tname <- \"speciesA\";    }    reflex update {\task speciesB {\t    write self.name; // output : \"speciesB\"\t    write myself.name; // output : \"speciesA\"\t    ask speciesC {\t\twrite self.name; // output : \"speciesC\"\t\twrite myself.name; // output : \"speciesB\"\t    }\t}    }}species speciesB {    init {\tname <- \"speciesB\";    }}species speciesC {    init {\tname <- \"speciesC\";    }}\nNb: try to avoid multiple imbrications of ask statements. Most of the time, there is another way to do the same thing.\nSome useful interaction operators​\nThe operator at_distance can be used to know the list of agents that are in a certain distance from another agent.\nspecies my_species {    reflex update {\tlist<agent> neighbors <- agents at_distance(5);\t// neighbors contains the list of all the agents located at a distance <= 5 from the caller agent.    }}\nThe operator closest_to returns the closest agent of a position among a container.\nspecies my_species {    reflex update {\tagent agentA <- agents closest_to(self);\t// agentA contains the closest agent from the caller agent.\tagent agentB <- other_specie closest_to({2,3});\t// agentB contains the closest instance of other_specie from the location {2,3}.    }}species other_specie { }\nExample​\nTo practice those notions, here is a short basic example. Let's build a model with a given number of agents with a circle display (keep in mind that their shape has kept its default value: a point). They can move randomly on the environment (i.e. here move can be understood as changing its location), and when they are close enough from another agent, a line is displayed between them. This line is destroyed when the distance between the two agents is too important.\nHint: use the operator polyline to construct a line. List the points between angle brackets [ and ].\n\nHere is one example of implementation:\nmodel connect_the_neighborsglobal{    float speed <- 0.2;    float distance_to_intercept <- 10.0;    int number_of_circle <- 100;\t    init {\tcreate my_species number:number_of_circle;    }}species my_species {    reflex move {\tlocation <- {location.x+rnd(-speed,speed),location.y+rnd(-speed,speed)};    }\t    aspect default {\tdraw circle(1) color: #yellow border: #black;\task my_species at_distance(distance_to_intercept) {\t    draw polyline([self.location,myself.location]) color:#black;\t}    }}experiment my_experiment type:gui {    output{\tdisplay myDisplay {\t    species my_species aspect:default;\t}    }}"},{"filePath":"https:--gama-platform.org--wiki-Introduction-To-Gama-Java-API.txt","text":"Introduction to GAMA Java APIThis introduction to the Java API is dedicated to programmers that want to participate in the java code of GAMA. The main purpose is to describe the main packages and classes of the API to makes it simple to find such crucial information such as: how GAMA create containers, agent and geometries, how exceptions and log are managed, how java code maintain Type safety, etc.\nTable of content​\nConcepts\n\nFactories\nSpatial\nType\nIScope\nException\nDebug\nTest\n\nPackages\n\n1.Core\n\n\n\nFactories​\nContainer factories​\nGAMA provides 2 factories for containers: GamaListFactory and GamaMapFactory. Each of them has create methods to create objects of type IList and IMap. The types of elements in the container can be specified at creation using one of the elements defined in Types.\nWarning: the create method is used to create the container, with elements of a given type, but it also converts elements added in this type. To avoid conversion (not recommended), use the method createWithoutCasting.\n\nGamaListFactory : factory to create list of different type (see Java class)\n\nAs an example:\nIList<Double> distribution = GamaListFactory.create(Types.FLOAT);\nTo create List object without specifying the type, use Types.NO_TYPE:\nIList<Object> result = GamaListFactory.create(Types.NO_TYPE);\nor only:\nIList<Object> result = GamaListFactory.create();\n\nGamaMapFactory : factory to create map of different type (see Java class)\n\nAs an example:\nfinal IMap<String, IList<?>> ncdata = GamaMapFactory.create(Types.STRING, Types.LIST);\nTo create Map object without specifying the type, use Types.NO_TYPE:\nIMap<Object, Object> result = GamaMapFactory.create(Types.NO_TYPE, Types.NO_TYPE);\nor only:\nIMap<Object, Object> result = GamaMapFactory.create();\nIf you want to use map or set, try to the best to rely on collection that ensure order, so to avoid unconsistency in container access. Try the most to avoid returning high order hash based collection, e.g. Set or Map; in this case, rely on standard definition in Gama:\n\n\nTOrderedHashMap : see trove api.\n\n\nTLinkedHashSet : see trove api\n\n\nStream : you can use java build-in streams but there is a special version in Gama taken from StreamEx that should be preferred.\n\n\nmy_container.stream(my_scope)\nIf you want to get a stream back to a Gama container, you can use the collector in Factories:\nmy_container.stream(my_scope).collect(GamaListFactory.toGamaList())\nGeometry factory​\nGama geometry is based on the well established Jstor geometric library, while geographic aspect are handle using GeoTools library\n\nSpatial.Creation : provide several static method to initialize geometries\n\n\nSpatial​\nThe Spatial class provide several static access to the main methods to create, query, manipulate and transform geometries\nOperators​\nUse as Spatial.Operators follow by the operator, usually one of Gaml language:\nunion, intersection, minus, and other cross geometry operations\nQueries​\nclosest, distance, overlapping, and other relative spatial relationship\nTranspositions​\nenlarge, transpose, rotate, reduce and other specific transposition (like triangulation, squarification, etc.)\nPunctal​\noperations relative to points\nType​\nIType: The main class to manipulate GamaType (main implementation of IType) is Types, that provides access to most common type manipulated in Gama\nOpérateur de cast:\nTypes.get(IType.class)\nIScope interface​\nAn object of type IScope represents the context of execution of an agent (including experiments, simulations, and \"regular\" agents). Everywhere it is accessible (either passed as a parameter or available as an instance variable in some objects), it provides an easy access to a number of features: the current active agent, the shared random number generator, the global clock, the current simulation and experiment agents, the local variables declared in the current block, etc.\nIt also allows modifying this context, like changing values of local variables, adding new variables, although these functions should be reserved to very specific usages. Ordinarily, the scope is simply passed to core methods that allow to evaluate expressions, cast values, and so on.\nUse of an IScope​\nA variable scope of type IScope can be used to:\n\nget the current agent with: scope.getAgentScope()\n\nIAgent agent = scope.getAgentScope();\n\nevaluate an expression in the current scope:\n\nString mes = Cast.asString(scope, message.value(scope));\n\nknow whether the scope has been interrupted:\n\nboolean b = scope.interrupted();\nException​\nExceptions in GAMA\nAn exception that can appear in the GAMA platform can be run using the GamaRuntimeException class. This class allows throwing an error (using error(String,IScope) method) or a warning (using warning(String,IScope) method).\nIn particular, it can be useful to catch the Java Exception and to throw a GAMA exception.\ntry {        ...} catch(Exception e) {\tthrow GamaRuntimeException.error(\"informative message\", scope);}\nDebug​\nMain class for debug is in ummisco.gama.dev.utils : DEBUG\n\n\nTo turn GAMA Git version to debug mode change variable of the Debug class like: GLOBAL_OFF = false\n\n\nTurn on or off the debug for one class: DEBUG.ON() or DEBUG.OFF()\n\n\nYou can benchmark a method call using : DEBUG.TIME(\"Title to log\", () -> methodToBenchmark(...))\n\n\nYou can use different built-in level to print: DEBUG.ERR(string s) DEBUG.LOG(string s) DEBUG.OUT(Object message)\n\n\nTest​\nThere are Gaml primitives and statement to define test:\ntest \"Operator + (1)\" {\tassert (circle(5) + 5).height with_precision 1 = 20.0;\tassert (circle(5) + 5).location with_precision 9 = (circle(10)).location with_precision 9;}\nEverything can be made using Java Annotation (translated to Gaml test) :\nexamples = { @example (value=\"...\",equals=\"...\" )  }test = { \"...\" } // don't forget to turn test arg of examples to false\n\n\nCore​\nThe main plugin of the GAMA Platform that defines the core functionalities: most Gaml operators, statements, skills, types, etc.\nMetamodel​\n\nIAgent, IPopulation, IShape, ITopology,\nOuputs​\n\nUtil​\n\n\nRandomness in Gama: msi.gama.util.random\n\nGamaRND is the main class that implements Random java class. It has several implementations and is mainly used with RandomUtils that define all the Gaml random operators\n\n\nGraph in Gama:\n\n\nFile in Gama:\n\n\nOperators​\nThe packages where you can find all the operators defined in the core of Gama"},{"filePath":"https:--gama-platform.org--wiki-Introduction.txt","text":"IntroductionGAML is an agent-oriented language dedicated to the definition of agent-based simulations. It takes its roots in object-oriented languages like Java or Smalltalk, but extends the object-oriented programming approach with powerful concepts (like skills, declarative definitions or agent migration) to allow for a better expressivity in models.\nIt is of course very close to agent_based modeling languages like, e.g., NetLogo, but, in addition to enriching the traditional representation of agents with modern computing notions like inheritance, type safety or multi-level agency, and providing the possibility to use different behavioral architectures for programming agents, GAML extends the agent-based paradigm to eliminate the boundaries between the domain of a model (which, in ABM, is represented with agents) and the experimental processes surrounding its simulations (which are usually not represented with agents), including, for example, visualization processes. This paper (Drogoul A., Vanbergue D., Meurisse T., Multi-Agent Based Simulation: Where are the Agents ?, Multi-Agent Based Simulation 3, pp. 1-15, LNCS, Springer-Verlag. 2003) was in particular foundational in the definition of the concepts on which GAMA (and GAML) are based today.\nThis orientation has several conceptual consequences among which at least two are of immediate practical interest for modelers:\n\nSince simulations, or experiments, are represented by agents, GAMA is bound to support high-level model compositionality, i.e. the definition of models that can use other models as inner agents, leveraging multi-modeling or multi-paradigm modeling as particular cases of composition.\nThe visualization of models can be expressed by models of visualization, composed of agents entirely dedicated to visually represent other agents, allowing for a clear separation of concerns between a simulation and its representation and, hence, the possibility to play with multiple representations of the same model at once.\n\nTable of contents​\n\nKey Concepts (Under construction)\n\nLexical semantics of GAML\nTranslation into a concrete syntax\nVocabulary correspondance with the object-oriented paradigm as in Java\nVocabulary correspondance with the agent-based paradigm as in NetLogo\n\n\n\nLexical semantics of GAML​\nThe vocabulary of GAML is described in the following sentences, in which the meaning and relationships of the important words of the language (in bold face) are summarized.\n\nThe role of GAML is to support modelers in writing models, which are specifications of simulations that can be executed and controlled during experiments, themselves specified by experiment plans.\nThe agent-oriented modeling paradigm means that everything \"active\" (entities of a model, systems, processes, activities, like simulations and experiments) can be represented in GAML as an agent (which can be thought of as a computational component owning its own data and executing its own behavior, alone or in interaction with other agents).\nLike in the object-oriented paradigm, where the notion of class is used to supply a specification for objects, agents in GAML are specified by their species, which provide them with a set of attributes (what they know), actions (what they can do), behaviors (what they actually do) and also specifies properties of their population, for instance its topology (how they are connected) or schedule (in which order and when they should execute).\nAny species can be nested in another species (called its macro-species), in which case the populations of its instances will imperatively be hosted by an instance of this macro-species. A species can also inherit its properties from another species (called its parent species), creating a relationship similar to specialization in object-oriented design. In addition to this, species can be constructed in a compositional way with the notion of skills, bundles of attributes and actions that can be shared between different species and inherited by their children.\nGiven that all agents are specified by a species, simulations and experiments are then instances of two species which are, respectively, called model and experiment plan. Think of them as \"specialized\" categories of species.\nThe relationships between species, models and experiment plans are codified in the meta-model of GAML in the form of a framework composed of three abstract species respectively called agent (direct or indirect parent of all species), model (parent of all species that define a model) and experiment (parent of all species that define an experiment plan). In this meta-model, instances of the children of agent know the instance of the child of model in which they are hosted as their world, while the instance of experiment plan identifies the same agent as one of the simulations it is in charge of. The following diagram summarizes this framework:\n\n\nPutting this all together, writing a model in GAML then consists in defining a species which inherits from model, in which other species, inheriting (directly or not) from agent and representing the entities that populate this model, will be nested, and which is itself nested in one or several experiment plans among which a user will be able to choose which experiment he/she wants to execute.\n\nAt the operational level, i.e. when running an experiment in GAMA, an experiment agent is created. Its behavior, specified by its experiment plan, will create simulations agents (instance of the user model) and execute them. Recursively, the initialization of a simulation agent will create the agent population of the species defined in the model. Each of these agents, when they are created, can create the population of their micro-species...\nTranslation into a concrete syntax​\nThe concepts presented above are expressed in GAML using a syntax which bears resemblances with mainstream programming languages like Java, while reusing some structures from Smalltalk (namely, the syntax of facets or the infix notation of operators). While this syntax is fully described in the subsequent sections of the documentation, we summarize here the meaning of its most prominent structures and their correspondence (when it exists) with the ones used in Java and NetLogo.\n\nA model is composed of a header, in which it can refer to other models, and a sequence of species and experiments declarations, in the form of special declarative statements of the language.\nA statement can be either a declaration or a command. It is always composed of a keyword followed by an optional expression, followed by a sequence of facets, each of them composed of a keyword (terminated by a ‘:’) and an expression.\nfacets allow to pass arguments to statements. Their value is an expression of a given type. An expression can be a literary constant, the name of an attribute, variable or pseudo-variable, the name of a unit or constant of the language, or the application of an operator.\nA type can be a primitive type, a species type or a parametric type (i.e. a composition of types).\nSome statements can include sub-statements in a block (sequence of statements enclosed in curly brackets).\ndeclarative statements support the definition of special constructs of the language: for instance, species (including global and experiment species), attributes, actions, behaviors, aspects, variables, parameters and outputs of experiments.\nimperative statements that execute something or control the flow of execution of actions, behaviors and aspects are called commands.\nA species declaration (global, species or grid keywords) can only include 6 types of declarative statements : attributes, actions, behaviors, aspects, equations and (nested) species. In addition, experiment species allow to declare parameters, outputs and batch methods.\n\nVocabulary correspondence with the object-oriented paradigm as in Java​\nGAMLJavaspeciesclassmicro-speciesnested classparent speciessuperclasschild speciessubclassmodelprogramexperiment(main) classagentobjectattributememberactionmethodbehaviorcollection of methodsaspectcollection of methods, mixed with the behaviorskillinterface (on steroids)statementstatementtypetypeparametric typegenerics\nVocabulary correspondence with the agent-based paradigm as in NetLogo​\nGAMLNetLogospeciesbreedmicro-species-parent species-child species- (only from 'turtle')modelmodelexperimentobserveragentturtle/observerattribute'breed'-ownactionglobal function applied only to one breedbehaviorcollection of global functions applied to one breedaspectonly one, mixed with the behaviorskill-statementprimitivetypetypeparametric type-"},{"filePath":"https:--gama-platform.org--wiki-Launching.txt","text":"Launching GAMARunning GAMA for the first time requires that you launch the application (Gama.app on MacOS X, Gama.exe on Windows, Gama on Linux, located in the folder called GAMA_VERSION.NUMBER_YOUR_OS_NAME once you have unzipped the downloaded archive). In case you are unable to launch the application, or if error messages appear, please refer to the installation or troubleshooting instructions.\nTable of contents​\n\nLaunching GAMA\n\nLaunching the Application\nLaunching the Application from the command line\nChoosing a Workspace\nWelcome Page\n\n\n\nLaunching the Application​\nThe extraction of the downloaded archive provides:\n\non Mac OS X: a single file named Gama.app\non Windows and Linux: a folder named GAMA_1.8_YOUR_OS_NAME containing, among many other files and folders, the Gama.exe file (for Windows) and Gama (for Linux).\n\nRunning GAMA requires that you launch the application file (Gama.app on Mac OS X, Gama.exe on Windows, Gama on Linux) by double-clicking on them or from a terminal.\nLaunching the Application from the command line​\nNote that GAMA can also be launched in two different other ways:\n\nIn a so-called headless mode (i.e. without a user interface, from the command line, in order to conduct experiments or to be run remotely). Please refer to the corresponding instructions.\nFrom the terminal, using a path to a model file and the name or number of an experiment, in order to allow running this experiment directly (note that the two arguments are optional: if the second is omitted, the file is imported in the workspace if not already present and opened in an editor; if both are omitted, GAMA is launched as usual):\n\n\nGama.app/Contents/MacOS/Gama path_to_a_model_file#experiment_name_or_number on Mac OS X\nGama path_to_a_model_file#experiment_name_or_number on Linux\nGama.exe path_to_a_model_file#experiment_name_or_number on Windows\n\nChoosing a Workspace​\nPast the splash screen, GAMA will ask you to choose a workspace in which to store your models and their associated data and settings. The workspace can be any folder in your filesystem on which you have read/write privileges. If you want GAMA to remember your choice next time you run it (it can be handy if you run Gama from the command line), simply check the corresponding option. If this dialog does not show up when launching GAMA, it probably means that you inherit from an older workspace used with a previous GAMA version (and still \"remembered\"). In that case, a warning will be produced to indicate that the model library is out of date, offering you the possibility to create a new workspace.\n\nYou can enter its address or browse your filesystem using the appropriate button. If the folder already exists, it will be reused (after a warning if it is not already a workspace). If not, it will be created. It is always a good idea, when you launch a new version of GAMA for the first time, to create a new workspace. You will then, later, be able to import your existing models into it. Failing to do so might lead to odd errors in the various validation processes.\nWhen you try to choose a workspace used with a previous of GAMA, the following pop-up will appear.\n\nThe following pop-up appears when the user wants to create a new workspace in a folder that does not exist. Click on OK to create the folder and set this new folder as the GAMA workspace.\n\nWelcome Page​\nAs soon as the workspace is created, GAMA will open and you will be presented with its first window. GAMA is based on Eclipse and reuses most of its visual metaphors for organizing the work of the modeler. The main window is then composed of several parts, which can be views or editors, and are organized in a perspective. GAMA proposes 2 main perspectives: Modeling, dedicated to the creation of models, and Simulation, dedicated to their execution and exploration. Other perspectives are available if you use shared models.\nThe default perspective in which GAMA opens is Modeling. It is composed of a central area where GAML editors are displayed, which is surrounded by a Navigator view on the left-hand side of the window, an Outline view (linked with the open editor), the Problems view, which indicates errors and warnings present in the models stored in the workspace and an interactive console, which allows the modeler to try some expressions and get an immediate result.\n\nIn the absence of previously open models, GAMA will display a Welcome page (actually a web page), from which you can find links to the website, current documentation, tutorials, etc. This page can be kept open (for instance if you want to display the documentation when editing models) but it can also be safely closed (and reopened later from the \"Help\" menu).\n\nFrom this point, you are now able to edit a new model, navigate in the model library, or import an existing model."},{"filePath":"https:--gama-platform.org--wiki-LaunchingExperiments.txt","text":"Launching Experiments from the User InterfaceGAMA supports multiple ways of launching experiments from within the Modeling Perspective, in editors or in the navigator.\nTable of contents​\n\nLaunching Experiments from the User Interface\n\nFrom an Editor\nFrom the Navigator\nRunning Experiments Automatically\nRunning Several Simulations\n\n\n\nFrom an Editor​\nAs already mentioned in this page, GAML editors will provide the easiest way to launch experiments. Whenever a model that contains the definition of experiments is validated, these experiments will appear as distinct buttons, in the order in which they are defined in the file, in the header ribbon above the text. Simply clicking one of these buttons launches the corresponding experiment.\n\nFor each of those launching buttons, you can see different pictograms, showing the type of experiment. The various kinds of experiment are described in this page.\n\nFrom the Navigator​\nYou can also launch your experiments from the navigator, by expanding a model and double-clicking on one of the experiments available (the number of experiments for each model is visible also in the navigator). As for the editor, the various types of experimentations are differentiated by a pictogram.\n\nRunning Experiments Automatically​\nOnce an experiment has been launched (unless it is run in headless mode, of course), it normally displays its views and waits from an input from the user, usually a click on the \"Run\" or \"Step\" buttons (see here).\nIt is, however, possible to make experiments run directly once launched, without requiring any intervention from the user.  To activate this feature, open the preferences of GAMA. In the \"Execution\" tab, simply check \"Auto-run experiments when they are launched\" (which is unchecked by default) and hit \"Save\" to dismiss the dialog. Next time you will launch an experiment, it will run automatically (this option also applies to experiments launched from the command line).\n\nWhen the autorun is set in the Preferences, all the experiments in the workspace will be in autorun mode. If you want to activate this option only for a single experiment, it can be done programmatically by adding the autorun: to the experiment statement as detailed in this page.\nRunning Several Simulations​\nIt is possible in GAMA to run several simulations (multi-simulation feature). Each simulation will be launched with the same seed (which means that if the parameters are the same, then the result will be exactly the same). All those simulations are synchronized in the same cycle.\nTo run several simulations, you have to write it directly in your model.\n"},{"filePath":"https:--gama-platform.org--wiki-LearnGAMLStepByStep.txt","text":"Learn GAML Step by StepThis large progressive tutorial has been designed to help you to learn GAML (GAma Modeling Language).\nIt will cover the main part of the possibilities provided by GAML, and guide you to learn some more.\nHow to proceed to learn better?​\nAs you will progress in the tutorial, you will see several links (written in blue to makes you jump to another part. You can click on them if you want to learn directly about a specific topic, but we do not encourage to do this, because you can get easily lost by reading this tutorial this way. As it is named, we encourage you to follow this tutorial \"step by step\". For each chapter, some links are available in the \"search\" tab, if you want to learn more about this subject.\nAlthough, if you really want to learn about a specific topic, our advice is to use the \"learning graph\" interface, in the website, so that you can choose your area of interest, and a learning path will be automatically designed for you to assimilate the specific concept better.\nGood luck with your reading, and please do not hesitate to contact us through the mailing list if you have a question/suggestion!"},{"filePath":"https:--gama-platform.org--wiki-Literals.txt","text":"Literals(some literal expressions are also described in data types)\nA literal is a way to specify an unnamed constant value corresponding to a given data type. GAML supports various types of literals for often — or less often — used data types.\nTable of contents​\n\nLiterals\n\nSimple Types\nLiteral Constructors\nUniversal Literal\n\n\n\nSimple Types​\nValues of simple (i.e. not composed) types can all be expressed using literal expressions. Namely:\n\nbool: true and false.\nint: decimal value, such as 100, or hexadecimal value if preceded by '#' (e.g. #AAAAAA, which returns the int 11184810)\nfloat: the value in plain digits, using '.' for the decimal point (e.g. 123.297)\nstring: a sequence of characters enclosed between quotes ('my string') or double quotes (\"my string\")\n\nLiteral Constructors​\nAlthough they are not strictly literals in the sense given above, some special constructs (called literal constructors) allow the modeler to declare constants of other data types. They are actually operators but can be thought of literals when used with constant operands.\n\npair: the key and the value separated by :: (e.g. 12::'abc')\nlist: the elements, separated by commas, enclosed inside square brackets (e.g. [12,15,15])\nmap: a list of pairs (e.g. [12::'abc', 13::'def'])\npoint: 2 or 3 int or float ordinates enclosed inside curly brackets (e.g. {10.0,10.0,10.0})\n\nUniversal Literal​\nFinally, a special literal, of type unknown, is shared between the data types and all the agent types (aka species). Only bool, int and float, which do not derive from unknown, do not accept this literal. All the others will accept it (e.g. string s <- nil; is ok).\n\nunknown: nil, which represents the non-initialized (or, literally, unknown) value.\n"},{"filePath":"https:--gama-platform.org--wiki-LuneraysFlu.txt","text":"Luneray's fluThis tutorial has for goal to introduce how to build a model with GAMA and to use GIS data and graphs. In particular, this tutorial shows how to write a simple GAMA model (the structure of a model, the notion of species...) load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. All the files related to this tutorial (shapefiles and models) are available here.\nThe importation of models is described here.\nModel Overview​\nThe model built in this tutorial concerns the flu spreading in the city of Luneray (Normandie, France).\n\nTwo layers of GIS data are used: a road layer (polylines) and a building layer (polygons). In this model, people agents are moving from building to building using the road network. Each infected people can infect their neighbor people.\nSome data collected concerning Luneray and the disease:\n\nNumber of inhabitants: 2147 (source: wikipedia)\nMean speed of the inhabitants (while moving on the road): 2-5 km/h\nThe disease - non-lethal - is spreading (by air) from people to people\nTime to cure the disease: more than 100 days\nInfection distance: 10 meters\nInfection probability (when two people are at infection distance) : 0.05/ 5 minutes\n\nFrom the data collected, we made some modeling choice:\n\nSimulation step: 5 minutes\nPeople are moving on the roads from building to building\nPeople use the shortest path to move between buildings\nAll people move at a constant speed\nEach time, people arrived at a building they are staying a certain time\nInfected people are never cured\n\nStep List​\nThis tutorial is composed of 6 steps corresponding to 6 models which are incremental representation of the same model, starting with the simplest model 1 and finishing with the latest one, model 6. For each step, we will present its purpose, an explicit formulation, and the corresponding GAML code.\n\nCreation of a first basic disease spreading model\nDefinition of monitors and chart outputs\nImportation of GIS data\nUse of a graph to constraint the movements of people\nDefinition of 3D displays\nExploration of the model\n"},{"filePath":"https:--gama-platform.org--wiki-LuneraysFlu_step1.txt","text":"1. Creation of a first basic disease spreading modelThis first step illustrates how to create simple agents and make them move in their environment.\n\nFormulation​\n\nSet the time duration of a time step to 5 minutes\nDefine the people species with a moving skill\nDefine the move reflex that allows the people agent to move randomly and the infect reflex that allows them to infect other people agents.\nDefine the aspect of the people species\nAdd the people species to a display\n\nModel Definition​\nProject and model​\nThe first step of this tutorial consists of launching GAMA and choosing a workspace, then to define a new project or to import the existing one. For people that do not want to re-write all the models but just to follow the model construction, they can just download the model project here and the follow this procedure to import it into GAMA. For the other, the project and model creation procedures are detailed here.\nNote that the concepts of workspace and projects are explained here.\nmodel structure​\nA GAMA model is composed of three types of sections:\n\nglobal: this section, that is unique, defines the \"world\" agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).\nspecies and grid: these sections define the species of agents composing the model. Grid is defined in the following model step \"vegetation dynamic\";\nexperiment: these sections define a context of the execution of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model.\n\nMore details about the different sections of a GAMA model can be found here.\nspecies​\nA species represents a «prototype» of agents: it defines their common properties.\nThree different elements can be defined in a species:\n\nthe internal state of its agents (attributes)\ntheir behavior\nhow they are displayed (aspects)\n\nIn our model, we define a people species:\nspecies people {\t\t }\nIn addition, we want to add a new capability to our agent: the possibility to move randomly. For that, we add a specific skill to our people agents. A skill is a built-in module that provides the modeler a self-contain and relevant set of actions and variables. The moving provides the agents with several attributes and actions related to movement.\nspecies people skills: [moving]{    ...}\nInternal state​\nAn attribute is defined as follows: type of the attribute and name. Numerous types of attributes are available: int (integer), float (floating-point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, agents species, rgb (color), graph, path...\n\nOptional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max\n\nIn addition to the attributes the modeler explicitly defines, species \"inherits\" other attributes called \"built-in\" variables:\n\nA name (name): the identifier of the species\nA shape (shape): the default shape of the agents to be constructed after the species. It can be a point, a polygon, etc.\nA location (location): the centroid of its shape.\n\nIn our model, we define 2 new attributes to our people agents:\n\nspeed of type float, with for initial value: a random value between 2 and 5 km/h\nis_infected of type bool, with for initial value: false\n\nspecies people skills:[moving]{\t\t    float speed <- (2 + rnd(3)) #km/#h;    bool is_infected <- false;}\nNote we use the rnd operator to define a random value between 2 and 5 for the speed. In addition, we precise a unit for the speed value by using the # symbol. For more details about units, see here.\nBehavior​\nGAMA proposes several ways to define the behavior of a species: dynamic variables (update facet), reflexes...\nA reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:\nreflex reflex_name when: condition {...}\nThe when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.\nWe define a first reflex called move that is activated at each simulation step (no condition) and that makes the people move randomly using the wander action from the moving skill.\nspecies people skills:[moving]{\t\t    //variable definition    reflex move{\tdo wander;    }}\nWe define a second reflex called infect that is activated only when the agent is infected (is_infected = true) and that ask all the people at a distance of 10m to test a probability to be infected.\nspecies people skills:[moving]{\t\t    //variable definition and move reflex\t    reflex infect when: is_infected{\task people at_distance 10 #m {\t    if flip(0.05) {\t\tis_infected <- true;\t    }\t}    }}\nThe ask allows an agent to ask other agents to do something (i.e. to execute a sequence of statements). The at_distance operator allows to get the list of agents (here of people agents) that are located at a distance lower or equal to the given distance (here 10m). The flip operator allows to test a probability.\nDisplay​\nAn agent aspects have to be defined. An aspect is a way to display the agents of a species: aspect aspect_name {...}\nIn the block of an aspect, it is possible to draw:\n\nA geometry: for instance, the shape of the agent (but it may be a different one, for instance, a disk instead of a complex polygon)\nAn image: to draw icons\nA text: to draw a text\n\nIn our model, we define an aspect for the people agent called circle that draw the agents as a circle of 10m radius with a color that depends on their is_infected attribute. If the people agent is infected, it will be drawn in red, in green otherwise.\nspecies people {    ...//variable and reflex definition    aspect circle {\tdraw circle(10) color:is_infected ? #red : #green;    } }\nThe ? structure allows to return a different value (here red or green) according to a condition (here is_infected = true).\nglobal section​\nThe global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species.\nThe world agent represents everything that is global to the model: dynamics, variables...\nIt allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size but can be redefined if necessary. The step attribute of the world agent allows to specify the duration of one simulation step (by default, 1 step = 1 seconde).\nglobal variable​\nIn the current model, we define 4 global attributes:\n\nnb_people: the number of people that we want to create (init value: 2147)\nnb_infected_init: the number of people infected at the initialization of the simulation (init value: 5)\nstep: redefine in order to set the duration of a simulation step to 5 minutes.\nshape: redefine in order to set the geometry of the world to a square of 1500 meters side size.\n\nglobal {    int nb_people <- 2147;    int nb_infected_init <- 5;    float step <- 5 #mn;    geometry shape<-square(1500 #m);}\nModel initialization​\nThe init section of the global block allows to initialize the define what will happen at the initialization of a simulation, for instance, to create agents. We use the statement create  to create agents of a specific species: create species_name + :\n\nnumber: number of agents to create (int, 1 by default)\nfrom: GIS file to use to create the agents (optional, string or file)\nreturns: list of created agents (list)\n\nFor our model, we define the init block in order to create nb_people people agents and ask nb_infected_init of them to be infected:\nglobal {    // world variable definition    init{\tcreate people number:nb_people;\task nb_infected_init among people {\t    is_infected <- true;\t}    }}\nexperiment​\nAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch {[input] [output]}\n\ngui: experiment with a graphical interface, which displays its input parameters and outputs.\nbatch: Allows to setup a series of simulations (w/o graphical interface).\n\nIn our model, we define a gui experiment called main_experiment  :\nexperiment main_experiment type: gui {}\ninput​\nExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.\nA parameter is defined as follows:\nparameter title var: global_var category: cat;\n\ntitle : string to display\nvar : reference to a global variable (defined in the global section)\ncategory : string used to «store» the operators on the UI - optional\n<- : init value - optional\nmin : min value - optional\nmax : min value - optional\n\nNote that the init, min and max values can be defined in the global variable definition.\nIn our model, we define one parameter:\n\n\"Nb people infected at init\" that will define the value of the global variable nb_infected_init with a min value of 1 and a max value of 2147 (the number of people living in Luneray).\n\nexperiment main_experiment type:gui{    parameter \"Nb people infected at init\" var: nb_infected_init min: 1 max: 2147;\t    output { }}\noutput​\nOutput blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh_every: nb (int) (the display will be refreshed every nb steps of the simulation).\nEach display can include different layers (like in a GIS):\n\nAgents lists : agents layer_name value: agents_list aspect: my_aspect;\nAgents species : species  my_species aspect: my_aspect\nImages: image layer_name file: image_file;\nCharts : see later.\n\nNote that it is possible to define a opengl display (for 3D display or just to optimize the display) by using the facet type: opengl.\noutput {    display map {\tspecies people aspect: circle;\t    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Luneray%20flu/models/model1.gaml"},{"filePath":"https:--gama-platform.org--wiki-LuneraysFlu_step2.txt","text":"2. Definition of monitors and chart outputsThis second step illustrates how to create monitors and charts to follows the evolution of variables and to add an ending condition to the simulation.\n\nFormulation​\n\nAdd three new global dynamic variables to follow the evolution of the number of infected people agents, of not infected people agents and of the rate of infected people.\nDefine an ending condition for the simulation\nDefine a monitor to follow the rate of infected people agents\nDefine a chart to follow the rate of infected people agents\n\nModel Definition​\nglobal section​\nglobal variables​\nGAMA offers the possibility to define a dynamic variable that will be recomputed at each simulation step by using the update facet when defining a variable. When an agent is activated, first, it recomputes each of its variables with an update facet (in their definition order), then it activates each of its reflexes (in their definition order).\nTo better follow the evolution of sick people, we add three new global variables to the model:\n\nnb_people_infected of type int with nb_infected_init as init value and updated at each simulation step by the number of infected people\nnb_people_not_infected of type int with (nb_people - nb_infected_init) as init value and updated at each simulation step by the number of not infected people\ninfected_rate of type float updated at each simulation step by the number of infected people divided by the number of people.\n\nglobal{    //... other attributes    int nb_people_infected <- nb_infected_init update: people count (each.is_infected);    int nb_people_not_infected <- nb_people - nb_infected_init update: nb_people - nb_people_infected;    float infected_rate update: nb_people_infected/nb_people;    //... init}\nWe used the count operator that allows to count the number of elements of a list for which the left condition is true. The keyword each represents each element of the list.\nEnding condition​\nThe simplest way to add an ending condition to a model is to add a global reflex that is activated at the end of the simulation that will pause the simulation (use of the pause global action).\nIn our model, we add a new reflex called end_simulation that will be activated when the infected rate is 1.0 (i.e. all the people agents are infected) and that will apply the pause action.\nglobal {    //.. variable and init definition\t    reflex end_simulation when: infected_rate = 1.0 {\tdo pause;    }} \nexperiment​\nmonitor​\nGAMA provides modelers with the possibility to define monitors. A monitor allows to follow the value of an arbitrary expression in GAML. It will appear, in the User Interface, in a small window on its own and be recomputed every time step (or according to its refresh facet).\nDefinition of a monitor:\n\nvalue: mandatory, the expression whose value will be displayed by the monitor.\nrefresh: bool, optional: if the expression is true, compute (default is true).\n\nFor our model, we define a monitor to follow the value of the infected_rate variable:\nexperiment main_experiment type:gui{    //...parameters    output {\tmonitor \"Infected people rate\" value: infected_rate;\t\t        //...display    }}\nChart​\nIn GAMA, charts are considered as a display layer.\nGAMA can display 3 main types of charts using the type facet:\n\nhistogram\npie\nseries/xy/scatter: both display series with lines or dots, with 3 subtypes :\n\nseries: to display the evolution of one/several variables (vs time or not).\nxy: to specify both x and y value. To allow stacked plots, only one y value for each x value.\nscatter: free x and y values for each series.\n\n\n\nIn our model, we define a new display called chart_display that will be refreshed every 10 simulation steps. In this display, we add a series chart with 2 layers of data:\n\nsusceptible: the number of people that are not infected (in green)\ninfected: the number of people that are infected (in red)\n\nexperiment main_experiment type:gui{    //...parameters    output {\t//...display and monitors\t\t\tdisplay chart_display refresh:every(10 #cycles) {\t    chart \"Disease spreading\" type: series {\t\tdata \"susceptible\" value: nb_people_not_infected color: #green;\t\tdata \"infected\" value: nb_people_infected color: #red;\t    }\t}    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Luneray%20flu/models/model2.gaml"},{"filePath":"https:--gama-platform.org--wiki-LuneraysFlu_step3.txt","text":"3. Importation of GIS dataThis third step illustrates how to load GIS data and to agentify them.\n\nFormulation​\n\nDefine 2 new species that will just be displayed: road and building.\nDefine new global attributes to load GIS data (shapefile).\nUse the GIS data to create the road and building agents.\nAdd the road and building agents to the display.\n\nModel Definition​\nFor this step, you will need to add the shapefiles of the roads and buildings inside the includes folder of the project. The shapefiles (and all the other files) can be found here.\nspecies​\nIn this model, we have to define two species of agents: the road agents and the building ones. These agents will not have a particular behavior, they will just be displayed.\nFor each of these species, we define an aspect called geom. As we want to represent the geometry of the agent, we then use the keyword draw that allows to draw a given geometry. In order to draw the geometry of the agent, we use the attribute shape (which is a built-in attribute of all agents). The road will be displayed in black and the building in gray.\nspecies road {    aspect geom {\tdraw shape color: #black;    }}species building {    aspect geom {\tdraw shape color: #gray;    }}\nglobal section​\nglobal variables​\nGAMA allows to automatically read GIS data that are formatted as shapefiles (or as OSM file). In our model, we define 2 shapefiles: one corresponding to the roads and the other ones to the buildings. Note that GAMA is able to manage the projection of the GIS data.\nIn order to set the right size (and position) of the world geometry, we define its value as the envelope of the road shapefile (and no more a square of 1500 meters).\nglobal {    //... other attributes    file roads_shapefile <- file(\"../includes/roads.shp\");    file buildings_shapefile <- file(\"../includes/buildings.shp\");    geometry shape <- envelope(roads_shapefile);\t    //... init}\nAgentification of GIS data​\nIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read command followed by the name of the shapefile attribute.\nIn our model, we modify the init section in order to first create the road agents from the road shapefile, and the building agents from the building shapefile. Then, when creating people agents, we choose for them a random location inside a random building.\nNote that it is possible to execute a sequence of statements at the creation of agents by using a block ({...}) rather than a simple line (;) when using the create statement.\nglobal {    // world variable definition    init{\tcreate road from: roads_shapefile;\tcreate building from: buildings_shapefile;\tcreate people number:nb_people {\t    location <- any_location_in(one_of(building));\t\t\t}\task nb_infected_init among people {\t    is_infected <- true;\t}    }}\nWe used here the one_of operator that returns a random element from a list and the any_location_in operator that returns a random location inside a geometry.\nexperiment​\nOutput​\nIn the map display, we add the road and building species with their geom aspect just before the people species (in order to draw the people agents on the top of the roads and buildings).\nexperiment main_experiment type: gui {    ... //parameter definition    output {    ... //monitor definition\tdisplay map type: opengl{\t    species road aspect: geom;\t    species building aspect: geom;\t    species people aspect: circle;\t\t\t\t}\t... //chart display definition    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Luneray%20flu/models/model3.gaml"},{"filePath":"https:--gama-platform.org--wiki-LuneraysFlu_step4.txt","text":"4. Use of a graph to constraint the movements of peopleThis fourth step illustrates how to use a graph to constraint the movements of agents\n\nFormulation​\n\nDefine a new global variable: the road network (graph).\nBuild the road network graph from the road agents\nAdd new attribute to the people agents (target)\nDefine a new reflex for people agents: stay.\nModify the move reflex of the people agents.\n\nModel Definition​\nglobal section​\nglobal variables​\nIn this model, we want people agents to move from buildings to buildings by using the shortest path in the road network. In order to compute this shortest path, we need to use a graph structure.\nWe thus define a new global variable called road_network of type graph that will represent the road network.\nglobal{    //... other attributes    graph road_network;\t    //... init}\nIn order to compute the graph from the road network, we use, just after having created the road agents, the as_edge_graph operator. This operator automatically built a graph from a set of polylines. Each extremity point of the lines will become a node in the graph, and each polyline an edge. By default, the graph is not oriented and the weights of the edges are the perimeters of the polylines. It is of course possible to change through the use of some operators.\nglobal {    // world variable definition    init{\tcreate road from: roads_shapefile;\troad_network <- as_edge_graph(road);\t\t\tcreate building from: buildings_shapefile;\tcreate people number:nb_people {\t    location <- any_location_in(one_of(building));\t\t\t\t\t}\task nb_infected_init among people {\t    is_infected <- true;\t}    }}\npeople species​\nWe want to modify the behavior of the people agents in order to make them move from buildings to buildings by using the shortest path in the road network.\nVariables​\nIn order to implement this behavior, we will add two variables to our people species:\n\ntarget of type point that will be the location where the agent wants to go\n\nspecies people skills:[moving]{    //...the other attributes    point target;    //....}\nBehavior​\nFirst, we add a new reflex called stay that will be activated when the agent is in a house (i.e. its target is null) and that will define with a probability of 0.05 if the agent has to go or not. If the agent has to go, it will randomly choose a new target (a random location inside one of the building).\nreflex stay when: target = nil {    if flip(0.05) {\ttarget <- any_location_in (one_of(building));    }}\nThen, we modify the move reflex. This one will be only activated when the agent will have to move (target not null). Instead of using the wander action of the moving skill, we use the goto one that allows to make an agent moves toward a given target. In addition, it is possible to add a facet on to precise on which topology the agent will have to move on. In our case, the topology is the road network.\nWhen the agent reaches its destination (location = target), it sets its target to null.\nreflex move when: target != nil{    do goto target: target on: road_network;    if (location = target) {\ttarget <- nil;    } }\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Luneray%20flu/models/model4.gaml"},{"filePath":"https:--gama-platform.org--wiki-LuneraysFlu_step5.txt","text":"5. Definition of 3D displaysThis fifth step illustrates how to define 3D displays.\n\nFormulation​\n\nDefine a new 3D aspect for roads.\nDefine a new 3D aspect for buildings\nDefine a new 3D aspect for people\nDefine a new 3D display\n\nModel Definition​\nspecies​\nWe define a new aspect for the road species called geom3D that draw the road agent that as a black tube of 2m radius built from its geometry. Note that it is possible to get the list of points composing a geometry by using the points variable of the geometry.\n\nspecies road {    //....    aspect geom3D {\tdraw line(shape.points, 2.0) color: #black;    }}\nConcerning the building species, we define an aspect called geom3D that draws the shape of the building with a depth of 20 meters and with using a texture \"texture.jpg\" for the face and a texture for the roof \"roof_top.jpg\".\n\nspecies building {    //....    aspect geom3D {\tdraw shape depth: 20 #m border: #black texture: [\"../includes/roof_top.jpg\",\"../includes/texture.jpg\"];    }}\nAt last, we define a new aspect called geom3D for the people species that displays the agent only if it is on a road (target != nil). In this aspect, we use an obj file that contains a 3D object. The use of the obj_file operator allows to apply an initial rotation to an obj file. In our case, we add a rotation of -90° along the x-axis. We specify with the size facet that we want to draw the 3D object inside a bounding box of 5m. As the location of the 3D object is its centroid and as we want to draw the 3D object on the top of the ground, we use the at facet to put an offset along the z-axis. We use also the rotate facet to change the orientation of the 3D object according to the heading of the agent. At last, we choose to draw the 3D object in green if the agent is not infected; in red otherwise.\n\nspecies people skills:[moving]{\t\t    //....    aspect geom3D {\tif target != nil {\t    draw obj_file(\"../includes/people.obj\", 90::{-1,0,0}) size: 5\t\tat: location + {0,0,7} rotate: heading - 90 color: is_infected ? #red : #green;\t}    }}\noutput​\nWe define a new display called view3D of type opengl with the facet antialias set to false. Inside this display, we first set a light of type ambient and with an intensity of 80. We then draw a background image representing the satellite image of the Luneray. Note that GAMA is able to manage world files to georeferenced images. In our case, as a PGW file exists in the includes folder, the satellite image will be well localized in the display. After drawing the background image, we display first the building species with their geom3D aspect, then the road species with their geom3D aspect and finally the people species with their geom3D aspect. Only the people agents will be redrawn at each simulation step.\nexperiment main_experiment type: gui {    output {    // monitor and other displays\t\tdisplay view3D type: opengl antialias: false {\t\tlight #ambient intensity: 80;\t\timage \"../includes/luneray.jpg\" refresh: false; \t\tspecies building aspect: geom3D refresh: false;\t\tspecies road aspect: geom3D refresh: false;\t\tspecies people aspect: geom3D; \t}    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Luneray%20flu/models/model5.gaml"},{"filePath":"https:--gama-platform.org--wiki-LuneraysFlu_step6.txt","text":"6. Exploration of the modelThis final step illustrates how to explore the model through the introduction of batch experiments.\nFormulation​\n\nAdd an experiment to launch 10 simulations to analyze the sensitivity toward stochasticity.\nAdd an experiment to explore the impact of the proba_leave parameter.\nAdd an experiment to calibrate the model.\n\nThese 3 additions will add each a new experiment of type batch, more details about batch experiment on this page.\nModel Definition​\nSensitivity analysis toward stochasticity​\nThe aim is to run many simulations with the default values for parameters to analyze the impact of stochasticity over the simulation results. We choose as indicator to compare the simulations the infected_rate value after 2hours of simulations. We will launch 10 simulations and display the mean and standard deviation values of this variable over the 10 simulations.\nTo this purpose we need to define a new experiment with the following facet values:\n\ntype: the type of the experiment, here we choose the batch mode to be able to launch many simulations in one launch.\nuntil: the stop condition in the batch experiment, here time > 2#h.\nrepeat: the number of simulations to run with the same parameter values (number of replications), here 10.\n\nexperiment test_robustness type: batch until: time > 2#h repeat: 10 {    reflex information {\tlist<float> vals <- simulations collect each.infected_rate;\twrite \"mean: \" + mean(vals) + \" standard deviation: \" + standard_deviation(vals);\t    }}\nExperiments are also a kind of species. They can thus have variables and behaviors. Here we use the simulations variable that is the list of the 10 simulations (for the 10 replications). In addition, in batch mode, a reflex is executed at the end of all the replication simulations. We can thus create the list of all the infected_rate values (with the collect operator) and compute the mean and standard_deviation.\nExploration​\nThe aim here is to explore the impact of one parameter over the simulations' results. We keep the same indicator. We add the parameter to explore the experiment and specify the possibility it can take with either the among facet or the combination of min, max, and step facets.\nexperiment explore_model type: batch until: time > 2#h repeat: 2 {    parameter \"proba_leave\" var: proba_leave among: [0, 0.01, 0.05, 0.1, 1.0];\t    reflex save_results {\task simulations {\t    write \"proba_leave: \" + proba_leave + \" infected_rate: \" + self.infected_rate;\t    save [proba_leave, self.infected_rate] type: csv to:\"results.csv\" rewrite: (int(self) = 0) ? true : false header: true ;\t}    }}\nIn order to do a deeper investigation, in particular with an external tool, it could be useful to save the values in a file. For this purpose, we use the save statement. In our example, we save a list of values in the csv file (type: csv) specified in the to facet.\nCalibration​\nThe calibration process corresponds to the search of parameter values that maximize/minimize indicators. To this purpose, we need to define:\n\nthe parameters to explore, with their possible values,\nthe indicator to minimize/maximize,\nthe exploration method.\n\nHere we choose to minimize the value abs(infected_rate - 0.5) (i.e. we want to find parameters' value that makes the simulation having an infected_rate as close as possible to 0.5) after 2hours of simulation. The chosen optimization method is a genetic algorithm (more details on this page).\nexperiment calibration_model type: batch until: time > 2#h repeat: 3 {    parameter \"infection distance\" var: infection_distance min: 1.0 max: 20.0 step: 1;    parameter \"proba infection\" var: proba_infection min: 0.01 max: 1.0 step: 0.01;\t    method genetic pop_dim: 3 max_gen: 5 minimize: abs(infected_rate - 0.5);}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Luneray%20flu/models/model6.gaml"},{"filePath":"https:--gama-platform.org--wiki-ManipulateBasicSpecies.txt","text":"Manipulate basic speciesIn this chapter, we will learn how to manipulate some basic species. As you already know, a species can be seen as the definition of a type of agent (we call agent the instance of a species). In OOP (Object-Oriented Programming), a species can be seen as the class. Each species is then defined by some attributes (\"member\" in OOP), actions (\"method\" in OOP) and behavior (\"method\" in OOP).\nIn this section, we will first learn how to declare the world agent, using the global species. We will then learn how to declare regular species which will populate our world. The following lesson will be dedicated to learn how to define actions and behaviors for all those species. We will then learn how agents can interact between each other, especially with the statement ask. In the next chapter then, we will see how to attach skills to our species, giving them new attributes and actions. This section will be closed with a last lesson dealing with how inheritance works in GAML."},{"filePath":"https:--gama-platform.org--wiki-ManipulateDates.txt","text":"Manipulate DatesManaging Time in Models​\nIf some models are based on an abstract time - only the number of cycles is important - others are based on a real time. To this purpose, GAMA provides some tools to manage time.\nFirst, GAMA allows the modeler to define the duration of a simulation step. It provides access to different time variables. At last, since GAMA 1.7, it provides a date variable type and some global variables allowing to use a real calendar to manage time.\nDefinition of the step and use of temporal unity values​\nGAMA provides three important global variables to manage time:\n\ncycle (int - not modifiable): the current simulation step - this variable is incremented by 1 at each simulation step\nstep (float - can be modified): the duration of a simulation step (in seconds). By default, the duration is one second.\ntime (float - not modifiable): the current time spent since the beginning of the simulation - this variable is computed at each simulation step by: time = cycle * step.\n\nThe value of the cycle and time variables are shown in the top left (green rectangle) of the simulation interface. Clicking on the green rectangle allows to display either the number cycles or the time variable. Concerning this variable, it is presented following a years - months - days - hours - minutes - seconds format. In this presentation, every month is considered as being composed of 30 days (the different number of days of months are not taken into account).\nConcerning step global variable, the variable can be modified by the modeler. A classic way of doing it consists of reediting the variable in the global section:\nglobal {    float step <- 1 #hour;}\nIn this example, each simulation step will represent 1 hour. This time will be taken into account for all actions based on time (e.g. moving actions).\nNote that the value of the step variable should be given in seconds. To facilitate the definition of the step value and of all expressions based on time, GAMA provides different built-in constant variables accessible with the \"#\" symbol:\n\n#s : second - 1 second\n#mn : minute - 60 seconds\n#hour : hour - 60 minutes - 3600 seconds\n#day : day - 24 hours - 86400 seconds\n#week: week - 7 days - 604800 seconds\n#month : month - 30 days - 2592000 seconds\n#year : year - 12 month - 3.1104E7 seconds\n\nThe date variable type and the use of a real calendar​\nSince GAMA 1.7, it is possible to use a real calendar to manage the time. For that, the modeler has only to define the starting date of the simulation. This variable is of type date which allows him/her to represent a date and time.\nA date variable has several attributes:\n\nyear (int): the year component of the date\nmonth (int): the month component of the date\nday (int): the day component of the date\nhour (int): the hour component of the date\nminute (int): the minute component of the date\nsecond (int): the second component of the date\nday_of_week (int): the day of the week\nweek_of_year (int): the week of the year\n\nSeveral ways can be used to define a date. The simplest one consists in using a list of int values: [year,month of the year,day of the month, hour of the day, minute of the hour, second of the minute]\ndate my_date <- date([2010,3,23,17,30,10]); // the 23th of March 2010, at 17:30:10\nAnother way consists in using a string with the good format. The following one is perhaps the most complete, with year, month, day, hour, minute, second and also the time zone.\ndate my_date <- date(\"2010-3-23T17:30:10+07:00\"); \nBut the following ones can also be used:\n// without time zone:my_date3 <- date(\"2010-03-23 17:30:10\"); //Dates (without time)my_date3 <- date(\"20100323\");my_date3 <- date(\"2010-03-23\");// Dates using some patterns:my_date3 <- date(\"03 23 2010\",\"MM dd yyyy\");my_date3 <- date(\"01 23 20\",\"HH mm ss\");\nNote that the current (real) date can be accessed through the #now built-in variable (variable of type date).\nIn addition, GAMA provides different useful operators working on dates. For instance, it is possible to compute the duration in seconds between 2 dates using the \"-\" operator. The result is given in seconds:\nfloat d <- starting_date - my_date;\nIt is also possible to add or subtract a duration (in seconds) to a date:\nwrite \"my_date + 10: \" + (my_date + 10);write \"my_date - 10: \" + (my_date - 10);\nAt last, it is possible to add or subtract a duration (in years, months, weeks, days, hours, minutes,  seconds) to a date:\nwrite \"my_date add_years 1: \" + (my_date add_years 1);write \"my_date add_months 1: \" + (my_date add_months 1);write \"my_date add_weeks 1: \" + (my_date add_weeks 1);write \"my_date add_days 1: \" + (my_date add_days 1);write \"my_date add_hours 1: \" + (my_date add_hours 1);write \"my_date add_minutes 1: \" + (my_date add_minutes 1);write \"my_date add_seconds 1: \" + (my_date add_seconds 1);\t\t  write \"my_date subtract_years 1: \" + (my_date subtract_years 1);write \"my_date subtract_months 1: \" + (my_date subtract_months 1);write \"my_date subtract_weeks 1: \" + (my_date subtract_weeks 1);write \"my_date subtract_days 1: \" + (my_date subtract_days 1);write \"my_date subtract_hours 1: \" + (my_date subtract_hours 1);write \"my_date subtract_minutes 1: \" + (my_date subtract_minutes 1);write \"my_date subtract_seconds 1: \" + (my_date subtract_seconds 1);\nDate variables in the model​\nFor the modelers, two global date variables are available:\n\nstarting_date: date considered as the beginning of the simulation (by default the starting date is 1970-01-01 07:00:00.\ncurrent_date: current date of the simulation.\n\nDefining a value of the starting_date allows to change the normal time management of the simulation by a more realistic one (using a calendar):\nglobal {    date starting_date <- date([1979,12,17,19,45,10]);}\nWhen a value is set to this variable, the current_date variable is automatically initialized with the same value. However, at each simulation step, the current_date variable is incremented by the step variable. The value of the current_date will replace the value of the time variable in the top left green panel.\nNote that you have to be careful when a real calendar is used, the built-in constants #month and #year should not be used as there are not consistent with the calendar (where month can be composed of 28, 29, 30 or 31 days)."},{"filePath":"https:--gama-platform.org--wiki-ManipulateLight.txt","text":"Implementing lightWhen using OpenGL display, GAMA provides you the possibility to manipulate one or several lights, making your display more realistic.\nMost of the following screenshots will be taken with the following short example gaml:\nmodel test_lightgrid cells {    aspect base {\tdraw square(1) at:{grid_x,grid_y} color:#white;    }}experiment my_experiment type:gui{    output {\tdisplay my_display type: opengl background: #darkblue {\t    species cells aspect: base;\t    graphics \"my_layer\" {\t\tdraw square(100) color:#white at:{50,50};\t\tdraw cube(5) color:#lightgrey at:{50,30};\t\tdraw cube(5) color:#lightgrey at:{30,35};\t\tdraw cube(5) color:#lightgrey at:{60,35};\t\tdraw sphere(5) color:#lightgrey at:{10,10,2.5};\t\tdraw sphere(5) color:#lightgrey at:{20,30,2.5};\t\tdraw sphere(5) color:#lightgrey at:{40,30,2.5};\t\tdraw sphere(5) color:#lightgrey at:{40,60,2.5};\t\tdraw cone3D(5,5) color:#lightgrey at:{55,10,0};\t\tdraw cylinder(5,5) color:#lightgrey at:{10,60,0};\t    }\t}    }}\nIndex​\n\nLight generalities\nDefault light\nCustom lights\n\nLight generalities​\nBefore going deep into the code, here is a quick explanation about how light works in OpenGL.\nFirst of all, you need to know that there are 3 types of lights you can manipulate: the ambient light, the diffuse light and the specular light. Each \"light\" in OpenGL is in fact composed of those 3 types of lights.\nAmbient light​\nThe ambient light is the light of your world without any lighting. If a face of a cube is not stricken by the light rays, for instance, this face will appear totally black if there is no ambient light. To make your world more realistic, it is better to have ambient light.\nAmbient light has then no position or direction. It is equally distributed to all the objects of your scene.\nHere is an example of our GAML scene using only ambient light (color red) (see below how to define ambient light in GAML):\n\nDiffuse light​\nThe diffuse light can be seen as the light rays: if a face of a cube is stricken by the diffuse light, it will take the color of this diffuse light. You have to know that the more perpendicular the face of your object will be to the light ray, the more lightened the face will be.\nA diffuse light has then a direction. It can have also a position.\nYou have 2 categories of diffuse light: the positional lights, and the directional lights.\nPositional lights​\nThose lights have a position in your world. It is the case of point lights and spot lights.\n\nPoint lights\n\nPoints lights can be seen as a candle in your world, diffusing the light equally in all the direction.\nHere is an example of our GAML scene using only diffuse light, with a point light (color red, the light source is displayed as a red sphere) :\n\n\nSpot lights\n\nSpot lights can be seen as a torch light in your world. It needs a position, and also a direction and an angle.\nHere is an example of our GAML scene using only diffusion light, with a spot light (color red, the light source is displayed as a red cone) :\n\nPositional lights, as they have a position, can also have an attenuation according to the distance between the light source and the object. The value of positional lights are computed with the following formula:\ndiffuse_light = diffuse_light * ( 1 / (1 + constante_attenuation + linear_attenuation * d + quadratic_attenuation * d))\nBy changing those 3 values (constante_attenuation, linear_attenuation and quadratic_attenuation), you can control the way light is diffused over your world (if your world is \"foggy\" for instance, you may turn your linear and quadratic attenuation on). Note that by default, all those attenuations are equal to 0.\nHere is an example of our GAML scene using only diffusion light, with a point light with linear attenuation (color red, the light source is displayed as a red sphere):\n\nDirectional lights​\nDirectional lights have no real \"position\": they only have a direction. A directional light will strike all the objects of your world in the same direction. An example of directional light you have in the real world would be the light of the sun: the sun is so far away from us that you can consider that the rays have the same direction and the same intensity wherever they strike.\nSince there is no position for directional lights, there is no attenuation either.\nHere is an example of our GAML scene using only diffusion light, with a directional light (color red) :\n\nSpecular light​\nThis is a more advanced concept, giving an aspect a little bit \"shinny\" to the objects stricken by the specular light. It is used to simulate the interaction between the light and a special material (ex: wood, steel, rubber...).\nThis specular light is not implemented yet in GAMA, only the two others are.\nDefault light​\nIn your OpenGL display, without specifying any light, you will have only one light, with those following properties :\nThose values have been chosen in order to have the same visual effect in both OpenGL and java2D displays, when you display 2D objects, and also to have a nice \"3D effect\" when using the OpenGL displays. We chose the following setting by default:\n\nThe ambient light value: rgb(127,127,127,255)\ndiffuse light value: rgb(127,127,127,255)\ntype of light: direction\ndirection of the light: (0.5,0.5,-1);\n\nHere is an example of our GAML scene using the default light:\n\nCustom lights​\nIn your OpenGL display, you can create several lights, giving them the properties you want.\nIn order to add lights, or modifying the existing lights, you have to use the statement light inside your display scope:\nexperiment my_experiment type:gui {    output {\tdisplay \"my_display\" type:opengl {\t    light \"my_light\";\t}    }}\nA name has to be declared for the light. Through this facet, you can specify which light you want.\nOnce you are manipulating a light through the light statement, the light is turned on. To switch off the light, you have to add the facet active, and turn it to false.\nThe light you are declaring through the light statement is, in fact, a \"diffuse\" light. You can specify the color of the diffuse light through the facet intensity (by default, the color will be turned to white).\nAnother very important facet is the type facet. This facet accepts a value among #direction, #point and #spot.\nAmbient light​\nThe ambient light can be set when declaring a light, using the #ambient constant, through the facet intensity:\nexperiment my_experiment type: gui {    output {\tdisplay \"my_display\" type: opengl  {\t    light #ambient intensity: 100;\t}    }}\nNote for developers: Note that this ambient light is set to the GL_LIGHT0. This GL_LIGHT0 only contains an ambient light, and no either diffuse nor specular light.\nDeclaring direction light​\nA direction light, as explained in the first part, is a light without any position. Instead of the facet position, you will use the facet direction, giving a 3D vector.\nExample of implementation:\nlight \"my_direction_light\" type: #direction direction: {1,1,1} intensity: #red;\nDeclaring point light​\nA point light will need a facet position, in order to give the position of the light source.\nExample of implementation of a basic point light:\nlight \"my_point_light\" type: #point location: {10,20,10} intensity: #red;\nYou can add, if you want, a custom attenuation of the light, through the facets linear_attenuation or quadratic_attenuation.\nExample of implementation of a point light with attenuation :\nlight \"my_point_light\"  type: #point location: {10,20,10} intensity: #red linear_attenuation: 0.1;\nDeclaring spot light​\nA spot light will need the facet position (a spot light is a positional light) and the facet direction. A spot light will also need a special facet spot_angle to determine the angle of the spot (by default, this value is set to 45 degree).\nExample of implementation of a basic spot light:\nlight \"my_spot_light\" type: #spot location: {0,0,100}direction:{0.5,0.5,-1} intensity: #red angle: 20;\nSame as for point light, you can specify an attenuation for a spot light.\nExample of implementation of a spot light with attenuation:\nlight \"my_spot_light\" type:#spot location:{0,0,100} direction:{0.5,0.5,-1} intensity:#red angle:30 linear_attenuation: 0.1;\nNote that when you are working with lights, you can display your lights through the facet show (of light) to help you to implement your model. The three types of lights are displayed differently:\n\nThe point light is represented by a sphere with the color of the diffuse light you specified, in the position of your light source.\nThe spot light is represented by a cone with the color of the diffuse light you specified, in the position of your light source, the orientation of your light source. The size of the base of the cone will depend on the angle you specified.\nThe direction light, as it has no real position, is represented with arrows a bit above the world, with the direction of your direction light, and the color of the diffuse light you specified.\n\n\nNote for developers: Note that, since the GL_LIGHT0 is already reserved for the ambient light (only !), all the other lights (from 1 to 7) are the lights from GL_LIGHT1 to GL_LIGHT7."},{"filePath":"https:--gama-platform.org--wiki-ManipulateOSMDatas.txt","text":"Manipulate OSM DatasThis section will be presented as a quick tutorial, showing how to proceed to manipulate OSM (Open street map) data, clean them and load them into GAMA. We will use the software QGIS to change the attributes of the OSM file.\nNote that GAMA can read and import OpenStreetMap data natively and create agents from them. An example model is provided in the Model Library (Data Importation / OSM File Import.gaml). In this case, you will have to write a model to import, select data from OpenStreetMap before creating agents and then could export them into shapefiles, much easier to use in GAMA.\nFrom the website openstreetmap.org, we will choose a place (in this example, we will take a neighborhood in New York City). Directly from the website, you can export the chosen area in the osm format.\n\nWe have now to manipulate the attributes for the exported osm file.\nSeveral softwares can be used, but we will focus on QGIS, which is totally free and provides a lot of possibilities in term of manipulation of data.\nOnce you have installed correctly QGIS, launch QGIS Desktop, and start to import the topology from the osm file.\nQGis 3, the version we are using to build this tutorial, needs us to install a plugin to process files downloaded from OSM website. There are several versions of plugins allowing to do that. However, the most stable and simple one to use is QuickOSM. Go to your extension manager, select \"All extensions\" on the top left corner, look for \"QuickOSM\" extension and install it.\n\nYou should now be able to use the extension QuickOSM. Open its menu by entering the vector menu on the top QGis panel, go to QuickOSM, then select :\n\nOSM file\nBrowse your xml file.\nBrowse to select the folder that will welcome the processed file through QGis (select the \"includes\" folder of your current GAMA project for more efficiency).\nSelect the format you want for your processed file (in the example, ESRI shapefile will give a .shp, very well processed by GAMA afterwards).\nOpen your file.\n\n\nYou will go back naturally to the main QGis UI and you downloaded OSM layer will be visible.\nBefore beginning the layer treatment process with QGis, please note that it is easier to use separated shapefiles for each entities if the objective is to use GAMA afterwards. Therefore, we recommend importing in GAMA separated shapefiles for each spatial entity you want to make appear in your model. Indeed, it is simpler to create one species for each spatial entity instead of having one species declined by different arributes. If you want to represent buildings and houses, it's recommended to have two separated files : one for buildings and one for houses.\nFirst, we want buildings to be isolated from the other polygons. We can use the field 'building' to make an attribute selection to do that. By opening the attribute table of the file, we can check that this field exists and that every building has been attributed a \"yes\". If other information are given, replace the information by \"yes\" to facilitate the process of selection. Once it's done, go to the attribute selection menu on the top panel and type this in the dialogue box : \"building\" = 'yes'. Click on \"select features\" once it's done and close the window.\n\n\n\nIf typed correctly, QGis should understand that you want to select only polygons that are recognized as buildings. The buildings polygons should be highlighted in yellow now. Save the selected features as a new .shp file in your \"includes\" folder. We called ours \"OSM_For_GAMA_Buildings\". The new layer which just appeared should only comprise buildings of the area.\n\nThen, we can create a new field for the new buildings layer to allow a better handling in GAMA platform do differentiate colors : first, enter you attribute table of the layer.\nThen, go to edit mode (the pen icon on the top left corner) and select field calculator.\n\nStay on the left hand side, we will now set up the field's characteristics, you can copy what you see in the screenshot bellow. Pay attention to selecting \"string\" to the field type, otherwise you won't be able to get the proper format of attributes in the following steps of this tutorial.\n\nWe want to create this attribute and associate to it variables that will be colors. We want to ask QGis to do that randomly on its own. Therefore, we have to provide the software a function. Go to the \"function editor\" tab, click on the \"+\" to add a new function file and write these lines down after having deleted the default help :\nfrom qgis.core import *from qgis.gui import *import random, string@qgsfunction(args='auto', group='Custom')def myFun(value1, feature, parent):    return random.choice([\"blue\",\"red\"])\nSave and run the function using the proper button on the bottom right corner.\n\nThen go to the expression type and call your function by typing :\nmyFun('attrForGam')\nClick on \"Ok\" which will get you back to your attribute table : you can now check the layer's attributes to see if the new field 'attrForGam' has been filled with random values \"red\" or \"blue\".\n\nWhen you download data from OSM website, some fields might be missing. For instance, the file we downloaded here doesn't include the buildings' height. To give realistic aspects to our model, we want here to call another function to make QGis create a \"Height\" field and associate automatically a height to buildings between 20 and 50 meters high. You can repeat the previous steps for the 'attrForGam' field to create a 'Height' field using the following code :\nfrom qgis.core import *from qgis.gui import *import random, string@qgsfunction(args='auto', group='Custom')def myFunHeight(value1, feature, parent):    return random.randrange(20, 50, 1)\nDon't forget to call this new function in the expression tab : myFunHeight('Height'). Then, check if the new field has been added and save the modifications of your attributes.\n\nOur work on the buildings layer is done. You don't have to save it since QGis is automatically saving the modifications you do on your files (the one we previously called \"OSM_For_GAMA_Buildings\").\nThe file for buildings is now ready to be used in GAMA for modelling. We now have to take care our other polygons and lines we downloaded.\nWe now want to add the main natural elements to our model : parks. For this, we only have to select the few parks we have in the area thanks to the spatial selection tool provided by QGis.\nTo do that, you have to use the original polygons layer you downloaded to make a spatial selection of the parks.\nTo select several polygons using this tool, just press shift + left click on each polygons you are interested with. Before beginning the selection, locate where the parks are so that you are sure the polygons you select are the parks you want to represent.\n\nSelect the polygon layer.\nSelect the tool \"select features by area or single click\" on the top panel.\nSelect the right polygons using left click and pressing maj to select several polygons.\n\n\nThen, save the selected polygons as a new shapefile which will only comprise parks areas. For this tutorial, we called the parks shapefile \"OSM_For_GAMA_Parks\".\nFinally, we need roads for our possible agents to travel the city. The shapefile already exists from the OSM file we downloaded. It is possible to modify it using the edition mode after selecting the lines layer, and delete the roads we don't want.\n\nDon't forget to save your layer as a .shp file in your \"includes\" folder of your current GAMA project. For this tutorial, we call the roads shapefile \"OSM_For_GAMA_Parks\"\nPlease note that you can repeat these steps as many times as you want according to the level of details you need in your model. As OSM provides a large possibility of land use types, we cannot go over every one of them in this tutorial. The steps are the same as the ones described above.\nYou can now import your three .shp files that should be in your \"includes\" folder of your current project.\nmodel OSMtutorialglobal {    // Global variables related to the Management units  \tfile shapeFile1 <- file(\"../includes/OSM_For_GAMA_Buildings.shp\");    file shapeFile2 <- file(\"../includes/OSM_For_GAMA_Parks.shp\");\tfile shapeFile3 <- file(\"../includes/OSM_For_GAMA_Roads.shp\");    //definition of the environment size from the shapefile.     //Note that is possible to define it from several files by using: geometry shape <- envelope(envelope(file1) + envelope(file2) + ...);    geometry shape <- envelope(envelope(shapeFile1) + envelope(shapeFile2) + envelope(shapeFile3));        init {    //Creation of Buildings agents from the shapefile (and reading some of the shapefile attributes)    create Buildings from: shapeFile1        with: [elementId::int(read('full_id')), elementHeight::int(read('Height')), elementColor::string(read('attrForGam'))] ;            create Parks from: shapeFile2;    \t    create Roads from: shapeFile3 where (each != nil);    }}    species Buildings{    int elementId;    int elementHeight;    string elementColor;        aspect basic{    draw shape color: (elementColor = \"blue\") ? #blue : ( (elementColor = \"red\") ? #red : #yellow) depth: elementHeight;    }} species Parks {\t\taspect basic {\t\tdraw shape color: #green;\t}} species Roads {\t\taspect basic {\t\tdraw shape color: #grey width: 3#meter;\t}}experiment main type: gui {         output {    display HowToUseOpenStreetMap type:opengl {       species Buildings aspect: basic;        species Parks aspect: basic;       species Roads aspect: basic;    }    }\nHere is the result, with a special colorization of the different elements regarding the value of the attribute \"attrForGama\", an elevation regarding the value of the attribute \"height\", and basic species creation for roads and parks.\n"},{"filePath":"https:--gama-platform.org--wiki-MenusAndCommands.txt","text":"Controls of experimentsThe simulation perspective adds on the user interface a number of new menus and commands (i.e. buttons) that are specific to experiment-related tasks.\nTable of contents​\n\nControls of experiments\n\nExperiment Menu\nAgents Menu\nGeneral Toolbar\n\n\n\nExperiment Menu​\nA menu, called \"Experiment\", allows controlling the current experiment. It shares some of its commands with the general toolbar (see below).\n\n\nRun/Pause Experiment: allows to run or pause the experiment depending on its current state.\nStep Experiment: runs the experiment for one cycle and pauses it after.\nReload Experiment: stops the current experiment, deletes its contents and reloads it, taking into account the parameters values that might have been changed by the user.\nStop at first error: if checked, the current experiment will stop running when an error is issued. The default value can be configured in the preferences.\nTreat warnings like errors: if checked, a warning will be considered as an error (and if the previous item is checked, will stop the experiment). The default value can be configured in the preferences.\nDisplay errors and warning: if checked, displays the errors and warnings issued by the experiment. If not, do not display them. The default value can be configured in the preferences.\nClose Experiment: forces the experiment to stop, whatever it is currently doing, purges the memory from it, and switches to the modeling perspective. Use this command with caution, as it can have undesirable effects depending on the state of the experiment (for example, if it is reading files, or outputting data, etc.).\n\nAgents Menu​\nA second menu is added in the simulation perspective: \"Agents\". This menu allows for easy access to the different agents that populate an experiment.\n\nThis hierarchical menu is always organized in the same way, whatever the experiment being run. A first level is dedicated to the current top-level experiment agent: it allows the modeler to inspect the agent itself and to browse its population(s) (i.e. the simulation agents). A second level lists the \"micro-populations\" present in each simulation agent and allows to inspect the agent itself. And the third level will give access to an overview of all the agents of the population in a table (\"Browse ant population...\") and to each individual agent in these populations. This organization is, of course, recursive: if these agents are themselves, hosts of micro-populations, they will be displayed in their individual menu.\nEach agent, when selected, will reveal a similar individual menu. This menu will contain a set of predefined actions, the commands defined by the user for this species if any, and then the micro-populations hosted by this agent, if any. Agents (like the instances of \"ant\" below) that do not host other agents and whose species has no user commands will have a \"simple\" individual menu.\n\nThese are the 4 actions that will be there most of the time:\n\nInspect: open an inspector on this agent.\nFocus on all displays: this option is not accessible if no displays are defined. Makes all the displays zoom on the selected agent (if it is displayed) so that it occupies the whole view.\nHighlight: makes this agent the current \"highlighted\" agent, forcing it to appear \"highlighted\" in all the displays that might have been defined.\nKill: destroys the selected agent and disposes of it. Use this command with caution, as it can have undesirable effects if the agent is currently executing its behavior.\n\nIf an agent hosts other agents (it is the case in multi-level architecture), you can access to the micro-population quite easily (e.g. in the model Library models/Modeling/Multi-Level Usage/Corridor.gaml):\n\nIf user commands are defined for a species (for example in the existing model Library models/Visualization and User Interaction/User Interaction/User Command.gaml), their individuals' menu will look like the following. Notice that in this model two species have user command:\n\nthe simulation agent (2 user commands are defined in the global section of the model),\nthe ants agents (2 user commands defined in the species definition section).\n\n\nGeneral Toolbar​\nThe last piece of user interface specific to the Simulation Perspective is a toolbar, which contains controls and information displays related to the current experiment.\nThis toolbar is voluntarily minimalist, with four buttons already present in the experiment menu (namely, \"Play/Pause Experiment\", \"Step Experiment\", \"Reload Experiment\" and \"Close Experiment\"), which do not need to be detailed here, and two new controls (\"Experiment status\" and \"Cycle Delay\"), which are explained below.\n\nWhile opening an experiment, the status will display some information about what's going on. For instance, GAMA is busy instantiating the agents or opening the displays.\n\n\nThe orange color usually means that, although the experiment is not ready, things are progressing without problems (a red color message is an indication that something went wrong). When the loading of the experiment is finished, GAMA displays the message \"Simulation ready\" on a green background. If the user runs the simulation, the status changes and displays the number of cycles already elapsed in the simulation currently managed by the experiment.\n\nHovering over the status produces more accurate information about the internal clock of the simulation.\n\nWhen we launch an experiment, an experiment agent is created with its own internal clock. It will then create 1 (or more) simulation agent(s). The toolbar provides thus information about both the experiment agent and the simulation(s), from top to bottom:\n\nthe number of cycles elapsed,\nthe simulated time already elapsed (in the example above, one cycle lasts one second of simulated time) for the simulation agents only,\nthe duration of cycle in milliseconds,\nthe average duration of one cycle (computed over the number of cycles elapsed),\nthe total duration, so far, of the simulation (still in milliseconds).\n\nIn the case of a multi-simulation (i.e. an experiment launching several simulations), one block per simulation is displayed.\n\nAlthough these durations are entirely dependent on the speed of the simulation engine (and, of course, the number of agents, their behaviors, etc.), there is a way to control it partially with the second control, which allows the user to force a minimal duration (in milliseconds) for a cycle, from 0s (its initial position) to 1s. Note that this minimal duration (or delay) will remain the same for the subsequent reloads of the experiment.\n\nIn case it is necessary to have more than 1s of delay, it has to be defined, instead, as an attribute of the experiment."},{"filePath":"https:--gama-platform.org--wiki-MirrorSpecies.txt","text":"Mirror speciesA mirror species is a species whose population is automatically managed with respect to another species. Whenever an agent is created or destroyed from the other species, an instance of the mirror species is created or destroyed. Each of these 'mirror agents' has access to its reference agent (called its target).\nMirror species can be used in different situations but the one we describe here is more oriented towards visualization purposes.\nIndex​\n\nDeclaration\nExample\n\nDeclaration​\nA mirror species can be defined using the mirrors facet as following:\nspecies B mirrors: A { }\nIn this case, the species B mirrors the species A.\nBy default, the location of the species B will be random but in many cases, one wants to place the mirror agent at the same location as the reference species. This can be achieved by simply adding the following lines in the mirror species:\nspecies B mirrors: A{    point location <- target.location update: target.location;}\ntarget is a built-in attribute of a mirror species. It refers to the instance of the species tracked.\nIn the same spirit, any attribute of a reference species can be reached using the same syntax. For instance, if the species A has an attribute called attribute1 of type int it is possible to get this attribute from the mirror species B using the following syntax:\nint value <- target.attribute1;\nExample​\nTo practice a bit with the mirror notion, we will now build a simple model displaying a species A (aspect: white circle) moving randomly, and another species B (aspect: blue sphere) with the species A location on x and y, with an upper value for the z-axis.\n\nHere is an example of an implementation for this model:\nmodel Mirrorglobal {  init{    create A number:100;      }}species A skills:[moving]{    reflex update{        do wander;    }    aspect base{        draw circle(1) color: #white border: #black;    }}species B mirrors: A{    point location <- target.location update: {target.location.x,target.location.y,target.location.z+5};        aspect base {        draw sphere(2) color: #blue;    }}experiment mirroExp type: gui {    output {        display superposedView type: opengl{           species A aspect: base;          species B aspect: base transparency:0.5;        }    }}"},{"filePath":"https:--gama-platform.org--wiki-ModelOrganization.txt","text":"Organization of a modelAs already extensively detailed in the introduction page, defining a model in GAML amounts to defining a model species, which later allows to instantiate a model agent (aka a simulation), which may or may not contain micro-species, and which can be flanked by experiment plans in order to be simulated.\nThis conceptual structure is respected in the definition of model files, which follows a similar pattern:\n\nDefinition of the global species, preceded by a header, in order to represent the model species\nDefinition of the different micro-species (either nested inside the global species or at the same level)\nDefinition of the different experiment plans that target this model\n\nTable of contents​\n\nModel Header (model species)\nImport gaml file\nSpecies declarations\nExperiment declarations\nBasic skeleton of a model\n\nModel Header (model species)​\nThe header of a model file begins with the declaration of the name of the model. Contrarily to other statements, this declaration does not end with a semi-colon.\nmodel name_of_the_model\nThe name of the model is not necessarily the same as the name of the file. It must conform to the general rule for naming species, i.e. be a valid identifier (beginning with a letter, containing only letters, digits, and dashes). This name will be used for building the name of the model species, from which simulations will be instantiated. For instance, the following declaration:\nmodel dummy\nwill internally create a species called dummy_model, child of the abstract species model, from which simulations (called dummy_model0, dummy_model1, etc.) will be instantiated.\nImport gaml file​\nThis declaration is followed by optional import statements that indicate which other models this model is importing. Import statements do not end with a semi-colon.\nImporting a model can take two forms. The first one, called inheritance import, is declared as follows:\nimport \"relative_path_to_a_model_file\"import \"relative_path_to_another_model_file\"\nThe second one, called usage import, is declared as follows:\nimport \"relative_path_to_a_model_file\" as model_identifier\nWhen importing models using the first form, all the declarations of the model(s) imported will be merged with those of the current model (in the order with which the import statements are declared, i.e. the latest definitions of global attributes or behaviors superseding the previous ones).\nThe second form is reserved for using models as micro-models of the current model. This possibility is still experimental in the current version of GAMA.\nThe last part of the header is the definition of the global species, which is the actual definition of the model species itself.\nglobal {    // Definition of [global attributes](GlobalSpecies#declaration), [actions and behaviors](DefiningActionsAndBehaviors)}\nNote that neither the imports nor the definition of global is mandatory. Only the model statement is.\ninfoWhile importing a model, every file is concatenated. Therefore, every variable will be processed from the gaml file where the experiment is located.This might lead to some issues explained in #137 where relative path set in an imported file will be based on the model you're starting and not the file you defined it.\nSpecies declarations​\nThe header is followed by the declaration of the different species of agents that populate the model.\nThe special species global is the world species. You will declare here all the global attributes/actions/behaviors. The global species does not have a name, and is unique in your model.\nglobal {    // definition of global attributes, actions, behaviors}\nRegular species can be declared with the keyword species. You can declare several regular species, and they all have to be named. A species defines its attributes, actions and behaviors and aspects.\nspecies nameOfSpecies {\t// definition of your species attributes, actions and behaviors and aspects}\nNote that the possibility to define the species after the global definition is actually a convenience: these species are micro-species of the model species and, hence, could be perfectly defined as nested species of global. For instance:\nglobal {    // definition of global attributes, actions, behaviors}species A {...}species B {...}\nis completely equivalent to:\nglobal {    // definition of [global attributes](GlobalSpecies#declaration), actions, behaviors    species A {...}    species B {...}}\nExperiment declarations​\nExperiments are usually declared at the end of the file. They start with the keyword experiment. They contains the simulation parameters, and the definition of the output (such as displays, monitors or inspectors). You can declare as many experiments as you want.\nexperiment first_experiment {    // definition of parameters (intputs)    // definition of output    output {...}}experiment second_experiment {    // definition of parameters (inputs)    // definition of output}\nNote that you have four types of experiments:\n\nA GUI experiment allows you to display a graphical interface with input parameters and outputs. It is declared with the following structure:\n\nexperiment gui_experiment type:gui {   [parameters]   [output]   [...]}\n\nA Batch experiment allows you to execute numerous successive simulation runs (often used for model exploration). It is declared with the following structure:\n\nexperiment batch_experiment type:batch {   [parameters]   [exploration method]   [...]}\n\nA Test experiment allows you to write unit tests on a model (used to ensure its quality). It is declared with the following structure:\n\nexperiment test_experiment type:test autorun: true {   [setup]   [tests]   [...]}\n\nA memorize experiment allows you to store each step of the simulation in memory and to backtrack to previous steps. It is declared with the following structure:\n\nexperiment test_experiment type:memorize {   [parameters]   [output]   [...]}\nBasic skeleton of a model​\nHere is the basic skeleton of a model :\nmodel name_of_the_modelglobal {\t// definition of [global attributes](GlobalSpecies#declaration), actions, behaviours}species my_specie {\t// definition of attributes, actions, behaviors}experiment my_experiment /* + specify the type : \"type:gui\", \"type:batch\", \"type:test\", or \"test:memorize\" */{\t// here the definition of your experiment, with...\t// ... your inputs\toutput {\t\t// ... and your outputs\t}}\nDon't forget this structure! This will be the basis for all the models you will create from now."},{"filePath":"https:--gama-platform.org--wiki-MultiLevelArchitecture.txt","text":"Multi-level architectureThe multi-level architecture offers the modeler the following possibilities: the declaration of a species as a micro-species of another species, the representation of an entity as different types of agent (i.e., GAML species), the dynamic migration of agents between populations.\nIndex​\n\nDeclaration of micro-species\nAccess to micro-agents / host agent\nRepresentation of an entity as different types of agent\nDynamic migration of agents\nExample\n\nDeclaration of micro-species​\nA species can have other species as micro-species. The micro-species of a species is declared inside the species' declaration.\nspecies macro_species {      species micro_species_in_group {      }}\nIn the above example, micro_species_in_group is a micro-species of macro_species. An agent of macro_species can have agents micro_species_in_group as micro-agents. Agents of micro_species_in_group have an agent of macro_species as host agent.\nAs the species micro_species_in_group is declared inside the species macro_species, micro_species_in_group will return a list of micro_species_in_group agent inside the given macro_species agent.\nglobal {    init {\tcreate macro_species number:5;    }}species macro_species  {\t    init {\tcreate micro_species_in_group number: rnd(10);\twrite \"the macro species agent named \"+name+\" contains \"+length(micro_species_in_group)+\" agents of micro-species.\";    }    species micro_species_in_group { }}experiment my_experiment type: gui { }\nIn the above example, we create 5 macro-species agents, and each one creates a random number of inner micro-species agents. We can see that micro_species_in_group refers to the list of micro-species agents inside the given macro-species agent.\nAccess to micro-agents, host agent​\nTo access micro-agents (from a macro-agent), and to host agent (from a micro-agents), you have to use two built-in attributes.\nThe members built-in attribute is used inside the macro-agent, to get the list of all its micro-agents.\nspecies macro_species  {    init {\tcreate first_micro_species number: 3;\tcreate second_micro_species number: 6;\twrite \"the macro-agent named \"+name+\" contains \"+length(members)+\" micro-agents.\";    }\t    species first_micro_species { }        species second_micro_species { }}\nThe host built-in attribute is used inside a micro-agent to get its host macro-agent.\nspecies macro_species {\t    micro_species_in_group micro_agent;\t    init {\tcreate micro_species_in_group number: rnd(10);\twrite \"the macro-agent named \"+name+\" contains \"+length(members)+\" micro-agents.\";    }\t    species micro_species_in_group {    \tinit {    \t    write \"the micro-agent named \"+name+\" is hosted by \"+host;    \t}    }}\nNB: We already said that the world agent is a particular agent, instantiated just once. In fact, the world agent is the host of all the agents. You can try to get the host for a regular species agent, you will get the world agent itself (named as you named your model). You can also try to get the members of your world (from the global scope for example), and you will get the list of the agents presents in the world.\nglobal {    init {\tcreate macro_species number:5;\twrite \"the world has \"+length(members)+\" members.\";    }}species macro_species  {\t    init {\twrite \"the macro agent named \"+name+\" is hosted by \"+host;    }}\nRepresentation of an entity as different types of agent​\nThe multi-level architecture is often used in order to represent an entity through different types of agent. For example, an agent \"bee\" can have a behavior when it is alone, but when the agent is near from a lot of agents, he can changes his type to \"bee_in_swarm\", defined as a micro-species agent of a macro-species \"swarm\" agent. Another example: an agent \"pedestrian\" can have a certain behavior when walking on the street, and then change his type to \"pedestrian_in_building\" when he is in a macro-agent \"building\".\nYou have then to distinguish two different species to define your micro-species:\n\nThe first can be seen as a regular species (it is the \"bee\" or the \"pedestrian\" for instance). We will name this species as \"micro_species\".\nThe second is the real micro-species, defined inside the macro-species (it is the \"bee_in_swarm\" or the \"pedestrian_in_building\" for instance). We will name this species as \"micro_species_in_group\". This species has to inherit from the \"micro_species\" in order to allow migrations between micro_species_in_group and micro_species.\n\nspecies micro_species { }species macro_species  {\t    species micro_species_in_group parent: micro_species { }}\nDynamic migration of agents​\nIn our example about bees, a \"swarm\" entity is composed of nearby flying \"bee\" entities. When a \"bee\" entity approaches a \"swarm\" entity, this \"bee\" entity will become a member of the group. To represent this, the modeler lets the \"bee\" agent change its species to \"bee_in_swarm\" species. The \"bee\" agent hence becomes a \"bee_in_swarm\" agent. To change species of an agent, we can use one of the following statements: capture, release, migrate.\nThe statement capture is used by the \"macro_species\" to capture one (or several) \"micro_species\" agent(s), and turn it (them) to a \"micro_species_in_group\". You can specify which agent (or list of agents) you want to capture by passing them as the first argument of the statement capture. The facet as is used to cast the agent(s) from \"micro_species\" to the species \"micro_species_in_group\". You can use the facet returns to get the newly captured agent(s).\ncapture agents_of_micro_species as: micro_species_in_group;\nThe statement release is used by a \"macro_species\" agent to release one (or several) \"micro_species_in_group\" agent(s), and turn it (them) to a \"micro_species\". You can specify which agent (or list of agents) you want to release by giving them as the first argument of the release statement. The facet as is used to cast the agents from \"micro_species_in_group\" species to \"micro_species\" species. The facet in is used to specify the new host (by default, it is the host of the \"macro_species\"). You can use the facet returns to get the newly released agent(s).\nrelease agents_of_micro_species_in_group as: micro_species in: world;\nThe statement migrate, less used, permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Read the GAML Reference to learn more about this statement.\nExample:​\nHere is an example of micro_species that gather together in macro_species when they are close enough.\n\nmodel multilevelglobal {    int release_time <- 20;    int capture_time <- 100;    int remaining_release_time <- 0;    int remaining_capture_time <- capture_time;    init {\tcreate micro_species number:200;    }    reflex reflex_timer {\tif (remaining_release_time=1) {\t    remaining_release_time <- 0;\t    remaining_capture_time <- capture_time;\t} else if (remaining_capture_time=1) {\t    remaining_capture_time <- 0;\t    remaining_release_time <- release_time;\t}\tremaining_release_time <- remaining_release_time - 1;\tremaining_capture_time <- remaining_capture_time - 1;    }    reflex capture_micro_species when:(remaining_capture_time>0 and flip(0.1)) {\task macro_species {\t    list<micro_species> micro_species_in_range <- micro_species at_distance 1;\t    if (micro_species_in_range != []) {\t\tdo capture_micro_species(micro_species_in_range);\t    }\t}\task micro_species {\t    list<micro_species> micro_species_list_to_be_captured <- micro_species at_distance 1;\t    if(micro_species_list_to_be_captured != []) {\t\tcreate macro_species {\t\t    location <- myself.location;\t\t    add myself to:micro_species_list_to_be_captured;\t\t    do capture_micro_species(micro_species_list_to_be_captured);\t\t}\t    }\t}    }}species micro_species skills:[moving] {    geometry shape <- circle(1);    reflex move{\tdo wander;    }    aspect base {\tdraw shape border: #black;    }\t}species macro_species {    geometry shape <- circle(1) update:circle(length(members));\t    species micro_species_in_group parent:micro_species { }    action capture_micro_species(list<micro_species> micro_list) {\tloop mic_sp over:micro_list {\t    capture mic_sp as:micro_species_in_group;\t}    }\t    reflex release_reflex when: (remaining_release_time>0 and flip(0.1)) {\trelease members as: micro_species in:world;\tdo die;    }\t    aspect base {\tdraw shape border: #black;\tdraw string(length(members)) color:#black size:4;    }}experiment MyExperiment type: gui {    output {\tdisplay MyDisplay type: java2D {\t    species macro_species aspect: base;\t    species micro_species aspect: base;\t}    }}"},{"filePath":"https:--gama-platform.org--wiki-MultiParadigmModeling.txt","text":"Multi-Paradigm Modeling\n\nMulti-paradigm modeling is a research field focused on how to define a model semantically. From the beginning of this step by step tutorial, our approach is based on behavior (or reflex), for each agents. In this part, we will see that GAMA provides other ways to implement your model, using several control architectures. Sometime, it will be easier to implement your models choosing other paradigms.\nIn a first part, we will see how to use some control architectures which already exist in GAML, such as finite state machine architecture, task based architecture or user control architecture. In a second part, we will see an approach based on mathematical modeling through use of differential equations."},{"filePath":"https:--gama-platform.org--wiki-NavigatingWorkspace.txt","text":"Navigating in the WorkspaceAll the models that you edit or run using GAMA are accessible from a central location: the Navigator, which is always on the left-hand side of the main window and cannot be closed. This view presents the models currently present in (or linked from) your workspace.\n\nTable of contents​\n\nNavigating in the Workspace\n\nStatus of projects and models\nThe Different Categories of Models\n\nLibrary models\nPlugin models\nTest models\nUser models\n\n\nInspect Models\nMoving Models Around\nClosing and Deleting Projects\n\n\n\nStatus of projects and models​\nAll the projects and models have an icon with a red or green circle on it. This eases to locate models containing compilation errors (red circle) and projects that have been successfully validated (green circle).\n\nThe Different Categories of Models​\nIn the Navigator, models are organized in four different categories: Models library, Plugin models, Test models, and User models. This organization is purely logical and does not reflect where the models are actually stored in the workspace (or elsewhere). Whatever their actual location, model files need to be stored in projects, which may contain also other files (called resources) needed for the models to function (such as data files). A project may, of course, contain several model files, especially if they are importing each other, if they represent different models on the same topic, or if they share the same resources.\n\nLibrary models​\nThis category represents the models that are shipped with each version of GAMA. They do not reside in the workspace but are considered as linked from it. This link is established every time a new workspace is created. Their actual location is within a plugin (msi.gama.models) of the GAMA application. This category contains 7 main projects in GAMA 1.9, which are further refined in folders and sub-folders that contain model files and resources.\n\nThe 7 main projects on the Library models are:\n\nData: all these plugins illustrate how to manage data in GAML. This includes how to import data (in all the supported formats) into a model, export (i.e. save) agents or data in the simulations in files, clean data (e.g. clean a road network), get and save data in databases, and use data analysis operators.\nGAML Syntax: these models have the only goal to illustrate the syntax of the GAML language. This includes how to use the various data structures (list, map, matrix...), architectures, loop, interactions, and conditional structures, or how to schedule agents...\nModel Exploration: all these models illustrate the various ways to explore models and in particular the various possible experiment (batch, multi-simulations...).\nModeling: these models provide implementations of various classical difficulties encountered by modelers: how to make agents move (on a graph, a grid...), how to implement decision-making process...\nToy Models: these models are replications of classical models from the literature, including Sugarscape, Schelling, ants, boids...\nTutorials: this project contains all the files of the various tutorials (available from the website).\nVisualization and User Interaction: these models illustrate most of the GAMA features in terms of visualization and interactions with the simulation, e.g. the 3D visualization...\n\n\nIt may happen, on some occasions, that the library of models is not synchronized with the version of GAMA that uses your workspace. This is the case if you use different versions of GAMA to work with the same workspace. In that case, it is required that the library be manually updated. This can be done using the \"Update library\" item in the contextual menu.\n\nTo look up for a particular model in the library, users can use the \"Find model...\" search bar, which allows looking for models by their title (for example, models containing \"BDI\" in the example below).\n\nPlugin models​\nThis category represents the models that are related to a specific plugin (additional or integrated by default). The corresponding plugin is shown between parenthesis.\n\nWhen you add an additional plugin extending the GAML language is added, a new project can be added to this category.\nTest models​\nThese models are unit tests for the GAML language: they aim at testing each element of the language to check whether they produce the expected result. The aim is to avoid regression after evolutions of the software. They can be run from the validation view.\nUser models​\nThis category regroups all the projects that have been created or imported in the workspace by the user. Each project can be actually a folder that resides in the folder of the workspace (so they can be easily located from within the filesystem) or a link to a folder located anywhere in the filesystem (in case of a project importation). Any modification (addition, removal of files...) made to them in the file system (or using another application) is immediately reflected in the Navigator and vice-versa.\nModel files, although it is by no means mandatory, usually reside in a sub-folder of the project called models. Similarly, all the test models are located in the tests folder.\n\nInspect Models​\nEach model is presented as a node in the navigation workspace, including Experiment buttons and/or a Contents node and/or a Uses node and/or a Tags node and/or an Imports node.\n\n\nImports: The node Impots lists all the model files that are imported in the current model.\n\n\n\nUses node: The node Uses is present if your model uses some external resources, and if the path to the resource is correct (if the path to the resource is not correct, the resource will not be displayed under Uses).\n\n\n\n\nTags node: The node Tags lists all the tags that have been specified in the header of the model.\n\n\n\n\nContents: The node Contents describes the tree of all the elements in the model. It is similar to the Overview view.\n\n\n**Experiment button **: Experiment buttons are present if your model contains experiments (it is usually the case !). To run the corresponding experiment, just click on it. To learn more about running experiments, jump into this section.\n\n\n\nMoving Models Around​\nModel files, as well as resources, or even complete projects, can be moved around between the \"Models Library\"/\"Plugin Models\" and \"Users Models\" categories, or within them, directly in the Navigator. Drag'n drop operations are supported, as well as copy and paste. For example, the model Life.gaml, present in the \"Models Library\", can perfectly be copied and then pasted in a project in the \"Users Model\". This local copy in the workspace can then be further edited by the user without altering the original one.\n\nClosing and Deleting Projects​\nUsers can choose to get rid of old projects by either closing or deleting them. Closing a project means that it will still reside in the workspace (and be still visible, although a bit differently, in the Navigator) but its model(s) won't participate to the build process and won't be displayable until the project is opened again.\n\n\nDeleting a project must be invoked when the user wants this project to not appear in the workspace anymore (unless that is, it is imported again). Invoking this command will effectively make the workspace \"forget\" about this project, and this can be further doubled with a deletion of the project's resources and models from the filesystem.\n\n"},{"filePath":"https:--gama-platform.org--wiki-OperatorsAA.txt","text":"Operators (A to A)\nThis file is automatically generated from java files. Do Not Edit It.\n\nDefinition​\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.\nMost of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).\nThe ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.  - 10, ! (operand1 or operand2)).\nFinally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n\nif they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))\nif they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.\nif they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\nPriority between operators​\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n\nthe constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values.\nit is followed by the ?: operator, the functional if-else (e.g.  a > b ? a + 10 : a - 10 will return the result of the if-else).\nnext are the logical operators, and and or (e.g. a > b or b > c will return the value of the test)\nnext are the comparison operators (i.e. >, <, <=, >=, =, !=)\nnext the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\nnext the unary operators - and !\nnext the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)\nand finally the functional operators, which have the highest priority of all.\n\n\nUsing actions as operators​\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\nFor instance, if the following species is defined:\nspecies spec1 {        int min(int x, int y) {                return x > y ? x : y;        }}\nAny agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\nglobal {        init {                create spec1;                spec1 my_agent <- spec1[0];                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);        }}\nIf the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\nTable of Contents​\n\nOperators by categories​\n\n3D​\nbox, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,\n\nArithmetic operators​\n-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,\n\nBDI​\nadd_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,\n\nCasting operators​\nas, as_int, as_matrix, field_with, font, is, is_skill, list_with, matrix_with, species_of, to_gaml, to_geojson, to_list, with_size, with_style,\n\nColor-related operators​\n-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum, to_hsb,\n\nComparison operators​\n!=, <, <=, =, >, >=, between,\n\nContainers-related operators​\n-, ::, +, accumulate, all_match, among, as_json_string, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,\n\nDate-related operators​\n-, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,\n\nDates​\n\nDisplays​\nhorizontal, stack, vertical,\n\nedge​\nedge_between, strahler,\n\nEDP-related operators​\ndiff, diff2,\n\nFiles-related operators​\nagent_file, copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_agent, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_shape, is_simulation, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, shape_file, simulation_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,\n\nGamaMetaType​\ntype_of,\n\nGamaSVGFile​\nimage,\n\nGraphs-related operators​\nadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,\n\nGrid-related operators​\nas_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,\n\nImageOperators​\n*, antialiased, blend, blurred, brighter, clipped_with, darker, grayscale, horizontal_flip, image, matrix, rotated_by, sharpened, snapshot, tinted_with, vertical_flip, with_height, with_size, with_width,\n\nIterator operators​\naccumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,\n\nList-related operators​\nall_indexes_of, copy_between, index_of, last_index_of,\n\nLogical operators​\n:, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,\n\nMap comparaison operators​\nfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,\n\nMap-related operators​\nas_map, create_map, index_of, last_index_of,\n\nMatrix-related operators​\n-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, flatten, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,\n\nmulticriteria operators​\nelectre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,\n\nPath-related operators​\nagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,\n\nPedestrian​\ngenerate_pedestrian_network,\n\nPoints-related operators​\n-, /, *, +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,\n\nRandom operators​\nbinomial, exp_density, exp_rnd, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,\n\nReverseOperators​\nserialize,\n\nShape​\narc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,\n\nSpatial operators​\n-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, k_nearest_neighbors, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,\n\nSpatial properties operators​\ncovers, crosses, intersects, partially_overlaps, touches,\n\nSpatial queries operators​\nagent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,\n\nSpatial relations operators​\ndirection_between, distance_between, distance_to, path_between, path_to, towards,\n\nSpatial statistical operators​\nhierarchical_clustering, k_nearest_neighbors, simple_clustering_by_distance,\n\nSpatial transformations operators​\n-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,\n\nSpecies-related operators​\nindex_of, last_index_of, of_generic_species, of_species,\n\nStatistical operators​\nauto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, k_nearest_neighbors, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, morrisAnalysis, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, residuals, rms, rSquare, simple_clustering_by_distance, skewness, sobolAnalysis, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,\n\nStrings-related operators​\n+, <, <=, >, >=, at, capitalize, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,\n\nSubModel​\nload_sub_model,\n\nSystem​\n., choose, command, copy, copy_from_clipboard, copy_to_clipboard, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, play_sound, user_confirm, user_input_dialog, wizard, wizard_page,\n\nTime-related operators​\ndate, string,\n\nTypes-related operators​\naction, agent, attributes, BDIPlan, bool, container, conversation, directory, emotion, file, float, gaml_type, geometry, graph, int, kml, list, map, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, topology, unknown,\n\nUser control operators​\nchoose, enter, user_confirm, user_input_dialog, wizard, wizard_page,\n\nOperators​\n\n-​\nPossible uses:​\n\n- (point) --->  point\n- (int) --->  int\n- (float) --->  float\npoint - float --->  point\n- (point , float) --->  point\nint - matrix --->  matrix\n- (int , matrix) --->  matrix\ngeometry - geometry --->  geometry\n- (geometry , geometry) --->  geometry\nlist - unknown --->  list\n- (list , unknown) --->  list\nmatrix<unknown> - int --->  matrix\n- (matrix<unknown> , int) --->  matrix\ncontainer - container --->  list\n- (container , container) --->  list\nint - float --->  float\n- (int , float) --->  float\nspecies - agent --->  list\n- (species , agent) --->  list\nfloat - matrix --->  matrix\n- (float , matrix) --->  matrix\nrgb - int --->  rgb\n- (rgb , int) --->  rgb\ndate - int --->  date\n- (date , int) --->  date\ndate - date --->  float\n- (date , date) --->  float\nmatrix<unknown> - matrix --->  matrix\n- (matrix<unknown> , matrix) --->  matrix\nfield - int --->  field\n- (field , int) --->  field\nfield - matrix --->  field\n- (field , matrix) --->  field\ndate - float --->  date\n- (date , float) --->  date\nfloat - float --->  float\n- (float , float) --->  float\nmap - pair --->  map\n- (map , pair) --->  map\nfield - float --->  field\n- (field , float) --->  field\npoint - int --->  point\n- (point , int) --->  point\nint - int --->  int\n- (int , int) --->  int\nrgb - rgb --->  rgb\n- (rgb , rgb) --->  rgb\nmatrix<unknown> - float --->  matrix\n- (matrix<unknown> , float) --->  matrix\ngeometry - container<unknown,geometry> --->  geometry\n- (geometry , container<unknown,geometry>) --->  geometry\nfloat - int --->  float\n- (float , int) --->  float\nmap - map --->  map\n- (map , map) --->  map\ngeometry - float --->  geometry\n- (geometry , float) --->  geometry\npoint - point --->  point\n- (point , point) --->  point\n\nResult:​\nReturns the difference of the two operands.\nIf it is used as an unary operator, it returns the opposite of the operand.\nComment:​\nThe behavior of the operator depends on the type of the operands.\nSpecial cases:​\n\nif both operands are containers and the right operand is empty, - returns the left operand\nif the left operand is a species and the right operand is an agent of the species, - returns a list containing all the agents of the species minus this agent\nif left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the difference of the operand coordinate with this number.\n\npoint var18 <- {1, 2} - 4.5; // var18 equals {-3.5, -2.5, -4.5} point var19 <- {1, 2} - 4; // var19 equals {-3.0,-2.0,-4.0}\n\nif one operand is a matrix and the other a number (float or int), performs a normal arithmetic difference of the number with each element of the matrix (results are float if the number is a float.\n\nmatrix var20 <- 3.5 - matrix([[2,5],[3,4]]); // var20 equals matrix([[1.5,-1.5],[0.5,-0.5]])\n\nif both operands are a point, a geometry or an agent, returns the geometry resulting from the difference between both geometries\n\ngeometry var21 <- geom1 - geom2; // var21 equals a geometry corresponding to difference between geom1 and geom2\n\nif the left operand is a list and the right operand is an object of any type (except list), - returns a list containing the elements of the left operand minus the first occurence of this object\n\nlist<int> var22 <- [1,2,3,4,5,6,2] - 2; // var22 equals [1,3,4,5,6,2] list<int> var23 <- [1,2,3,4,5,6] - 0; // var23 equals [1,2,3,4,5,6]\n\nif both operands are containers, returns a new list in which all the elements of the right operand have been removed from the left one\n\nlist<int> var24 <- [1,2,3,4,5,6] - [2,4,9]; // var24 equals [1,3,5,6] list<int> var25 <- [1,2,3,4,5,6] - [0,8]; // var25 equals [1,2,3,4,5,6]\n\nif one operand is a color and the other an integer, returns a new color resulting from the subtraction of each component of the color with the right operand\n\nrgb var26 <- rgb([255, 128, 32]) - 3; // var26 equals rgb([252,125,29])\n\nif one of the operands is a date and the other a number, returns a date corresponding to the date minus the given number as duration (in seconds)\n\ndate var27 <- date('2000-01-01') - 86400; // var27 equals date('1999-12-31')\n\nif both operands are dates, returns the duration in seconds between date2 and date1. To obtain a more precise duration, in milliseconds, use milliseconds_between(date1, date2)\n\nfloat var28 <- date('2000-01-02') - date('2000-01-01'); // var28 equals 86400\n\nif both operands are numbers, performs a normal arithmetic difference and returns a float if one of them is a float.\n\nint var29 <- 1 - 1; // var29 equals 0\n\nif both operands are colors, returns a new color resulting from the subtraction of the two operands, component by component\n\nrgb var30 <- rgb([255, 128, 32]) - rgb('red'); // var30 equals rgb([0,128,32])\n\nif the right-operand is a list of points, geometries or agents, returns the geometry resulting from the difference between the left-geometry and all of the right-geometries\n\ngeometry var31 <- rectangle(10,10) - [circle(2), square(2)]; // var31 equals rectangle(10,10) - (circle(2) + square(2))\n\nif the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) reduced by the right-hand operand distance\n\ngeometry var32 <- shape - 5; // var32 equals a geometry corresponding to the geometry of the agent applying the operator reduced by a distance of 5\n\nif both operands are points, returns their difference (coordinates per coordinates).\n\npoint var33 <- {1, 2} - {4, 5}; // var33 equals {-3.0, -3.0}\nExamples:​\nfloat var0 <- 1 - 1.0; // var0 equals 0.0 float var1 <- 3 - 1.2; // var1 equals 1.8 matrix var2 <- (10.0 - (3.0 as_matrix({2,3}))); // var2 equals matrix([[7.0,7.0,7.0],[7.0,7.0,7.0]]) point var3 <- -{3.0,5.0}; // var3 equals {-3.0,-5.0} point var4 <- -{1.0,6.0,7.0}; // var4 equals {-1.0,-6.0,-7.0} date var5 <- date('2000-01-01') - 86400; // var5 equals date('1999-12-31') float var6 <- 1.0 - 1.0; // var6 equals 0.0 float var7 <- 3.7 - 1.2; // var7 equals 2.5 float var8 <- 3.0 - 1.2; // var8 equals 1.8 map var9 <- ['a'::1,'b'::2] - ('b'::2); // var9 equals ['a'::1] map var10 <- ['a'::1,'b'::2] - ('c'::3); // var10 equals ['a'::1,'b'::2] int var11 <- - (-56); // var11 equals 56 point var12 <- {2.0,3.0,4.0} - 1; // var12 equals {1.0,2.0,3.0} float var13 <- 1.0 - 1; // var13 equals 0.0 float var14 <- 3.7 - 1; // var14 equals 2.7 float var15 <- 3.0 - 1; // var15 equals 2.0 map var16 <- ['a'::1,'b'::2] - ['b'::2]; // var16 equals ['a'::1] map var17 <- ['a'::1,'b'::2] - ['b'::2,'c'::3]; // var17 equals ['a'::1]\nSee also: +, milliseconds_between, -, *, /,\n\n:\nPossible uses:​\n\nunknown : unknown --->  unknown\n: (unknown , unknown) --->  unknown\n\nResult:​\nIt is used in combination with the ? operator. If the left-hand of ? operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :\nExamples:​\nlist<string> var0 <- [10, 19, 43, 12, 7, 22] collect ((each > 20) ? 'above' : 'below'); // var0 equals ['below', 'below', 'above', 'below', 'below', 'above']\nSee also: ?,\n\n::​\nPossible uses:​\n\nany expression :: any expression --->  pair\n:: (any expression , any expression) --->  pair\n\nResult:​\nproduces a new pair combining the left and the right operands\nSpecial cases:​\n\nnil is not acceptable as a key (although it is as a value). If such a case happens, :: will throw an appropriate error\n\n\n!​\nPossible uses:​\n\n! (bool) --->  bool\n\nResult:​\nopposite boolean value.\nSpecial cases:​\n\nif the parameter is not boolean, it is casted to a boolean value.\n\nExamples:​\nbool var0 <- ! (true); // var0 equals false\nSee also: bool, and, or,\n\n!=​\nPossible uses:​\n\nint != float --->  bool\n!= (int , float) --->  bool\nfloat != float --->  bool\n!= (float , float) --->  bool\nunknown != unknown --->  bool\n!= (unknown , unknown) --->  bool\nfloat != int --->  bool\n!= (float , int) --->  bool\ndate != date --->  bool\n!= (date , date) --->  bool\n\nResult:​\ntrue if both operands are different, false otherwise\nExamples:​\nbool var0 <- 3 != 3.0; // var0 equals false bool var1 <- 4 != 4.7; // var1 equals true bool var2 <- 3.0 != 3.0; // var2 equals false bool var3 <- 4.0 != 4.7; // var3 equals true bool var4 <- [2,3] != [2,3]; // var4 equals false bool var5 <- [2,4] != [2,3]; // var5 equals true bool var6 <- 3.0 != 3; // var6 equals false bool var7 <- 4.7 != 4; // var7 equals true bool var8 <- #now != #now minus_hours 1; // var8 equals true\nSee also: =, >, <, >=, <=,\n\n?​\nPossible uses:​\n\nbool ? any expression --->  unknown\n? (bool , any expression) --->  unknown\n\nResult:​\nIt is used in combination with the : operator: if the left-hand operand evaluates to true, returns the value of the left-hand operand of the :, otherwise that of the right-hand operand of the :\nComment:​\nThese functional tests can be combined together.\nExamples:​\nlist<string> var0 <- [10, 19, 43, 12, 7, 22] collect ((each > 20) ? 'above' : 'below'); // var0 equals ['below', 'below', 'above', 'below', 'below', 'above'] rgb col <- (flip(0.3) ? #red : (flip(0.9) ? #blue : #green));\nSee also: :,\n\n/​\nPossible uses:​\n\nfield / int --->  field\n/ (field , int) --->  field\nmatrix<unknown> / float --->  matrix\n/ (matrix<unknown> , float) --->  matrix\nint / float --->  float\n/ (int , float) --->  float\nrgb / float --->  rgb\n/ (rgb , float) --->  rgb\nfloat / float --->  float\n/ (float , float) --->  float\nmatrix<unknown> / matrix --->  matrix\n/ (matrix<unknown> , matrix) --->  matrix\npoint / float --->  point\n/ (point , float) --->  point\nrgb / int --->  rgb\n/ (rgb , int) --->  rgb\nfloat / int --->  float\n/ (float , int) --->  float\nmatrix<unknown> / int --->  matrix\n/ (matrix<unknown> , int) --->  matrix\nfield / float --->  field\n/ (field , float) --->  field\npoint / int --->  point\n/ (point , int) --->  point\nint / int --->  float\n/ (int , int) --->  float\n\nResult:​\nReturns the division of the two operands.\nSpecial cases:​\n\nif the right-hand operand is equal to zero, raises a \"Division by zero\" exception\nif one operand is a color and the other a double, returns a new color resulting from the division of each component of the color by the right operand. The result on each component is then truncated.\n\nrgb var0 <- rgb([255, 128, 32]) / 2.5; // var0 equals rgb([102,51,13])\n\nif the left operand is a point, returns a new point with coordinates divided by the right operand\n\npoint var1 <- {5, 7.5} / 2.5; // var1 equals {2, 3} point var2 <- {2,5} / 4; // var2 equals {0.5,1.25}\n\nif one operand is a color and the other an integer, returns a new color resulting from the division of each component of the color by the right operand\n\nrgb var3 <- rgb([255, 128, 32]) / 2; // var3 equals rgb([127,64,16])\n\nif both operands are numbers (float or int), performs a normal arithmetic division and returns a float.\n\nfloat var4 <- 3 / 5.0; // var4 equals 0.6\nSee also: *, +, -,\n\n.​\nPossible uses:​\n\nagent . any expression --->  unknown\n. (agent , any expression) --->  unknown\n\nResult:​\nIt has two different uses: it can be the dot product between 2 matrices or return an evaluation of the expression (right-hand operand) in the scope the given agent.\nSpecial cases:​\n\nif the agent is nil or dead, throws an exception\nif the left operand is an agent, it evaluates of the expression (right-hand operand) in the scope the given agent\n\nunknown var0 <- agent1.location; // var0 equals the location of the agent agent1\n\n.​\nPossible uses:​\n\nmatrix . matrix --->  matrix\n. (matrix , matrix) --->  matrix\n\nSpecial cases:​\n\nif both operands are matrix, returns the dot product of them\n\nmatrix var0 <- matrix([[1,1],[1,2]]) . matrix([[1,1],[1,2]]); // var0 equals matrix([[2,3],[3,5]])\n\n^​\nPossible uses:​\n\nint ^ float --->  float\n^ (int , float) --->  float\nfloat ^ int --->  float\n^ (float , int) --->  float\nfloat ^ float --->  float\n^ (float , float) --->  float\nint ^ int --->  float\n^ (int , int) --->  float\n\nResult:​\nReturns the value (always a float) of the left operand raised to the power of the right operand.\nSpecial cases:​\n\nif the right-hand operand is equal to 0, returns 1\nif it is equal to 1, returns the left-hand operand.\nVarious examples of power\n\nfloat var1 <- 2 ^ 3; // var1 equals 8.0\nExamples:​\nfloat var0 <- 4.84 ^ 0.5; // var0 equals 2.2\nSee also: *, sqrt,\n\n@​\nSame signification as at\n\n*​\nPossible uses:​\n\nint * matrix --->  matrix\n* (int , matrix) --->  matrix\nfloat * int --->  float\n* (float , int) --->  float\ngeometry * float --->  geometry\n* (geometry , float) --->  geometry\npoint * point --->  float\n* (point , point) --->  float\nmatrix<unknown> * matrix --->  matrix\n* (matrix<unknown> , matrix) --->  matrix\ngeometry * point --->  geometry\n* (geometry , point) --->  geometry\nfield * float --->  field\n* (field , float) --->  field\nint * int --->  int\n* (int , int) --->  int\nrgb * float --->  rgb\n* (rgb , float) --->  rgb\nfloat * float --->  float\n* (float , float) --->  float\npoint * float --->  point\n* (point , float) --->  point\nrgb * int --->  rgb\n* (rgb , int) --->  rgb\nmatrix<unknown> * float --->  matrix\n* (matrix<unknown> , float) --->  matrix\nfield * int --->  field\n* (field , int) --->  field\npoint * int --->  point\n* (point , int) --->  point\nfloat * matrix --->  matrix\n* (float , matrix) --->  matrix\nmatrix<unknown> * int --->  matrix\n* (matrix<unknown> , int) --->  matrix\nint * float --->  float\n* (int , float) --->  float\n\nResult:​\nReturns the product of the two operands.\nSpecial cases:​\n\nif one operand is a matrix and the other a number (float or int), performs a normal arithmetic product of the number with each element of the matrix (results are float if the number is a float.\n\nmatrix var1 <- 2 * matrix([[2,5],[3,4]]); // var1 equals matrix([[4,10],[6,8]])\n\nif the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficient\n\ngeometry var2 <- circle(10) * 2; // var2 equals circle(20) geometry var3 <- (circle(10) * 2).location with_precision 9; // var3 equals (circle(20)).location with_precision 9 float var4 <- (circle(10) * 2).height with_precision 9; // var4 equals (circle(20)).height with_precision 9\n\nif both operands are points, returns their scalar product\n\nfloat var5 <- {2,5} * {4.5, 5}; // var5 equals 34.0\n\nif the left-hand operand is a geometry and the right-hand operand a point, returns a geometry corresponding to the left-hand operand (geometry, agent, point) scaled by the right-hand operand coefficients in the 3 dimensions\n\ngeometry var6 <- shape * {0.5,0.5,2}; // var6 equals a geometry corresponding to the geometry of the agent applying the operator scaled by a coefficient of 0.5 in x, 0.5 in y and 2 in z\n\nif both operands are numbers (float or int), performs a normal arithmetic product and returns a float if one of them is a float.\n\nint var7 <- 1 * 1; // var7 equals 1\n\nif one operand is a color and the other a float, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)\n\nrgb var8 <- rgb([255, 128, 32]) * 2.0; // var8 equals rgb([255,255,64])\n\nif one operand is a color and the other an integer, returns a new color resulting from the product of each component of the color with the right operand (with a maximum value at 255)\n\nrgb var9 <- rgb([255, 128, 32]) * 2; // var9 equals rgb([255,255,64])\n\nif the left-hand operator is a point and the right-hand a number, returns a point with coordinates multiplied by the number\n\npoint var10 <- {2,5} * 4; // var10 equals {8.0, 20.0} point var11 <- {2, 4} * 2.5; // var11 equals {5.0, 10.0}\nExamples:​\nfloat var0 <- 2.5 * 2; // var0 equals 5.0\nSee also: /, +, -,\n\n*​\nPossible uses:​\n\nimage * float --->  image\n* (image , float) --->  image\n\nResult:​\nApplies a proportional scaling ratio to the image passed in parameter and returns a new scaled image. A ratio of 0 will return nil, a ratio of 1 will return the original image. Automatic scaling and resizing methods are used. The original image is left untouched\n\n+​\nPossible uses:​\n\nfield + float --->  field\n+ (field , float) --->  field\npoint + point --->  point\n+ (point , point) --->  point\nfloat + matrix --->  matrix\n+ (float , matrix) --->  matrix\nrgb + rgb --->  rgb\n+ (rgb , rgb) --->  rgb\nmatrix<unknown> + float --->  matrix\n+ (matrix<unknown> , float) --->  matrix\nint + float --->  float\n+ (int , float) --->  float\nmatrix<unknown> + matrix --->  matrix\n+ (matrix<unknown> , matrix) --->  matrix\nmap + map --->  map\n+ (map , map) --->  map\nstring + unknown --->  string\n+ (string , unknown) --->  string\npoint + int --->  point\n+ (point , int) --->  point\ncontainer + container --->  container\n+ (container , container) --->  container\nfield + int --->  field\n+ (field , int) --->  field\nint + int --->  int\n+ (int , int) --->  int\ndate + int --->  date\n+ (date , int) --->  date\ngeometry + geometry --->  geometry\n+ (geometry , geometry) --->  geometry\nfloat + int --->  float\n+ (float , int) --->  float\nmap + pair --->  map\n+ (map , pair) --->  map\nfloat + float --->  float\n+ (float , float) --->  float\nfield + matrix --->  field\n+ (field , matrix) --->  field\nrgb + int --->  rgb\n+ (rgb , int) --->  rgb\nint + matrix --->  matrix\n+ (int , matrix) --->  matrix\ndate + float --->  date\n+ (date , float) --->  date\npoint + float --->  point\n+ (point , float) --->  point\ndate + string --->  string\n+ (date , string) --->  string\ngeometry + float --->  geometry\n+ (geometry , float) --->  geometry\ncontainer + unknown --->  list\n+ (container , unknown) --->  list\nmatrix<unknown> + int --->  matrix\n+ (matrix<unknown> , int) --->  matrix\nstring + string --->  string\n+ (string , string) --->  string\n+ (geometry, float, int) --->  geometry\n+ (geometry, float, bool) --->  geometry\n+ (geometry, float, int, int) --->  geometry\n+ (geometry, float, int, int, bool) --->  geometry\n\nResult:​\nReturns the sum, union or concatenation of the two operands.\nSpecial cases:​\n\nif one of the operands is nil, + throws an error\nif both operands are species, returns a special type of list called meta-population\nif both operands are points, returns their sum.\n\npoint var9 <- {1, 2} + {4, 5}; // var9 equals {5.0, 7.0}\n\nif both operands are colors, returns a new color resulting from the sum of the two operands, component by component\n\nrgb var10 <- rgb([255, 128, 32]) + rgb('red'); // var10 equals rgb([255,128,32])\n\nif the left-hand operand is a geometry and the right-hand operands a float, an integer, one of #round, #square or #flat and a boolean, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style and single sided is the boolean is true\n\ngeometry var11 <- line([{10,10}, {50,50}]) + (5,32,#round, true); // var11 equals A ploygon corresponding to the buffer generated\n\nif the left-hand operand is a string, returns the concatenation of the two operands (the left-hand one beind casted into a string)\n\nstring var12 <- \"hello \" + 12; // var12 equals \"hello 12\"\n\nif the left-hand operand is a geometry and the right-hand operands a float, an integer and one of #round, #square or #flat, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand and a flat, square or round end cap style\n\ngeometry var13 <- circle(5) + (5,32,#round); // var13 equals circle(10)\n\nif both operands are list, +returns the concatenation of both lists.\n\nlist<int> var14 <- [1,2,3,4,5,6] + [2,4,9]; // var14 equals [1,2,3,4,5,6,2,4,9] list<int> var15 <- [1,2,3,4,5,6] + [0,8]; // var15 equals [1,2,3,4,5,6,0,8]\n\nif both operands are numbers (float or int), performs a normal arithmetic sum and returns a float if one of them is a float.\n\nint var16 <- 1 + 1; // var16 equals 2\n\nif one of the operands is a date and the other a number, returns a date corresponding to the date plus the given number as duration (in seconds)\n\ndate var17 <- date('2000-01-01') + 86400; // var17 equals date('2000-01-02')\n\nif the right-operand is a point, a geometry or an agent, returns the geometry resulting from the union between both geometries\n\ngeometry var18 <- geom1 + geom2; // var18 equals a geometry corresponding to union between geom1 and geom2\n\nif the left-hand operand is a geometry and the right-hand operands a float and an integer, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), using a number of segments equal to the second right-hand operand\n\ngeometry var19 <- circle(5) + (5,32); // var19 equals circle(10)\n\nif one operand is a color and the other an integer, returns a new color resulting from the sum of each component of the color with the right operand\n\nrgb var20 <- rgb([255, 128, 32]) + 3; // var20 equals rgb([255,131,35])\n\nif one operand is a matrix and the other a number (float or int), performs a normal arithmetic sum of the number with each element of the matrix (results are float if the number is a float.\n\nmatrix var21 <- 3.5 + matrix([[2,5],[3,4]]); // var21 equals matrix([[5.5,8.5],[6.5,7.5]])\n\nif the left-hand operand is a point and the right-hand a number, returns a new point with each coordinate as the sum of the operand coordinate with this number.\n\npoint var22 <- {1, 2} + 4.5; // var22 equals {5.5, 6.5,4.5}\n\nif the left-hand operand is a geometry and the right-hand operand a float, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the right-hand operand distance. The number of segments used by default is 8 and the end cap style is #round\n\ngeometry var23 <- circle(5) + 5; // var23 equals circle(10)\n\nif the left-hand operand is a geometry and the right-hand operands a float and a boolean, returns a geometry corresponding to the left-hand operand (geometry, agent, point) enlarged by the first right-hand operand (distance), single sided is the boolean is true\n\ngeometry var24 <- line([{10,10}, {50,50}]) + (5, true); // var24 equals A ploygon corresponding to the buffer generated\n\nif the right operand is an object of any type (except a container), + returns a list of the elements of the left operand, to which this object has been added\n\nlist<int> var25 <- [1,2,3,4,5,6] + 2; // var25 equals [1,2,3,4,5,6,2] list<int> var26 <- [1,2,3,4,5,6] + 0; // var26 equals [1,2,3,4,5,6,0]\n\nif the left-hand and right-hand operand are a string, returns the concatenation of the two operands\n\nstring var27 <- \"hello \" + \"World\"; // var27 equals \"hello World\"\nExamples:​\nmap var0 <- ['a'::1,'b'::2] + ['c'::3]; // var0 equals ['a'::1,'b'::2,'c'::3] map var1 <- ['a'::1,'b'::2] + [5::3.0]; // var1 equals ['a'::1,'b'::2,5::3.0] point var2 <- {1, 2} + 4; // var2 equals {5.0, 6.0,4.0} float var3 <- 1.0 + 1; // var3 equals 2.0 float var4 <- 1.0 + 2.5; // var4 equals 3.5 map var5 <- ['a'::1,'b'::2] + ('c'::3); // var5 equals ['a'::1,'b'::2,'c'::3] map var6 <- ['a'::1,'b'::2] + ('c'::3); // var6 equals ['a'::1,'b'::2,'c'::3] date var7 <- date('2016-01-01 00:00:01') + 86400; // var7 equals date('2016-01-02 00:00:01') string var8 <- date('2000-01-01 00:00:00') + '_Test'; // var8 equals '2000-01-01 00:00:00_Test'\nSee also: /, -, *,\n\n<​\nPossible uses:​\n\ndate < date --->  bool\n< (date , date) --->  bool\nint < int --->  bool\n< (int , int) --->  bool\nint < float --->  bool\n< (int , float) --->  bool\nstring < string --->  bool\n< (string , string) --->  bool\npoint < point --->  bool\n< (point , point) --->  bool\nfloat < int --->  bool\n< (float , int) --->  bool\nfloat < float --->  bool\n< (float , float) --->  bool\n\nResult:​\ntrue if the left-hand operand is less than the right-hand operand, false otherwise.\nSpecial cases:​\n\nif one of the operands is nil, returns false\nif both operands are String, uses a lexicographic comparison of two strings\n\nbool var0 <- 'abc' < 'aeb'; // var0 equals true\n\nif both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.\n\nbool var1 <- {5,7} < {4,6}; // var1 equals false bool var2 <- {5,7} < {4,8}; // var2 equals false\nExamples:​\nbool var3 <- #now < #now minus_hours 1; // var3 equals false bool var4 <- 3 < 7; // var4 equals true bool var5 <- 3 < 2.5; // var5 equals false bool var6 <- 3.5 < 7; // var6 equals true bool var7 <- 3.5 < 7.6; // var7 equals true\nSee also: >, >=, <=, =, !=,\n\n<=​\nPossible uses:​\n\nint <= float --->  bool\n<= (int , float) --->  bool\npoint <= point --->  bool\n<= (point , point) --->  bool\nstring <= string --->  bool\n<= (string , string) --->  bool\nfloat <= int --->  bool\n<= (float , int) --->  bool\nfloat <= float --->  bool\n<= (float , float) --->  bool\nint <= int --->  bool\n<= (int , int) --->  bool\ndate <= date --->  bool\n<= (date , date) --->  bool\n\nResult:​\ntrue if the left-hand operand is less or equal than the right-hand operand, false otherwise.\nSpecial cases:​\n\nif one of the operands is nil, returns false\nif both operands are points, returns true if and only if the left component (x) of the left operand if less than or equal to x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.\n\nbool var0 <- {5,7} <= {4,6}; // var0 equals false bool var1 <- {5,7} <= {4,8}; // var1 equals false\n\nif both operands are String, uses a lexicographic comparison of two strings\n\nbool var2 <- 'abc' <= 'aeb'; // var2 equals true\nExamples:​\nbool var3 <- 3 <= 2.5; // var3 equals false bool var4 <- 7.0 <= 7; // var4 equals true bool var5 <- 3.5 <= 3.5; // var5 equals true bool var6 <- 3 <= 7; // var6 equals true bool var7 <- (#now <= (#now minus_hours 1)); // var7 equals false\nSee also: >, <, >=, =, !=,\n\n=​\nPossible uses:​\n\ndate = date --->  bool\n= (date , date) --->  bool\nfloat = float --->  bool\n= (float , float) --->  bool\nunknown = unknown --->  bool\n= (unknown , unknown) --->  bool\nfloat = int --->  bool\n= (float , int) --->  bool\nint = float --->  bool\n= (int , float) --->  bool\nint = int --->  bool\n= (int , int) --->  bool\n\nResult:​\nreturns true if both operands are equal, false otherwise\nreturns true if both operands are equal, false otherwise\nSpecial cases:​\n\nif both operands are any kind of objects, returns true if they are identical (i.e., the same object) or equal (comparisons between nil values are permitted)\n\nbool var0 <- [2,3] = [2,3]; // var0 equals true\nExamples:​\nbool var1 <- #now = #now minus_hours 1; // var1 equals false bool var2 <- 4.5 = 4.7; // var2 equals false bool var3 <- 4.7 = 4; // var3 equals false bool var4 <- 3 = 3.0; // var4 equals true bool var5 <- 4 = 4.7; // var5 equals false bool var6 <- 4 = 5; // var6 equals false\nSee also: >, <, >=, <=, !=,\n\n>​\nPossible uses:​\n\nint > int --->  bool\n> (int , int) --->  bool\nfloat > int --->  bool\n> (float , int) --->  bool\nint > float --->  bool\n> (int , float) --->  bool\nstring > string --->  bool\n> (string , string) --->  bool\nfloat > float --->  bool\n> (float , float) --->  bool\ndate > date --->  bool\n> (date , date) --->  bool\npoint > point --->  bool\n> (point , point) --->  bool\n\nResult:​\ntrue if the left-hand operand is greater than the right-hand operand, false otherwise.\nSpecial cases:​\n\nif one of the operands is nil, returns false\nif both operands are String, uses a lexicographic comparison of two strings\n\nbool var5 <- 'abc' > 'aeb'; // var5 equals false\n\nif both operands are points, returns true if and only if the left component (x) of the left operand if greater than x of the right one and if the right component (y) of the left operand is greater than y of the right one.\n\nbool var6 <- {5,7} > {4,6}; // var6 equals true bool var7 <- {5,7} > {4,8}; // var7 equals false\nExamples:​\nbool var0 <- 13.0 > 7.0; // var0 equals true bool var1 <- 3.5 > 7; // var1 equals false bool var2 <- 3 > 2.5; // var2 equals true bool var3 <- 3.5 > 7.6; // var3 equals false bool var4 <- (#now > (#now minus_hours 1)); // var4 equals true\nSee also: <, >=, <=, =, !=,\n\n>=​\nPossible uses:​\n\nint >= float --->  bool\n>= (int , float) --->  bool\npoint >= point --->  bool\n>= (point , point) --->  bool\nstring >= string --->  bool\n>= (string , string) --->  bool\nfloat >= int --->  bool\n>= (float , int) --->  bool\nint >= int --->  bool\n>= (int , int) --->  bool\nfloat >= float --->  bool\n>= (float , float) --->  bool\ndate >= date --->  bool\n>= (date , date) --->  bool\n\nResult:​\ntrue if the left-hand operand is greater or equal than the right-hand operand, false otherwise.\nSpecial cases:​\n\nif one of the operands is nil, returns false\nif both operands are points, returns true if and only if the left component (x) of the left operand if greater or equal than x of the right one and if the right component (y) of the left operand is greater than or equal to y of the right one.\n\nbool var0 <- {5,7} >= {4,6}; // var0 equals true bool var1 <- {5,7} >= {4,8}; // var1 equals false\n\nif both operands are string, uses a lexicographic comparison of the two strings\n\nbool var2 <- 'abc' >= 'aeb'; // var2 equals false bool var3 <- 'abc' >= 'abc'; // var3 equals true\nExamples:​\nbool var4 <- 3 >= 2.5; // var4 equals true bool var5 <- 3.5 >= 7; // var5 equals false bool var6 <- 3 >= 7; // var6 equals false bool var7 <- 3.5 >= 3.5; // var7 equals true bool var8 <- #now >= #now minus_hours 1; // var8 equals true\nSee also: >, <, <=, =, !=,\n\nabs​\nPossible uses:​\n\nabs (float) --->  float\nabs (int) --->  int\n\nResult:​\nReturns the absolute value of the operand (so a positive int or float depending on the type of the operand).\nExamples:​\nfloat var0 <- abs (200 * -1 + 0.5); // var0 equals 199.5 int var1 <- abs (-10); // var1 equals 10 int var2 <- abs (10); // var2 equals 10\n\naccumulate​\nPossible uses:​\n\ncontainer accumulate any expression --->  list\naccumulate (container , any expression) --->  list\n\nResult:​\nreturns a new flat list, in which each element is the evaluation of the right-hand operand. If this evaluation returns a list, the elements of this result are added directly to the list returned\nComment:​\naccumulate is dedicated to the application of a same computation on each element of a container (and returns a list). In the right-hand operand, the keyword each can be used to represent, in turn, each of the left-hand operand elements.\nExamples:​\nlist var0 <- [a1,a2,a3] accumulate (each neighbors_at 10); // var0 equals a flat list of all the neighbors of these three agents list<int> var1 <- [1,2,4] accumulate ([2,4]); // var1 equals [2,4,2,4,2,4] list<int> var2 <- [1,2,4] accumulate (each * 2); // var2 equals [2,4,8]\nSee also: collect,\n\nacos​\nPossible uses:​\n\nacos (int) --->  float\nacos (float) --->  float\n\nResult:​\nReturns the value (in the interval [0,180], in decimal degrees) of the arccos of the operand (which should be in [-1,1]).\nSpecial cases:​\n\nif the right-hand operand is outside of the [-1,1] interval, returns NaN\n\nExamples:​\nfloat var0 <- acos (0); // var0 equals 90.0\nSee also: asin, atan, cos,\n\naction​\nPossible uses:​\n\naction (any) --->  action\n\nResult:​\ncasts the operand in a action object.\n\nadd_3Dmodel​\nPossible uses:​\n\nadd_3Dmodel (kml, point, float, float, string) --->  kml\nadd_3Dmodel (kml, point, float, float, string, date, date) --->  kml\n\nResult:​\nthe kml export manager with new 3D model: specify the 3D model (collada) to add to the kml\nSee also: add_geometry, add_icon, add_label,\n\nadd_days​\nSame signification as plus_days\n\nadd_edge​\nPossible uses:​\n\ngraph add_edge pair --->  graph\nadd_edge (graph , pair) --->  graph\n\nResult:​\nadd an edge between a source vertex and a target vertex (resp. the left and the right element of the pair operand)\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph. If the edge already exists, the graph is unchanged\nExamples:​\ngraph <- graph add_edge (source::target);\nSee also: add_node, graph,\n\nadd_geometry​\nPossible uses:​\n\nadd_geometry (kml, geometry, float, rgb) --->  kml\nadd_geometry (kml, geometry, rgb, rgb) --->  kml\nadd_geometry (kml, geometry, float, rgb, rgb) --->  kml\nadd_geometry (kml, geometry, float, rgb, rgb, date) --->  kml\nadd_geometry (kml, geometry, float, rgb, rgb, date, date) --->  kml\n\nResult:​\nDefine the kml export manager with new geometry\nSee also: add_3Dmodel, add_icon, add_label,\n\nadd_hours​\nSame signification as plus_hours\n\nadd_icon​\nPossible uses:​\n\nadd_icon (kml, point, float, float, string) --->  kml\nadd_icon (kml, point, float, float, string, date, date) --->  kml\n\nResult:​\nDefine the kml export manager with new icons\nSee also: add_geometry, add_icon,\n\nadd_minutes​\nSame signification as plus_minutes\n\nadd_months​\nSame signification as plus_months\n\nadd_ms​\nSame signification as plus_ms\n\nadd_node​\nPossible uses:​\n\ngraph add_node geometry --->  graph\nadd_node (graph , geometry) --->  graph\n\nResult:​\nadds a node in a graph.\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph\nExamples:​\ngraph var0 <- graph add_node node(0); // var0 equals the graph, to which node(0) has been added\nSee also: add_edge, graph,\n\nadd_point​\nPossible uses:​\n\ngeometry add_point point --->  geometry\nadd_point (geometry , point) --->  geometry\n\nResult:​\nA new geometry resulting from the addition of the right point (coordinate) to the left-hand geometry. Note that adding a point to a line or polyline will always return a closed contour. Also note that the position at which the added point will appear in the geometry is not necessarily the last one, as points are always ordered in a clockwise fashion in geometries\nExamples:​\ngeometry var0 <- polygon([{10,10},{10,20},{20,20}]) add_point {20,10}; // var0 equals polygon([{10,10},{10,20},{20,20},{20,10}])\n\nadd_seconds​\nSame signification as +\n\nadd_values​\nPossible uses:​\n\npredicate add_values map --->  predicate\nadd_values (predicate , map) --->  predicate\n\nResult:​\nadd a new value to the map of the given predicate\nExamples:​\npredicate add_values [\"time\"::10];\n\nadd_weeks​\nSame signification as plus_weeks\n\nadd_years​\nSame signification as plus_years\n\nadjacency​\nPossible uses:​\n\nadjacency (graph) --->  matrix<float>\n\nResult:​\nadjacency matrix of the given graph.\n\nafter​\nPossible uses:​\n\nafter (date) --->  bool\nany expression after date --->  bool\nafter (any expression , date) --->  bool\n\nResult:​\nReturns true if the current_date of the model is strictly after the date passed in argument. Synonym of 'current_date > argument'. Can be used in its composed form with 2 arguments to express the lower boundary for the computation of a frequency. Note that only dates strictly after this one will be tested against the frequency\nExamples:​\nreflex when: after(starting_date) {} \t// this reflex will always be run after the first step reflex when: false after(starting date + #10days) {} \t// This reflex will not be run after this date. Better to use 'until' or 'before' in that case every(2#days) after (starting_date + 1#day) \t// the computation will return true every two days (using the starting_date of the model as the starting point) only for the dates strictly after this starting_date + 1#day\n\nagent​\nPossible uses:​\n\nagent (any) --->  agent\n\nResult:​\ncasts the operand in a agent object.\n\nagent_closest_to​\nPossible uses:​\n\nagent_closest_to (unknown) --->  agent\n\nResult:​\nAn agent, the closest to the operand (casted as a geometry).\nComment:​\nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\nExamples:​\nagent var0 <- agent_closest_to(self); // var0 equals the closest agent to the agent applying the operator.\nSee also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping,\n\nagent_farthest_to​\nPossible uses:​\n\nagent_farthest_to (unknown) --->  agent\n\nResult:​\nAn agent, the farthest to the operand (casted as a geometry).\nComment:​\nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\nExamples:​\nagent var0 <- agent_farthest_to(self); // var0 equals the farthest agent to the agent applying the operator.\nSee also: neighbors_at, neighbors_of, agents_inside, agents_overlapping, closest_to, inside, overlapping, agent_closest_to, farthest_to,\n\nagent_file​\nPossible uses:​\n\nagent_file (string) --->  file\n\nResult:​\nConstructs a file of type agent. Allowed extensions are limited to agent\nSpecial cases:​\n\nagent_file(string): File containing a saved agent. Three internal formats are supported: json, xml and java binary serialisation protocol\n\nSee also: is_agent,\n\nagent_from_geometry​\nPossible uses:​\n\npath agent_from_geometry geometry --->  agent\nagent_from_geometry (path , geometry) --->  agent\n\nResult:​\nreturns the agent corresponding to given geometry (right-hand operand) in the given path (left-hand operand).\nSpecial cases:​\n\nif the left-hand operand is nil, returns nil\n\nExamples:​\ngeometry line <- one_of(path_followed.segments); road ag <- road(path_followed agent_from_geometry line);\nSee also: path,\n\nagent_intersecting​\nSame signification as agents_overlapping\n\nagents_at_distance​\nPossible uses:​\n\nagents_at_distance (float) --->  list\n\nResult:​\nA list of agents situated at a distance lower than the right argument.\nExamples:​\nlist var0 <- agents_at_distance(20); // var0 equals all the agents (excluding the caller) which distance to the caller is lower than 20\nSee also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,\n\nagents_covering​\nPossible uses:​\n\nagents_covering (unknown) --->  list<agent>\n\nResult:​\nA list of agents covered by the operand (casted as a geometry).\nExamples:​\nlist<agent> var0 <- agents_covering(self); // var0 equals the agents that cover the shape of the agent applying the operator.\nSee also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,\n\nagents_crossing​\nPossible uses:​\n\nagents_crossing (unknown) --->  list<agent>\n\nResult:​\nA list of agents cross the operand (casted as a geometry).\nExamples:​\nlist<agent> var0 <- agents_crossing(self); // var0 equals the agents that crossing the shape of the agent applying the operator.\nSee also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,\n\nagents_inside​\nPossible uses:​\n\nagents_inside (unknown) --->  list<agent>\n\nResult:​\nA list of agents covered by the operand (casted as a geometry).\nExamples:​\nlist<agent> var0 <- agents_inside(self); // var0 equals the agents that are covered by the shape of the agent applying the operator.\nSee also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,\n\nagents_overlapping​\nPossible uses:​\n\nagents_overlapping (unknown) --->  list<agent>\n\nResult:​\nA list of agents overlapping the operand (casted as a geometry).\nExamples:​\nlist<agent> var0 <- agents_overlapping(self); // var0 equals the agents that overlap the shape of the agent applying the operator.\nSee also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping, at_distance,\n\nagents_partially_overlapping​\nPossible uses:​\n\nagents_partially_overlapping (unknown) --->  list<agent>\n\nResult:​\nA list of agents that partially overlap the operand (casted as a geometry).\nExamples:​\nlist<agent> var0 <- agents_partially_overlapping(self); // var0 equals the agents that partially overlap the shape of the agent applying the operator.\nSee also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,\n\nagents_touching​\nPossible uses:​\n\nagents_touching (unknown) --->  list<agent>\n\nResult:​\nA list of agents touching the operand (casted as a geometry).\nExamples:​\nlist<agent> var0 <- agents_touching(self); // var0 equals the agents that touch the shape of the agent applying the operator.\nSee also: agent_closest_to, agents_overlapping, closest_to, inside, overlapping,\n\nall_indexes_of​\nPossible uses:​\n\nlist all_indexes_of unknown --->  list\nall_indexes_of (list , unknown) --->  list\n\nResult:​\nall the index of all the occurences of the right operand in the left operand container\nComment:​\nThe definition of all_indexes_of and the type of the index depend on the container\nSpecial cases:​\n\nif the left operand is a list, all_indexes_of returns a list of all the indexes as integers\n\nlist var0 <- [1,2,3,1,2,3] all_indexes_of 1; // var0 equals [0,3] list var1 <- [1,2,3,1,2,3] all_indexes_of 4; // var1 equals []\nSee also: index_of, last_index_of,\n\nall_match​\nPossible uses:​\n\ncontainer all_match any expression --->  bool\nall_match (container , any expression) --->  bool\n\nResult:​\nReturns true if all the elements of the left-hand operand make the right-hand operand evaluate to true. Returns true if the left-hand operand is empty. 'c all_match each.property' is strictly equivalent to '(c count each.property)  = length(c)' but faster in most cases (as it is a shortcircuited operator)\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\nSpecial cases:​\n\nif the left-hand operand is nil, all_match throws an error\n\nExamples:​\nbool var0 <- [1,2,3,4,5,6,7,8] all_match (each > 3); // var0 equals false bool var1 <- [1::2, 3::4, 5::6] all_match (each > 4); // var1 equals false\nSee also: none_matches, one_matches, count,\n\nall_pairs_shortest_path​\nPossible uses:​\n\nall_pairs_shortest_path (graph) --->  matrix<int>\n\nResult:​\nreturns the successor matrix of shortest paths between all node pairs (rows: source, columns: target): a cell (i,j) will thus contains the next node in the shortest path between i and j.\nExamples:​\nmatrix<int> var0 <- all_pairs_shortest_paths(my_graph); // var0 equals shortest_paths_matrix will contain all pairs of shortest paths\n\nall_verify​\nSame signification as all_match\n\nalpha_index​\nPossible uses:​\n\nalpha_index (graph) --->  float\n\nResult:​\nreturns the alpha index of the graph (measure of connectivity which evaluates the number of cycles in a graph in comparison with the maximum number of cycles. The higher the alpha index, the more a network is connected: alpha = nb_cycles / (2*S-5) - planar graph)\nExamples:​\nfloat var1 <- alpha_index(graphEpidemio); // var1 equals the alpha index of the graph\nSee also: beta_index, gamma_index, nb_cycles, connectivity_index,\n\namong​\nPossible uses:​\n\nint among container --->  list\namong (int , container) --->  list\n\nResult:​\nReturns a list of length the value of the left-hand operand, containing random elements from the right-hand operand. As of GAMA 1.6, the order in which the elements are returned can be different than the order in which they appear in the right-hand container\nSpecial cases:​\n\nif the right-hand operand is empty, among returns a new empty list. If it is nil, it throws an error.\nif the left-hand operand is greater than the length of the right-hand operand, among returns the right-hand operand (converted as a list). If it is smaller or equal to zero, it returns an empty list\n\nExamples:​\nlist<int> var0 <- 3 among [1,2,4,3,5,7,6,8]; // var0 equals [1,2,8] (for example) list var1 <- 3 among g2; // var1 equals [node6,node11,node7] list var2 <- 3 among list(node); // var2 equals [node1,node11,node4] list<int> var3 <- 1 among [1::2,3::4]; // var3 equals 2 or 4\n\nand​\nPossible uses:​\n\nbool and any expression --->  bool\nand (bool , any expression) --->  bool\n\nResult:​\na bool value, equal to the logical and between the left-hand operand and the right-hand operand.\nComment:​\nboth operands are always casted to bool before applying the operator. Thus, an expression like (1 and 0) is accepted and returns false.\nExamples:​\nbool var0 <- true and false; // var0 equals false bool var1 <- false and false; // var1 equals false bool var2 <- false and true; // var2 equals false bool var3 <- true and true; // var3 equals true  int a <-3 ; int b <- 4; int c <- 7; bool var5 <- ((a+b) = c ) and ((a+b) > c ); // var5 equals false\nSee also: bool, or, !,\n\nand​\nPossible uses:​\n\npredicate and predicate --->  predicate\nand (predicate , predicate) --->  predicate\n\nResult:​\ncreate a new predicate from two others by including them as subintentions\nExamples:​\npredicate1 and predicate2\n\nangle_between​\nPossible uses:​\n\nangle_between (point, point, point) --->  float\n\nResult:​\nthe angle between vectors P0P1 and P0P2 (P0, P1, P2 being the three point operands)\nExamples:​\nfloat var0 <- angle_between({5,5},{10,5},{5,10}); // var0 equals 90\n\nantialiased​\nPossible uses:​\n\nantialiased (image) --->  image\n\nResult:​\nApplication of a very light blur kernel that acts like an anti-aliasing filter when applied to an image. This operation can be applied multiple times in a row if greater.\n\nany​\nSame signification as one_of\n\nany_location_in​\nPossible uses:​\n\nany_location_in (geometry) --->  point\n\nResult:​\nA point inside (or touching) the operand-geometry.\nExamples:​\npoint var0 <- any_location_in(square(5)); // var0 equals a point in the square, for example : {3,4.6}.\nSee also: closest_points_with, farthest_point_to, points_at,\n\nany_point_in​\nSame signification as any_location_in\n\nappend_horizontally​\nPossible uses:​\n\nmatrix append_horizontally matrix --->  matrix\nappend_horizontally (matrix , matrix) --->  matrix\n\nResult:​\nA matrix resulting from the concatenation of the rows of the two given matrices.\n\nappend_vertically​\nPossible uses:​\n\nmatrix append_vertically matrix --->  matrix\nappend_vertically (matrix , matrix) --->  matrix\n\nResult:​\nA matrix resulting from the concatenation of the columns  of the two given matrices.\nExamples:​\nmatrix var0 <- matrix([[1,2],[3,4]]) append_vertically matrix([[1,2],[3,4]]); // var0 equals matrix([[1,2,1,2],[3,4,3,4]])\n\narc​\nPossible uses:​\n\narc (float, float, float) --->  geometry\narc (float, float, float, bool) --->  geometry\n\nResult:​\nAn arc, which radius is equal to the first operand, heading to the second, amplitude to the third and a boolean indicating whether to return a linestring or a polygon to the fourth\nComment:​\nthe center of the arc is by default the location of the current agent in which has been called this operator. This operator returns a polygon by default.the center of the arc is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if the radius operand is lower or equal to 0.\nreturns a point if the radius operand is lower or equal to 0.\n\nExamples:​\ngeometry var0 <- arc(4,45,90); // var0 equals a geometry as an arc of radius 4, in a direction of 45° and an amplitude of 90° geometry var1 <- arc(4,45,90, false); // var1 equals a geometry as an arc of radius 4, in a direction of 45° and an amplitude of 90°, which only contains the points on the arc\nSee also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,\n\naround​\nPossible uses:​\n\nfloat around unknown --->  geometry\naround (float , unknown) --->  geometry\n\nResult:​\nA geometry resulting from the difference between a buffer around the right-operand casted in geometry at a distance left-operand (right-operand buffer left-operand) and the right-operand casted as geometry.\nSpecial cases:​\n\nreturns a circle geometry of radius right-operand if the left-operand is nil\n\nExamples:​\ngeometry var0 <- 10 around circle(5); // var0 equals the ring geometry between 5 and 10.\nSee also: circle, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,\n\nas​\nPossible uses:​\n\nunknown as any GAML type --->  unknown\nas (unknown , any GAML type) --->  unknown\n\nResult:​\nCasting of the first argument into a given type\nComment:​\nIt is equivalent to the application of the type operator on the left operand.\nExamples:​\nint var0 <- 3.5 as int; // var0 equals int(3.5)\n\nas_4_grid​\nPossible uses:​\n\ngeometry as_4_grid point --->  matrix\nas_4_grid (geometry , point) --->  matrix\n\nResult:​\nA matrix of square geometries (grid with 4-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)\nExamples:​\nmatrix var0 <- self as_4_grid {10, 5}; // var0 equals the matrix of square geometries (grid with 4-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.\nSee also: as_grid, as_hexagonal_grid,\n\nas_distance_graph​\nPossible uses:​\n\ncontainer as_distance_graph float --->  graph\nas_distance_graph (container , float) --->  graph\nas_distance_graph (container, float, species) --->  graph\n\nResult:​\ncreates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices close enough (less than a distance, right-hand operand).\nComment:​\nas_distance_graph is more efficient for a list of points than as_intersection_graph.\nExamples:​\nlist(ant) as_distance_graph 3.0\nSee also: as_intersection_graph, as_edge_graph,\n\nas_driving_graph​\nPossible uses:​\n\ncontainer as_driving_graph container --->  graph\nas_driving_graph (container , container) --->  graph\n\nResult:​\ncreates a graph from the list/map of edges given as operand and connect the node to the edge\nExamples:​\nas_driving_graph(road, node)  --:  build a graph while using the road agents as edges and the node agents as nodes\nSee also: as_intersection_graph, as_distance_graph, as_edge_graph,\n\nas_edge_graph​\nPossible uses:​\n\nas_edge_graph (container) --->  graph\nas_edge_graph (map) --->  graph\ncontainer as_edge_graph container --->  graph\nas_edge_graph (container , container) --->  graph\ncontainer as_edge_graph float --->  graph\nas_edge_graph (container , float) --->  graph\n\nResult:​\ncreates a graph from the list/map of edges given as operand\nSpecial cases:​\n\nif the operand is a list, the graph will be built with elements of the list as edges\n\ngraph var0 <- as_edge_graph([line([{1,5},{12,45}]),line([{12,45},{34,56}])]); // var0 equals a graph with two edges and three vertices\n\nif the operand is a map, the graph will be built by creating edges from pairs of the map\n\ngraph var1 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); // var1 equals a graph with these three vertices and two edges\n\nif the operand is a list and a tolerance (max distance in meters to consider that 2 points are the same node) is given, the graph will be built with elements of the list as edges and two edges will be connected by a node if the distance between their extremity (first or last points) are at distance lower or equal to the tolerance\n\ngraph var2 <- as_edge_graph([line([{1,5},{12,45}]),line([{13,45},{34,56}])],1); // var2 equals a graph with two edges and three vertices\nSee also: as_intersection_graph, as_distance_graph,\n\nas_grid​\nPossible uses:​\n\ngeometry as_grid point --->  matrix\nas_grid (geometry , point) --->  matrix\n\nResult:​\nA matrix of square geometries (grid with 8-neighborhood) with dimension given by the right-hand operand ({nb_cols, nb_lines}) corresponding to the square tessellation of the left-hand operand geometry (geometry, agent)\nExamples:​\nmatrix var0 <- self as_grid {10, 5}; // var0 equals a matrix of square geometries (grid with 8-neighborhood) with 10 columns and 5 lines corresponding to the square tessellation of the geometry of the agent applying the operator.\nSee also: as_4_grid, as_hexagonal_grid,\n\nas_hexagonal_grid​\nPossible uses:​\n\ngeometry as_hexagonal_grid point --->  list<geometry>\nas_hexagonal_grid (geometry , point) --->  list<geometry>\n\nResult:​\nA list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry\nExamples:​\nlist<geometry> var0 <- self as_hexagonal_grid {10, 5}; // var0 equals list of geometries (hexagonal) corresponding to the hexagonal tesselation of the first operand geometry\nSee also: as_4_grid, as_grid,\n\nas_int​\nPossible uses:​\n\nstring as_int int --->  int\nas_int (string , int) --->  int\n\nResult:​\nparses the string argument as a signed integer in the radix specified by the second argument.\nSpecial cases:​\n\nif the left operand is nil or empty, as_int returns 0\nif the left operand does not represent an integer in the specified radix, as_int throws an exception\n\nExamples:​\nint var0 <- '20' as_int 10; // var0 equals 20 int var1 <- '20' as_int 8; // var1 equals 16 int var2 <- '20' as_int 16; // var2 equals 32 int var3 <- '1F' as_int 16; // var3 equals 31 int var4 <- 'hello' as_int 32; // var4 equals 18306744\nSee also: int,\n\nas_intersection_graph​\nPossible uses:​\n\ncontainer as_intersection_graph float --->  graph\nas_intersection_graph (container , float) --->  graph\nas_intersection_graph (container, float, species) --->  graph\n\nResult:​\ncreates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).\ncreates a graph from a list of vertices (left-hand operand). An edge is created between each pair of vertices with an intersection (with a given tolerance).\nComment:​\nas_intersection_graph is more efficient for a list of geometries (but less accurate) than as_distance_graph.\nExamples:​\nlist(ant) as_intersection_graph 0.5\nSee also: as_distance_graph, as_edge_graph,\n\nas_json_string​\nPossible uses:​\n\nas_json_string (container) --->  string\n\nResult:​\nTries to convert the container into a json-formatted string\nSpecial cases:​\n\nWith a map:\n\nstring var0 <- as_json_string(map('int_value'::1, 'string_value'::'some words', 'tab'::[1, 2, 3])); // var0 equals {\"int_value\":1,\"string_value\":\"some words\",\"tab\":[1,2,3]}\n\nWith an array:\n\nstring var1 <- as_json_string([1, 2, 3, 'some words']); // var1 equals [1,2,3,\"some words\"]\n\nas_map​\nPossible uses:​\n\ncontainer as_map any expression --->  map\nas_map (container , any expression) --->  map\n\nResult:​\nproduces a new map from the evaluation of the right-hand operand for each element of the left-hand operand\nComment:​\nthe right-hand operand should be a pair\nSpecial cases:​\n\nif the left-hand operand is nil, as_map throws an error.\n\nExamples:​\nmap<int,int> var0 <- [1,2,3,4,5,6,7,8] as_map (each::(each * 2)); // var0 equals [1::2, 2::4, 3::6, 4::8, 5::10, 6::12, 7::14, 8::16] map<int,int> var1 <- [1::2,3::4,5::6] as_map (each::(each * 2)); // var1 equals [2::4, 4::8, 6::12] \n\nas_matrix​\nPossible uses:​\n\nunknown as_matrix point --->  matrix\nas_matrix (unknown , point) --->  matrix\n\nResult:​\ncasts the left operand into a matrix with right operand as preferred size\nComment:​\nThis operator is very useful to cast a file containing raster data into a matrix.Note that both components of the right operand point should be positive, otherwise an exception is raised.The operator as_matrix creates a matrix of preferred size. It fills in it with elements of the left operand until the matrix is full If the size is to short, some elements will be omitted. Matrix remaining elements will be filled in by nil.\nSpecial cases:​\n\nif the right operand is nil, as_matrix is equivalent to the matrix operator\n\nSee also: matrix,\n\nas_path​\nPossible uses:​\n\nlist<geometry> as_path graph --->  path\nas_path (list<geometry> , graph) --->  path\n\nResult:​\ncreate a graph path from the list of shape\nExamples:​\npath var0 <- [road1,road2,road3] as_path my_graph; // var0 equals a path road1->road2->road3 of my_graph\n\nas_spatial_graph​\nPossible uses:​\n\nas_spatial_graph (graph) --->  msi.gama.metamodel.topology.graph.ISpatialGraph\n\nResult:​\nCreates a spatial graph out of an arbitrary graph. If the argument is already a spatial graph, returns it unchanged. If it contains geometrical nodes or edges, they are kept unchanged\n\nasin​\nPossible uses:​\n\nasin (float) --->  float\nasin (int) --->  float\n\nResult:​\nthe arcsin of the operand\nSpecial cases:​\n\nif the right-hand operand is outside of the [-1,1] interval, returns NaN\n\nExamples:​\nfloat var0 <- asin (0); // var0 equals 0.0 float var1 <- asin (90); // var1 equals #nan\nSee also: acos, atan, sin,\n\nat​\nPossible uses:​\n\nlist at int --->  unknown\nat (list , int) --->  unknown\ncontainer at unknown --->  unknown\nat (container , unknown) --->  unknown\nstring at int --->  string\nat (string , int) --->  string\nmatrix at point --->  unknown\nat (matrix , point) --->  unknown\nspecies at int --->  agent\nat (species , int) --->  agent\n\nResult:​\nthe element at the right operand index of the container\nComment:​\nThe first element of the container is located at the index 0. In addition, if the user tries to get the element at an index higher or equals than the length of the container, he will get an IndexOutOfBoundException.The at operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a file, at returns the element of the file content at the index specified by the right operand\nif it is a population, at returns the agent at the index specified by the right operand\nif it is a graph and if the right operand is a node, at returns the in and out edges corresponding to that node\nif it is a graph and if the right operand is an edge, at returns the pair node_out::node_in of the edge\nif it is a graph and if the right operand is a pair node1::node2, at returns the edge from node1 to node2 in the graph\nif it is a list or a matrix, at returns the element at the index specified by the right operand\n\nint var0 <- [1, 2, 3] at 2; // var0 equals 3 point var1 <- [{1,2}, {3,4}, {5,6}] at 0; // var1 equals {1.0,2.0}\nExamples:​\nstring var2 <- 'abcdef' at 0; // var2 equals 'a'\nSee also: contains_all, contains_any,\n\nat_distance​\nPossible uses:​\n\ncontainer<unknown,geometry> at_distance float --->  list<geometry>\nat_distance (container<unknown,geometry> , float) --->  list<geometry>\n\nResult:​\nA list of agents or geometries among the left-operand list that are located at a distance <= the right operand from the caller agent (in its topology)\nExamples:​\nlist<geometry> var0 <- [ag1, ag2, ag3] at_distance 20; // var0 equals the agents of the list located at a distance <= 20 from the caller agent (in the same order).\nSee also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, overlapping,\n\nat_location​\nPossible uses:​\n\ngeometry at_location point --->  geometry\nat_location (geometry , point) --->  geometry\n\nResult:​\nA geometry resulting from the tran of a translation to the right-hand operand point of the left-hand operand (geometry, agent, point)\nExamples:​\ngeometry var0 <- self at_location {10, 20}; // var0 equals the geometry resulting from a translation to the location {10, 20} of the left-hand geometry (or agent). float var1 <-  (box({10, 10 , 5}) at_location point(50,50,0)).location.x; // var1 equals 50.0\n\natan​\nPossible uses:​\n\natan (float) --->  float\natan (int) --->  float\n\nResult:​\nReturns the value (in the interval [-90,90], in decimal degrees) of the arctan of the operand (which can be any real number).\nExamples:​\nfloat var0 <- atan (1); // var0 equals 45.0\nSee also: acos, asin, tan,\n\natan2​\nPossible uses:​\n\nfloat atan2 float --->  float\natan2 (float , float) --->  float\n\nResult:​\nthe atan2 value of the two operands.\nComment:​\nThe function atan2 is the arctangent function with two arguments. The purpose of using two arguments instead of one is to gather information on the signs of the inputs in order to return the appropriate quadrant of the computed angle, which is not possible for the single-argument arctangent function. Beware: the first argument is y and the second is x\nExamples:​\nfloat var0 <- atan2 (0,0); // var0 equals 0.0 float var1 <- atan2 (0,1); // var1 equals 0.0 float var2 <- atan2 (0,-1); // var2 equals 180.0 float var3 <- atan2 (1,0); // var3 equals 90.0 float var4 <- atan2 (1,1); // var4 equals 45.0 float var5 <- atan2 (1,-1); // var5 equals 135.0 float var6 <- atan2 (-1,0); // var6 equals -90.0 float var7 <- atan2 (-1,1); // var7 equals -45.0 float var8 <- atan2 (-1,-1); // var8 equals -135.0\nSee also: atan, acos, asin,\n\nattributes​\nPossible uses:​\n\nattributes (any) --->  attributes\n\nResult:​\ncasts the operand in a attributes object.\n\nauto_correlation​\nPossible uses:​\n\ncontainer auto_correlation int --->  float\nauto_correlation (container , int) --->  float\n\nResult:​\nReturns the auto-correlation of a data sequence given some lag\nExamples:​\nfloat var0 <- auto_correlation([1,0,1,0,1,0],2); // var0 equals 1 float var1 <- auto_correlation([1,0,1,0,1,0],1); // var1 equals -1"},{"filePath":"https:--gama-platform.org--wiki-OperatorsBC.txt","text":"Operators (B to C)\nThis file is automatically generated from java files. Do Not Edit It.\n\nDefinition​\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.\nMost of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).\nThe ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.  - 10, ! (operand1 or operand2)).\nFinally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n\nif they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))\nif they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.\nif they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\nPriority between operators​\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n\nthe constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values.\nit is followed by the ?: operator, the functional if-else (e.g.  a > b ? a + 10 : a - 10 will return the result of the if-else).\nnext are the logical operators, and and or (e.g. a > b or b > c will return the value of the test)\nnext are the comparison operators (i.e. >, <, <=, >=, =, !=)\nnext the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\nnext the unary operators - and !\nnext the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)\nand finally the functional operators, which have the highest priority of all.\n\n\nUsing actions as operators​\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\nFor instance, if the following species is defined:\nspecies spec1 {        int min(int x, int y) {                return x > y ? x : y;        }}\nAny agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\nglobal {        init {                create spec1;                spec1 my_agent <- spec1[0];                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);        }}\nIf the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\nTable of Contents​\n\nOperators by categories​\n\n3D​\nbox, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,\n\nArithmetic operators​\n-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,\n\nBDI​\nadd_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,\n\nCasting operators​\nas, as_int, as_matrix, field_with, font, is, is_skill, list_with, matrix_with, species_of, to_gaml, to_geojson, to_list, with_size, with_style,\n\nColor-related operators​\n-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum, to_hsb,\n\nComparison operators​\n!=, <, <=, =, >, >=, between,\n\nContainers-related operators​\n-, ::, +, accumulate, all_match, among, as_json_string, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,\n\nDate-related operators​\n-, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,\n\nDates​\n\nDisplays​\nhorizontal, stack, vertical,\n\nedge​\nedge_between, strahler,\n\nEDP-related operators​\ndiff, diff2,\n\nFiles-related operators​\nagent_file, copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_agent, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_shape, is_simulation, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, shape_file, simulation_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,\n\nGamaMetaType​\ntype_of,\n\nGamaSVGFile​\nimage,\n\nGraphs-related operators​\nadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,\n\nGrid-related operators​\nas_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,\n\nImageOperators​\n*, antialiased, blend, blurred, brighter, clipped_with, darker, grayscale, horizontal_flip, image, matrix, rotated_by, sharpened, snapshot, tinted_with, vertical_flip, with_height, with_size, with_width,\n\nIterator operators​\naccumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,\n\nList-related operators​\nall_indexes_of, copy_between, index_of, last_index_of,\n\nLogical operators​\n:, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,\n\nMap comparaison operators​\nfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,\n\nMap-related operators​\nas_map, create_map, index_of, last_index_of,\n\nMatrix-related operators​\n-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, flatten, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,\n\nmulticriteria operators​\nelectre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,\n\nPath-related operators​\nagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,\n\nPedestrian​\ngenerate_pedestrian_network,\n\nPoints-related operators​\n-, /, *, +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,\n\nRandom operators​\nbinomial, exp_density, exp_rnd, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,\n\nReverseOperators​\nserialize,\n\nShape​\narc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,\n\nSpatial operators​\n-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, k_nearest_neighbors, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,\n\nSpatial properties operators​\ncovers, crosses, intersects, partially_overlaps, touches,\n\nSpatial queries operators​\nagent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,\n\nSpatial relations operators​\ndirection_between, distance_between, distance_to, path_between, path_to, towards,\n\nSpatial statistical operators​\nhierarchical_clustering, k_nearest_neighbors, simple_clustering_by_distance,\n\nSpatial transformations operators​\n-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,\n\nSpecies-related operators​\nindex_of, last_index_of, of_generic_species, of_species,\n\nStatistical operators​\nauto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, k_nearest_neighbors, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, morrisAnalysis, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, residuals, rms, rSquare, simple_clustering_by_distance, skewness, sobolAnalysis, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,\n\nStrings-related operators​\n+, <, <=, >, >=, at, capitalize, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,\n\nSubModel​\nload_sub_model,\n\nSystem​\n., choose, command, copy, copy_from_clipboard, copy_to_clipboard, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, play_sound, user_confirm, user_input_dialog, wizard, wizard_page,\n\nTime-related operators​\ndate, string,\n\nTypes-related operators​\naction, agent, attributes, BDIPlan, bool, container, conversation, directory, emotion, file, float, gaml_type, geometry, graph, int, kml, list, map, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, topology, unknown,\n\nUser control operators​\nchoose, enter, user_confirm, user_input_dialog, wizard, wizard_page,\n\nOperators​\n\nBDIPlan​\nPossible uses:​\n\nBDIPlan (any) --->  BDIPlan\n\nResult:​\ncasts the operand in a BDIPlan object.\n\nbefore​\nPossible uses:​\n\nbefore (date) --->  bool\nany expression before date --->  bool\nbefore (any expression , date) --->  bool\n\nResult:​\nReturns true if the current_date of the model is strictly before the date passed in argument. Synonym of 'current_date < argument'\nExamples:​\nreflex when: before(starting_date) {} \t// this reflex will never be run\n\nbeta​\nPossible uses:​\n\nfloat beta float --->  float\nbeta (float , float) --->  float\n\nResult:​\nReturns the beta function with arguments a, b.\nComment:​\nChecked on R. beta(4,5)\nExamples:​\nfloat var0 <- beta(4,5) with_precision(4); // var0 equals 0.0036\n\nbeta_index​\nPossible uses:​\n\nbeta_index (graph) --->  float\n\nResult:​\nreturns the beta index of the graph (Measures the level of connectivity in a graph and is expressed by the relationship between the number of links (e) over the number of nodes (v) : beta = e/v.\nExamples:​\ngraph graphEpidemio <- graph([]); float var1 <- beta_index(graphEpidemio); // var1 equals the beta index of the graph\nSee also: alpha_index, gamma_index, nb_cycles, connectivity_index,\n\nbetween​\nSame signification as copy_between\nPossible uses:​\n\ndate between date --->  bool\nbetween (date , date) --->  bool\nbetween (date, date, date) --->  bool\nbetween (int, int, int) --->  bool\nbetween (any expression, date, date) --->  bool\nbetween (float, float, float) --->  bool\n\nResult:​\nreturns true the first operand is bigger than the second operand and smaller than the third operand\nSpecial cases:​\n\nreturns true if the first operand is between the two dates passed in arguments (both exclusive). Can be combined with 'every' to express a frequency between two dates\n\nbool var0 <- (date('2016-01-01') between(date('2000-01-01'), date('2020-02-02'))); // var0 equals true // will return true every new day between these two dates, taking the first one as the starting point every(#day between(date('2000-01-01'), date('2020-02-02'))) \n\nWith only 2 date operands, it returns true if the current_date is between the 2 date  operands.\n\nbool var3 <- between(date('2000-01-01'), date('2020-02-02')); // var3 equals false\nExamples:​\nbool var4 <- between(5, 1, 10); // var4 equals true bool var5 <- between(5.0, 1.0, 10.0); // var5 equals true\n\nbetweenness_centrality​\nPossible uses:​\n\nbetweenness_centrality (graph) --->  map\n\nResult:​\nreturns a map containing for each vertex (key), its betweenness centrality (value): number of shortest paths passing through each vertex\nExamples:​\ngraph graphEpidemio <- graph([]); map var1 <- betweenness_centrality(graphEpidemio); // var1 equals the betweenness centrality index of the graph\n\nbiggest_cliques_of​\nPossible uses:​\n\nbiggest_cliques_of (graph) --->  list<list>\n\nResult:​\nreturns the biggest cliques of a graph using the Bron-Kerbosch clique detection algorithm\nExamples:​\ngraph my_graph <- graph([]); list<list> var1 <- biggest_cliques_of (my_graph); // var1 equals the list of the biggest cliques as list\nSee also: maximal_cliques_of,\n\nbinomial​\nPossible uses:​\n\nint binomial float --->  int\nbinomial (int , float) --->  int\n\nResult:​\nA value from a random variable following a binomial distribution. The operands represent the number of experiments n and the success probability p.\nComment:​\nThe binomial distribution is the discrete probability distribution of the number of successes in a sequence of n independent yes/no experiments, each of which yields success with probability p, cf. Binomial distribution on Wikipedia.\nExamples:​\nint var0 <- binomial(15,0.6); // var0 equals a random positive integer\nSee also: gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd,\n\nbinomial_coeff​\nPossible uses:​\n\nint binomial_coeff int --->  float\nbinomial_coeff (int , int) --->  float\n\nResult:​\nReturns n choose k as a double. Note the integerization of the double return value.\nExamples:​\nfloat var0 <- binomial_coeff(10,2); // var0 equals 45\n\nbinomial_complemented​\nPossible uses:​\n\nbinomial_complemented (int, int, float) --->  float\n\nResult:​\nReturns the sum of the terms k+1 through n of the Binomial probability density, where n is the number of trials and P is the probability of success in the range 0 to 1.\nExamples:​\nfloat var0 <- binomial_complemented(10,5,0.5) with_precision(2); // var0 equals 0.38\n\nbinomial_sum​\nPossible uses:​\n\nbinomial_sum (int, int, float) --->  float\n\nResult:​\nReturns the sum of the terms 0 through k of the Binomial probability density, where n is the number of trials and p is the probability of success in the range 0 to 1.\nExamples:​\nfloat var0 <- binomial_sum(5,10,0.5) with_precision(2); // var0 equals 0.62\n\nblend​\nPossible uses:​\n\nrgb blend rgb --->  rgb\nblend (rgb , rgb) --->  rgb\nblend (rgb, rgb, float) --->  rgb\n\nResult:​\nBlend two colors with an optional ratio (c1 * r + c2 * (1 - r)) between 0 and 1\nSpecial cases:​\n\nIf the ratio is omitted, an even blend is done\n\nrgb var0 <- blend(#red, #blue); // var0 equals to a color very close to the purple\nExamples:​\nrgb var1 <- blend(#red, #blue, 0.3); // var1 equals to a color between the purple and the blue\nSee also: rgb, hsb,\n\nblend​\nPossible uses:​\n\nblend (image, image, float) --->  image\n\nResult:​\nBlend two images with an optional ratio between 0 and 1 (determines the transparency of the second image, applied as an overlay to the first). The size of the resulting image is that of the first parameter. The original image is left untouched\nExamples:​\nimage var0 <- blend(img1, img2, 0.3); // var0 equals to a composed image with the two\n\nblurred​\nPossible uses:​\n\nblurred (image) --->  image\n\nResult:​\nApplication of a blurrying filter to the image passed in parameter. This operation can be applied multiple times. The original image is left untouched\n\nbool​\nPossible uses:​\n\nbool (any) --->  bool\n\nResult:​\ncasts the operand in a bool object.\n\nbox​\nPossible uses:​\n\nbox (point) --->  geometry\nbox (float, float, float) --->  geometry\n\nResult:​\nA box geometry which side sizes are given by the operands.\nComment:​\nthe center of the box is by default the location of the current agent in which has been called this operator.the center of the box is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\nreturns nil if the operand is nil.\n\nExamples:​\ngeometry var0 <- box(10, 5 , 5); // var0 equals a geometry as a rectangle with width = 10, height = 5 depth= 5. geometry var1 <- box({10, 5 , 5}); // var1 equals a geometry as a rectangle with width = 10, height = 5 depth= 5. float var2 <-  (box({10, 10 , 5}) at_location point(50,50,0)).location.y; // var2 equals 50.0\nSee also: around, circle, sphere, cone, line, link, norm, point, polygon, polyline, square, cube, triangle,\n\nbrewer_colors​\nPossible uses:​\n\nbrewer_colors (string) --->  list<rgb>\nstring brewer_colors int --->  list<rgb>\nbrewer_colors (string , int) --->  list<rgb>\n\nResult:​\nBuild a list of colors of a given type (see website http://colorbrewer2.org/). The list of palettes can be obtained by calling brewer_palettes. This list can be safely modified afterwards (adding or removing colors)\nBuild a list of colors of a given type (see website http://colorbrewer2.org/) with a given number of classes\nExamples:​\nlist<rgb> var0 <- list<rgb> colors <- brewer_colors(\"OrRd\");; // var0 equals a list of 6 blue colors list<rgb> var1 <- list<rgb> colors <- brewer_colors(\"Pastel1\", 5);; // var1 equals a list of 5 sequential colors in the palette named 'Pastel1'. The list of palettes can be obtained by calling brewer_palettes\nSee also: brewer_palettes,\n\nbrewer_palettes​\nPossible uses:​\n\nbrewer_palettes (int) --->  list<string>\nint brewer_palettes int --->  list<string>\nbrewer_palettes (int , int) --->  list<string>\n\nResult:​\nreturns the list a palette with a given min number of classes)\nreturns the list a palette with a given min number of classes and max number of classes)\nExamples:​\nlist<string> var0 <- list<string> palettes <- brewer_palettes(3);; // var0 equals a list of palettes that are composed of a min of 3 colors list<string> var1 <- list<string> palettes <- brewer_palettes(5,10);; // var1 equals a list of palettes that are composed of a min of 5 colors and a max of 10 colors\nSee also: brewer_colors,\n\nbrighter​\nPossible uses:​\n\nbrighter (image) --->  image\n\nResult:​\nUsed to return an image 10% brigther. This operation can be applied multiple times in a row if greater than 10% changes in brightness are desired.\n\nbuffer​\nSame signification as +\n\nbuild​\nPossible uses:​\n\nbuild (matrix) --->  regression\n\nResult:​\nreturns the regression build from the matrix data (a row = an instance, the first value of each line is the y value) while using the given ordinary least squares method. Usage: build(data)\nExamples:​\nbuild(matrix([[1.0,2.0,3.0,4.0],[2.0,3.0,4.0,2.0]]))\n\ncapitalize​\nPossible uses:​\n\ncapitalize (string) --->  string\n\nResult:​\nReturns a string where the first letter is capitalized\nExamples:​\nstring var0 <- capitalize(\"abc\"); // var0 equals 'Abc'\nSee also: lower_case, upper_case,\n\ncartesian_product​\nPossible uses:​\n\ncartesian_product (list) --->  unknown\n\n\nceil​\nPossible uses:​\n\nceil (float) --->  float\n\nResult:​\nMaps the operand to the smallest following integer, i.e. the smallest integer not less than x.\nExamples:​\nfloat var0 <- ceil(3); // var0 equals 3.0 float var1 <- ceil(3.5); // var1 equals 4.0 float var2 <- ceil(-4.7); // var2 equals -4.0\nSee also: floor, round,\n\ncell_at​\nPossible uses:​\n\nfield cell_at point --->  geometry\ncell_at (field , point) --->  geometry\ncell_at (field, int, int) --->  geometry\n\n\ncells_in​\nPossible uses:​\n\nfield cells_in geometry --->  list<geometry>\ncells_in (field , geometry) --->  list<geometry>\n\n\ncells_overlapping​\nPossible uses:​\n\nfield cells_overlapping geometry --->  list<geometry>\ncells_overlapping (field , geometry) --->  list<geometry>\n\n\ncentroid​\nPossible uses:​\n\ncentroid (geometry) --->  point\n\nResult:​\nCentroid (weighted sum of the centroids of a decomposition of the area into triangles) of the operand-geometry. Can be different to the location of the geometry\nExamples:​\npoint var0 <- centroid(world); // var0 equals the centroid of the square, for example : {50.0,50.0}.\nSee also: any_location_in, closest_points_with, farthest_point_to, points_at,\n\nchar​\nPossible uses:​\n\nchar (int) --->  string\n\nSpecial cases:​\n\nconverts ACSII integer value to character\n\nstring var0 <- char (34); // var0 equals '\"'\n\nchi_square​\nPossible uses:​\n\nfloat chi_square float --->  float\nchi_square (float , float) --->  float\n\nResult:​\nReturns the area under the left hand tail (from 0 to x) of the Chi square probability density function with df degrees of freedom.\nExamples:​\nfloat var0 <- chi_square(20.0,10) with_precision(3); // var0 equals 0.971\n\nchi_square_complemented​\nPossible uses:​\n\nfloat chi_square_complemented float --->  float\nchi_square_complemented (float , float) --->  float\n\nResult:​\nReturns the area under the right hand tail (from x to infinity) of the Chi square probability density function with df degrees of freedom.\nExamples:​\nfloat var0 <- chi_square_complemented(2,10) with_precision(3); // var0 equals 0.996\n\nchoose​\nPossible uses:​\n\nchoose (string, any GAML type, unknown, list) --->  unknown\n\nResult:​\nAllows the user to choose a value by specifying a title, a type, and a list of possible values\n\ncircle​\nPossible uses:​\n\ncircle (float) --->  geometry\nfloat circle point --->  geometry\ncircle (float , point) --->  geometry\n\nResult:​\nA circle geometry which radius is equal to the operand.\nComment:​\nthe center of the circle is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if the radius operand is lower or equal to 0.\nWhen circle is used with 2 operands, the second one is the center of the created circle.\n\ngeometry var1 <- circle(10,{80,30}); // var1 equals a geometry as a circle of radius 10, the center will be in the location {80,30}.\nExamples:​\ngeometry var0 <- circle(10); // var0 equals a geometry as a circle of radius 10.\nSee also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,\n\nclean​\nPossible uses:​\n\nclean (geometry) --->  geometry\n\nResult:​\nA geometry corresponding to the cleaning of the operand (geometry, agent, point)\nComment:​\nThe cleaning corresponds to a buffer with a distance of 0.0\nExamples:​\ngeometry var0 <- clean(self); // var0 equals returns the geometry resulting from the cleaning of the geometry of the agent applying the operator.\n\nclean_network​\nPossible uses:​\n\nclean_network (list<geometry>, float, bool, bool) --->  list<geometry>\n\nResult:​\nA list of polylines corresponding to the cleaning of the first operand (list of polyline geometry or agents), considering the tolerance distance given by the second operand; the third operator is used to define if the operator should as well split the lines at their intersections(true to split the lines); the last operandis used to specify if the operator should as well keep only the main connected component of the network. Usage: clean_network(lines:list of geometries or agents, tolerance: float, split_lines: bool, keepMainConnectedComponent: bool)\nComment:​\nThe cleaned set of polylines\nExamples:​\nlist<geometry> var0 <- clean_network(my_road_shapefile.contents, 1.0, true, false); // var0 equals returns the list of polulines resulting from the cleaning of the geometry of the agent applying the operator with a tolerance of 1m, and splitting the lines at their intersections. list<geometry> var1 <- clean_network([line({10,10}, {20,20}), line({10,20},{20,10})],3.0,true,false); // var1 equals [line({10.0,20.0,0.0},{15.0,15.0,0.0}),line({15.0,15.0,0.0},{20.0,10.0,0.0}), line({10.0,10.0,0.0},{15.0,15.0,0.0}), line({15.0,15.0,0.0},{20.0,20.0,0.0})]\n\nclipped_with​\nPossible uses:​\n\nclipped_with (image, int, int, int, int) --->  image\n\nResult:​\nUsed to crop the given image using a rectangle starting at the top-left x, y coordinates and expanding using the width and height. If one of the dimensions of the resulting image is 0, of if they are equal to that of the given image, returns it.  The original image is left untouched\n\nclosest_points_with​\nPossible uses:​\n\ngeometry closest_points_with geometry --->  list<point>\nclosest_points_with (geometry , geometry) --->  list<point>\n\nResult:​\nA list of two closest points between the two geometries.\nExamples:​\nlist<point> var0 <- geom1 closest_points_with(geom2); // var0 equals [pt1, pt2] with pt1 the closest point of geom1 to geom2 and pt1 the closest point of geom2 to geom1\nSee also: any_location_in, any_point_in, farthest_point_to, points_at,\n\nclosest_to​\nPossible uses:​\n\ncontainer<unknown,geometry> closest_to geometry --->  geometry\nclosest_to (container<unknown,geometry> , geometry) --->  geometry\nclosest_to (container<unknown,geometry>, geometry, int) --->  list<geometry>\n\nResult:​\nAn agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the closest to the operand (casted as a geometry).\nThe N agents or geometries among the left-operand list of agents, species or meta-population (addition of species), that are the closest to the operand (casted as a geometry).\nComment:​\nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.the distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\nExamples:​\ngeometry var0 <- [ag1, ag2, ag3] closest_to(self); // var0 equals return the closest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self list<geometry> var2 <- [ag1, ag2, ag3] closest_to(self, 2); // var2 equals return the 2 closest agents among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to (self, 5)\nSee also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to,\n\ncollect​\nPossible uses:​\n\ncontainer collect any expression --->  list\ncollect (container , any expression) --->  list\n\nResult:​\nreturns a new list, in which each element is the evaluation of the right-hand operand.\nComment:​\ncollect is similar to accumulate except that accumulate always produces flat lists if the right-hand operand returns a list.In addition, collect can be applied to any container.\nSpecial cases:​\n\nif the left-hand operand is nil, collect throws an error\n\nExamples:​\nlist var0 <- [1,2,4] collect (each *2); // var0 equals [2,4,8] list var1 <- [1,2,4] collect ([2,4]); // var1 equals [[2,4],[2,4],[2,4]] list var2 <- [1::2, 3::4, 5::6] collect (each + 2); // var2 equals [4,6,8] list var3 <- (list(node) collect (node(each).location.x * 2); // var3 equals the list of nodes with their x multiplied by 2\nSee also: accumulate,\n\ncolumn_at​\nPossible uses:​\n\nmatrix<unknown> column_at int --->  list<unknown>\ncolumn_at (matrix<unknown> , int) --->  list<unknown>\n\nResult:​\nreturns the column at a num_col (right-hand operand)\nExamples:​\nlist<unknown> var0 <- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) column_at 2; // var0 equals [\"el31\",\"el32\",\"el33\"]\nSee also: row_at, rows_list,\n\ncolumns_list​\nPossible uses:​\n\ncolumns_list (matrix<unknown>) --->  list<list<unknown>>\n\nResult:​\nreturns a list of the columns of the matrix, with each column as a list of elements\nExamples:​\nlist<list<unknown>> var0 <- columns_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); // var0 equals [[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]\nSee also: rows_list,\n\ncommand​\nPossible uses:​\n\ncommand (string) --->  string\nstring command string --->  string\ncommand (string , string) --->  string\ncommand (string, string, map<string,string>) --->  string\n\nResult:​\ncommand allows GAMA to issue a system command using the system terminal or shell and to receive a string containing the outcome of the command or script executed. By default, commands are blocking the agent calling them, unless the sequence ' &' is used at the end. In this case, the result of the operator is an empty string. The basic form with only one string in argument uses the directory of the model and does not set any environment variables. Two other forms (with a directory and a map<string, string> of environment variables) are available.\n\ncone​\nPossible uses:​\n\ncone (point) --->  geometry\nint cone int --->  geometry\ncone (int , int) --->  geometry\n\nResult:​\nA cone geometry which min and max angles are given by the operands.\nComment:​\nthe center of the cone is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\n\nExamples:​\ngeometry var0 <- cone({0, 45}); // var0 equals a geometry as a cone with min angle is 0 and max angle is 45. geometry var1 <- cone(0, 45); // var1 equals a geometry as a cone with min angle is 0 and max angle is 45.\nSee also: around, circle, line, link, norm, point, polygon, polyline, rectangle, square, triangle,\n\ncone3D​\nPossible uses:​\n\nfloat cone3D float --->  geometry\ncone3D (float , float) --->  geometry\n\nResult:​\nA cone geometry which base radius size is equal to the first operand, and which the height is equal to the second operand.\nComment:​\nthe center of the cone is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if the operand is lower or equal to 0.\n\nExamples:​\ngeometry var0 <- cone3D(10.0,5.0); // var0 equals a geometry as a cone with a base circle of radius 10 and a height of 5.\nSee also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,\n\nconnected_components_of​\nPossible uses:​\n\nconnected_components_of (graph) --->  list<list>\ngraph connected_components_of bool --->  list<list>\nconnected_components_of (graph , bool) --->  list<list>\n\nResult:​\nreturns the connected components of a graph, i.e. the list of all edges (if the boolean is true) or vertices (if the boolean is false) that are in the connected components.\nreturns the connected components of a graph, i.e. the list of all vertices that are in the maximally connected component together with the specified vertex.\nExamples:​\ngraph my_graph2 <- graph([]); list<list> var1 <- connected_components_of (my_graph2, true); // var1 equals the list of all the components as list graph my_graph <- graph([]); list<list> var3 <- connected_components_of (my_graph); // var3 equals the list of all the components as list\nSee also: alpha_index, connectivity_index, nb_cycles,\n\nconnectivity_index​\nPossible uses:​\n\nconnectivity_index (graph) --->  float\n\nResult:​\nreturns a simple connectivity index. This number is estimated through the number of nodes (v) and of sub-graphs (p) : IC = (v - p) /(v - 1).\nExamples:​\ngraph graphEpidemio <- graph([]); float var1 <- connectivity_index(graphEpidemio); // var1 equals the connectivity index of the graph\nSee also: alpha_index, beta_index, gamma_index, nb_cycles,\n\ncontainer​\nPossible uses:​\n\ncontainer (any) --->  container\n\nResult:​\ncasts the operand in a container object.\n\ncontains​\nPossible uses:​\n\ncontainer<KeyType,ValueType> contains unknown --->  bool\ncontains (container<KeyType,ValueType> , unknown) --->  bool\nstring contains string --->  bool\ncontains (string , string) --->  bool\n\nResult:​\ntrue, if the container contains the right operand, false otherwise. 'contains' can also be written 'contains_value'. On graphs, it is equivalent to calling 'contains_edge'\nComment:​\nthe contains operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a map, contains, which can also be written 'contains_value', returns true if the operand is a value of the map\nif it is a pair, contains_key returns true if the operand is equal to the value of the pair\nif it is a file, contains returns true it the operand is contained in the file content\nif it is a population, contains returns true if the operand is an agent of the population, false otherwise\nif it is a graph, contains can be written 'contains_edge' and  returns true if the operand is an edge of the graph, false otherwise (use 'contains_node' for testing the presence of a node)\nif both operands are strings, returns true if the right-hand operand contains the right-hand pattern;\nif it is a list or a matrix, contains returns true if the list or matrix contains the right operand\n\nbool var0 <- [1, 2, 3] contains 2; // var0 equals true bool var1 <- [{1,2}, {3,4}, {5,6}] contains {3,4}; // var1 equals true\nExamples:​\nbool var2 <- 'abcded' contains 'bc'; // var2 equals true\nSee also: contains_all, contains_any, contains_key,\n\ncontains_all​\nPossible uses:​\n\ncontainer contains_all container --->  bool\ncontains_all (container , container) --->  bool\nstring contains_all list --->  bool\ncontains_all (string , list) --->  bool\n\nResult:​\ntrue if the left operand contains all the elements of the right operand, false otherwise\nComment:​\nthe definition of contains depends on the container\nSpecial cases:​\n\nif the right operand is nil or empty, contains_all returns true\nif the left-operand is a string, test whether the string contains all the element of the list;\n\nbool var4 <- \"abcabcabc\" contains_all [\"ca\",\"xy\"]; // var4 equals false\nExamples:​\nbool var0 <- [1,2,3,4,5,6] contains_all [2,4]; // var0 equals true  bool var1 <- [1,2,3,4,5,6] contains_all [2,8]; // var1 equals false bool var2 <- [1::2, 3::4, 5::6] contains_all [1,3]; // var2 equals false  bool var3 <- [1::2, 3::4, 5::6] contains_all [2,4]; // var3 equals true\nSee also: contains, contains_any,\n\ncontains_any​\nPossible uses:​\n\ncontainer contains_any container --->  bool\ncontains_any (container , container) --->  bool\nstring contains_any list --->  bool\ncontains_any (string , list) --->  bool\n\nResult:​\ntrue if the left operand contains one of the elements of the right operand, false otherwise\nComment:​\nthe definition of contains depends on the container\nSpecial cases:​\n\nif the right operand is nil or empty, contains_any returns false\n\nExamples:​\nbool var0 <- [1,2,3,4,5,6] contains_any [2,4]; // var0 equals true  bool var1 <- [1,2,3,4,5,6] contains_any [2,8]; // var1 equals true bool var2 <- [1::2, 3::4, 5::6] contains_any [1,3]; // var2 equals false bool var3 <- [1::2, 3::4, 5::6] contains_any [2,4]; // var3 equals true bool var4 <- \"abcabcabc\" contains_any [\"ca\",\"xy\"]; // var4 equals true\nSee also: contains, contains_all,\n\ncontains_edge​\nPossible uses:​\n\ngraph contains_edge pair --->  bool\ncontains_edge (graph , pair) --->  bool\ngraph contains_edge unknown --->  bool\ncontains_edge (graph , unknown) --->  bool\n\nResult:​\nreturns true if the graph(left-hand operand) contains the given edge (righ-hand operand), false otherwise\nSpecial cases:​\n\nif the left-hand operand is nil, returns false\nif the right-hand operand is a pair, returns true if it exists an edge between the two elements of the pair in the graph\n\nbool var0 <- graphEpidemio contains_edge (node(0)::node(3)); // var0 equals true\nExamples:​\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var2 <- graphFromMap contains_edge link({1,5},{12,45}); // var2 equals true\nSee also: contains_vertex,\n\ncontains_key​\nPossible uses:​\n\ncontainer<KeyType,ValueType> contains_key unknown --->  bool\ncontains_key (container<KeyType,ValueType> , unknown) --->  bool\n\nResult:​\ntrue, if the left-hand operand -- the container -- contains a key -- or an index -- equal to the right-hand operand, false otherwise. On graphs, 'contains_key' is equivalent to calling 'contains_vertex'\nComment:​\nthe behavior of contains_key depends on the nature of the container\nSpecial cases:​\n\nif it is a map, contains_key returns true if the operand is a key of the map\nif it is a pair, contains_key returns true if the operand is equal to the key of the pair\nif it is a matrix, contains_key returns true if the point operand is a valid index of the matrix (i.e. >= {0,0} and < {rows, col})\nif it is a file, contains_key is applied to the file contents -- a container\nif it is a graph, contains_key returns true if the graph contains the corresponding vertex\nif it is a list, contains_key returns true if the right-hand operand is an integer and if it is a valid index (i.e. >= 0 and < length)\n\nbool var0 <- [1, 2, 3] contains_key 3; // var0 equals false bool var1 <- [{1,2}, {3,4}, {5,6}] contains_key 0; // var1 equals true\nSee also: contains_all, contains, contains_any,\n\ncontains_node​\nSame signification as contains_key\n\ncontains_value​\nSame signification as contains\n\ncontains_vertex​\nPossible uses:​\n\ngraph contains_vertex unknown --->  bool\ncontains_vertex (graph , unknown) --->  bool\n\nResult:​\nreturns true if the graph(left-hand operand) contains the given vertex (righ-hand operand), false otherwise\nSpecial cases:​\n\nif the left-hand operand is nil, returns false\n\nExamples:​\ngraph graphFromMap<-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); bool var1 <- graphFromMap contains_vertex {1,5}; // var1 equals true\nSee also: contains_edge,\n\nconversation​\nPossible uses:​\n\nconversation (any) --->  conversation\n\nResult:​\ncasts the operand in a conversation object.\n\nconvex_hull​\nPossible uses:​\n\nconvex_hull (geometry) --->  geometry\n\nResult:​\nA geometry corresponding to the convex hull of the operand.\nExamples:​\ngeometry var0 <- convex_hull(self); // var0 equals the convex hull of the geometry of the agent applying the operator\n\ncopy​\nPossible uses:​\n\ncopy (unknown) --->  unknown\n\nResult:​\nreturns a copy of the operand.\n\ncopy_between​\nPossible uses:​\n\ncopy_between (list, int, int) --->  list\ncopy_between (string, int, int) --->  string\n\nResult:​\nReturns a copy of the first operand between the indexes determined by the second (inclusive) and third operands (exclusive)\nSpecial cases:​\n\nIf the first operand is empty, returns an empty object of the same type\nIf the second operand is greater than or equal to the third operand, return an empty object of the same type\nIf the first operand is nil, raises an error\n\nExamples:​\nlist var0 <-  copy_between ([4, 1, 6, 9 ,7], 1, 3); // var0 equals [1, 6] string var1 <- copy_between(\"abcabcabc\", 2,6); // var1 equals \"cabc\"\n\ncopy_file​\nPossible uses:​\n\nstring copy_file string --->  bool\ncopy_file (string , string) --->  bool\ncopy_file (string, string, bool) --->  bool\n\nResult:​\ncopy a file or a folder\ncopy a file or a folder\nExamples:​\nbool copy_file_ok <- copy_file(\"../includes/my_folder\",\"../includes/my_new_folder\"); bool copy_file_ok <- copy_file(\"../includes/my_folder\",\"../includes/my_new_folder\",true);\n\ncopy_from_clipboard​\nPossible uses:​\n\ncopy_from_clipboard (any GAML type) --->  unknown\n\nResult:​\nTries to copy data from the clipboard by passing its expected type. Returns nil if it has not been correctly retrieved, or not retrievable using the given type or if GAMA is in a headless environment\nExamples:​\nstring copied  <- copy_from_clipboard(string);\n\ncopy_to_clipboard​\nPossible uses:​\n\ncopy_to_clipboard (string) --->  bool\n\nResult:​\nTries to copy the text in parameter to the clipboard and returns whether it has been correctly copied or not (for instance it might be impossible in a headless environment)\nExamples:​\nbool copied  <- copy_to_clipboard('text to copy');\n\ncopy_to_clipboard​\nPossible uses:​\n\ncopy_to_clipboard (image) --->  bool\n\nResult:​\nTries to copy the given image to the clipboard and returns whether it has been correctly copied or not (for instance it might be impossible in a headless environment)\nExamples:​\nbool copied  <- copy_to_clipboard(img);\n\ncorrelation​\nPossible uses:​\n\ncontainer correlation container --->  float\ncorrelation (container , container) --->  float\n\nResult:​\nReturns the correlation of two data sequences (having the same size)\nExamples:​\nfloat var0 <- correlation([1,2,1,3,1,2], [1,2,1,3,1,2]) with_precision(4); // var0 equals 1.2 float var1 <- correlation([13,2,1,4,1,2], [1,2,1,3,1,2]) with_precision(2); // var1 equals -0.21\n\ncos​\nPossible uses:​\n\ncos (int) --->  float\ncos (float) --->  float\n\nResult:​\nReturns the value (in [-1,1]) of the cosinus of the operand (in decimal degrees).  The argument is casted to an int before being evaluated.\nSpecial cases:​\n\nOperand values out of the range [0-359] are normalized.\n\nExamples:​\nfloat var0 <- cos (0); // var0 equals 1.0 float var1 <- cos(360); // var1 equals 1.0 float var2 <- cos(-720); // var2 equals 1.0 float var3 <- cos (0.0); // var3 equals 1.0 float var4 <- cos(360.0); // var4 equals 1.0 float var5 <- cos(-720.0); // var5 equals 1.0\nSee also: sin, tan,\n\ncos_rad​\nPossible uses:​\n\ncos_rad (float) --->  float\n\nResult:​\nReturns the value (in [-1,1]) of the cosinus of the operand (in radians).\nSpecial cases:​\n\nOperand values out of the range [0-359] are normalized.\n\nExamples:​\nfloat var0 <- cos_rad(0.0); // var0 equals 1.0 float var1 <- cos_rad(#pi); // var1 equals -1.0\nSee also: sin, tan,\n\ncount​\nPossible uses:​\n\ncontainer count any expression --->  int\ncount (container , any expression) --->  int\n\nResult:​\nreturns an int, equal to the number of elements of the left-hand operand that make the right-hand operand evaluate to true.\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\nSpecial cases:​\n\nif the left-hand operand is nil, count throws an error\n\nExamples:​\nint var0 <- [1,2,3,4,5,6,7,8] count (each > 3); // var0 equals 5 // Number of nodes of graph g2 without any out edge graph g2 <- graph([]); int var3 <- g2 count (length(g2 out_edges_of each) = 0  ) ; // var3 equals the total number of out edges // Number of agents node with x > 32 int n <- (list(node) count (round(node(each).location.x) > 32); int var6 <- [1::2, 3::4, 5::6] count (each > 4); // var6 equals 1\nSee also: group_by,\n\ncovariance​\nPossible uses:​\n\ncontainer covariance container --->  float\ncovariance (container , container) --->  float\n\nResult:​\nReturns the covariance of two data sequences\nExamples:​\nfloat var0 <- covariance([13,2,1,4,1,2], [1,2,1,3,1,2]) with_precision(2); // var0 equals -0.67\n\ncovering​\nPossible uses:​\n\ncontainer<unknown,geometry> covering geometry --->  list<geometry>\ncovering (container<unknown,geometry> , geometry) --->  list<geometry>\n\nResult:​\nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), covering the operand (casted as a geometry).\nExamples:​\nlist<geometry> var0 <- [ag1, ag2, ag3] covering(self); // var0 equals the agents among ag1, ag2 and ag3 that cover the shape of the right-hand argument. list<geometry> var1 <- (species1 + species2) covering (self); // var1 equals the agents among species species1 and species2 that covers the shape of the right-hand argument.\nSee also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,\n\ncovers​\nPossible uses:​\n\ngeometry covers geometry --->  bool\ncovers (geometry , geometry) --->  bool\n\nResult:​\nA boolean, equal to true if the left-geometry (or agent/point) covers the right-geometry (or agent/point).\nSpecial cases:​\n\nif one of the operand is null, returns false.\n\nExamples:​\nbool var0 <- square(5) covers square(2); // var0 equals true\nSee also: disjoint_from, crosses, overlaps, partially_overlaps, touches,\n\ncreate_map​\nPossible uses:​\n\nlist create_map list --->  map\ncreate_map (list , list) --->  map\n\nResult:​\nreturns a new map using the left operand as keys for the right operand\nSpecial cases:​\n\nif the left operand contains duplicates, create_map throws an error.\nif both operands have different lengths, choose the minimum length between the two operandsfor the size of the map\n\nExamples:​\nmap<int,string> var0 <- create_map([0,1,2],['a','b','c']); // var0 equals [0::'a',1::'b',2::'c'] map<int,float> var1 <- create_map([0,1],[0.1,0.2,0.3]); // var1 equals [0::0.1,1::0.2] map<string,float> var2 <- create_map(['a','b','c','d'],[1.0,2.0,3.0]); // var2 equals ['a'::1.0,'b'::2.0,'c'::3.0]\n\ncropped_to​\nSame signification as clipped_with\n\ncross​\nPossible uses:​\n\ncross (float) --->  geometry\nfloat cross float --->  geometry\ncross (float , float) --->  geometry\n\nResult:​\nA cross, which radius is equal to the first operand (and eventually the width of the lines for the second)\nExamples:​\ngeometry var0 <- cross(10); // var0 equals a geometry as a cross of radius 10 geometry var1 <- cross(10,2); // var1 equals a geometry as a cross of radius 10, and with a width of 2 for the lines \nSee also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,\n\ncrosses​\nPossible uses:​\n\ngeometry crosses geometry --->  bool\ncrosses (geometry , geometry) --->  bool\n\nResult:​\nA boolean, equal to true if the left-geometry (or agent/point) crosses the right-geometry (or agent/point).\nSpecial cases:​\n\nif one of the operand is null, returns false.\nif one operand is a point, returns false.\n\nExamples:​\nbool var0 <- polyline([{10,10},{20,20}]) crosses polyline([{10,20},{20,10}]); // var0 equals true bool var1 <- polyline([{10,10},{20,20}]) crosses {15,15}; // var1 equals true bool var2 <- polyline([{0,0},{25,25}]) crosses polygon([{10,10},{10,20},{20,20},{20,10}]); // var2 equals true\nSee also: disjoint_from, intersects, overlaps, partially_overlaps, touches,\n\ncrossing​\nPossible uses:​\n\ncontainer<unknown,geometry> crossing geometry --->  list<geometry>\ncrossing (container<unknown,geometry> , geometry) --->  list<geometry>\n\nResult:​\nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), crossing the operand (casted as a geometry).\nExamples:​\nlist<geometry> var0 <- [ag1, ag2, ag3] crossing(self); // var0 equals the agents among ag1, ag2 and ag3 that cross the shape of the right-hand argument. list<geometry> var1 <- (species1 + species2) crossing (self); // var1 equals the agents among species species1 and species2 that cross the shape of the right-hand argument.\nSee also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,\n\ncrs​\nPossible uses:​\n\ncrs (file) --->  string\n\nResult:​\nthe Coordinate Reference System (CRS) of the GIS file\nExamples:​\nstring var0 <- crs(my_shapefile); // var0 equals the crs of the shapefile\n\nCRS_transform​\nPossible uses:​\n\nCRS_transform (geometry) --->  geometry\ngeometry CRS_transform string --->  geometry\nCRS_transform (geometry , string) --->  geometry\nCRS_transform (geometry, string, string) --->  geometry\n\nSpecial cases:​\n\nreturns the geometry corresponding to the transformation of the given geometry from the first CRS to the second CRS (Coordinate Reference System)\n\ngeometry var0 <- {8.35,47.22} CRS_transform(\"EPSG:4326\",\"EPSG:4326\"); // var0 equals {929517.7481238344,5978057.894895313,0.0}\n\nreturns the geometry corresponding to the transformation of the given geometry by the left operand CRS (Coordinate Reference System)\n\ngeometry var1 <- shape CRS_transform(\"EPSG:4326\"); // var1 equals a geometry corresponding to the agent geometry transformed into the EPSG:4326 CRS\n\nreturns the geometry corresponding to the transformation of the given geometry by the current CRS (Coordinate Reference System), the one corresponding to the world's agent one\n\ngeometry var2 <- CRS_transform(shape); // var2 equals a geometry corresponding to the agent geometry transformed into the current CRS\n\ncsv_file​\nPossible uses:​\n\ncsv_file (string) --->  file\nstring csv_file bool --->  file\ncsv_file (string , bool) --->  file\nstring csv_file string --->  file\ncsv_file (string , string) --->  file\nstring csv_file matrix<unknown> --->  file\ncsv_file (string , matrix<unknown>) --->  file\ncsv_file (string, string, bool) --->  file\ncsv_file (string, string, any GAML type) --->  file\ncsv_file (string, string, string, bool) --->  file\ncsv_file (string, string, string, any GAML type) --->  file\ncsv_file (string, string, any GAML type, bool) --->  file\ncsv_file (string, string, any GAML type, point) --->  file\n\nResult:​\nConstructs a file of type csv. Allowed extensions are limited to csv, tsv\nSpecial cases:​\n\ncsv_file(string): This file constructor allows to read a CSV file with the default separator (coma), no header, and no assumption on the type of data. No text qualifier will be used\n\ncsv_file f <- csv_file(\"file.csv\");\n\ncsv_file(string,bool): This file constructor allows to read a CSV file with the default separator (coma), with specifying if the model has a header or not (boolean), and no assumption on the type of data. No text qualifier will be used\n\ncsv_file f <- csv_file(\"file.csv\",true);\n\ncsv_file(string,string): This file constructor allows to read a CSV file and specify the separator used, without making any assumption on the type of data. Headers should be detected automatically if they exist. No text qualifier will be used\n\ncsv_file f <- csv_file(\"file.csv\", \";\");\n\ncsv_file(string,string,bool): This file constructor allows to read a CSV file and specify (1) the separator used; (2) if the model has a header or not, without making any assumption on the type of data. No text qualifier will be used\n\ncsv_file f <- csv_file(\"file.csv\", \";\",true);\n\ncsv_file(string,string,string,bool): This file constructor allows to read a CSV file and specify (1) the separator used; (2) the text qualifier used; (3) if the model has a header or not, without making any assumption on the type of data\n\ncsv_file f <- csv_file(\"file.csv\", ';', '\"', true);\n\ncsv_file(string,string,any GAML type): This file constructor allows to read a CSV file with a given separator, no header, and the type of data. No text qualifier will be used\n\ncsv_file f <- csv_file(\"file.csv\", \";\",int);\n\ncsv_file(string,string,string,any GAML type): This file constructor allows to read a CSV file and specify the separator, text qualifier to use, and the type of data to read.  Headers should be detected automatically if they exist.\n\ncsv_file f <- csv_file(\"file.csv\", ';', '\"', int);\n\ncsv_file(string,string,any GAML type,bool): This file constructor allows to read a CSV file with a given separator, the type of data, with specifying if the model has a header or not (boolean). No text qualifier will be used\n\ncsv_file f <- csv_file(\"file.csv\", \";\",int,true);\n\ncsv_file(string,string,any GAML type,point): This file constructor allows to read a CSV file with a given separator, the type of data, with specifying the number of cols and rows taken into account. No text qualifier will be used\n\ncsv_file f <- csv_file(\"file.csv\", \";\",int,true, {5, 100});\n\ncsv_file(string,matrix<unknown>): This file constructor allows to store a matrix in a CSV file (it does not save it - just store it in memory),\n\ncsv_file f <- csv_file(\"file.csv\", matrix([10,10],[10,10]));\nSee also: is_csv,\n\ncube​\nPossible uses:​\n\ncube (float) --->  geometry\n\nResult:​\nA cube geometry which side size is equal to the operand.\nComment:​\nthe center of the cube is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\n\nExamples:​\ngeometry var0 <- cube(10); // var0 equals a geometry as a square of side size 10.\nSee also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,\n\ncurve​\nPossible uses:​\n\ncurve (point, point, point) --->  geometry\ncurve (point, point, float) --->  geometry\ncurve (point, point, point, int) --->  geometry\ncurve (point, point, float, float) --->  geometry\ncurve (point, point, float, bool) --->  geometry\ncurve (point, point, point, point) --->  geometry\ncurve (point, point, float, int, float) --->  geometry\ncurve (point, point, point, point, int) --->  geometry\ncurve (point, point, float, bool, int) --->  geometry\ncurve (point, point, float, int, float, float) --->  geometry\ncurve (point, point, float, bool, int, float) --->  geometry\n\nResult:​\nThe operator computes a Bezier curve geometry between the given operators, with 10 or a given number of points, and from left to rigth or right to left.\nSpecial cases:​\n\nif one  of the operand is nil, returns nil\nWhen used with 3 points, it computes a quadratic Bezier curve geometry built from the three given points and composed of 10 points.\n\ngeometry var0 <- curve({0,0}, {0,10}, {10,10}); // var0 equals a quadratic Bezier curve geometry composed of 10 points from p0 to p2.\n\nWhen used with 3 points and an integer, it  computes a quadratic Bezier curve geometry built from the three given points. If the last operand (number of points) is inferior to 2, returns nil\n\ngeometry var1 <- curve({0,0}, {0,10}, {10,10}, 20); // var1 equals a quadratic Bezier curve geometry composed of 20 points from p0 to p2.\n\nWhen used with 2 points, a float coefficient, and a float angle, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius considering the given rotation angle (90 = along the z axis).\n\ngeometry var2 <- curve({0,0},{10,10}, 0.5, 90); // var2 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.\n\nWhen used with 2 points, a float coefficient, a boolean, an integer number of points, and a float angle, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points, considering the given rotation angle (90 = along the z axis).\n\ngeometry var3 <- curve({0,0},{10,10}, 0.5, 100, 90); // var3 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.\n\nWhen used with 2 points, a float coefficient, a boolean, an integer number of points, a float proportion, and a float angle, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points, considering the given inflection point (between 0.0 and 1.0 - default 0.5), and the given rotation angle (90 = along the z axis).\n\ngeometry var4 <- curve({0,0},{10,10}, 0.5, 100, 0.8, 90); // var4 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.\n\nWhen used with 2 points, a float coefficient and a boolean, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of 10 points. The last boolean is used to specified if it is the right side.\n\ngeometry var5 <- curve({0,0},{10,10}, 0.5, false); // var5 equals a cubic Bezier curve geometry composed of 10 points from p0 to p1 at the left side.\n\nWhen used with 2 points and a float coefficient, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of 10 points.\n\ngeometry var6 <- curve({0,0},{10,10}, 0.5); // var6 equals a cubic Bezier curve geometry composed of 10 points from p0 to p1.\n\nWhen used with 4 points, it computes, it computes a cubic Bezier curve geometry built from the four given points and composed of 10 points.\n\ngeometry var7 <- curve({0,0}, {0,10}, {10,10}); // var7 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.\n\nWhen used with 2 points, a float coefficient, a boolean, an integer number of points, and a float proportion, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points - the boolean is used to specified if it is the right side and the last value to indicate where is the inflection point (between 0.0 and 1.0 - default 0.5).\n\ngeometry var8 <- curve({0,0},{10,10}, 0.5, false, 100, 0.8); // var8 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.\n\nWhen used with 4 points and an integer number of  points, it computes a cubic Bezier curve geometry built from the four given points composed of a given number of points. If the number of points is  lower than 2, it returns nil.\n\ngeometry var9 <- curve({0,0}, {0,10}, {10,10}); // var9 equals a cubic Bezier curve geometry composed of 10 points from p0 to p3.\n\nWhen used with 2 points, a float coefficient, a boolean, and an integer number of points, it computes a cubic Bezier curve geometry built from the two given points with the given coefficient for the radius and composed of the given number of points - the boolean is used to specified if it is the right side.\n\ngeometry var10 <- curve({0,0},{10,10}, 0.5, false, 100); // var10 equals a cubic Bezier curve geometry composed of 100 points from p0 to p1 at the right side.\nSee also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,\n\ncylinder​\nPossible uses:​\n\nfloat cylinder float --->  geometry\ncylinder (float , float) --->  geometry\n\nResult:​\nA cylinder geometry which radius is equal to the operand.\nComment:​\nthe center of the cylinder is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if the operand is lower or equal to 0.\n\nExamples:​\ngeometry var0 <- cylinder(10,10); // var0 equals a geometry as a circle of radius 10.\nSee also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,"},{"filePath":"https:--gama-platform.org--wiki-OperatorsDH.txt","text":"Operators (D to H)\nThis file is automatically generated from java files. Do Not Edit It.\n\nDefinition​\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.\nMost of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).\nThe ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.  - 10, ! (operand1 or operand2)).\nFinally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n\nif they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))\nif they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.\nif they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\nPriority between operators​\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n\nthe constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values.\nit is followed by the ?: operator, the functional if-else (e.g.  a > b ? a + 10 : a - 10 will return the result of the if-else).\nnext are the logical operators, and and or (e.g. a > b or b > c will return the value of the test)\nnext are the comparison operators (i.e. >, <, <=, >=, =, !=)\nnext the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\nnext the unary operators - and !\nnext the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)\nand finally the functional operators, which have the highest priority of all.\n\n\nUsing actions as operators​\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\nFor instance, if the following species is defined:\nspecies spec1 {        int min(int x, int y) {                return x > y ? x : y;        }}\nAny agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\nglobal {        init {                create spec1;                spec1 my_agent <- spec1[0];                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);        }}\nIf the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\nTable of Contents​\n\nOperators by categories​\n\n3D​\nbox, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,\n\nArithmetic operators​\n-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,\n\nBDI​\nadd_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,\n\nCasting operators​\nas, as_int, as_matrix, field_with, font, is, is_skill, list_with, matrix_with, species_of, to_gaml, to_geojson, to_list, with_size, with_style,\n\nColor-related operators​\n-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum, to_hsb,\n\nComparison operators​\n!=, <, <=, =, >, >=, between,\n\nContainers-related operators​\n-, ::, +, accumulate, all_match, among, as_json_string, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,\n\nDate-related operators​\n-, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,\n\nDates​\n\nDisplays​\nhorizontal, stack, vertical,\n\nedge​\nedge_between, strahler,\n\nEDP-related operators​\ndiff, diff2,\n\nFiles-related operators​\nagent_file, copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_agent, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_shape, is_simulation, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, shape_file, simulation_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,\n\nGamaMetaType​\ntype_of,\n\nGamaSVGFile​\nimage,\n\nGraphs-related operators​\nadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,\n\nGrid-related operators​\nas_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,\n\nImageOperators​\n*, antialiased, blend, blurred, brighter, clipped_with, darker, grayscale, horizontal_flip, image, matrix, rotated_by, sharpened, snapshot, tinted_with, vertical_flip, with_height, with_size, with_width,\n\nIterator operators​\naccumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,\n\nList-related operators​\nall_indexes_of, copy_between, index_of, last_index_of,\n\nLogical operators​\n:, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,\n\nMap comparaison operators​\nfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,\n\nMap-related operators​\nas_map, create_map, index_of, last_index_of,\n\nMatrix-related operators​\n-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, flatten, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,\n\nmulticriteria operators​\nelectre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,\n\nPath-related operators​\nagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,\n\nPedestrian​\ngenerate_pedestrian_network,\n\nPoints-related operators​\n-, /, *, +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,\n\nRandom operators​\nbinomial, exp_density, exp_rnd, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,\n\nReverseOperators​\nserialize,\n\nShape​\narc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,\n\nSpatial operators​\n-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, k_nearest_neighbors, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,\n\nSpatial properties operators​\ncovers, crosses, intersects, partially_overlaps, touches,\n\nSpatial queries operators​\nagent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,\n\nSpatial relations operators​\ndirection_between, distance_between, distance_to, path_between, path_to, towards,\n\nSpatial statistical operators​\nhierarchical_clustering, k_nearest_neighbors, simple_clustering_by_distance,\n\nSpatial transformations operators​\n-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,\n\nSpecies-related operators​\nindex_of, last_index_of, of_generic_species, of_species,\n\nStatistical operators​\nauto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, k_nearest_neighbors, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, morrisAnalysis, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, residuals, rms, rSquare, simple_clustering_by_distance, skewness, sobolAnalysis, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,\n\nStrings-related operators​\n+, <, <=, >, >=, at, capitalize, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,\n\nSubModel​\nload_sub_model,\n\nSystem​\n., choose, command, copy, copy_from_clipboard, copy_to_clipboard, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, play_sound, user_confirm, user_input_dialog, wizard, wizard_page,\n\nTime-related operators​\ndate, string,\n\nTypes-related operators​\naction, agent, attributes, BDIPlan, bool, container, conversation, directory, emotion, file, float, gaml_type, geometry, graph, int, kml, list, map, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, topology, unknown,\n\nUser control operators​\nchoose, enter, user_confirm, user_input_dialog, wizard, wizard_page,\n\nOperators​\n\ndarker​\nPossible uses:​\n\ndarker (image) --->  image\n\nResult:​\nUsed to return an image 10% darker. This operation can be applied multiple times in a row if greater than 10% changes in brightness are desired.\n\ndate​\nPossible uses:​\n\nstring date string --->  date\ndate (string , string) --->  date\ndate (string, string, string) --->  date\n\nResult:​\nconverts a string to a date following a custom pattern. The pattern can use \"%Y %M %N %D %E %h %m %s %z\" for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will parse the date using one of the ISO date & time formats (similar to date('...') in that case). The pattern can also follow the pattern definition found here, which gives much more control over what will be parsed: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constant: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences\nSpecial cases:​\n\nIn addition to the date and  pattern string operands, a specific locale (e.g. 'fr', 'en'...) can be added.\n\ndate d <- date(\"1999-january-30\", 'yyyy-MMMM-dd', 'en');\nExamples:​\ndate den <- date(\"1999-12-30\", 'yyyy-MM-dd');\n\ndbscan​\nPossible uses:​\n\ndbscan (list, float, int) --->  list<list>\n\nResult:​\nreturns the list of clusters (list of instance indices) computed with the dbscan (density-based spatial clustering of applications with noise) algorithm from the first operand data according to the maximum radius of the neighborhood to be considered (eps) and the minimum number of points needed for a cluster (minPts). Usage: dbscan(data,eps,minPoints)\nSpecial cases:​\n\nif the lengths of two vectors in the right-hand aren't equal, returns 0\n\nExamples:​\nlist<list> var0 <- dbscan ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],10,2); // var0 equals [[0,1,2,3]]\n\ndead​\nPossible uses:​\n\ndead (agent) --->  bool\n\nResult:​\ntrue if the agent is dead (or null), false otherwise.\nExamples:​\nbool var0 <- dead(agent_A); // var0 equals true or false\n\ndegree_of​\nPossible uses:​\n\ngraph degree_of unknown --->  int\ndegree_of (graph , unknown) --->  int\n\nResult:​\nreturns the degree (in+out) of a vertex (right-hand operand) in the graph given as left-hand operand.\nExamples:​\nint var1 <- graphFromMap degree_of (node(3)); // var1 equals 3\nSee also: in_degree_of, out_degree_of,\n\ndelete_file​\nPossible uses:​\n\ndelete_file (string) --->  bool\n\nResult:​\ndelete a file or a folder\nExamples:​\nbool delete_file_ok <- delete_file([\"../includes/my_folder\"];\n\ndet​\nSame signification as determinant\n\ndeterminant​\nPossible uses:​\n\ndeterminant (matrix) --->  float\n\nResult:​\nThe determinant of the given matrix\nExamples:​\nfloat var0 <- determinant(matrix([[1,2],[3,4]])); // var0 equals -2\n\ndiff​\nPossible uses:​\n\nfloat diff float --->  float\ndiff (float , float) --->  float\n\nResult:​\nA placeholder function for expressing equations\n\ndiff2​\nPossible uses:​\n\nfloat diff2 float --->  float\ndiff2 (float , float) --->  float\n\nResult:​\nA placeholder function for expressing equations\n\ndirected​\nPossible uses:​\n\ndirected (graph) --->  graph\n\nResult:​\nthe operand graph becomes a directed graph.\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph.\nSee also: undirected,\n\ndirection_between​\nPossible uses:​\n\ntopology direction_between container<unknown,geometry> --->  float\ndirection_between (topology , container<unknown,geometry>) --->  float\n\nResult:​\nA direction (in degree) between a list of two geometries (geometries, agents, points) considering a topology.\nExamples:​\nfloat var0 <- my_topology direction_between [ag1, ag2]; // var0 equals the direction between ag1 and ag2 considering the topology my_topology\nSee also: towards, direction_to, distance_to, distance_between, path_between, path_to,\n\ndirection_to​\nSame signification as towards\n\ndirectory​\nPossible uses:​\n\ndirectory (any) --->  directory\n\nResult:​\ncasts the operand in a directory object.\n\ndisjoint_from​\nPossible uses:​\n\ngeometry disjoint_from geometry --->  bool\ndisjoint_from (geometry , geometry) --->  bool\n\nResult:​\nA boolean, equal to true if the left-geometry (or agent/point) is disjoints from the right-geometry (or agent/point).\nSpecial cases:​\n\nif one of the operand is null, returns true.\nif one operand is a point, returns false if the point is included in the geometry.\n\nExamples:​\nbool var0 <- polyline([{10,10},{20,20}]) disjoint_from polyline([{15,15},{25,25}]); // var0 equals false bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{15,15},{15,25},{25,25},{25,15}]); // var1 equals false bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from {25,25}; // var2 equals true bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) disjoint_from polygon([{35,35},{35,45},{45,45},{45,35}]); // var3 equals true\nSee also: intersects, crosses, overlaps, partially_overlaps, touches,\n\ndistance_between​\nPossible uses:​\n\ntopology distance_between container<unknown,geometry> --->  float\ndistance_between (topology , container<unknown,geometry>) --->  float\n\nResult:​\nA distance between a list of geometries (geometries, agents, points) considering a topology.\nExamples:​\nfloat var0 <- my_topology distance_between [ag1, ag2, ag3]; // var0 equals the distance between ag1, ag2 and ag3 considering the topology my_topology\nSee also: towards, direction_to, distance_to, direction_between, path_between, path_to,\n\ndistance_to​\nPossible uses:​\n\npoint distance_to point --->  float\ndistance_to (point , point) --->  float\ngeometry distance_to geometry --->  float\ndistance_to (geometry , geometry) --->  float\n\nResult:​\nA distance between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.\nExamples:​\nfloat var0 <- ag1 distance_to ag2; // var0 equals the distance between ag1 and ag2 considering the topology of the agent applying the operator\nSee also: towards, direction_to, distance_between, direction_between, path_between, path_to,\n\ndistinct​\nSame signification as remove_duplicates\n\ndistribution_of​\nPossible uses:​\n\ndistribution_of (container) --->  map\ncontainer distribution_of int --->  map\ndistribution_of (container , int) --->  map\ndistribution_of (container, int, float, float) --->  map\n\nResult:​\nDiscretize a list of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)\nExamples:​\nmap var0 <- distribution_of([1,1,2,12.5]); // var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var1 <- distribution_of([1,1,2,12.5]); // var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var2 <- distribution_of([1,1,2,12.5],10); // var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nSee also: as_map,\n\ndistribution2d_of​\nPossible uses:​\n\ncontainer distribution2d_of container --->  map\ndistribution2d_of (container , container) --->  map\ndistribution2d_of (container, container, int, int) --->  map\ndistribution2d_of (container, container, int, float, float, int, float, float) --->  map\n\nResult:​\nDiscretize two lists of values into n bins (computes the bins from a numerical variable into n (default 10) bins. Returns a distribution map with the values (values key), the interval legends (legend key), the distribution parameters (params keys, for cumulative charts). Parameters can be (list), (list, nbbins) or (list,nbbins,valmin,valmax)\nExamples:​\nmap var0 <- distribution2d_of([1,1,2,12.5]); // var0 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var1 <- distribution2d_of([1,1,2,12.5],10); // var1 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]]) map var2 <- distribution2d_of([1,1,2,12.5],10); // var2 equals map(['values'::[2,1,0,0,0,0,1,0,0,0],'legend'::['[0.0:2.0]','[2.0:4.0]','[4.0:6.0]','[6.0:8.0]','[8.0:10.0]','[10.0:12.0]','[12.0:14.0]','[14.0:16.0]','[16.0:18.0]','[18.0:20.0]'],'parlist'::[1,0]])\nSee also: as_map,\n\ndiv​\nPossible uses:​\n\nfloat div int --->  int\ndiv (float , int) --->  int\nint div int --->  int\ndiv (int , int) --->  int\nfloat div float --->  int\ndiv (float , float) --->  int\nint div float --->  int\ndiv (int , float) --->  int\n\nResult:​\nReturns the truncation of the division of the left-hand operand by the right-hand operand.\nSpecial cases:​\n\nif the right-hand operand is equal to zero, raises an exception.\n\nExamples:​\nint var0 <- 40.5 div 3; // var0 equals 13 int var1 <- 40 div 3; // var1 equals 13 int var2 <- 40.1 div 4.5; // var2 equals 8 int var3 <- 40 div 4.1; // var3 equals 9\nSee also: mod,\n\ndnorm​\nSame signification as normal_density\n\ndtw​\nPossible uses:​\n\nlist dtw list --->  float\ndtw (list , list) --->  float\ndtw (list, list, int) --->  float\n\nResult:​\nreturns the dynamic time warping between the two series of values (step pattern used: symetric1) with Sakoe-Chiba band (radius: the window width of Sakoe-Chiba band)\nreturns the dynamic time warping between the two series of values (step pattern used: symetric1)\nExamples:​\nfloat var0 <- dtw([10.0,5.0,1.0, 3.0],[1.0,10.0,5.0,1.0], 2); // var0 equals 11.0 float var1 <- dtw([32.0,5.0,1.0,3.0],[1.0,10.0,5.0,1.0]); // var1 equals 38.0\n\ndurbin_watson​\nPossible uses:​\n\ndurbin_watson (container) --->  float\n\nResult:​\nDurbin-Watson computation\nExamples:​\nfloat var0 <- durbin_watson([13,2,1,4,1,2]) with_precision(4); // var0 equals 0.7231\n\ndxf_file​\nPossible uses:​\n\ndxf_file (string) --->  file\nstring dxf_file float --->  file\ndxf_file (string , float) --->  file\n\nResult:​\nConstructs a file of type dxf. Allowed extensions are limited to dxf\nSpecial cases:​\n\ndxf_file(string): This file constructor allows to read a dxf (.dxf) file\n\nfile f <- dxf_file(\"file.dxf\");\n\ndxf_file(string,float): This file constructor allows to read a dxf (.dxf) file and specify the unit (meter by default)\n\nfile f <- dxf_file(\"file.dxf\",#m);\nSee also: is_dxf,\n\nedge​\nPossible uses:​\n\nedge (pair) --->  unknown\nedge (unknown) --->  unknown\nunknown edge unknown --->  unknown\nedge (unknown , unknown) --->  unknown\nunknown edge float --->  unknown\nedge (unknown , float) --->  unknown\npair edge int --->  unknown\nedge (pair , int) --->  unknown\nunknown edge int --->  unknown\nedge (unknown , int) --->  unknown\npair edge float --->  unknown\nedge (pair , float) --->  unknown\nedge (unknown, unknown, int) --->  unknown\nedge (pair, unknown, float) --->  unknown\nedge (unknown, unknown, unknown) --->  unknown\nedge (pair, unknown, int) --->  unknown\nedge (unknown, unknown, float) --->  unknown\nedge (unknown, unknown, unknown, int) --->  unknown\nedge (unknown, unknown, unknown, float) --->  unknown\n\nResult:​\nAllows to create a wrapper (of type unknown) that wraps two objects and indicates they should be considered as the source and the target of a new edge of a graph. The third (omissible) parameter indicates which weight this edge should have in the graph\nComment:​\nUseful only in graph-related operations (addition, removal of edges, creation of graphs)\n\nedge_between​\nPossible uses:​\n\ngraph edge_between pair --->  unknown\nedge_between (graph , pair) --->  unknown\n\nResult:​\nreturns the edge linking two nodes\nExamples:​\nunknown var0 <- graphFromMap edge_between node1::node2; // var0 equals edge1\nSee also: out_edges_of, in_edges_of,\n\nedge_betweenness​\nPossible uses:​\n\nedge_betweenness (graph) --->  map\n\nResult:​\nreturns a map containing for each edge (key), its betweenness centrality (value): number of shortest paths passing through each edge\nExamples:​\ngraph graphEpidemio <- graph([]); map var1 <- edge_betweenness(graphEpidemio); // var1 equals the edge betweenness index of the graph\n\nedges​\nPossible uses:​\n\nedges (container) --->  container\n\nResult:​\nAllows to create a wrapper (of type list) that wraps a list of objects and indicates they should be considered as edges of a graph\n\neigenvalues​\nPossible uses:​\n\neigenvalues (matrix) --->  list<float>\n\nResult:​\nThe list of the eigen values of the given matrix\nExamples:​\nlist<float> var0 <- eigenvalues(matrix([[5,-3],[6,-4]])); // var0 equals [2.0000000000000004,-0.9999999999999998]\n\nelectre_DM​\nPossible uses:​\n\nelectre_DM (list<list>, list<map<string,unknown>>, float) --->  int\n\nResult:​\nThe index of the best candidate according to a method based on the ELECTRE methods. The principle of the ELECTRE methods is to compare the possible candidates by pair. These methods analyses the possible outranking relation existing between two candidates. A candidate outranks another if this one is at least as good as the other one. The ELECTRE methods are based on two concepts: the concordance and the discordance. The concordance characterizes the fact that, for an outranking relation to be validated, a sufficient majority of criteria should be in favor of this assertion. The discordance characterizes the fact that, for an outranking relation to be validated, none of the criteria in the minority should oppose too strongly this assertion. These two conditions must be true for validating the outranking assertion. More information about the ELECTRE methods can be found in Figueira,  J., Mousseau, V., Roy, B.: ELECTRE Methods. In: Figueira, J., Greco, S., and Ehrgott, M., (Eds.), Multiple Criteria Decision Analysis: State of the Art Surveys, Springer, New York, 133--162 (2005). The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fives elements: a name, a weight, a preference value (p), an indifference value (q) and a veto value (v). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant. The veto value represents the threshold from which the difference between two criterion values disqualifies the candidate that obtained the smaller value; the last operand is the fuzzy cut.\nSpecial cases:​\n\nreturns -1 is the list of candidates is nil or empty\n\nExamples:​\nint var0 <- electre_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]],0.7); // var0 equals 0\nSee also: weighted_means_DM, promethee_DM, evidence_theory_DM,\n\nellipse​\nPossible uses:​\n\nfloat ellipse float --->  geometry\nellipse (float , float) --->  geometry\n\nResult:​\nAn ellipse geometry which x-radius is equal to the first operand and y-radius is equal to the second operand\nComment:​\nthe center of the ellipse is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if both operands are lower or equal to 0, a line if only one is.\n\nExamples:​\ngeometry var0 <- ellipse(10, 10); // var0 equals a geometry as an ellipse of width 10 and height 10.\nSee also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, circle, squircle, triangle,\n\nelliptical_arc​\nPossible uses:​\n\nelliptical_arc (point, point, float, int) --->  geometry\n\nResult:​\nAn elliptical arc from the first operand (point) to the second operand (point), which radius is equal to the third operand, and a int giving the number of points to use as a last operand\nExamples:​\ngeometry var0 <- elliptical_arc({0,0},{10,10},5.0, 20); // var0 equals a geometry from {0,0} to {10,10} considering a radius of 5.0 built using 20 points\nSee also: arc, around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,\n\nemotion​\nPossible uses:​\n\nemotion (any) --->  emotion\n\nResult:​\ncasts the operand in a emotion object.\n\nempty​\nPossible uses:​\n\nempty (container<KeyType,ValueType>) --->  bool\nempty (string) --->  bool\n\nResult:​\ntrue if the operand is empty, false otherwise.\nComment:​\nthe empty operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a map, empty returns true if the map contains no key-value mappings, and false otherwise\nif it is a file, empty returns true if the content of the file (that is also a container) is empty, and false otherwise\nif it is a population, empty returns true if there is no agent in the population, and false otherwise\nif it is a graph, empty returns true if it contains no vertex and no edge, and false otherwise\nif it is a matrix of int, float or object, it will return true if all elements are respectively 0, 0.0 or null, and false otherwise\nif it is a matrix of geometry, it will return true if the matrix contains no cell, and false otherwise\nif it is a list, empty returns true if there is no element in the list, and false otherwise\n\nbool var0 <- empty([]); // var0 equals true\n\nif it is a string, empty returns true if the string does not contain any character, and false otherwise\n\nbool var1 <- empty ('abced'); // var1 equals false\n\nenlarged_by​\nSame signification as +\n\nenter​\nPossible uses:​\n\nstring enter any GAML type --->  unknown\nenter (string , any GAML type) --->  unknown\nstring enter string --->  unknown\nenter (string , string) --->  unknown\nstring enter bool --->  unknown\nenter (string , bool) --->  unknown\nstring enter unknown --->  unknown\nenter (string , unknown) --->  unknown\nstring enter float --->  unknown\nenter (string , float) --->  unknown\nstring enter int --->  unknown\nenter (string , int) --->  unknown\nenter (string, any GAML type, unknown) --->  unknown\nenter (string, float, float, float) --->  unknown\nenter (string, int, int, int) --->  unknown\nenter (string, float, float, float, float) --->  unknown\nenter (string, int, int, int, int) --->  unknown\n\nResult:​\nAllows the user to enter a string by specifying a title and an initial value\nSpecial cases:​\n\nWhen the second operand is the boolean type or a boolean value, the GUI is then a switch\n\nmap<string,unknown> m <- user_input(enter(\"Title\",true)); map<string,unknown> m2 <- user_input(enter(\"Title\",bool));\n\nThe GUI is then a slider when an init value, a min (int or float), a max (int or float) (and eventually a  step (int or float) ) operands.\n\nmap resMinMax <- user_input([enter(\"Title\",5,0)]) map resMinMax <- user_input([enter(\"Title\",5,0,10)]) map resMMStepFF <- user_input([enter(\"Title\",5,0.1,10.1,0.5)]);\n\nenvelope​\nPossible uses:​\n\nenvelope (unknown) --->  geometry\n\nResult:​\nA 3D geometry that represents the box that surrounds the geometries or the surface described by the arguments. More general than geometry(arguments).envelope, as it allows to pass int, double, point, image files, shape files, asc files, or any list combining these arguments, in which case the envelope will be correctly expanded. If an envelope cannot be determined from the arguments, a default one of dimensions (0,100, 0, 100, 0, 100) is returned\nSpecial cases:​\n\nThis operator is often used to define the environment of simulation\n\nExamples:​\nfile road_shapefile <- file(\"../includes/roads.shp\"); geometry shape <- envelope(road_shapefile); // shape is the system variable of  the environment geometry var3 <- polygon([{0,0}, {20,0}, {10,10}, {10,0}]); // var3 equals create a polygon to get the envolpe float var4 <- envelope(polygon([{0,0}, {20,0}, {10,10}, {10,0}])).area; // var4 equals 200.0\n\neval_gaml​\nPossible uses:​\n\neval_gaml (string) --->  unknown\n\nResult:​\nevaluates the given GAML string.\nExamples:​\nunknown var0 <- eval_gaml(\"2+3\"); // var0 equals 5\n\neval_when​\nPossible uses:​\n\neval_when (BDIPlan) --->  bool\n\nResult:​\nevaluate the facet when of a given plan\nExamples:​\neval_when(plan1)\n\nevaluate_sub_model​\nPossible uses:​\n\nagent evaluate_sub_model string --->  unknown\nevaluate_sub_model (agent , string) --->  unknown\n\nResult:​\nLoad a submodel\nComment:​\nloaded submodel\n\neven​\nPossible uses:​\n\neven (int) --->  bool\n\nResult:​\nReturns true if the operand is even and false if it is odd.\nSpecial cases:​\n\nif the operand is equal to 0, it returns true.\nif the operand is a float, it is truncated before\n\nExamples:​\nbool var0 <- even (3); // var0 equals false bool var1 <- even(-12); // var1 equals true\n\nevery​\nPossible uses:​\n\nevery (int) --->  bool\nevery (any expression) --->  bool\nlist every int --->  list\nevery (list , int) --->  list\nunknown every int --->  unknown\nevery (unknown , int) --->  unknown\nint every int --->  int\nevery (int , int) --->  int\nbool every int --->  bool\nevery (bool , int) --->  bool\nlist every any expression --->  list<date>\nevery (list , any expression) --->  list<date>\nfloat every int --->  float\nevery (float , int) --->  float\n\nResult:​\ntrue every operand * cycle, false otherwise\nRetrieves elements from the first argument every step (second argument) elements. Raises an error if the step is negative or equal to zero\nreturns the first operand every 2nd operand * cycle, nil otherwise\nreturns the first integer operand every 2nd operand * cycle, 0 otherwise\nreturns the first bool operand every 2nd operand * cycle, false otherwise\napplies a step to an interval of dates defined by 'date1 to date2'. Beware that using every with #month or #year will produce odd results,as these pseudo-constants are not constant; only the first value will be used to compute the intervals, so, for instance, if current_date is set to February#month will only represent 28 or 29 days.\nreturns the first float operand every 2nd operand * cycle, 0.0 otherwise\nexpects a frequency (expressed in seconds of simulated time) as argument. Will return true every time the current_date matches with this frequency\nComment:​\nthe value of the every operator depends on the cycle. It can be used to do something every x cycle.the value of the every operator depends on the cycle. It can be used to return a value every x cycle. object every(10#cycle) is strictly equivalent to every(10#cycle) ? object : nilthe value of the every operator depends on the cycle. It can be used to return a value every x cycle. 1000 every(10#cycle) is strictly equivalent to every(10#cycle) ? 1000 : 0the value of the every operator depends on the cycle. It can be used to return a value every x cycle. object every(10#cycle) is strictly equivalent to every(10#cycle) ? object : falsethe value of the every operator depends on the cycle. It can be used to return a value every x cycle. 1000.0 every(10#cycle) is strictly equivalent to every(10#cycle) ? 1000.0 : 0.0Used to do something at regular intervals of time. Can be used in conjunction with 'since', 'after', 'before', 'until' or 'between', so that this computation only takes place in the temporal segment defined by these operators. In all cases, the starting_date of the model is used as a reference starting point\nExamples:​\nif every(2#cycle) {write \"the cycle number is even\";} \t     else {write \"the cycle number is odd\";} if ({2000,2000} every(2#cycle) != nil) {write \"this is a point\";} \t     else {write \"this is nil\";} if (1000 every(2#cycle) != 0) {write \"this is a value\";} \t     else {write \"this is 0\";} if (true every(2#cycle) != false) {write \"this is true\";} \t     else {write \"this is false\";} (date('2000-01-01') to date('2010-01-01')) every (#day) // builds an interval between these two dates which contains all the days starting from the beginning of the interval if (1000.0 every(2#cycle) != 0) {write \"this is a value\";} \t     else {write \"this is 0.0\";} reflex when: every(2#days) since date('2000-01-01') { .. } state a { transition to: b when: every(2#mn);} state b { transition to: a when: every(30#s);} // This oscillatory behavior will use the starting_date of the model as its starting point in time\nSee also: to, since, after,\n\nevery_cycle​\nSame signification as every\n\nevidence_theory_DM​\nPossible uses:​\n\nlist<list> evidence_theory_DM list<map<string,unknown>> --->  int\nevidence_theory_DM (list<list> , list<map<string,unknown>>) --->  int\nevidence_theory_DM (list<list>, list<map<string,unknown>>, bool) --->  int\n\nResult:​\nThe index of the best candidate according to a method based on the Evidence theory. This theory, which was proposed by Shafer (Shafer G (1976) A mathematical theory of evidence, Princeton University Press), is based on the work of Dempster (Dempster A (1967) Upper and lower probabilities induced by multivalued mapping. Annals of Mathematical Statistics, vol.  38, pp. 325--339) on lower and upper probability distributions. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains seven elements: a name, a first threshold s1, a second threshold s2, a value for the assertion \"this candidate is the best\" at threshold s1 (v1p), a value for the assertion \"this candidate is the best\" at threshold s2 (v2p), a value for the assertion \"this candidate is not the best\" at threshold s1 (v1c), a value for the assertion \"this candidate is not the best\" at threshold s2 (v2c). v1p, v2p, v1c and v2c have to been defined in order that: v1p + v1c <= 1.0; v2p + v2c <= 1.0.; the last operand allows to use a simple version of this multi-criteria decision making method (simple if true)\nSpecial cases:​\n\nreturns -1 is the list of candidates is nil or empty\nif the operator is used with only 2 operands (the candidates and the criteria), the last parameter (use simple method) is set to true\n\nExamples:​\nint var0 <- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true],[\"name\"::\"price\",  \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true]], false); // var0 equals 0 int var1 <- evidence_theory_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true],[\"name\"::\"price\",  \"s1\" :: 0.0,\"s2\"::1.0, \"v1p\"::0.0, \"v2p\"::1.0, \"v1c\"::0.0, \"v2c\"::0.0, \"maximize\" :: true]]); // var1 equals 0\nSee also: weighted_means_DM, electre_DM,\n\nexp​\nPossible uses:​\n\nexp (int) --->  float\nexp (float) --->  float\n\nResult:​\nReturns Euler's number e raised to the power of the operand.\nSpecial cases:​\n\nthe operand is casted to a float before being evaluated.\n\nExamples:​\nfloat var0 <- exp (0.0); // var0 equals 1.0\nSee also: ln,\n\nexp_density​\nPossible uses:​\n\nfloat exp_density float --->  float\nexp_density (float , float) --->  float\n\nResult:​\nreturns the probability density function (PDF) at the specified point x of the exponential distribution with the given rate.\nExamples:​\nfloat var0 <- exp_density(5,3) ; // var0 equals 0.731\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, lognormal_density, gamma_density,\n\nexp_rnd​\nPossible uses:​\n\nexp_rnd (float) --->  float\n\nResult:​\nreturns a random value from a exponential distribution with specified values of the rate (lambda) parameters. See https://mathworld.wolfram.com/ExponentialDistribution.html for more details ).\nExamples:​\nfloat var0 <- exp_rnd(5) ; // var0 equals 0.731\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_trunc_rnd,\n\nfact​\nPossible uses:​\n\nfact (int) --->  float\n\nResult:​\nReturns the factorial of the operand.\nSpecial cases:​\n\nif the operand is less than 0, fact returns 0.\n\nExamples:​\nfloat var0 <- fact(4); // var0 equals 24\n\nfarthest_point_to​\nPossible uses:​\n\ngeometry farthest_point_to point --->  point\nfarthest_point_to (geometry , point) --->  point\n\nResult:​\nthe farthest point of the left-operand to the left-point.\nExamples:​\npoint var0 <- geom farthest_point_to(pt); // var0 equals the farthest point of geom to pt\nSee also: any_location_in, any_point_in, closest_points_with, points_at,\n\nfarthest_to​\nPossible uses:​\n\ncontainer<unknown,geometry> farthest_to geometry --->  geometry\nfarthest_to (container<unknown,geometry> , geometry) --->  geometry\n\nResult:​\nAn agent or a geometry among the left-operand list of agents, species or meta-population (addition of species), the farthest to the operand (casted as a geometry).\nComment:​\nthe distance is computed in the topology of the calling agent (the agent in which this operator is used), with the distance algorithm specific to the topology.\nExamples:​\ngeometry var0 <- [ag1, ag2, ag3] closest_to(self); // var0 equals return the farthest agent among ag1, ag2 and ag3 to the agent applying the operator. (species1 + species2) closest_to self\nSee also: neighbors_at, neighbors_of, inside, overlapping, agents_overlapping, agents_inside, agent_closest_to, closest_to, agent_farthest_to,\n\nfield​\nPossible uses:​\n\nint field int --->  field\nfield (int , int) --->  field\nunknown field float --->  field\nfield (unknown , float) --->  field\nfield (int, int, float) --->  field\nfield (int, int, float, float) --->  field\n\n\nfield_with​\nPossible uses:​\n\npoint field_with any expression --->  field\nfield_with (point , any expression) --->  field\n\nResult:​\ncreates a field with a size provided by the first operand, and filled by the evaluation of the second operand for each cell\nComment:​\nNote that both components of the right operand point should be positive, otherwise an exception is raised.\nSee also: matrix, as_matrix,\n\nfile​\nPossible uses:​\n\nfile (any) --->  file\n\nResult:​\ncasts the operand in a file object.\n\nfile_exists​\nPossible uses:​\n\nfile_exists (string) --->  bool\n\nResult:​\nTest whether the parameter is the path to an existing file. False if it does not exist of if it is a folder\nExamples:​\nstring file_name <-\"../includes/buildings.shp\"; if file_exists(file_name){ \twrite \"File exists in the computer\"; }\n\nfirst​\nPossible uses:​\n\nfirst (string) --->  string\nfirst (container<KeyType,ValueType>) --->  ValueType\nint first container --->  list\nfirst (int , container) --->  list\n\nResult:​\nthe first value of the operand\nComment:​\nthe first operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a map, first returns the first value of the first pair (in insertion order)\nif it is a file, first returns the first element of the content of the file (that is also a container)\nif it is a population, first returns the first agent of the population\nif it is a graph, first returns the first edge (in creation order)\nif it is a matrix, first returns the element at {0,0} in the matrix\nfor a matrix of int or float, it will return 0 if the matrix is empty\nfor a matrix of object or geometry, it will return nil if the matrix is empty\nif it is a string, first returns a string composed of its first character\n\nstring var0 <- first ('abce'); // var0 equals 'a'\n\nif it is a list, first returns the first element of the list, or nil if the list is empty\n\nint var1 <- first ([1, 2, 3]); // var1 equals 1\nSee also: last,\n\nfirst_of​\nSame signification as first\n\nfirst_with​\nPossible uses:​\n\ncontainer first_with any expression --->  unknown\nfirst_with (container , any expression) --->  unknown\n\nResult:​\nthe first element of the left-hand operand that makes the right-hand operand evaluate to true.\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-hand operand is nil, first_with throws an error. If there is no element that satisfies the condition, it returns nil\nif the left-operand is a map, the keyword each will contain each value\n\nint var4 <- [1::2, 3::4, 5::6] first_with (each >= 4); // var4 equals 4 pair var5 <- [1::2, 3::4, 5::6].pairs first_with (each.value >= 4); // var5 equals (3::4)\nExamples:​\nunknown var0 <- [1,2,3,4,5,6,7,8] first_with (each > 3); // var0 equals 4 unknown var2 <- g2 first_with (length(g2 out_edges_of each) = 0); // var2 equals node9 unknown var3 <- (list(node) first_with (round(node(each).location.x) > 32); // var3 equals node2\nSee also: group_by, last_with, where,\n\nflatten​\nPossible uses:​\n\nflatten (field) --->  field\nfield flatten unknown --->  field\nflatten (field , unknown) --->  field\n\n\nflip​\nPossible uses:​\n\nflip (float) --->  bool\n\nResult:​\ntrue or false given the probability represented by the operand\nSpecial cases:​\n\nflip 0 always returns false, flip 1 true\n\nExamples:​\nbool var0 <- flip (0.66666); // var0 equals 2/3 chances to return true.\nSee also: rnd,\n\nfloat​\nPossible uses:​\n\nfloat (any) --->  float\n\nResult:​\ncasts the operand in a float object.\n\nfloor​\nPossible uses:​\n\nfloor (float) --->  int\n\nResult:​\nMaps the operand to the largest previous following integer, i.e. the largest integer not greater than x.\nExamples:​\nint var0 <- floor(3); // var0 equals 3 int var1 <- floor(3.5); // var1 equals 3 int var2 <- floor(-4.7); // var2 equals -5\nSee also: ceil, round,\n\nfolder​\nPossible uses:​\n\nfolder (string) --->  file\n\nResult:​\nopens an existing repository\nSpecial cases:​\n\nIf the specified string does not refer to an existing repository, an exception is risen.\n\nExamples:​\nfile dirT <- folder(\"../includes/\"); \t\t\t\t// dirT represents the repository \"../includes/\" \t\t\t\t// dirT.contents here contains the list of the names of included files\nSee also: file, new_folder,\n\nfolder_exists​\nPossible uses:​\n\nfolder_exists (string) --->  bool\nstring folder_exists list<string> --->  bool\nfolder_exists (string , list<string>) --->  bool\n\nResult:​\nTest whether the parameter is the path to an existing folder. False if it doesnt exist or if it is a file\nTest whether the parameter is the path to an existing folder. False if it doesnt exist or if it is a file\nExamples:​\nstring file_name <-\"../includes/\"; if folder_exists(file_name){ \twrite \"Folder exists in the computer\"; } string file_name <-\"../includes/\"; if folder_exists(file_name){ \twrite \"Folder exists in the computer\"; }\n\nfont​\nPossible uses:​\n\nstring font int --->  font\nfont (string , int) --->  font\nfont (string, int, int) --->  font\n\nResult:​\nCreates a new font, by specifying its name (either a font face name like 'Lucida Grande Bold' or 'Helvetica', or a logical name like 'Dialog', 'SansSerif', 'Serif', etc.), a size in points and a style, either #bold, #italic or #plain or a combination (addition) of them.\nExamples:​\nfont var0 <- font ('Helvetica Neue',12, #bold + #italic); // var0 equals a bold and italic face of the Helvetica Neue family\n\nfrequency_of​\nPossible uses:​\n\ncontainer frequency_of any expression --->  map\nfrequency_of (container , any expression) --->  map\n\nResult:​\nReturns a map with keys equal to the application of the right-hand argument (like collect) and values equal to the frequency of this key (i.e. how many times it has been obtained)\nExamples:​\nmap var0 <- [1, 2, 3, 3, 4, 4, 5, 3, 3, 4] frequency_of each; // var0 equals map([1::1,2::1,3::4,4::3,5::1])\n\nfrom​\nSame signification as since\n\nfuzzy_choquet_DM​\nPossible uses:​\n\nfuzzy_choquet_DM (list<list>, list<string>, map) --->  int\n\nResult:​\nThe index of the candidate that maximizes the Fuzzy Choquet Integral value. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of string); the third operand the weights of each sub-set of criteria (map with list for key and float for value)\nSpecial cases:​\n\nreturns -1 is the list of candidates is nil or empty\n\nExamples:​\nint var0 <- fuzzy_choquet_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [\"utility\", \"price\", \"size\"],[[\"utility\"]::0.5,[\"size\"]::0.1,[\"price\"]::0.4,[\"utility\", \"price\"]::0.55]); // var0 equals 0\nSee also: promethee_DM, electre_DM, evidence_theory_DM,\n\nfuzzy_kappa​\nPossible uses:​\n\nfuzzy_kappa (list<agent>, list<unknown>, list<unknown>, list<float>, list<unknown>, matrix<float>, float) --->  float\nfuzzy_kappa (list<agent>, list<unknown>, list<unknown>, list<float>, list<unknown>, matrix<float>, float, list<unknown>) --->  float\n\nResult:​\nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\nfuzzy kappa indicator for 2 map comparisons: fuzzy_kappa(agents_list,list_vals1,list_vals2, output_similarity_per_agents,categories,fuzzy_categories_matrix, fuzzy_distance, weights). Reference: Visser, H., and T. de Nijs, 2006. The map comparison kit, Environmental Modelling & Software, 21\nExamples:​\nfuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2) fuzzy_kappa([ag1, ag2, ag3, ag4, ag5],[cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0],[0,1,0],[0,0,1]], 2, [1.0,3.0,2.0,2.0,4.0])\n\nfuzzy_kappa_sim​\nPossible uses:​\n\nfuzzy_kappa_sim (list<agent>, list<unknown>, list<unknown>, list<unknown>, list<float>, list<unknown>, matrix<float>, float) --->  float\nfuzzy_kappa_sim (list<agent>, list<unknown>, list<unknown>, list<unknown>, list<float>, list<unknown>, matrix<float>, float, list<unknown>) --->  float\n\nResult:​\nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance, weights). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,\nfuzzy kappa simulation indicator for 2 map comparisons: fuzzy_kappa_sim(agents_list,list_vals1,list_vals2, output_similarity_per_agents,fuzzy_transitions_matrix, fuzzy_distance). Reference: Jasper van Vliet, Alex Hagen-Zanker, Jelle Hurkens, Hedwig van Delden, A fuzzy set approach to assess the predictive accuracy of land use simulations, Ecological Modelling, 24 July 2013, Pages 32-42, ISSN 0304-3800,\nExamples:​\nfuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2,[1.0,3.0,2.0,2.0,4.0]) fuzzy_kappa_sim([ag1, ag2, ag3, ag4, ag5], [cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2], similarity_per_agents,[cat1,cat2,cat3],[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]], 2)\n\ngaml_file​\nPossible uses:​\n\ngaml_file (string) --->  file\ngaml_file (string, string, string) --->  file\n\nResult:​\nConstructs a file of type gaml. Allowed extensions are limited to gaml, experiment\nSpecial cases:​\n\ngaml_file(string): This file constructor allows to read a gaml file (.gaml)\n\nfile f <- gaml_file(\"file.gaml\");\n\ngaml_file(string,string,string): This file constructor allows to compile a gaml file and run an experiment\n\nfile f <- gaml_file(\"file.gaml\", \"my_experiment\", \"my_model\");\nSee also: is_gaml,\n\ngaml_type​\nPossible uses:​\n\ngaml_type (any) --->  gaml_type\n\nResult:​\ncasts the operand in a gaml_type object.\n\ngamma​\nPossible uses:​\n\ngamma (float) --->  float\n\nResult:​\nReturns the value of the Gamma function at x.\nExamples:​\nfloat var0 <- gamma(5); // var0 equals 24.0\n\ngamma_density​\nPossible uses:​\n\ngamma_density (float, float, float) --->  float\n\nResult:​\ngamma_density(x,shape,scale) returns the probability density function (PDF) at the specified point x of the Gamma distribution with the given shape and scale.\nExamples:​\nfloat var0 <- gamma_density(1,9,0.5); // var0 equals 0.731\nSee also: binomial, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, weibull_density, lognormal_density,\n\ngamma_distribution​\nPossible uses:​\n\ngamma_distribution (float, float, float) --->  float\n\nResult:​\nReturns the integral from zero to x of the gamma probability density function.\nComment:​\nincomplete_gamma(a,x) is equal to pgamma(a,1,x).\nExamples:​\nfloat var0 <- gamma_distribution(2,3,0.9) with_precision(3); // var0 equals 0.269\n\ngamma_distribution_complemented​\nPossible uses:​\n\ngamma_distribution_complemented (float, float, float) --->  float\n\nResult:​\nReturns the integral from x to infinity of the gamma probability density function.\nExamples:​\nfloat var0 <- gamma_distribution_complemented(2,3,0.9) with_precision(3); // var0 equals 0.731\n\ngamma_index​\nPossible uses:​\n\ngamma_index (graph) --->  float\n\nResult:​\nreturns the gamma index of the graph (A measure of connectivity that considers the relationship between the number of observed links and the number of possible links: gamma = e/(3 * (v - 2)) - for planar graph.\nExamples:​\ngraph graphEpidemio <- graph([]); float var1 <- gamma_index(graphEpidemio); // var1 equals the gamma index of the graph\nSee also: alpha_index, beta_index, nb_cycles, connectivity_index,\n\ngamma_rnd​\nPossible uses:​\n\nfloat gamma_rnd float --->  float\ngamma_rnd (float , float) --->  float\n\nResult:​\nreturns a random value from a gamma distribution with specified values of the shape and scale parameters\nExamples:​\nfloat var0 <- gamma_rnd(9,0.5); // var0 equals 0.731\nSee also: binomial, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, gamma_trunc_rnd,\n\ngamma_trunc_rnd​\nPossible uses:​\n\ngamma_trunc_rnd (float, float, float, float) --->  float\ngamma_trunc_rnd (float, float, float, bool) --->  float\n\nResult:​\nreturns a random value from a truncated gamma distribution (in a range or given only one boundary) with specified values of the shape and scale parameters.\nSpecial cases:​\n\nwhen 2 float operands are specified, they are taken as mininimum and maximum values for the result\n\ngamma_trunc_rnd(2,3,0,5)\n\nwhen 1 float and a boolean (isMax) operands are specified, the float value represents the single boundary (max if the boolean is true, min otherwise),\n\ngamma_trunc_rnd(2,3,5,true)\nSee also: gamma_rnd, weibull_trunc_rnd, lognormal_trunc_rnd, truncated_gauss,\n\ngauss​\nPossible uses:​\n\ngauss (point) --->  float\nfloat gauss float --->  float\ngauss (float , float) --->  float\n\nResult:​\nA value from a normally distributed random variable with expected value (mean as first operand) and variance (standardDeviation as second operand). The probability density function of such a variable is a Gaussian.\nThe operator can be used with an operand of type point {meand,standardDeviation}.\nSpecial cases:​\n\nwhen standardDeviation value is 0.0, it always returns the mean value\nwhen the operand is a point, it is read as {mean, standardDeviation}\n\nExamples:​\nfloat var0 <- gauss(0,0.3); // var0 equals 0.22354 float var1 <- gauss({0,0.3}); // var1 equals 0.22354\nSee also: binomial, gamma_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd,\n\ngauss_rnd​\nSame signification as gauss\n\ngenerate_barabasi_albert​\nPossible uses:​\n\ngenerate_barabasi_albert (int, int, int, bool) --->  graph\ngenerate_barabasi_albert (container, int, int, bool) --->  graph\ngenerate_barabasi_albert (int, int, int, bool, species) --->  graph\ngenerate_barabasi_albert (int, int, int, bool, species, species) --->  graph\n\nResult:​\nreturns a random scale-free network (following Barabasi-Albert (BA) model).\nreturns a random scale-free network (following Barabasi-Albert (BA) model).\nreturns a random scale-free network (following Barabasi-Albert (BA) model).\nComment:​\nThe Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:The Barabasi-Albert (BA) model is an algorithm for generating random scale-free networks using a preferential attachment mechanism. A scale-free network is a network whose degree distribution follows a power law, at least asymptotically.Such networks are widely observed in natural and human-made systems, including the Internet, the world wide web, citation networks, and some social networks. [From Wikipedia article]The map operand should includes following elements:\nSpecial cases:​\n\n\"nbInitNodes\": number of initial nodes; \"nbEdgesAdded\": number of edges of each new node added during the network growth; \"nbNodes\": final number of nodes; \"directed\": is the graph directed or not;\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz( \t\t\t60, \t\t\t1, \t\t\t100, \t\ttrue);\n\n\"nbInitNodes\": number of initial nodes; \"nbEdgesAdded\": number of edges of each new node added during the network growth; \"nbNodes\": final number of nodes; \"directed\": is the graph directed or not; \"node_species\": the species of vertices; \"edges_species\": the species of edges\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz( \t\t\t60, \t\t\t1, \t\t\t100, \t\ttrue, \t\t\tmyVertexSpecies, \t\t\tmyEdgeSpecies);\n\n\"nbInitNodes\": number of initial nodes; \"nbEdgesAdded\": number of edges of each new node added during the network growth; \"nbNodes\": final number of nodes; \"directed\": is the graph directed or not; \"node_species\": the species of vertices; \"edges_species\": the species of edges\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz( \t\t\t60, \t\t\t1, \t\t\t100, \t\ttrue, \t\t\tmyVertexSpecies);\n\n\"nbInitNodes\": number of initial nodes; \"nodes\": list of existing nodes to connect (agents or geometries); \"nbEdgesAdded\": number of edges of each new node added during the network growth; \"directed\": is the graph directed or not;\n\ngraph myGraph <- generate_watts_strogatz(people, 10,1,false);\nSee also: generate_watts_strogatz,\n\ngenerate_complete_graph​\nPossible uses:​\n\nbool generate_complete_graph list --->  graph\ngenerate_complete_graph (bool , list) --->  graph\nint generate_complete_graph bool --->  graph\ngenerate_complete_graph (int , bool) --->  graph\ngenerate_complete_graph (bool, list, species) --->  graph\ngenerate_complete_graph (int, bool, species) --->  graph\ngenerate_complete_graph (int, bool, species, species) --->  graph\n\nResult:​\nreturns a fully connected graph.\nreturns a fully connected graph.\nreturns a fully connected graph.\nreturns a fully connected graph.\nreturns a fully connected graph.\nSpecial cases:​\n\n\"directed\": is the graph has to be directed or not;\"nodes\": the list of existing nodes\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph( \t\t\ttrue, \t\t\tnodes);\n\nnbNodes: number of nodes to create;directed: is the graph directed or not\n\ngraph myGraph <- generate_complete_graph( \t\t\t100, \t\t\ttrue);\n\n\"directed\": is the graph has to be directed or not;\"nodes\": the list of existing nodes; \"edges_species\": the species of edges\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph( true, nodes, edge_species);\n\nnbNodes: number of nodes to create;directed: is the graph directed or not;node_species: the species of nodes\n\ngraph myGraph <- generate_complete_graph( \t\t\t100, \t\t\ttrue, \t\t\tnode_species);\n\nnbNodes: number of nodes to create;directed: is the graph directed or not;node_species: the species of nodes; edges_species: the species of edges\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_complete_graph( 100, true, node_species, edge_species);\nSee also: generate_barabasi_albert, generate_watts_strogatz,\n\ngenerate_pedestrian_network​\nPossible uses:​\n\ngenerate_pedestrian_network (list<container<unknown,geometry>>, container<unknown,geometry>, bool, bool, float, float, bool, float, float, float, float) --->  list<geometry>\ngenerate_pedestrian_network (list<container<unknown,geometry>>, container<unknown,geometry>, bool, bool, float, float, bool, float, float, float, float, float) --->  list<geometry>\ngenerate_pedestrian_network (list<container<unknown,geometry>>, container<unknown,geometry>, container<unknown,geometry>, bool, bool, float, float, bool, float, float, float, float) --->  list<geometry>\ngenerate_pedestrian_network (list<container<unknown,geometry>>, container<unknown,geometry>, container<unknown,geometry>, bool, bool, float, float, bool, float, float, float, float, float) --->  list<geometry>\n\nResult:​\nThe method allows to build a network of corridors to be used by pedestrian while traveling around a space made of obstacles and other users. It makes it possible to avoide collision with other agents (e.g. buildings) including other pedestrians and in the same time managing a path to a destination in a complex environment (e.g. a city). The method  is highly customizable, with many parameters listed as below: <p>     obstacles : a list containing the lists of geometries or agents that are obstacles for pedestrians (e.g. walls, cars).     bounds : a list of geometries that represent the spatial boundary of the network (i.e. the enclosing space of the network).     open : a boolean expression that will add nodes in the network within open areas. More precisely, new invisible points are added to improve triangulation in areas with very few obstacles.    randomDist : a boolean expression, related to the previous 'open' parameter, that allows to switch between a random (true) spatial distribution or a distribution (false) that build upon a equidistant repartition of points all around the area.    open area : a float in meters representing the minimum distance for an area to be considered as an open area (i.e. euclidian distance between centroid and farest obstacle)    density point : a float representing the density of points per meter within open areas.   clean network : a boolean expression that allows to enhance the network (true) or living as it is generated (false). Enhancement includes filling very small gaps between edges and nodes.    cliping : tolerance for the cliping in triangulation (float; distance) - see skeletonize operator    tolerance : tolerance for the triangulation (float)    min dist obstacle : minimal distance to obstacles to keep a path (float; if 0.0, no filtering)    simplification : simplification distance for the final geometries   square size : size of squares for decomposition (optimization)  \nSpecial cases:​\n\nThe method allows to build a network of corridors to be used by pedestrian while traveling around a space made of obstacles and other users. It makes it possible to avoide collision with other agents (e.g. buildings) including other pedestrians and in the same time managing a path to a destination in a complex environment (e.g. a city). The method  is highly customizable, with many parameters listed as below: <p>     obstacles : a list containing the lists of geometries or agents that are obstacles for pedestrians (e.g. walls, cars).     bounds : a list of geometries that represent the spatial boundary of the network (i.e. the enclosing space of the network).     open : a boolean expression that will add nodes in the network within open areas. More precisely, new invisible points are added to improve triangulation in areas with very few obstacles.    randomDist : a boolean expression, related to the previous 'open' parameter, that allows to switch between a random (true) spatial distribution or a distribution (false) that build upon a equidistant repartition of points all around the area.    open area : a float in meters representing the minimum distance for an area to be considered as an open area (i.e. euclidian distance between centroid and farest obstacle)    density point : a float representing the density of points per meter within open areas.   clean network : a boolean expression that allows to enhance the network (true) or living as it is generated (false). Enhancement includes filling very small gaps between edges and nodes.    cliping : tolerance for the cliping in triangulation (float; distance) - see skeletonize operator    tolerance : tolerance for the triangulation (float)    min dist obstacle : minimal distance to obstacles to keep a path (float; if 0.0, no filtering)    simplification : simplification distance for the final geometries \nThe method allows to build a network of corridors to be used by pedestrian while traveling around a space made of obstacles and other users. It makes it possible to avoide collision with other agents (e.g. buildings) including other pedestrians and in the same time managing a path to a destination in a complex environment (e.g. a city). The method  is highly customizable, with many parameters listed as below: <p>     obstacles : a list containing the lists of geometries or agents that are obstacles for pedestrians (e.g. walls, cars).     bounds : a list of geometries that represent the spatial boundary of the network (i.e. the enclosing space of the network).     regular network : allows to combine the generated network with a simplified car user oriented network. More specifically, the network generated will combine enhance pedestrian oriented generated network with the given network: The property of the latter does not allows pedestrian to avoid collision (1D) when using its edges (while moving in 2D space and avoiding collision in the former).   open : a boolean expression that will add nodes in the network within open areas. More precisely, new invisible points are added to improve triangulation in areas with very few obstacles.    randomDist : a boolean expression, related to the previous 'open' parameter, that allows to switch between a random (true) spatial distribution or a distribution (false) that build upon a equidistant repartition of points all around the area.    open area : a float in meters representing the minimum distance for an area to be considered as an open area (i.e. euclidian distance between centroid and farest obstacle)    density point : a float representing the density of points per meter within open areas.   clean network : a boolean expression that allows to enhance the network (true) or living as it is generated (false). Enhancement includes filling very small gaps between edges and nodes.    cliping : tolerance for the cliping in triangulation (float; distance) - see skeletonize operator    tolerance : tolerance for the triangulation (float)    min dist obstacle : minimal distance to obstacles to keep a path (float; if 0.0, no filtering)    simplification : simplification distance for the final geometries \nThe method allows to build a network of corridors to be used by pedestrian while traveling around a space made of obstacles and other users. It makes it possible to avoide collision with other agents (e.g. buildings) including other pedestrians and in the same time managing a path to a destination in a complex environment (e.g. a city). The method  is highly customizable, with many parameters listed as below: <p>     obstacles : a list containing the lists of geometries or agents that are obstacles for pedestrians (e.g. walls, cars).     bounds : a list of geometries that represent the spatial boundary of the network (i.e. the enclosing space of the network).     regular network : allows to combine the generated network with a simplified car user oriented network. More specifically, the network generated will combine enhance pedestrian oriented generated network with the given network: The property of the latter does not allows pedestrian to avoid collision (1D) when using its edges (while moving in 2D space and avoiding collision in the former).   open : a boolean expression that will add nodes in the network within open areas. More precisely, new invisible points are added to improve triangulation in areas with very few obstacles.    randomDist : a boolean expression, related to the previous 'open' parameter, that allows to switch between a random (true) spatial distribution or a distribution (false) that build upon a equidistant repartition of points all around the area.    open area : a float in meters representing the minimum distance for an area to be considered as an open area (i.e. euclidian distance between centroid and farest obstacle)    density point : a float representing the density of points per meter within open areas.   clean network : a boolean expression that allows to enhance the network (true) or living as it is generated (false). Enhancement includes filling very small gaps between edges and nodes.    cliping : tolerance for the cliping in triangulation (float; distance) - see skeletonize operator    tolerance : tolerance for the triangulation (float)    min dist obstacle : minimal distance to obstacles to keep a path (float; if 0.0, no filtering)  \n\nExamples:​\nlist<geometry> var0 <- generate_pedestrian_network([wall], [world],true,false,3.0,0.1, true,0.1,0.0,0.0,0.0,0.0); // var0 equals a list of polylines corresponding to the pedestrian paths list<geometry> var1 <- generate_pedestrian_network([wall], [world],true,false,3.0,0.1, true,0.1,0.0,0.0,0.0,50.0); // var1 equals a list of polylines corresponding to the pedestrian paths list<geometry> var2 <- generate_pedestrian_network([wall], [world], [road], true,false,3.0,0.1, true,0.1,0.0,0.0,0.0,50.0); // var2 equals a list of polylines corresponding to the pedestrian paths list<geometry> var3 <- generate_pedestrian_network([wall], [world], [road], true,false,3.0,0.1, true,0.1,0.0,0.0,0.0); // var3 equals a list of polylines corresponding to the pedestrian paths\n\ngenerate_random_graph​\nPossible uses:​\n\ngenerate_random_graph (int, int, bool) --->  graph\ngenerate_random_graph (int, int, bool, species) --->  graph\ngenerate_random_graph (int, int, bool, species, species) --->  graph\n\nResult:​\nreturns a random graph.\nreturns a random graph.\nreturns a random graph.\nSpecial cases:​\n\nnbNodes: number of nodes to create;nbEdges: number of edges to create;directed: is the graph directed or not\n\ngraph myGraph <- generate_random_graph( 50, 100, true);\n\nnbNodes: number of nodes to create;nbEdges: number of edges to create;directed: is the graph directed or not;node_species: the species of nodes\n\ngraph myGraph <- generate_random_graph( 50, 100, true, node_species);\n\nnbNodes: number of nodes to be created; nbEdges: number of edges to be created; directed: is the graph has to be directed or not;node_species: the species of nodes; edges_species: the species of edges\n\ngraph<node_species,edge_species> myGraph <- generate_random_graph( 50, 100, true, node_species, edge_species);\nSee also: generate_barabasi_albert, generate_watts_strogatz,\n\ngenerate_terrain​\nPossible uses:​\n\ngenerate_terrain (int, int, int, float, float, float) --->  field\n\nResult:​\nThis operator allows to generate a pseudo-terrain using a simplex noise generator. Its usage is kept simple: it takes first a seed (random or not), then the dimensions (width and height) of the field to generate, then a level (between 0 and 1) of details (which actually determines the number of passes to make), then the value (between 0 and 1) of smoothess, with 0 being completely rought and 1 super smooth, and finally the value (between 0 and 1) of scattering, with 0 building maps in 'one piece' and 1 completely scattered ones.\n\ngenerate_watts_strogatz​\nPossible uses:​\n\ngenerate_watts_strogatz (container, float, int, bool) --->  graph\ngenerate_watts_strogatz (int, float, int, bool) --->  graph\ngenerate_watts_strogatz (int, float, int, bool, species) --->  graph\ngenerate_watts_strogatz (int, float, int, bool, species, species) --->  graph\n\nResult:​\nreturns a random small-world network (following Watts-Strogatz model).\nreturns a random small-world network (following Watts-Strogatz model).\nreturns a random small-world network (following Watts-Strogatz model).\nreturns a random small-world network (following Watts-Strogatz model).\nComment:​\nThe Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:The Watts-Strogatz model is a random graph generation model that produces graphs with small-world properties, including short average path lengths and high clustering.A small-world network is a type of graph in which most nodes are not neighbors of one another, but most nodes can be reached from every other by a small number of hops or steps. [From Wikipedia article]The map operand should includes following elements:\nSpecial cases:​\n\n\"nbNodes\": the graph will contain (size + 1) nodes (size must be greater than k); \"p\": probability to \"rewire\" an edge (so it must be between 0 and 1, the parameter is often called beta in the literature); \"k\": the base degree of each node (k must be greater than 2 and even); \"directed\": is the graph directed or not; \"node_species\": the species of vertices; \"edges_species\": the species of edges\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz( \t\t\t100, \t\t\t0.3, \t\t\t5, \t\ttrue, \t\t\tmyVertexSpecies, \t\t\tmyEdgeSpecies);\n\n\"nodes\": the list of nodes to connect; \"p\": probability to \"rewire\" an edge (so it must be between 0 and 1, the parameter is often called beta in the literature); \"k\": the base degree of each node (k must be greater than 2 and even); \"directed\": is the graph directed or not\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz( \t\t\tpeople, \t\t\t0.3, \t\t\t5, \t\ttrue);\n\n\"nbNodes\": the graph will contain (size + 1) nodes (size must be greater than k); \"p\": probability to \"rewire\" an edge (so it must be between 0 and 1, the parameter is often called beta in the literature); \"k\": the base degree of each node (k must be greater than 2 and even); \"directed\": is the graph directed or not\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz( \t\t\t100, \t\t\t0.3, \t\t\t5, \t\ttrue);\n\n\"nbNodes\": the graph will contain (size + 1) nodes (size must be greater than k); \"p\": probability to \"rewire\" an edge (so it must be between 0 and 1, the parameter is often called beta in the literature); \"k\": the base degree of each node (k must be greater than 2 and even); \"directed\": is the graph directed or not; \"node_species\": the species of vertices\n\ngraph<myVertexSpecy,myEdgeSpecy> myGraph <- generate_watts_strogatz( \t\t\t100, \t\t\t0.3, \t\t\t5, \t\ttrue, \t\t\tmyVertexSpecies);\nSee also: generate_barabasi_albert,\n\ngeojson_file​\nPossible uses:​\n\ngeojson_file (string) --->  file\nstring geojson_file int --->  file\ngeojson_file (string , int) --->  file\nstring geojson_file string --->  file\ngeojson_file (string , string) --->  file\nstring geojson_file bool --->  file\ngeojson_file (string , bool) --->  file\ngeojson_file (string, int, bool) --->  file\ngeojson_file (string, string, bool) --->  file\n\nResult:​\nConstructs a file of type geojson. Allowed extensions are limited to json, geojson, geo.json\nSpecial cases:​\n\ngeojson_file(string): This file constructor allows to read a geojson file (https://geojson.org/)\n\nfile f <- geojson_file(\"file.json\");\n\ngeojson_file(string,int): This file constructor allows to read a geojson file and specifying the coordinates system code, as an int\n\nfile f <- geojson_file(\"file.json\", 32648);\n\ngeojson_file(string,string): This file constructor allows to read a geojson file and specifying the coordinates system code (epg,...,), as a string\n\nfile f <- geojson_file(\"file.json\", \"EPSG:32648\");\n\ngeojson_file(string,bool): This file constructor allows to read a geojson file and take a potential z value (not taken in account by default)\n\nfile f <- geojson_file(\"file.json\", true);\n\ngeojson_file(string,int,bool): This file constructor allows to read a geojson file, specifying the coordinates system code, as an int and take a potential z value (not taken in account by default)\n\nfile f <- geojson_file(\"file.json\",32648, true);\n\ngeojson_file(string,string,bool): This file constructor allows to read a geojson file, specifying the coordinates system code (epg,...,), as a string and take a potential z value (not taken in account by default\n\nfile f <- geojson_file(\"file.json\", \"EPSG:32648\",true);\nSee also: is_geojson,\n\ngeometric_mean​\nPossible uses:​\n\ngeometric_mean (container) --->  float\n\nResult:​\nthe geometric mean of the elements of the operand. See Geometric_mean for more details.\nComment:​\nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\nExamples:​\nfloat var0 <- geometric_mean ([4.5, 3.5, 5.5, 7.0]); // var0 equals 4.962326343467649\nSee also: mean, median, harmonic_mean,\n\ngeometry​\nPossible uses:​\n\ngeometry (any) --->  geometry\n\nResult:​\ncasts the operand in a geometry object.\n\ngeometry_collection​\nPossible uses:​\n\ngeometry_collection (container<unknown,geometry>) --->  geometry\n\nResult:​\nA geometry collection (multi-geometry) composed of the given list of geometries.\nSpecial cases:​\n\nif the operand is nil, returns the point geometry {0,0}\nif the operand is composed of a single geometry, returns a copy of the geometry.\n\nExamples:​\ngeometry var0 <- geometry_collection([{0,0}, {0,10}, {10,10}, {10,0}]); // var0 equals a geometry composed of the 4 points (multi-point).\nSee also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle, line,\n\nget​\nPossible uses:​\n\ngeometry get string --->  unknown\nget (geometry , string) --->  unknown\nagent get string --->  unknown\nget (agent , string) --->  unknown\n\nResult:​\nReads an attribute of the specified agent (or geometry) (left operand). The attribute name is specified by the right operand.\nSpecial cases:​\n\nReading the attribute of a geometry\n\nstring geom_area <- a_geometry get('area');     // reads then 'area' attribute of 'a_geometry' variable then assigns the returned value to the geom_area variable\n\nReading the attribute of another agent\n\nstring agent_name <- an_agent get('name');     // reads then 'name' attribute of an_agent then assigns the returned value to the agent_name variable\n\nget_about​\nPossible uses:​\n\nget_about (emotion) --->  predicate\n\nResult:​\nget the about value of the given emotion\nExamples:​\nget_about(emotion)\n\nget_agent​\nPossible uses:​\n\nget_agent (social_link) --->  agent\n\nResult:​\nget the agent value of the given social link\nExamples:​\nget_agent(social_link1)\n\nget_agent_cause​\nPossible uses:​\n\nget_agent_cause (emotion) --->  agent\nget_agent_cause (predicate) --->  agent\n\nResult:​\nget the agent cause value of the given emotion\nevaluate the agent_cause value of a predicate\nExamples:​\nget_agent_cause(emotion) get_agent_cause(pred1)\n\nget_belief_op​\nPossible uses:​\n\nagent get_belief_op predicate --->  mental_state\nget_belief_op (agent , predicate) --->  mental_state\n\nResult:​\nget the belief in the belief base with the given predicate.\nExamples:​\nmental_state var0 <- get_belief_op(self,predicate(\"has_water\")); // var0 equals nil\n\nget_belief_with_name_op​\nPossible uses:​\n\nagent get_belief_with_name_op string --->  mental_state\nget_belief_with_name_op (agent , string) --->  mental_state\n\nResult:​\nget the belief in the belief base with the given name.\nExamples:​\nmental_state var0 <- get_belief_with_name_op(self,\"has_water\"); // var0 equals nil\n\nget_beliefs_op​\nPossible uses:​\n\nagent get_beliefs_op predicate --->  list<mental_state>\nget_beliefs_op (agent , predicate) --->  list<mental_state>\n\nResult:​\nget the beliefs in the belief base with the given predicate.\nExamples:​\nget_beliefs_op(self,predicate(\"has_water\"))\n\nget_beliefs_with_name_op​\nPossible uses:​\n\nagent get_beliefs_with_name_op string --->  list<mental_state>\nget_beliefs_with_name_op (agent , string) --->  list<mental_state>\n\nResult:​\nget the list of beliefs in the belief base which predicate has the given name.\nExamples:​\nget_beliefs_with_name_op(self,\"has_water\")\n\nget_current_intention_op​\nPossible uses:​\n\nget_current_intention_op (agent) --->  mental_state\n\nResult:​\nget the current intention.\nExamples:​\nmental_state var0 <- get_current_intention_op(self); // var0 equals nil\n\nget_decay​\nPossible uses:​\n\nget_decay (emotion) --->  float\n\nResult:​\nget the decay value of the given emotion\nExamples:​\nget_decay(emotion)\n\nget_desire_op​\nPossible uses:​\n\nagent get_desire_op predicate --->  mental_state\nget_desire_op (agent , predicate) --->  mental_state\n\nResult:​\nget the desire in the desire base with the given predicate.\nExamples:​\nmental_state var0 <- get_belief_op(self,predicate(\"has_water\")); // var0 equals nil\n\nget_desire_with_name_op​\nPossible uses:​\n\nagent get_desire_with_name_op string --->  mental_state\nget_desire_with_name_op (agent , string) --->  mental_state\n\nResult:​\nget the desire in the desire base with the given name.\nExamples:​\nmental_state var0 <- get_desire_with_name_op(self,\"has_water\"); // var0 equals nil\n\nget_desires_op​\nPossible uses:​\n\nagent get_desires_op predicate --->  list<mental_state>\nget_desires_op (agent , predicate) --->  list<mental_state>\n\nResult:​\nget the desires in the desire base with the given predicate.\nExamples:​\nget_desires_op(self,predicate(\"has_water\"))\n\nget_desires_with_name_op​\nPossible uses:​\n\nagent get_desires_with_name_op string --->  list<mental_state>\nget_desires_with_name_op (agent , string) --->  list<mental_state>\n\nResult:​\nget the list of desires in the desire base which predicate has the given name.\nExamples:​\nget_desires_with_name_op(self,\"has_water\")\n\nget_dominance​\nPossible uses:​\n\nget_dominance (social_link) --->  float\n\nResult:​\nget the dominance value of the given social link\nExamples:​\nget_dominance(social_link1)\n\nget_familiarity​\nPossible uses:​\n\nget_familiarity (social_link) --->  float\n\nResult:​\nget the familiarity value of the given social link\nExamples:​\nget_familiarity(social_link1)\n\nget_ideal_op​\nPossible uses:​\n\nagent get_ideal_op predicate --->  mental_state\nget_ideal_op (agent , predicate) --->  mental_state\n\nResult:​\nget the ideal in the ideal base with the given name.\nExamples:​\nmental_state var0 <- get_ideal_op(self,predicate(\"has_water\")); // var0 equals nil\n\nget_ideal_with_name_op​\nPossible uses:​\n\nagent get_ideal_with_name_op string --->  mental_state\nget_ideal_with_name_op (agent , string) --->  mental_state\n\nResult:​\nget the ideal in the ideal base with the given name.\nExamples:​\nmental_state var0 <- get_ideal_with_name_op(self,\"has_water\"); // var0 equals nil\n\nget_ideals_op​\nPossible uses:​\n\nagent get_ideals_op predicate --->  list<mental_state>\nget_ideals_op (agent , predicate) --->  list<mental_state>\n\nResult:​\nget the ideal in the ideal base with the given name.\nExamples:​\nget_ideals_op(self,predicate(\"has_water\"))\n\nget_ideals_with_name_op​\nPossible uses:​\n\nagent get_ideals_with_name_op string --->  list<mental_state>\nget_ideals_with_name_op (agent , string) --->  list<mental_state>\n\nResult:​\nget the list of ideals in the ideal base which predicate has the given name.\nExamples:​\nget_ideals_with_name_op(self,\"has_water\")\n\nget_intensity​\nPossible uses:​\n\nget_intensity (emotion) --->  float\n\nResult:​\nget the intensity value of the given emotion\nExamples:​\nget_intensity(emo1)\n\nget_intention_op​\nPossible uses:​\n\nagent get_intention_op predicate --->  mental_state\nget_intention_op (agent , predicate) --->  mental_state\n\nResult:​\nget the intention in the intention base with the given predicate.\nExamples:​\nget_intention_op(self,predicate(\"has_water\"))\n\nget_intention_with_name_op​\nPossible uses:​\n\nagent get_intention_with_name_op string --->  mental_state\nget_intention_with_name_op (agent , string) --->  mental_state\n\nResult:​\nget the intention in the intention base with the given name.\nExamples:​\nget_intention_with_name_op(self,\"has_water\")\n\nget_intentions_op​\nPossible uses:​\n\nagent get_intentions_op predicate --->  list<mental_state>\nget_intentions_op (agent , predicate) --->  list<mental_state>\n\nResult:​\nget the intentions in the intention base with the given predicate.\nExamples:​\nget_intentions_op(self,predicate(\"has_water\"))\n\nget_intentions_with_name_op​\nPossible uses:​\n\nagent get_intentions_with_name_op string --->  list<mental_state>\nget_intentions_with_name_op (agent , string) --->  list<mental_state>\n\nResult:​\nget the list of intentions in the intention base which predicate has the given name.\nExamples:​\nget_intentions_with_name_op(self,\"has_water\")\n\nget_lifetime​\nPossible uses:​\n\nget_lifetime (mental_state) --->  int\n\nResult:​\nget the lifetime value of the given mental state\nExamples:​\nget_lifetime(mental_state1)\n\nget_liking​\nPossible uses:​\n\nget_liking (social_link) --->  float\n\nResult:​\nget the liking value of the given social link\nExamples:​\nget_liking(social_link1)\n\nget_modality​\nPossible uses:​\n\nget_modality (mental_state) --->  string\n\nResult:​\nget the modality value of the given mental state\nExamples:​\nget_modality(mental_state1)\n\nget_obligation_op​\nPossible uses:​\n\nagent get_obligation_op predicate --->  mental_state\nget_obligation_op (agent , predicate) --->  mental_state\n\nResult:​\nget the obligation in the obligation base with the given predicate.\nExamples:​\nmental_state var0 <- get_obligation_op(self,predicate(\"has_water\")); // var0 equals nil\n\nget_obligation_with_name_op​\nPossible uses:​\n\nagent get_obligation_with_name_op string --->  mental_state\nget_obligation_with_name_op (agent , string) --->  mental_state\n\nResult:​\nget the obligation in the obligation base with the given name.\nExamples:​\nmental_state var0 <- get_obligation_with_name_op(self,\"has_water\"); // var0 equals nil\n\nget_obligations_op​\nPossible uses:​\n\nagent get_obligations_op predicate --->  list<mental_state>\nget_obligations_op (agent , predicate) --->  list<mental_state>\n\nResult:​\nget the obligations in the obligation base with the given predicate.\nExamples:​\nget_obligations_op(self,predicate(\"has_water\"))\n\nget_obligations_with_name_op​\nPossible uses:​\n\nagent get_obligations_with_name_op string --->  list<mental_state>\nget_obligations_with_name_op (agent , string) --->  list<mental_state>\n\nResult:​\nget the list of obligations in the obligation base which predicate has the given name.\nExamples:​\nget_obligations_with_name_op(self,\"has_water\")\n\nget_plan_name​\nPossible uses:​\n\nget_plan_name (BDIPlan) --->  string\n\nResult:​\nget the name of a given plan\nExamples:​\nget_plan_name(agent.current_plan)\n\nget_predicate​\nPossible uses:​\n\nget_predicate (mental_state) --->  predicate\n\nResult:​\nget the predicate value of the given mental state\nExamples:​\nget_predicate(mental_state1)\n\nget_solidarity​\nPossible uses:​\n\nget_solidarity (social_link) --->  float\n\nResult:​\nget the solidarity value of the given social link\nExamples:​\nget_solidarity(social_link1)\n\nget_strength​\nPossible uses:​\n\nget_strength (mental_state) --->  float\n\nResult:​\nget the strength value of the given mental state\nExamples:​\nget_strength(mental_state1)\n\nget_super_intention​\nPossible uses:​\n\nget_super_intention (predicate) --->  mental_state\n\nResult:​\nget the super intention linked to a mental state\nExamples:​\nget_super_intention(get_belief(pred1))\n\nget_trust​\nPossible uses:​\n\nget_trust (social_link) --->  float\n\nResult:​\nget the familiarity value of the given social link\nExamples:​\nget_familiarity(social_link1)\n\nget_truth​\nPossible uses:​\n\nget_truth (predicate) --->  bool\n\nResult:​\nevaluate the truth value of a predicate\nExamples:​\nget_truth(pred1)\n\nget_uncertainties_op​\nPossible uses:​\n\nagent get_uncertainties_op predicate --->  list<mental_state>\nget_uncertainties_op (agent , predicate) --->  list<mental_state>\n\nResult:​\nget the uncertainties in the uncertainty base with the given predicate.\nExamples:​\nget_uncertainties_op(self,predicate(\"has_water\"))\n\nget_uncertainties_with_name_op​\nPossible uses:​\n\nagent get_uncertainties_with_name_op string --->  list<mental_state>\nget_uncertainties_with_name_op (agent , string) --->  list<mental_state>\n\nResult:​\nget the list of uncertainties in the uncertainty base which predicate has the given name.\nExamples:​\nget_uncertainties_with_name_op(self,\"has_water\")\n\nget_uncertainty_op​\nPossible uses:​\n\nagent get_uncertainty_op predicate --->  mental_state\nget_uncertainty_op (agent , predicate) --->  mental_state\n\nResult:​\nget the uncertainty in the uncertainty base with the given predicate.\nExamples:​\nmental_state var0 <- get_uncertainty_op(self,predicate(\"has_water\")); // var0 equals nil\n\nget_uncertainty_with_name_op​\nPossible uses:​\n\nagent get_uncertainty_with_name_op string --->  mental_state\nget_uncertainty_with_name_op (agent , string) --->  mental_state\n\nResult:​\nget the uncertainty in the uncertainty base with the given name.\nExamples:​\nmental_state var0 <- get_uncertainty_with_name_op(self,\"has_water\"); // var0 equals nil\n\nget_values​\nPossible uses:​\n\nget_values (predicate) --->  map<string,unknown>\n\nResult:​\nreturn the map values of a predicate\nExamples:​\nget_values(pred1)\n\ngif_file​\nPossible uses:​\n\ngif_file (string) --->  file\nstring gif_file matrix<int> --->  file\ngif_file (string , matrix<int>) --->  file\n\nResult:​\nConstructs a file of type gif. Allowed extensions are limited to gif\nSpecial cases:​\n\ngif_file(string): This file constructor allows to read a gif file\n\ngif_file f <- gif_file(\"file.gif\");\n\ngif_file(string,matrix<int>): This file constructor allows to store a matrix in a gif file (it does not save it - just store it in memory)\n\ngif_file f <- gif_file(\"file.gif\",matrix([10,10],[10,10]));\nSee also: is_gif,\n\ngini​\nPossible uses:​\n\ngini (list<float>) --->  float\n\nSpecial cases:​\n\nreturn the Gini Index of the given list of values (list of floats)\n\nfloat var0 <- gini([1.0, 0.5, 2.0]); // var0 equals the gini index computed i.e. 0.2857143\n\ngirvan_newman_clustering​\nPossible uses:​\n\ngraph girvan_newman_clustering int --->  list\ngirvan_newman_clustering (graph , int) --->  list\n\nResult:​\nThe Girvan�Newman algorithm is a hierarchical method used to detect communities. It detects communities by progressively removing edges from the original network.It returns a list of list of vertices and takes as operand the graph and the number of clusters\n\ngml_file​\nPossible uses:​\n\ngml_file (string) --->  file\nstring gml_file int --->  file\ngml_file (string , int) --->  file\nstring gml_file string --->  file\ngml_file (string , string) --->  file\nstring gml_file bool --->  file\ngml_file (string , bool) --->  file\ngml_file (string, int, bool) --->  file\ngml_file (string, string, bool) --->  file\n\nResult:​\nConstructs a file of type gml. Allowed extensions are limited to gml\nSpecial cases:​\n\ngml_file(string): This file constructor allows to read a gml file\n\nfile f <- gml_file(\"file.gml\");\n\ngml_file(string,int): This file constructor allows to read a gml file and specifying the coordinates system code, as an int (epsg code)\n\nfile f <- gml_file(\"file.gml\", 32648);\n\ngml_file(string,string): This file constructor allows to read a gml file and specifying the coordinates system code (epg,...,), as a string\n\nfile f <- gml_file(\"file.gml\", \"EPSG:32648\");\n\ngml_file(string,bool): This file constructor allows to read a gml file and take a potential z value (not taken in account by default)\n\nfile f <- gml_file(\"file.gml\", true);\n\ngml_file(string,int,bool): This file constructor allows to read a gml file, specifying the coordinates system code, as an int (epsg code) and take a potential z value (not taken in account by default)\n\nfile f <- gml_file(\"file.gml\", 32648, true);\n\ngml_file(string,string,bool): This file constructor allows to read a gml file, specifying the coordinates system code (epg,...,), as a string and take a potential z value (not taken in account by default\n\nfile f <- gml_file(\"file.gml\", \"EPSG:32648\",true);\nSee also: is_gml,\n\ngradient​\nPossible uses:​\n\ngradient (map<rgb,float>) --->  map<rgb,float>\ngradient (list<rgb>) --->  map<rgb,float>\nrgb gradient rgb --->  map<rgb,float>\ngradient (rgb , rgb) --->  map<rgb,float>\ngradient (rgb, rgb, float) --->  map<rgb,float>\n\nResult:​\nreturns the definition of a linear gradient between two colors, with a ratio (between 0 and 1, otherwise clamped) represented internally as a color map [start::0.0,(startr+stop(1-r))::r, stop::1.0]\nreturns the definition of a linear gradient between two colors, represented internally as a color map [start::0.0,stop::1.0]\nreturns the definition of a linear gradient between n colors provided with their positions on a scale between 0 and 1. A similar color map is returned, in the same color order, with all the positions normalized (so that they are shifted and scaled to fit between 0 and 1). Throws an error if the number of colors is less than 2 or if the positions are not strictly ordered\nreturns the definition of a linear gradient between n colors, represented internally as a color map [c1::1/n,c2::1/n, ... cn::1/n]\n\ngraph​\nPossible uses:​\n\ngraph (any) --->  graph\n\nResult:​\ncasts the operand in a graph object.\n\ngraph6_file​\nPossible uses:​\n\ngraph6_file (string) --->  file\nstring graph6_file species --->  file\ngraph6_file (string , species) --->  file\ngraph6_file (string, species, species) --->  file\n\nResult:​\nConstructs a file of type graph6. Allowed extensions are limited to graph6\nSpecial cases:​\n\ngraph6_file(string): References a graph6 file by its filename\ngraph6_file(string,species): References a graph6 file by its filename and the species to use to instantiate the nodes\ngraph6_file(string,species,species): References a graph6 file by its filename and the species to use to instantiate the nodes and the edges\n\nSee also: is_graph6,\n\ngraphdimacs_file​\nPossible uses:​\n\ngraphdimacs_file (string) --->  file\nstring graphdimacs_file species --->  file\ngraphdimacs_file (string , species) --->  file\ngraphdimacs_file (string, species, species) --->  file\n\nResult:​\nConstructs a file of type graphdimacs. Allowed extensions are limited to dimacs\nSpecial cases:​\n\ngraphdimacs_file(string): References a dimacs file by its filename\ngraphdimacs_file(string,species): References a dimacs file by its filename and the species to use to instantiate the nodes\ngraphdimacs_file(string,species,species): References a dimacs file by its filename and the species to use to instantiate the nodes and the edges\n\nSee also: is_graphdimacs,\n\ngraphdot_file​\nPossible uses:​\n\ngraphdot_file (string) --->  file\nstring graphdot_file species --->  file\ngraphdot_file (string , species) --->  file\ngraphdot_file (string, species, species) --->  file\n\nResult:​\nConstructs a file of type graphdot. Allowed extensions are limited to dot\nSpecial cases:​\n\ngraphdot_file(string): References a dot graph file by its filename\ngraphdot_file(string,species): References a dot graph file by its filename and the species to use to instantiate the nodes\ngraphdot_file(string,species,species): References a dot graph file by its filename and the 2 species to use to instantiate the nodes and the edges\n\nSee also: is_graphdot,\n\ngraphgexf_file​\nPossible uses:​\n\ngraphgexf_file (string) --->  file\nstring graphgexf_file species --->  file\ngraphgexf_file (string , species) --->  file\ngraphgexf_file (string, species, species) --->  file\n\nResult:​\nConstructs a file of type graphgexf. Allowed extensions are limited to gexf\nSpecial cases:​\n\ngraphgexf_file(string): References a gexf graph file by its filename\ngraphgexf_file(string,species): References a gexf graph file by its filename and the species to use to instantiate the nodes\ngraphgexf_file(string,species,species): References a gexf graph file by its filename and the 2 species to use to instantiate the nodes and the edges\n\nSee also: is_graphgexf,\n\ngraphgml_file​\nPossible uses:​\n\ngraphgml_file (string) --->  file\nstring graphgml_file species --->  file\ngraphgml_file (string , species) --->  file\ngraphgml_file (string, species, species) --->  file\n\nResult:​\nConstructs a file of type graphgml. Allowed extensions are limited to gml\nSpecial cases:​\n\ngraphgml_file(string): References a gml graph file by its filename\ngraphgml_file(string,species): References a gml graph file by its filename and the species to use to instantiate the nodes\ngraphgml_file(string,species,species): References a gml graph file by its filename and the 2 species to use to instantiate the nodes and the edges\n\nSee also: is_graphgml,\n\ngraphml_file​\nPossible uses:​\n\ngraphml_file (string) --->  file\nstring graphml_file species --->  file\ngraphml_file (string , species) --->  file\ngraphml_file (string, species, species) --->  file\ngraphml_file (string, species, species, string, string) --->  file\n\nResult:​\nConstructs a file of type graphml. Allowed extensions are limited to graphml\nSpecial cases:​\n\ngraphml_file(string): References a graphml graph file by its filename\ngraphml_file(string,species): References a graphml graph file by its filename and the species to use to instantiate the nodes\ngraphml_file(string,species,species): References a graphml graph file by its filename and the 2 species to use to instantiate the nodes and the edges\ngraphml_file(string,species,species,string,string): References a graphml graph file by its filename and the 2 species to use to instantiate the nodes and the edges\n\nSee also: is_graphml,\n\ngraphtsplib_file​\nPossible uses:​\n\ngraphtsplib_file (string) --->  file\nstring graphtsplib_file species --->  file\ngraphtsplib_file (string , species) --->  file\ngraphtsplib_file (string, species, species) --->  file\n\nResult:​\nConstructs a file of type graphtsplib. Allowed extensions are limited to tsplib\nSpecial cases:​\n\ngraphtsplib_file(string): References a tsplib graph file by its filename\ngraphtsplib_file(string,species): References a tsplib graph file by its filename and the species to use to instantiate the nodes\ngraphtsplib_file(string,species,species): References a tsplib graph file by its filename and the 2 species to use to instantiate the nodes and the edges\n\nSee also: is_graphtsplib,\n\ngrayscale​\nPossible uses:​\n\ngrayscale (rgb) --->  rgb\n\nResult:​\nConverts rgb color to grayscale value\nComment:​\nr=red, g=green, b=blue. Between 0 and 255 and gray = 0.299 * red + 0.587 * green + 0.114 * blue (Photoshop value)\nExamples:​\nrgb var0 <- grayscale (rgb(255,0,0)); // var0 equals to a dark grey\nSee also: rgb, hsb,\n\ngrayscale​\nPossible uses:​\n\ngrayscale (image) --->  image\n\nResult:​\nUsed to convert any image to a grayscale color palette and return it. The original image is left untouched\n\ngrid_at​\nPossible uses:​\n\nspecies grid_at point --->  agent\ngrid_at (species , point) --->  agent\n\nResult:​\nreturns the cell of the grid (right-hand operand) at the position given by the right-hand operand\nComment:​\nIf the left-hand operand is a point of floats, it is used as a point of ints.\nSpecial cases:​\n\nif the left-hand operand is not a grid cell species, returns nil\n\nExamples:​\nagent var0 <- grid_cell grid_at {1,2}; // var0 equals the agent grid_cell with grid_x=1 and grid_y = 2\n\ngrid_cells_to_graph​\nPossible uses:​\n\ngrid_cells_to_graph (container) --->  graph\ncontainer grid_cells_to_graph species --->  graph\ngrid_cells_to_graph (container , species) --->  graph\n\nResult:​\ncreates a graph from a list of cells (operand). An edge is created between neighbors.\nExamples:​\nmy_cell_graph <- grid_cells_to_graph(cells_list);\nSee also: as_intersection_graph, as_edge_graph,\n\ngrid_file​\nPossible uses:​\n\ngrid_file (string) --->  file\nstring grid_file bool --->  file\ngrid_file (string , bool) --->  file\nstring grid_file int --->  file\ngrid_file (string , int) --->  file\nstring grid_file string --->  file\ngrid_file (string , string) --->  file\nstring grid_file field --->  file\ngrid_file (string , field) --->  file\n\nResult:​\nConstructs a file of type grid. Allowed extensions are limited to asc, tif\nSpecial cases:​\n\ngrid_file(string): This file constructor allows to read a asc file or a tif (geotif) file\n\nfile f <- grid_file(\"file.asc\");\n\ngrid_file(string,bool): This file constructor allows to read a asc file or a tif (geotif) file, but without converting it into shapes. Only a matrix of float values is created\n\nfile f <- grid_file(\"file.asc\", false);\n\ngrid_file(string,int): This file constructor allows to read a asc file or a tif (geotif) file specifying the coordinates system code, as an int (epsg code)\n\nfile f <- grid_file(\"file.asc\", 32648);\n\ngrid_file(string,string): This file constructor allows to read a asc file or a tif (geotif) file specifying the coordinates system code (epg,...,), as a string\n\nfile f <- grid_file(\"file.asc\",\"EPSG:32648\");\n\ngrid_file(string,field): This allows to build a writable grid file from the values of a field\n\nfile f <- grid_file(\"file.tif\",my_field); save f;\nSee also: is_grid,\n\ngroup_by​\nPossible uses:​\n\ncontainer group_by any expression --->  map\ngroup_by (container , any expression) --->  map\n\nResult:​\nReturns a map, where the keys take the possible values of the right-hand operand and the map values are the list of elements of the left-hand operand associated to the key value\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-hand operand is nil, group_by throws an error\n\nExamples:​\nmap var0 <- [1,2,3,4,5,6,7,8] group_by (each > 3); // var0 equals [false::[1, 2, 3], true::[4, 5, 6, 7, 8]] map var1 <- g2 group_by (length(g2 out_edges_of each) ); // var1 equals [ 0::[node9, node7, node10, node8, node11], 1::[node6], 2::[node5], 3::[node4]] map var2 <- (list(node) group_by (round(node(each).location.x)); // var2 equals [32::[node5], 21::[node1], 4::[node0], 66::[node2], 96::[node3]] map<bool,list> var3 <- [1::2, 3::4, 5::6] group_by (each > 4); // var3 equals [false::[2, 4], true::[6]]\nSee also: first_with, last_with, where,\n\nharmonic_mean​\nPossible uses:​\n\nharmonic_mean (container) --->  float\n\nResult:​\nthe harmonic mean of the elements of the operand. See Harmonic_mean for more details.\nComment:​\nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\nExamples:​\nfloat var0 <- harmonic_mean ([4.5, 3.5, 5.5, 7.0]); // var0 equals 4.804159445407279\nSee also: mean, median, geometric_mean,\n\nhas_belief_op​\nPossible uses:​\n\nagent has_belief_op predicate --->  bool\nhas_belief_op (agent , predicate) --->  bool\n\nResult:​\nindicates if there already is a belief about the given predicate.\nExamples:​\nbool var0 <- has_belief_op(self,predicate(\"has_water\")); // var0 equals false\n\nhas_belief_with_name_op​\nPossible uses:​\n\nagent has_belief_with_name_op string --->  bool\nhas_belief_with_name_op (agent , string) --->  bool\n\nResult:​\nindicates if there already is a belief about the given name.\nExamples:​\nbool var0 <- has_belief_with_name_op(self,\"has_water\"); // var0 equals false\n\nhas_desire_op​\nPossible uses:​\n\nagent has_desire_op predicate --->  bool\nhas_desire_op (agent , predicate) --->  bool\n\nResult:​\nindicates if there already is a desire about the given predicate.\nExamples:​\nbool var0 <- has_desire_op(self,predicate(\"has_water\")); // var0 equals false\n\nhas_desire_with_name_op​\nPossible uses:​\n\nagent has_desire_with_name_op string --->  bool\nhas_desire_with_name_op (agent , string) --->  bool\n\nResult:​\nindicates if there already is a desire about the given name.\nExamples:​\nbool var0 <- has_desire_with_name_op(self,\"has_water\"); // var0 equals false\n\nhas_ideal_op​\nPossible uses:​\n\nagent has_ideal_op predicate --->  bool\nhas_ideal_op (agent , predicate) --->  bool\n\nResult:​\nindicates if there already is an ideal about the given predicate.\nExamples:​\nbool var0 <- has_ideal_op(self,predicate(\"has_water\")); // var0 equals false\n\nhas_ideal_with_name_op​\nPossible uses:​\n\nagent has_ideal_with_name_op string --->  bool\nhas_ideal_with_name_op (agent , string) --->  bool\n\nResult:​\nindicates if there already is an ideal about the given name.\nExamples:​\nbool var0 <- has_ideal_with_name_op(self,\"has_water\"); // var0 equals false\n\nhas_intention_op​\nPossible uses:​\n\nagent has_intention_op predicate --->  bool\nhas_intention_op (agent , predicate) --->  bool\n\nResult:​\nindicates if there already is an intention about the given predicate.\nExamples:​\nbool var0 <- has_intention_op(self,predicate(\"has_water\")); // var0 equals false\n\nhas_intention_with_name_op​\nPossible uses:​\n\nagent has_intention_with_name_op string --->  bool\nhas_intention_with_name_op (agent , string) --->  bool\n\nResult:​\nindicates if there already is an intention about the given name.\nExamples:​\nbool var0 <- has_intention_with_name_op(self,\"has_water\"); // var0 equals false\n\nhas_obligation_op​\nPossible uses:​\n\nagent has_obligation_op predicate --->  bool\nhas_obligation_op (agent , predicate) --->  bool\n\nResult:​\nindicates if there already is an obligation about the given predicate.\nExamples:​\nbool var0 <- has_obligation_op(self,predicate(\"has_water\")); // var0 equals false\n\nhas_obligation_with_name_op​\nPossible uses:​\n\nagent has_obligation_with_name_op string --->  bool\nhas_obligation_with_name_op (agent , string) --->  bool\n\nResult:​\nindicates if there already is an obligation about the given name.\nExamples:​\nbool var0 <- has_obligation_with_name_op(self,\"has_water\"); // var0 equals false\n\nhas_uncertainty_op​\nPossible uses:​\n\nagent has_uncertainty_op predicate --->  bool\nhas_uncertainty_op (agent , predicate) --->  bool\n\nResult:​\nindicates if there already is an uncertainty about the given predicate.\nExamples:​\nbool var0 <- has_uncertainty_op(self,predicate(\"has_water\")); // var0 equals false\n\nhas_uncertainty_with_name_op​\nPossible uses:​\n\nagent has_uncertainty_with_name_op string --->  bool\nhas_uncertainty_with_name_op (agent , string) --->  bool\n\nResult:​\nindicates if there already is an uncertainty about the given name.\nExamples:​\nbool var0 <- has_uncertainty_with_name_op(self,\"has_water\"); // var0 equals false\n\nhexagon​\nPossible uses:​\n\nhexagon (float) --->  geometry\nhexagon (point) --->  geometry\nfloat hexagon float --->  geometry\nhexagon (float , float) --->  geometry\n\nResult:​\nA hexagon geometry which the given with and height\nComment:​\nthe center of the hexagon is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\n\nExamples:​\ngeometry var0 <- hexagon(10); // var0 equals a geometry as a hexagon of width of 10 and height of 10. geometry var1 <- hexagon(10,5); // var1 equals a geometry as a hexagon of width of 10 and height of 5. geometry var2 <- hexagon({10,5}); // var2 equals a geometry as a hexagon of width of 10 and height of 5.\nSee also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,\n\nhierarchical_clustering​\nPossible uses:​\n\ncontainer<unknown,agent> hierarchical_clustering float --->  list\nhierarchical_clustering (container<unknown,agent> , float) --->  list\n\nResult:​\nA tree (list of list) contained groups of agents clustered by distance considering a distance min between two groups.\nComment:​\nuse of hierarchical clustering with Minimum for linkage criterion between two groups of agents.\nExamples:​\nlist var0 <- [ag1, ag2, ag3, ag4, ag5] hierarchical_clustering 20.0; // var0 equals for example, can return [[[ag1],[ag3]], [ag2], [[[ag4],[ag5]],[ag6]]\nSee also: simple_clustering_by_distance,\n\nhorizontal​\nPossible uses:​\n\nhorizontal (map<unknown,int>) --->  unknown<string>\n\nResult:​\nCreates a horizontal layout node (a sash). Sashes can contain any number (> 1) of other elements: stacks, horizontal or vertical sashes, or display indices. Each element is represented by a pair in the map, where the key is the element and the value its weight within the sash\n\nhorizontal_flip​\nPossible uses:​\n\nhorizontal_flip (image) --->  image\n\nResult:​\nReturns an image flipped horizontally by reflecting the original image around the y axis. The original image is left untouched\n\nhsb​\nPossible uses:​\n\nhsb (float, float, float) --->  rgb\nhsb (float, float, float, int) --->  rgb\nhsb (float, float, float, float) --->  rgb\n\nResult:​\nConverts hsb (h=hue, s=saturation, b=brightness) value to Gama color\nComment:​\nh,s and b components should be floating-point values between 0.0 and 1.0 and when used alpha should be an integer (between 0 and 255) or a float (between 0 and 1) . Examples: Red=(0.0,1.0,1.0), Yellow=(0.16,1.0,1.0), Green=(0.33,1.0,1.0), Cyan=(0.5,1.0,1.0), Blue=(0.66,1.0,1.0), Magenta=(0.83,1.0,1.0)\nExamples:​\nrgb var0 <- hsb (0.0,1.0,1.0); // var0 equals rgb(\"red\") rgb var1 <- hsb (0.5,1.0,1.0,0.0); // var1 equals rgb(\"cyan\",0)\nSee also: rgb,\n\nhypot​\nPossible uses:​\n\nhypot (float, float, float, float) --->  float\n\nResult:​\nReturns sqrt(x2 +y2) without intermediate overflow or underflow.\nSpecial cases:​\n\nIf either argument is infinite, then the result is positive infinity. If either argument is NaN and neither argument is infinite, then the result is NaN.\n\nExamples:​\nfloat var0 <- hypot(0,1,0,1); // var0 equals sqrt(2)"},{"filePath":"https:--gama-platform.org--wiki-OperatorsIM.txt","text":"Operators (I to M)\nThis file is automatically generated from java files. Do Not Edit It.\n\nDefinition​\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.\nMost of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).\nThe ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.  - 10, ! (operand1 or operand2)).\nFinally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n\nif they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))\nif they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.\nif they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\nPriority between operators​\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n\nthe constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values.\nit is followed by the ?: operator, the functional if-else (e.g.  a > b ? a + 10 : a - 10 will return the result of the if-else).\nnext are the logical operators, and and or (e.g. a > b or b > c will return the value of the test)\nnext are the comparison operators (i.e. >, <, <=, >=, =, !=)\nnext the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\nnext the unary operators - and !\nnext the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)\nand finally the functional operators, which have the highest priority of all.\n\n\nUsing actions as operators​\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\nFor instance, if the following species is defined:\nspecies spec1 {        int min(int x, int y) {                return x > y ? x : y;        }}\nAny agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\nglobal {        init {                create spec1;                spec1 my_agent <- spec1[0];                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);        }}\nIf the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\nTable of Contents​\n\nOperators by categories​\n\n3D​\nbox, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,\n\nArithmetic operators​\n-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,\n\nBDI​\nadd_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,\n\nCasting operators​\nas, as_int, as_matrix, field_with, font, is, is_skill, list_with, matrix_with, species_of, to_gaml, to_geojson, to_list, with_size, with_style,\n\nColor-related operators​\n-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum, to_hsb,\n\nComparison operators​\n!=, <, <=, =, >, >=, between,\n\nContainers-related operators​\n-, ::, +, accumulate, all_match, among, as_json_string, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,\n\nDate-related operators​\n-, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,\n\nDates​\n\nDisplays​\nhorizontal, stack, vertical,\n\nedge​\nedge_between, strahler,\n\nEDP-related operators​\ndiff, diff2,\n\nFiles-related operators​\nagent_file, copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_agent, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_shape, is_simulation, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, shape_file, simulation_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,\n\nGamaMetaType​\ntype_of,\n\nGamaSVGFile​\nimage,\n\nGraphs-related operators​\nadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,\n\nGrid-related operators​\nas_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,\n\nImageOperators​\n*, antialiased, blend, blurred, brighter, clipped_with, darker, grayscale, horizontal_flip, image, matrix, rotated_by, sharpened, snapshot, tinted_with, vertical_flip, with_height, with_size, with_width,\n\nIterator operators​\naccumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,\n\nList-related operators​\nall_indexes_of, copy_between, index_of, last_index_of,\n\nLogical operators​\n:, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,\n\nMap comparaison operators​\nfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,\n\nMap-related operators​\nas_map, create_map, index_of, last_index_of,\n\nMatrix-related operators​\n-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, flatten, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,\n\nmulticriteria operators​\nelectre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,\n\nPath-related operators​\nagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,\n\nPedestrian​\ngenerate_pedestrian_network,\n\nPoints-related operators​\n-, /, *, +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,\n\nRandom operators​\nbinomial, exp_density, exp_rnd, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,\n\nReverseOperators​\nserialize,\n\nShape​\narc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,\n\nSpatial operators​\n-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, k_nearest_neighbors, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,\n\nSpatial properties operators​\ncovers, crosses, intersects, partially_overlaps, touches,\n\nSpatial queries operators​\nagent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,\n\nSpatial relations operators​\ndirection_between, distance_between, distance_to, path_between, path_to, towards,\n\nSpatial statistical operators​\nhierarchical_clustering, k_nearest_neighbors, simple_clustering_by_distance,\n\nSpatial transformations operators​\n-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,\n\nSpecies-related operators​\nindex_of, last_index_of, of_generic_species, of_species,\n\nStatistical operators​\nauto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, k_nearest_neighbors, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, morrisAnalysis, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, residuals, rms, rSquare, simple_clustering_by_distance, skewness, sobolAnalysis, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,\n\nStrings-related operators​\n+, <, <=, >, >=, at, capitalize, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,\n\nSubModel​\nload_sub_model,\n\nSystem​\n., choose, command, copy, copy_from_clipboard, copy_to_clipboard, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, play_sound, user_confirm, user_input_dialog, wizard, wizard_page,\n\nTime-related operators​\ndate, string,\n\nTypes-related operators​\naction, agent, attributes, BDIPlan, bool, container, conversation, directory, emotion, file, float, gaml_type, geometry, graph, int, kml, list, map, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, topology, unknown,\n\nUser control operators​\nchoose, enter, user_confirm, user_input_dialog, wizard, wizard_page,\n\nOperators​\n\nIDW​\nPossible uses:​\n\nIDW (container<unknown,geometry>, map, int) --->  map<geometry,float>\n\nResult:​\nInverse Distance Weighting (IDW) is a type of deterministic method for multivariate interpolation with a known scattered set of points. The assigned values to each geometry are calculated with a weighted average of the values available at the known points. See: http://en.wikipedia.org/wiki/Inverse_distance_weighting Usage: IDW (list of geometries, map of points (key: point, value: value), power parameter)\nExamples:​\nmap<geometry,float> var0 <- IDW([ag1, ag2, ag3, ag4, ag5],[{10,10}::25.0, {10,80}::10.0, {100,10}::15.0], 2); // var0 equals for example, can return [ag1::12.0, ag2::23.0,ag3::12.0,ag4::14.0,ag5::17.0]\n\nimage​\nPossible uses:​\n\nint image int --->  image\nimage (int , int) --->  image\nimage (file, int, int) --->  image\nimage (int, int, bool) --->  image\nimage (int, int, rgb) --->  image\n\nResult:​\nBuilds a new image from the specified file, p\tassing the width and height in parameter\nBuilds a new blank image with the specified dimensions and indicates if it will support transparency or not\nBuilds a new blank image of the specified dimensions, which does not accept transparency\nBuilds a new image with the specified dimensions and already filled with the given rgb color\n\nimage_file​\nPossible uses:​\n\nimage_file (string) --->  file\nstring image_file string --->  file\nimage_file (string , string) --->  file\nstring image_file matrix<int> --->  file\nimage_file (string , matrix<int>) --->  file\nstring image_file java.awt.image.BufferedImage --->  file\nimage_file (string , java.awt.image.BufferedImage) --->  file\n\nResult:​\nConstructs a file of type image. Allowed extensions are limited to tiff, jpg, jpeg, png, pict, bmp\nSpecial cases:​\n\nimage_file(string,java.awt.image.BufferedImage):\nimage_file(string): This file constructor allows to read an image file (tiff, jpg, jpeg, png, pict, bmp)\n\nfile f <-image_file(\"file.png\");\n\nimage_file(string,string): This file constructor allows to read an image file (tiff, jpg, jpeg, png, pict, bmp) and to force the extension of the file (can be useful for images coming from URL)\n\nfile f <-image_file(\"http://my_url\", \"png\");\n\nimage_file(string,matrix<int>): This file constructor allows to store a matrix in a image file (it does not save it - just store it in memory)\n\nfile f <-image_file(\"file.png\");\nSee also: is_image,\n\nin​\nPossible uses:​\n\nunknown in container --->  bool\nin (unknown , container) --->  bool\nstring in string --->  bool\nin (string , string) --->  bool\n\nResult:​\ntrue if the right operand contains the left operand, false otherwise\nComment:​\nthe definition of in depends on the container\nSpecial cases:​\n\nif the right operand is nil or empty, in returns false\nif both operands are strings, returns true if the left-hand operand patterns is included in to the right-hand string;\n\nExamples:​\nbool var0 <- 2 in [1,2,3,4,5,6]; // var0 equals true bool var1 <- 7 in [1,2,3,4,5,6]; // var1 equals false bool var2 <- 3 in [1::2, 3::4, 5::6]; // var2 equals false bool var3 <- 6 in [1::2, 3::4, 5::6]; // var3 equals true bool var4 <-  'bc' in 'abcded'; // var4 equals true\nSee also: contains,\n\nin_degree_of​\nPossible uses:​\n\ngraph in_degree_of unknown --->  int\nin_degree_of (graph , unknown) --->  int\n\nResult:​\nreturns the in degree of a vertex (right-hand operand) in the graph given as left-hand operand.\nExamples:​\nint var1 <- graphFromMap in_degree_of (node(3)); // var1 equals 2\nSee also: out_degree_of, degree_of,\n\nin_edges_of​\nPossible uses:​\n\ngraph in_edges_of unknown --->  list\nin_edges_of (graph , unknown) --->  list\n\nResult:​\nreturns the list of the in-edges of a vertex (right-hand operand) in the graph given as left-hand operand.\nExamples:​\nlist var1 <- graphFromMap in_edges_of node({12,45}); // var1 equals [LineString]\nSee also: out_edges_of,\n\nincomplete_beta​\nPossible uses:​\n\nincomplete_beta (float, float, float) --->  float\n\nResult:​\nReturns the regularized integral of the beta function with arguments a and b, from zero to x.\nExamples:​\nfloat var0 <- incomplete_beta(2,3,0.9) with_precision(3); // var0 equals 0.996\n\nincomplete_gamma​\nPossible uses:​\n\nfloat incomplete_gamma float --->  float\nincomplete_gamma (float , float) --->  float\n\nResult:​\nReturns the regularized integral of the Gamma function with argument a to the integration end point x.\nExamples:​\nfloat var0 <- incomplete_gamma(1,5.3) with_precision(3); // var0 equals 0.995\n\nincomplete_gamma_complement​\nPossible uses:​\n\nfloat incomplete_gamma_complement float --->  float\nincomplete_gamma_complement (float , float) --->  float\n\nResult:​\nReturns the complemented regularized incomplete Gamma function of the argument a and integration start point x.\nComment:​\nIs the complement to 1 of incomplete_gamma.\nExamples:​\nfloat var0 <- incomplete_gamma_complement(1,5.3) with_precision(3); // var0 equals 0.005\n\nindented_by​\nPossible uses:​\n\nstring indented_by int --->  string\nindented_by (string , int) --->  string\n\nResult:​\nConverts a (possibly multiline) string by indenting it by a number -- specified by the second operand -- of tabulations to the right\nExamples:​\nstring var0 <- \"my\" + indented_by(\"text\", 1); // var0 equals \"my\ttext\"\n\nindex_by​\nPossible uses:​\n\ncontainer index_by any expression --->  map\nindex_by (container , any expression) --->  map\n\nResult:​\nproduces a new map from the evaluation of the right-hand operand for each element of the left-hand operand\nSpecial cases:​\n\nif the left-hand operand is nil, index_by throws an error. If the operation results in duplicate keys, only the first value corresponding to the key is kept\n\nExamples:​\nmap var0 <- [1,2,3,4,5,6,7,8] index_by (each - 1); // var0 equals [0::1, 1::2, 2::3, 3::4, 4::5, 5::6, 6::7, 7::8]\n\nindex_of​\nPossible uses:​\n\nstring index_of string --->  int\nindex_of (string , string) --->  int\nspecies index_of unknown --->  int\nindex_of (species , unknown) --->  int\nmatrix index_of unknown --->  point\nindex_of (matrix , unknown) --->  point\nmap<unknown,unknown> index_of unknown --->  unknown\nindex_of (map<unknown,unknown> , unknown) --->  unknown\nlist index_of unknown --->  int\nindex_of (list , unknown) --->  int\n\nResult:​\nthe index of the first occurence of the right operand in the left operand container\nComment:​\nThe definition of index_of and the type of the index depend on the container\nSpecial cases:​\n\nif the left operator is a species, returns the index of an agent in a species. If the argument is not an agent of this species, returns -1. Use int(agent) instead\nif the left operand is a map, index_of returns the index of a value or nil if the value is not mapped\nif both operands are strings, returns the index within the left-hand string of the first occurrence of the given right-hand string\n\nint var1 <- \"abcabcabc\" index_of \"ca\"; // var1 equals 2\n\nif the left operand is a matrix, index_of returns the index as a point\n\npoint var2 <- matrix([[1,2,3],[4,5,6]]) index_of 4; // var2 equals {1.0,0.0}\n\nif the left operand is a list, index_of returns the index as an integer\n\nint var3 <- [1,2,3,4,5,6] index_of 4; // var3 equals 3 int var4 <- [4,2,3,4,5,4] index_of 4; // var4 equals 0\nExamples:​\nunknown var0 <- [1::2, 3::4, 5::6] index_of 4; // var0 equals 3\nSee also: at, last_index_of,\n\ninside​\nPossible uses:​\n\ncontainer<unknown,geometry> inside geometry --->  list<geometry>\ninside (container<unknown,geometry> , geometry) --->  list<geometry>\n\nResult:​\nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), covered by the operand (casted as a geometry).\nExamples:​\nlist<geometry> var0 <- [ag1, ag2, ag3] inside(self); // var0 equals the agents among ag1, ag2 and ag3 that are covered by the shape of the right-hand argument. list<geometry> var1 <- (species1 + species2) inside (self); // var1 equals the agents among species species1 and species2 that are covered by the shape of the right-hand argument.\nSee also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,\n\nint​\nPossible uses:​\n\nint (any) --->  int\n\nResult:​\ncasts the operand in a int object.\n\ninter​\nPossible uses:​\n\ngeometry inter geometry --->  geometry\ninter (geometry , geometry) --->  geometry\ncontainer inter container --->  list\ninter (container , container) --->  list\n\nResult:​\nA geometry resulting from the intersection between the two geometries\nthe intersection of the two operands\nComment:​\nboth containers are transformed into sets (so without duplicated element, cf. remove_deplicates operator) before the set intersection is computed.\nSpecial cases:​\n\nreturns nil if one of the operands is nil\nif an operand is a graph, it will be transformed into the set of its nodes\nif an operand is a map, it will be transformed into the set of its values\n\nlist var3 <- [1::2, 3::4, 5::6] inter [2,4]; // var3 equals [2,4] list var4 <- [1::2, 3::4, 5::6] inter [1,3]; // var4 equals []\n\nif an operand is a matrix, it will be transformed into the set of the lines\n\nlist var5 <- matrix([[3,2,1],[4,5,4]]) inter [3,4]; // var5 equals [3,4]\nExamples:​\ngeometry var0 <- square(10) inter circle(5); // var0 equals circle(5) list var1 <- [1,2,3,4,5,6] inter [2,4]; // var1 equals [2,4] list var2 <- [1,2,3,4,5,6] inter [0,8]; // var2 equals []\nSee also: union, +, -, remove_duplicates,\n\ninterleave​\nPossible uses:​\n\ninterleave (container) --->  list\n\nResult:​\nReturns a new list containing the interleaved elements of the containers contained in the operand\nComment:​\nthe operand should be a list of lists of elements. The result is a list of elements.\nExamples:​\nlist var0 <- interleave([1,2,4,3,5,7,6,8]); // var0 equals [1,2,4,3,5,7,6,8] list var1 <- interleave([['e11','e12','e13'],['e21','e22','e23'],['e31','e32','e33']]); // var1 equals ['e11','e21','e31','e12','e22','e32','e13','e23','e33']\n\ninternal_integrated_value​\nPossible uses:​\n\nany expression internal_integrated_value any expression --->  list\ninternal_integrated_value (any expression , any expression) --->  list\n\nResult:​\nFor internal use only. Corresponds to the implementation, for agents, of the access to containers with [index]\n\nintersecting​\nSame signification as overlapping\n\nintersection​\nSame signification as inter\n\nintersects​\nPossible uses:​\n\ngeometry intersects geometry --->  bool\nintersects (geometry , geometry) --->  bool\n\nResult:​\nA boolean, equal to true if the left-geometry (or agent/point) intersects the right-geometry (or agent/point).\nSpecial cases:​\n\nif one of the operand is null, returns false.\n\nExamples:​\nbool var0 <- square(5) intersects {10,10}; // var0 equals false\nSee also: disjoint_from, crosses, overlaps, partially_overlaps, touches,\n\ninverse​\nPossible uses:​\n\ninverse (matrix) --->  matrix<float>\n\nResult:​\nThe inverse matrix of the given matrix. If no inverse exists, returns a matrix that has properties that resemble that of an inverse.\nExamples:​\nmatrix<float> var0 <- inverse(matrix([[4,3],[3,2]])); // var0 equals matrix([[-2.0,3.0],[3.0,-4.0]])\n\ninverse_distance_weighting​\nSame signification as IDW\n\ninverse_rotation​\nPossible uses:​\n\ninverse_rotation (pair<float,point>) --->  pair<float,point>\n\nResult:​\nThe inverse rotation. It is a rotation around the same axis with the opposite angle.\nExamples:​\npair<float,point> var0 <- inverse_rotation(38.0::{1,1,1}); // var0 equals -38.0::{1,1,1}\nSee also: [rotation_composition, normalized_rotation](OperatorsSZ#rotation_composition, normalized_rotation),\n\nis​\nPossible uses:​\n\nunknown is any expression --->  bool\nis (unknown , any expression) --->  bool\n\nResult:​\nreturns true if the left operand is of the right operand type, false otherwise\nExamples:​\nbool var0 <- 0 is int; // var0 equals true bool var1 <- an_agent is node; // var1 equals true bool var2 <- 1 is float; // var2 equals false\n\nis_agent​\nPossible uses:​\n\nis_agent (any) --->  bool\n\nResult:​\nTests whether the operand is a agent file.\nSee also: agent_file,\n\nis_csv​\nPossible uses:​\n\nis_csv (any) --->  bool\n\nResult:​\nTests whether the operand is a csv file.\nSee also: csv_file,\n\nis_dxf​\nPossible uses:​\n\nis_dxf (any) --->  bool\n\nResult:​\nTests whether the operand is a dxf file.\nSee also: dxf_file,\n\nis_error​\nPossible uses:​\n\nis_error (any expression) --->  bool\n\nResult:​\nReturns whether or not the argument raises an error when evaluated\n\nis_finite​\nPossible uses:​\n\nis_finite (float) --->  bool\n\nResult:​\nReturns whether the argument is a finite number or not\nExamples:​\nbool var0 <- is_finite(4.66); // var0 equals true bool var1 <- is_finite(#infinity); // var1 equals false\n\nis_gaml​\nPossible uses:​\n\nis_gaml (any) --->  bool\n\nResult:​\nTests whether the operand is a gaml file.\nSee also: gaml_file,\n\nis_geojson​\nPossible uses:​\n\nis_geojson (any) --->  bool\n\nResult:​\nTests whether the operand is a geojson file.\nSee also: geojson_file,\n\nis_gif​\nPossible uses:​\n\nis_gif (any) --->  bool\n\nResult:​\nTests whether the operand is a gif file.\nSee also: gif_file,\n\nis_gml​\nPossible uses:​\n\nis_gml (any) --->  bool\n\nResult:​\nTests whether the operand is a gml file.\nSee also: gml_file,\n\nis_graph6​\nPossible uses:​\n\nis_graph6 (any) --->  bool\n\nResult:​\nTests whether the operand is a graph6 file.\nSee also: graph6_file,\n\nis_graphdimacs​\nPossible uses:​\n\nis_graphdimacs (any) --->  bool\n\nResult:​\nTests whether the operand is a graphdimacs file.\nSee also: graphdimacs_file,\n\nis_graphdot​\nPossible uses:​\n\nis_graphdot (any) --->  bool\n\nResult:​\nTests whether the operand is a graphdot file.\nSee also: graphdot_file,\n\nis_graphgexf​\nPossible uses:​\n\nis_graphgexf (any) --->  bool\n\nResult:​\nTests whether the operand is a graphgexf file.\nSee also: graphgexf_file,\n\nis_graphgml​\nPossible uses:​\n\nis_graphgml (any) --->  bool\n\nResult:​\nTests whether the operand is a graphgml file.\nSee also: graphgml_file,\n\nis_graphml​\nPossible uses:​\n\nis_graphml (any) --->  bool\n\nResult:​\nTests whether the operand is a graphml file.\nSee also: graphml_file,\n\nis_graphtsplib​\nPossible uses:​\n\nis_graphtsplib (any) --->  bool\n\nResult:​\nTests whether the operand is a graphtsplib file.\nSee also: graphtsplib_file,\n\nis_grid​\nPossible uses:​\n\nis_grid (any) --->  bool\n\nResult:​\nTests whether the operand is a grid file.\nSee also: grid_file,\n\nis_image​\nPossible uses:​\n\nis_image (any) --->  bool\n\nResult:​\nTests whether the operand is a image file.\nSee also: image_file,\n\nis_json​\nPossible uses:​\n\nis_json (any) --->  bool\n\nResult:​\nTests whether the operand is a json file.\nSee also: json_file,\n\nis_number​\nPossible uses:​\n\nis_number (string) --->  bool\nis_number (float) --->  bool\n\nResult:​\ntests whether the operand represents a numerical value\nReturns whether the argument is a real number or not\nComment:​\nNote that the symbol . should be used for a float value (a string with , will not be considered as a numeric value). Symbols e and E are also accepted. A hexadecimal value should begin with #.\nExamples:​\nbool var0 <- is_number(\"test\"); // var0 equals false bool var1 <- is_number(\"123.56\"); // var1 equals true bool var2 <- is_number(\"-1.2e5\"); // var2 equals true bool var3 <- is_number(\"1,2\"); // var3 equals false bool var4 <- is_number(\"#12FA\"); // var4 equals true bool var5 <- is_number(4.66); // var5 equals true bool var6 <- is_number(#infinity); // var6 equals true bool var7 <- is_number(#nan); // var7 equals false\n\nis_obj​\nPossible uses:​\n\nis_obj (any) --->  bool\n\nResult:​\nTests whether the operand is a obj file.\nSee also: obj_file,\n\nis_osm​\nPossible uses:​\n\nis_osm (any) --->  bool\n\nResult:​\nTests whether the operand is a osm file.\nSee also: osm_file,\n\nis_pgm​\nPossible uses:​\n\nis_pgm (any) --->  bool\n\nResult:​\nTests whether the operand is a pgm file.\nSee also: pgm_file,\n\nis_property​\nPossible uses:​\n\nis_property (any) --->  bool\n\nResult:​\nTests whether the operand is a property file.\nSee also: property_file,\n\nis_reachable​\nPossible uses:​\n\nstring is_reachable int --->  bool\nis_reachable (string , int) --->  bool\nis_reachable (string, int, int) --->  bool\n\nResult:​\nReturns whether or not the given web address is reachable or not before a time_out time in milliseconds\nReturns whether or not the given web address is reachable or not before a time_out time in milliseconds\nExamples:​\nwrite sample(is_reachable(\"www.google.com\", 200)); write sample(is_reachable(\"www.google.com\", 200));\n\nis_shape​\nPossible uses:​\n\nis_shape (any) --->  bool\n\nResult:​\nTests whether the operand is a shape file.\nSee also: shape_file,\n\nis_simulation​\nPossible uses:​\n\nis_simulation (any) --->  bool\n\nResult:​\nTests whether the operand is a simulation file.\nSee also: simulation_file,\n\nis_skill​\nPossible uses:​\n\nunknown is_skill string --->  bool\nis_skill (unknown , string) --->  bool\n\nResult:​\nreturns true if the left operand is an agent whose species implements the right-hand skill name\nExamples:​\nbool var0 <- agentA is_skill 'moving'; // var0 equals true\n\nis_svg​\nPossible uses:​\n\nis_svg (any) --->  bool\n\nResult:​\nTests whether the operand is a svg file.\nSee also: svg_file,\n\nis_text​\nPossible uses:​\n\nis_text (any) --->  bool\n\nResult:​\nTests whether the operand is a text file.\nSee also: text_file,\n\nis_threeds​\nPossible uses:​\n\nis_threeds (any) --->  bool\n\nResult:​\nTests whether the operand is a threeds file.\nSee also: threeds_file,\n\nis_warning​\nPossible uses:​\n\nis_warning (any expression) --->  bool\n\nResult:​\nReturns whether or not the argument raises a warning when evaluated\n\nis_xml​\nPossible uses:​\n\nis_xml (any) --->  bool\n\nResult:​\nTests whether the operand is a xml file.\nSee also: xml_file,\n\njson_file​\nPossible uses:​\n\njson_file (string) --->  file\nstring json_file map<string,unknown> --->  file\njson_file (string , map<string,unknown>) --->  file\n\nResult:​\nConstructs a file of type json. Allowed extensions are limited to json\nSpecial cases:​\n\njson_file(string): This file constructor allows to read a json file\n\nfile f <-json_file(\"file.json\");\n\njson_file(string,map<string,unknown>): This constructor allows to  store a map in a json file (it does not save it). The file can then be saved later using the save statement\n\nfile f <-json_file(\"file.json\", map([\"var1\"::1.0, \"var2\"::3.0]));\nSee also: is_json,\n\nk_nearest_neighbors​\nPossible uses:​\n\nk_nearest_neighbors (agent, map<agent,unknown>, int) --->  unknown\n\nResult:​\nThis operator allows user to find the attribute of an agent basing on its k-nearest agents\nComment:​\nIn order to use this operator, users have to create a map which map the agents with one of their attributes (for example color or size,..). In the example below, 'map' is the map that I mention above, 'k' is the number of the nearest agents that we areconsidering\nExamples:​\nunknown var0 <- self k_nearest_neighbors (map,k); // var0 equals this will return the attribute which has highest frequency in the k-nearest neighbors of our agent \n\nk_spanning_tree_clustering​\nPossible uses:​\n\ngraph k_spanning_tree_clustering int --->  list\nk_spanning_tree_clustering (graph , int) --->  list\n\nResult:​\nThe algorithm finds a minimum spanning tree T using Prim's algorithm, then executes Kruskal's algorithm only on the edges of T until k trees are formed. The resulting trees are the final clusters.It returns a list of list of vertices and takes as operand the graph and the number of clusters\n\nkappa​\nPossible uses:​\n\nkappa (list<unknown>, list<unknown>, list<unknown>) --->  float\nkappa (list<unknown>, list<unknown>, list<unknown>, list<unknown>) --->  float\n\nResult:​\nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.\nkappa indicator for 2 map comparisons: kappa(list_vals1,list_vals2,categories, weights). Reference: Cohen, J. A coefficient of agreement for nominal scales. Educ. Psychol. Meas. 1960, 20.\nExamples:​\nkappa([cat1,cat1,cat2,cat3,cat2],[cat2,cat1,cat2,cat1,cat2],[cat1,cat2,cat3]) float var1 <- kappa([1,3,5,1,5],[1,1,1,1,5],[1,3,5]); // var1 equals 0.3333333333333334 float var2 <- kappa([1,1,1,1,5],[1,1,1,1,5],[1,3,5]); // var2 equals 1.0 float var3 <- kappa([\"cat1\",\"cat3\",\"cat2\",\"cat1\",\"cat3\"],[\"cat1\",\"cat3\",\"cat2\",\"cat3\",\"cat1\"],[\"cat1\",\"cat2\",\"cat3\"], [1.0, 2.0, 3.0, 1.0, 5.0]); // var3 equals 0.29411764705882354\n\nkappa_sim​\nPossible uses:​\n\nkappa_sim (list<unknown>, list<unknown>, list<unknown>, list<unknown>) --->  float\nkappa_sim (list<unknown>, list<unknown>, list<unknown>, list<unknown>, list<unknown>) --->  float\n\nResult:​\nkappa simulation indicator for 2 map comparisons: kappa(list_valsInits,list_valsObs,list_valsSim, categories). Reference: van Vliet, J., Bregt, A.K. & Hagen-Zanker, A. (2011). Revisiting Kappa to account for change in the accuracy assessment of land-use change models, Ecological Modelling 222(8).\nSpecial cases:​\n\nkappa_sim can be used with an additional weights operand\n\nfloat var1 <- kappa_sim([\"cat1\",\"cat1\",\"cat2\",\"cat2\",\"cat2\"],[\"cat1\",\"cat3\",\"cat2\",\"cat1\",\"cat3\"],[\"cat1\",\"cat3\",\"cat2\",\"cat3\",\"cat1\"],[\"cat1\",\"cat2\",\"cat3\"], [1.0, 2.0, 3.0, 1.0, 5.0]); // var1 equals 0.2702702702702703\nExamples:​\nfloat var0 <- kappa_sim([\"cat1\",\"cat1\",\"cat2\",\"cat2\",\"cat2\"],[\"cat1\",\"cat3\",\"cat2\",\"cat1\",\"cat3\"],[\"cat1\",\"cat3\",\"cat2\",\"cat3\",\"cat1\"],[\"cat1\",\"cat2\",\"cat3\"]); // var0 equals 0.3333333333333335\n\nkmeans​\nPossible uses:​\n\nlist kmeans int --->  list<list>\nkmeans (list , int) --->  list<list>\nkmeans (list, int, int) --->  list<list>\n\nResult:​\nreturns the list of clusters (list of instance indices) computed with the kmeans++ algorithm from the first operand data according to the number of clusters to split the data into (k) and the maximum number of iterations to run the algorithm.(If negative, no maximum will be used) (maxIt). Usage: kmeans(data,k,maxit)\nSpecial cases:​\n\nThe maximum number of (third operand) can be omitted.\n\nlist<list> var1 <- kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2); // var1 equals [[0,2,3],[1]]\nExamples:​\nlist<list> var0 <- kmeans ([[2,4,5], [3,8,2], [1,1,3], [4,3,4]],2,10); // var0 equals [[0,2,3],[1]]\n\nkml​\nPossible uses:​\n\nkml (any) --->  kml\n\nResult:​\ncasts the operand in a kml object.\n\nkurtosis​\nPossible uses:​\n\nkurtosis (list) --->  float\nfloat kurtosis float --->  float\nkurtosis (float , float) --->  float\n\nResult:​\nReturns the kurtosis from a moment and a standard deviation\nReturns the kurtosis (aka excess) of a list of values (kurtosis = { [n(n+1) / (n -1)(n - 2)(n-3)] sum[(x_i - mean)^4] / std^4 } - [3(n-1)^2 / (n-2)(n-3)])\nSpecial cases:​\n\nif the length of the list is lower than 3, returns NaN\n\nExamples:​\nfloat var0 <- kurtosis(3,12) with_precision(4); // var0 equals -2.9999 float var1 <- kurtosis ([1,2,3,4,5]); // var1 equals -1.200000000000002 float var2 <- kurtosis([13,2,1,4,1,2]) with_precision(4); // var2 equals 4.8083\n\nlabel_propagation_clustering​\nPossible uses:​\n\ngraph label_propagation_clustering int --->  list\nlabel_propagation_clustering (graph , int) --->  list\n\nResult:​\nThe algorithm is a near linear time algorithm capable of discovering communities in large graphs. It is described in detail in the following: Raghavan, U. N., Albert, R., and Kumara, S. (2007). Near linear time algorithm to detect\n\ncommunity structures in large-scale networks. Physical review E, 76(3), 036106.It returns a list of list of vertices and takes as operand the graph and maximal number of iteration\n\n\nlast​\nPossible uses:​\n\nlast (container<KeyType,ValueType>) --->  ValueType\nlast (string) --->  string\nint last container --->  list\nlast (int , container) --->  list\n\nResult:​\nthe last element of the operand\nComment:​\nthe last operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a map, last returns the value of the last pair (in insertion order)\nif it is a file, last returns the last element of the content of the file (that is also a container)\nif it is a population, last returns the last agent of the population\nif it is a graph, last returns a list containing the last edge created\nif it is a matrix, last returns the element at {length-1,length-1} in the matrix\nfor a matrix of int or float, it will return 0 if the matrix is empty\nfor a matrix of object or geometry, it will return nil if the matrix is empty\nif it is a list, last returns the last element of the list, or nil if the list is empty\n\nint var0 <- last ([1, 2, 3]); // var0 equals 3\n\nif it is a string, last returns a string composed of its last character, or an empty string if the operand is empty\n\nstring var1 <- last ('abce'); // var1 equals 'e'\nSee also: first,\n\nlast_index_of​\nPossible uses:​\n\nlist last_index_of unknown --->  int\nlast_index_of (list , unknown) --->  int\nstring last_index_of string --->  int\nlast_index_of (string , string) --->  int\nmatrix last_index_of unknown --->  point\nlast_index_of (matrix , unknown) --->  point\nmap<unknown,unknown> last_index_of unknown --->  unknown\nlast_index_of (map<unknown,unknown> , unknown) --->  unknown\nspecies last_index_of unknown --->  int\nlast_index_of (species , unknown) --->  int\n\nResult:​\nthe index of the last occurence of the right operand in the left operand container\nComment:​\nThe definition of last_index_of and the type of the index depend on the container\nSpecial cases:​\n\nif the left operand is a species, the last index of an agent is the same as its index\nif the left operand is a list, last_index_of returns the index as an integer\n\nint var0 <- [1,2,3,4,5,6] last_index_of 4; // var0 equals 3 int var1 <- [4,2,3,4,5,4] last_index_of 4; // var1 equals 5\n\nif both operands are strings, returns the index within the left-hand string of the rightmost occurrence of the given right-hand string\n\nint var2 <- \"abcabcabc\" last_index_of \"ca\"; // var2 equals 5\n\nif the left operand is a matrix, last_index_of returns the index as a point\n\npoint var3 <- matrix([[1,2,3],[4,5,4]]) last_index_of 4; // var3 equals {1.0,2.0}\n\nif the left operand is a map, last_index_of returns the index as an int (the key of the pair)\n\nunknown var4 <- [1::2, 3::4, 5::4] last_index_of 4; // var4 equals 5\nSee also: at, last_index_of, index_of,\n\nlast_of​\nSame signification as last\n\nlast_with​\nPossible uses:​\n\ncontainer last_with any expression --->  unknown\nlast_with (container , any expression) --->  unknown\n\nResult:​\nthe last element of the left-hand operand that makes the right-hand operand evaluate to true.\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-hand operand is nil, last_with throws an error.\nIf there is no element that satisfies the condition, it returns nil\nif the left-operand is a map, the keyword each will contain each value\n\nunknown var4 <- [1::2, 3::4, 5::6] last_with (each >= 4); // var4 equals 6 unknown var5 <- [1::2, 3::4, 5::6].pairs last_with (each.value >= 4); // var5 equals (5::6)\nExamples:​\nint var0 <- [1,2,3,4,5,6,7,8] last_with (each > 3); // var0 equals 8 unknown var2 <- g2 last_with (length(g2 out_edges_of each) = 0 ); // var2 equals a node unknown var3 <- (list(node) last_with (round(node(each).location.x) > 32); // var3 equals node3\nSee also: group_by, first_with, where,\n\nlayout_circle​\nPossible uses:​\n\nlayout_circle (graph, geometry, bool) --->  graph\n\nResult:​\nlayouts a Gama graph on a circle with equidistance between nodes. For now there is no optimization on node ordering.\nSpecial cases:​\n\nUsage: layoutCircle(graph, bound, shuffle) => graph : the graph to layout, bound : the geometry to display the graph within, shuffle : if true shuffle the nodes, then render same ordering\n\nExamples:​\nlayout_circle(graph, world.shape, false);\n\nlayout_force​\nPossible uses:​\n\nlayout_force (graph, geometry, float, float, int) --->  graph\nlayout_force (graph, geometry, float, float, int, float) --->  graph\n\nResult:​\nlayouts a GAMA graph using Force model (in a given spatial  bound and given coeff_force, cooling_rate, max_iteration, and equilibirum criterion parameters).\nSpecial cases:​\n\nusage: layoutForce(graph, bounds, coeff_force, cooling_rate, max_iteration, equilibirum criterion). graph is the graph to which applied the layout;  bounds is the shape (geometry) in which the graph should be located; coeff_force is the coefficien use to compute the force, typical value is 0.4; cooling rate is the decreasing coefficient of the temperature, typical value is 0.01;  max_iteration is the maximal number of iterations; equilibirum criterion is the maximaldistance of displacement for a vertice to be considered as in equilibrium\nusage: layoutForce(graph, bounds, coeff_force, cooling_rate, max_iteration). graph is the graph to which applied the layout;  bounds is the shape (geometry) in which the graph should be located; coeff_force is the coefficient used to compute the force, typical value is 0.4; cooling rate is the decreasing coefficient of the temperature, typical value is 0.01;  max_iteration is the maximal number of iterationsdistance of displacement for a vertice to be considered as in equilibrium\n\n\nlayout_force_FR​\nPossible uses:​\n\nlayout_force_FR (graph, geometry, float, int) --->  graph\n\nResult:​\nlayouts a GAMA graph using Fruchterman and Reingold Force-Directed Placement Algorithm (in a given spatial bound, normalization factor and max_iteration parameters).\nSpecial cases:​\n\nusage: layoutForce(graph, bounds, normalization_factor, max_iteration, equilibirum criterion). graph is the graph to which applied the layout;  bounds is the shape (geometry) in which the graph should be located; normalization_factor is the normalization factor for the optimal distance, typical value is 1.0;   max_iteration is the maximal number of iterations\n\n\nlayout_force_FR_indexed​\nPossible uses:​\n\nlayout_force_FR_indexed (graph, geometry, float, float, int) --->  graph\n\nResult:​\nlayouts a GAMA graph using Fruchterman and Reingold Force-Directed Placement Algorithm with The Barnes-Hut indexing technique(in a given spatial bound, theta, normalization factor and max_iteration parameters).\nSpecial cases:​\n\nusage: layoutForce(graph, bounds, normalization_factor, max_iteration, equilibirum criterion). graph is the graph to which applied the layout;  bounds is the shape (geometry) in which the graph should be located; theta value for approximation using the Barnes-Hut technique, typical value is 0.5; normalization_factor is the normalization factor for the optimal distance, typical value is 1.0;   max_iteration is the maximal number of iterations\n\n\nlayout_grid​\nPossible uses:​\n\nlayout_grid (graph, geometry, float) --->  graph\n\nResult:​\nlayouts a Gama graph based on a grid latice. usage: layoutForce(graph, bounds, coeff_nb_cells). graph is the graph to which\tthe layout is applied;  bounds is the shape (geometry) in which the graph should be located; coeff_nb_cellsthe coefficient for the number of cells to locate the vertices (nb of places = coeff_nb_cells * nb of vertices).\nExamples:​\nlayout_grid(graph, world.shape);\n\nlength​\nPossible uses:​\n\nlength (container<KeyType,ValueType>) --->  int\nlength (string) --->  int\n\nResult:​\nthe number of elements contained in the operand\nComment:​\nthe length operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a population, length returns number of agents of the population\nif it is a graph, length returns the number of vertexes or of edges (depending on the way it was created)\nif it is a list or a map, length returns the number of elements in the list or map\n\nint var0 <- length([12,13]); // var0 equals 2 int var1 <- length([]); // var1 equals 0\n\nif it is a matrix, length returns the number of cells\n\nint var2 <- length(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); // var2 equals 6\n\nif it is a string, length returns the number of characters\n\nint var3 <- length (\"I am an agent\"); // var3 equals 13\n\nlgamma​\nSame signification as log_gamma\n\nline​\nPossible uses:​\n\nline (container<unknown,geometry>) --->  geometry\ncontainer<unknown,geometry> line float --->  geometry\nline (container<unknown,geometry> , float) --->  geometry\n\nResult:​\nA polyline geometry from the given list of points.\nSpecial cases:​\n\nif the points list operand is nil, returns the point geometry {0,0}\nif the points list operand is composed of a single point, returns a point geometry.\nif a radius is added, the given list of points represented as a cylinder of radius r\n\ngeometry var3 <- polyline([{0,0}, {0,10}, {10,10}, {10,0}],0.2); // var3 equals a polyline geometry composed of the 4 points.\nExamples:​\ngeometry var0 <- polyline([{0,0}, {0,10}, {10,10}]); // var0 equals a polyline geometry composed of the 3 points. geometry var1 <- line([{10,10}, {10,0}]); // var1 equals a line from 2 points. string var2 <- string(polyline([{0,0}, {0,10}, {10,10}])+line([{10,10}, {10,0}])); // var2 equals \"MULTILINESTRING ((0 0, 0 10, 10 10), (10 10, 10 0))\"\nSee also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,\n\nlink​\nPossible uses:​\n\ngeometry link geometry --->  geometry\nlink (geometry , geometry) --->  geometry\n\nResult:​\nA dynamic line geometry between the location of the two operands\nComment:​\nThe geometry of the link is a line between the locations of the two operands, which is built and maintained dynamically\nSpecial cases:​\n\nif one of the operands is nil, link returns a point geometry at the location of the other. If both are null, it returns a point geometry at {0,0}\n\nExamples:​\ngeometry var0 <- link (geom1,geom2); // var0 equals a link geometry between geom1 and geom2.\nSee also: around, circle, cone, line, norm, point, polygon, polyline, rectangle, square, triangle,\n\nlist​\nPossible uses:​\n\nlist (any) --->  list\n\nResult:​\ncasts the operand in a list object.\n\nlist_with​\nPossible uses:​\n\nint list_with any expression --->  list\nlist_with (int , any expression) --->  list\n\nResult:​\ncreates a list with a size provided by the first operand, and filled with the second operand\nComment:​\nNote that the first operand  should be positive, and that the second one is evaluated for each position  in the list.\nExamples:​\nlist var0 <- list_with(5,2); // var0 equals [2,2,2,2,2]\nSee also: list,\n\nln​\nPossible uses:​\n\nln (float) --->  float\nln (int) --->  float\n\nResult:​\nReturns the natural logarithm (base e) of the operand.\nSpecial cases:​\n\nan exception is raised if the operand is less than zero.\n\nExamples:​\nfloat var0 <- ln(exp(1)); // var0 equals 1.0 float var1 <- ln(1); // var1 equals 0.0\nSee also: exp,\n\nload_shortest_paths​\nPossible uses:​\n\ngraph load_shortest_paths matrix --->  graph\nload_shortest_paths (graph , matrix) --->  graph\n\nResult:​\nput in the graph cache the computed shortest paths contained in the matrix (rows: source, columns: target)\nExamples:​\ngraph var0 <- load_shortest_paths(shortest_paths_matrix); // var0 equals return my_graph with all the shortest paths computed\n\nload_sub_model​\nPossible uses:​\n\nstring load_sub_model string --->  agent\nload_sub_model (string , string) --->  agent\n\nResult:​\nLoad a submodel\nComment:​\nloaded submodel\n\nlog​\nPossible uses:​\n\nlog (float) --->  float\nlog (int) --->  float\n\nResult:​\nReturns the logarithm (base 10) of the operand.\nSpecial cases:​\n\nan exception is raised if the operand is equals or less than zero.\n\nExamples:​\nfloat var0 <- log(10); // var0 equals 1.0 float var1 <- log(1); // var1 equals 0.0\nSee also: ln,\n\nlog_gamma​\nPossible uses:​\n\nlog_gamma (float) --->  float\n\nResult:​\nReturns the log of the value of the Gamma function at x.\nExamples:​\nfloat var0 <- log_gamma(0.6) with_precision(4); // var0 equals 0.3982\n\nlognormal_density​\nPossible uses:​\n\nlognormal_density (float, float, float) --->  float\n\nResult:​\nlognormal_density(x,shape,scale) returns the probability density function (PDF) at the specified point x of the logNormal distribution with the given shape and scale.\nExamples:​\nfloat var0 <- lognormal_density(1,2,3) ; // var0 equals 0.731\nSee also: binomial, gamma_rnd, gauss_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, weibull_density, gamma_density,\n\nlognormal_rnd​\nPossible uses:​\n\nfloat lognormal_rnd float --->  float\nlognormal_rnd (float , float) --->  float\n\nResult:​\nreturns a random value from a Log-Normal distribution with specified values of the shape (alpha) and scale (beta) parameters. See https://en.wikipedia.org/wiki/Log-normal_distribution for more details.\nExamples:​\nfloat var0 <- lognormal_rnd(2,3); // var0 equals 0.731\nSee also: binomial, gamma_rnd, gauss_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_rnd, lognormal_trunc_rnd,\n\nlognormal_trunc_rnd​\nPossible uses:​\n\nlognormal_trunc_rnd (float, float, float, bool) --->  float\nlognormal_trunc_rnd (float, float, float, float) --->  float\n\nResult:​\nreturns a random value from a truncated Log-Normal distribution (in a range or given only one boundary) with specified values of the shape (alpha) and scale (beta) parameters. See https://en.wikipedia.org/wiki/Log-normal_distribution for more details.\nSpecial cases:​\n\nwhen 1 float and a boolean (isMax) operands are specified, the float value represents the single boundary (max if the boolean is true, min otherwise),\n\nlognormal_trunc_rnd(2,3,5,true)\n\nwhen 2 float operands are specified, they are taken as mininimum and maximum values for the result\n\nlognormal_trunc_rnd(2,3,0,5)\nSee also: lognormal_rnd, gamma_trunc_rnd, weibull_trunc_rnd, truncated_gauss,\n\nlower_case​\nPossible uses:​\n\nlower_case (string) --->  string\n\nResult:​\nConverts all of the characters in the string operand to lower case\nExamples:​\nstring var0 <- lower_case(\"Abc\"); // var0 equals 'abc'\nSee also: upper_case,\n\nmain_connected_component​\nPossible uses:​\n\nmain_connected_component (graph) --->  graph\n\nResult:​\nreturns the sub-graph corresponding to the main connected components of the graph\nExamples:​\ngraph var0 <- main_connected_component(my_graph); // var0 equals the sub-graph corresponding to the main connected components of the graph\nSee also: connected_components_of,\n\nmap​\nPossible uses:​\n\nmap (any) --->  map\n\nResult:​\ncasts the operand in a map object.\n\nmasked_by​\nPossible uses:​\n\ngeometry masked_by container<unknown,geometry> --->  geometry\nmasked_by (geometry , container<unknown,geometry>) --->  geometry\nmasked_by (geometry, container<unknown,geometry>, int) --->  geometry\n\nExamples:​\ngeometry var0 <- perception_geom masked_by obstacle_list; // var0 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list. geometry var1 <- perception_geom masked_by obstacle_list; // var1 equals the geometry representing the part of perception_geom visible from the agent position considering the list of obstacles obstacle_list.\n\nmatrix​\nPossible uses:​\n\nmatrix (any) --->  matrix\n\nResult:​\ncasts the operand in a matrix object.\n\nmatrix​\nPossible uses:​\n\nmatrix (image) --->  matrix\n\nResult:​\nReturns the matrix<int> value of the image passed in parameter, where each pixel is represented by the RGB int value. The dimensions of the matrix are those of the image.\n\nmatrix_with​\nPossible uses:​\n\npoint matrix_with any expression --->  matrix\nmatrix_with (point , any expression) --->  matrix\n\nResult:​\ncreates a matrix with a size provided by the first operand, and filled with the second operand. The given expression, unless constant, is evaluated for each cell\nComment:​\nNote that both components of the right operand point should be positive, otherwise an exception is raised.\nSee also: matrix, as_matrix,\n\nmax​\nPossible uses:​\n\nmax (container) --->  unknown\n\nResult:​\nthe maximum element found in the operand\nComment:​\nthe max operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a population of a list of other type: max transforms all elements into integer and returns the maximum of them\nif it is a map, max returns the maximum among the list of all elements value\nif it is a file, max returns the maximum of the content of the file (that is also a container)\nif it is a graph, max returns the maximum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)\nif it is a matrix of int, float or object, max returns the maximum of all the numerical elements (thus all elements for integer and float matrices)\nif it is a matrix of geometry, max returns the maximum of the list of the geometries\nif it is a matrix of another type, max returns the maximum of the elements transformed into float\nif it is a list of int of float, max returns the maximum of all the elements\n\nunknown var0 <- max ([100, 23.2, 34.5]); // var0 equals 100.0\n\nif it is a list of points: max returns the maximum of all points as a point (i.e. the point with the greatest coordinate on the x-axis, in case of equality the point with the greatest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )\n\nunknown var1 <- max([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); // var1 equals {9.0,1.0}\nSee also: min,\n\nmax_flow_between​\nPossible uses:​\n\nmax_flow_between (graph, unknown, unknown) --->  map<unknown,float>\n\nResult:​\nThe max flow (map<edge,flow> in a graph between the source and the sink using Edmonds-Karp algorithm\nExamples:​\nmax_flow_between(my_graph, vertice1, vertice2)\n\nmax_of​\nPossible uses:​\n\ncontainer max_of any expression --->  unknown\nmax_of (container , any expression) --->  unknown\n\nResult:​\nthe maximum value of the right-hand expression evaluated on each of the elements of the left-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nAs of GAMA 1.6, if the left-hand operand is nil or empty, max_of throws an error\nif the left-operand is a map, the keyword each will contain each value\n\nunknown var4 <- [1::2, 3::4, 5::6] max_of (each + 3); // var4 equals 9\nExamples:​\nunknown var0 <- [1,2,4,3,5,7,6,8] max_of (each * 100 ); // var0 equals 800 graph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var2 <- g2.vertices max_of (g2 degree_of( each )); // var2 equals 2 unknown var3 <- (list(node) max_of (round(node(each).location.x)); // var3 equals 96\nSee also: min_of,\n\nmaximal_cliques_of​\nPossible uses:​\n\nmaximal_cliques_of (graph) --->  list<list>\n\nResult:​\nreturns the maximal cliques of a graph using the Bron-Kerbosch clique detection algorithm: A clique is maximal if it is impossible to enlarge it by adding another vertex from the graph. Note that a maximal clique is not necessarily the biggest clique in the graph.\nExamples:​\ngraph my_graph <- graph([]); list<list> var1 <- maximal_cliques_of (my_graph); // var1 equals the list of all the maximal cliques as list\nSee also: biggest_cliques_of,\n\nmean​\nPossible uses:​\n\nmean (container) --->  unknown\n\nResult:​\nthe mean of all the elements of the operand\nComment:​\nthe elements of the operand are summed (see sum for more details about the sum of container elements ) and then the sum value is divided by the number of elements.\nSpecial cases:​\n\nif the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color\n\nExamples:​\nunknown var0 <- mean ([4.5, 3.5, 5.5, 7.0]); // var0 equals 5.125 \nSee also: sum,\n\nmean_deviation​\nPossible uses:​\n\nmean_deviation (container) --->  float\n\nResult:​\nthe deviation from the mean of all the elements of the operand. See Mean_deviation for more details.\nComment:​\nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\nExamples:​\nfloat var0 <- mean_deviation ([4.5, 3.5, 5.5, 7.0]); // var0 equals 1.125\nSee also: mean, standard_deviation,\n\nmean_of​\nPossible uses:​\n\ncontainer mean_of any expression --->  unknown\nmean_of (container , any expression) --->  unknown\n\nResult:​\nthe mean of the right-hand expression evaluated on each of the elements of the left-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-operand is a map, the keyword each will contain each value\n\nunknown var1 <- [1::2, 3::4, 5::6] mean_of (each); // var1 equals 4\nExamples:​\nunknown var0 <- [1,2] mean_of (each * 10 ); // var0 equals 15\nSee also: min_of, max_of, sum_of, product_of,\n\nmedian​\nPossible uses:​\n\nmedian (container) --->  unknown\n\nResult:​\nthe median of all the elements of the operand.\nSpecial cases:​\n\nif the container contains points, the result will be a point. If the container contains rgb values, the result will be a rgb color\n\nExamples:​\nunknown var0 <- median ([4.5, 3.5, 5.5, 3.4, 7.0]); // var0 equals 4.5\nSee also: mean,\n\nmental_state​\nPossible uses:​\n\nmental_state (any) --->  mental_state\n\nResult:​\ncasts the operand in a mental_state object.\n\nmessage​\nPossible uses:​\n\nmessage (any) --->  message\n\nResult:​\ncasts the operand in a message object.\n\nmilliseconds_between​\nPossible uses:​\n\ndate milliseconds_between date --->  float\nmilliseconds_between (date , date) --->  float\n\nResult:​\nProvide the exact number of milliseconds between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\nExamples:​\nfloat var0 <- milliseconds_between(date('2000-01-01'), date('2000-02-01')); // var0 equals 2.6784E9\n\nmin​\nPossible uses:​\n\nmin (container) --->  unknown\n\nResult:​\nthe minimum element found in the operand.\nComment:​\nthe min operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a list of points: min returns the minimum of all points as a point (i.e. the point with the smallest coordinate on the x-axis, in case of equality the point with the smallest coordinate on the y-axis is chosen. If all the points are equal, the first one is returned. )\nif it is a population of a list of other types: min transforms all elements into integer and returns the minimum of them\nif it is a map, min returns the minimum among the list of all elements value\nif it is a file, min returns the minimum of the content of the file (that is also a container)\nif it is a graph, min returns the minimum of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)\nif it is a matrix of int, float or object, min returns the minimum of all the numerical elements (thus all elements for integer and float matrices)\nif it is a matrix of geometry, min returns the minimum of the list of the geometries\nif it is a matrix of another type, min returns the minimum of the elements transformed into float\nif it is a list of int or float: min returns the minimum of all the elements\n\nunknown var0 <- min ([100, 23.2, 34.5]); // var0 equals 23.2\nSee also: max,\n\nmin_of​\nPossible uses:​\n\ncontainer min_of any expression --->  unknown\nmin_of (container , any expression) --->  unknown\n\nResult:​\nthe minimum value of the right-hand expression evaluated on each of the elements of the left-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-hand operand is nil or empty, min_of throws an error\nif the left-operand is a map, the keyword each will contain each value\n\nunknown var4 <- [1::2, 3::4, 5::6] min_of (each + 3); // var4 equals 5\nExamples:​\nunknown var0 <- [1,2,4,3,5,7,6,8] min_of (each * 100 ); // var0 equals 100 graph g2 <- as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var2 <- g2 min_of (length(g2 out_edges_of each) ); // var2 equals 0 unknown var3 <- (list(node) min_of (round(node(each).location.x)); // var3 equals 4\nSee also: max_of,\n\nminus_days​\nPossible uses:​\n\ndate minus_days int --->  date\nminus_days (date , int) --->  date\n\nResult:​\nSubtract a given number of days from a date\nExamples:​\ndate var0 <- date('2000-01-01') minus_days 20; // var0 equals date('1999-12-12')\n\nminus_hours​\nPossible uses:​\n\ndate minus_hours int --->  date\nminus_hours (date , int) --->  date\n\nResult:​\nRemove a given number of hours from a date\nExamples:​\n// equivalent to date1 - 15 #h date var1 <- date('2000-01-01') minus_hours 15 ; // var1 equals date('1999-12-31 09:00:00')\n\nminus_minutes​\nPossible uses:​\n\ndate minus_minutes int --->  date\nminus_minutes (date , int) --->  date\n\nResult:​\nSubtract a given number of minutes from a date\nExamples:​\n// date('2000-01-01') to date1 - 5#mn date var1 <- date('2000-01-01') minus_minutes 5 ; // var1 equals date('1999-12-31 23:55:00')\n\nminus_months​\nPossible uses:​\n\ndate minus_months int --->  date\nminus_months (date , int) --->  date\n\nResult:​\nSubtract a given number of months from a date\nExamples:​\ndate var0 <- date('2000-01-01') minus_months 5; // var0 equals date('1999-08-01')\n\nminus_ms​\nPossible uses:​\n\ndate minus_ms int --->  date\nminus_ms (date , int) --->  date\n\nResult:​\nRemove a given number of milliseconds from a date\nExamples:​\n// equivalent to date1 - 15 #ms date var1 <- date('2000-01-01') minus_ms 1000 ; // var1 equals date('1999-12-31 23:59:59')\n\nminus_seconds​\nSame signification as -\n\nminus_weeks​\nPossible uses:​\n\ndate minus_weeks int --->  date\nminus_weeks (date , int) --->  date\n\nResult:​\nSubtract a given number of weeks from a date\nExamples:​\ndate var0 <- date('2000-01-01') minus_weeks 15; // var0 equals date('1999-09-18')\n\nminus_years​\nPossible uses:​\n\ndate minus_years int --->  date\nminus_years (date , int) --->  date\n\nResult:​\nSubtract a given number of year from a date\nExamples:​\ndate var0 <- date('2000-01-01') minus_years 3; // var0 equals date('1997-01-01')\n\nmod​\nPossible uses:​\n\nint mod int --->  int\nmod (int , int) --->  int\n\nResult:​\nReturns the remainder of the integer division of the left-hand operand by the right-hand operand.\nSpecial cases:​\n\nif operands are float, they are truncated\nif the right-hand operand is equal to zero, raises an exception.\n\nExamples:​\nint var0 <- 40 mod 3; // var0 equals 1\nSee also: div,\n\nmoment​\nPossible uses:​\n\nmoment (container, int, float) --->  float\n\nResult:​\nReturns the moment of k-th order with constant c of a data sequence\nExamples:​\nfloat var0 <- moment([13,2,1,4,1,2], 2, 1.2) with_precision(4); // var0 equals 24.74\n\nmonths_between​\nPossible uses:​\n\ndate months_between date --->  int\nmonths_between (date , date) --->  int\n\nResult:​\nProvide the exact number of months between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\nExamples:​\nint var0 <- months_between(date('2000-01-01'), date('2000-02-01')); // var0 equals 1\n\nmoran​\nPossible uses:​\n\nlist<float> moran matrix<float> --->  float\nmoran (list<float> , matrix<float>) --->  float\n\nSpecial cases:​\n\nreturn the Moran Index of the given list of interest points (list of floats) and the weight matrix (matrix of float)\n\nfloat var0 <- moran([1.0, 0.5, 2.0], weight_matrix); // var0 equals the Moran index is computed\n\nmorrisAnalysis​\nPossible uses:​\n\nmorrisAnalysis (string, int, int) --->  string\n\nResult:​\nReturn a string containing the Report of the morris analysis for the corresponding CSV file\n\nmul​\nPossible uses:​\n\nmul (container) --->  unknown\n\nResult:​\nthe product of all the elements of the operand\nComment:​\nthe mul operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a list of points: mul returns the product of all points as a point (each coordinate is the product of the corresponding coordinate of each element)\nif it is a list of other types: mul transforms all elements into integer and multiplies them\nif it is a map, mul returns the product of the value of all elements\nif it is a file, mul returns the product of the content of the file (that is also a container)\nif it is a graph, mul returns the product of the list of the elements of the graph (that can be the list of edges or vertexes depending on the graph)\nif it is a matrix of int, float or object, mul returns the product of all the numerical elements (thus all elements for integer and float matrices)\nif it is a matrix of geometry, mul returns the product of the list of the geometries\nif it is a matrix of other types: mul transforms all elements into float and multiplies them\nif it is a list of int or float: mul returns the product of all the elements\n\nunknown var0 <- mul ([100, 23.2, 34.5]); // var0 equals 80040.0\nSee also: sum,"},{"filePath":"https:--gama-platform.org--wiki-OperatorsNR.txt","text":"Operators (N to R)\nThis file is automatically generated from java files. Do Not Edit It.\n\nDefinition​\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.\nMost of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).\nThe ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.  - 10, ! (operand1 or operand2)).\nFinally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n\nif they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))\nif they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.\nif they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\nPriority between operators​\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n\nthe constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values.\nit is followed by the ?: operator, the functional if-else (e.g.  a > b ? a + 10 : a - 10 will return the result of the if-else).\nnext are the logical operators, and and or (e.g. a > b or b > c will return the value of the test)\nnext are the comparison operators (i.e. >, <, <=, >=, =, !=)\nnext the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\nnext the unary operators - and !\nnext the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)\nand finally the functional operators, which have the highest priority of all.\n\n\nUsing actions as operators​\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\nFor instance, if the following species is defined:\nspecies spec1 {        int min(int x, int y) {                return x > y ? x : y;        }}\nAny agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\nglobal {        init {                create spec1;                spec1 my_agent <- spec1[0];                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);        }}\nIf the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\nTable of Contents​\n\nOperators by categories​\n\n3D​\nbox, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,\n\nArithmetic operators​\n-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,\n\nBDI​\nadd_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,\n\nCasting operators​\nas, as_int, as_matrix, field_with, font, is, is_skill, list_with, matrix_with, species_of, to_gaml, to_geojson, to_list, with_size, with_style,\n\nColor-related operators​\n-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum, to_hsb,\n\nComparison operators​\n!=, <, <=, =, >, >=, between,\n\nContainers-related operators​\n-, ::, +, accumulate, all_match, among, as_json_string, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,\n\nDate-related operators​\n-, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,\n\nDates​\n\nDisplays​\nhorizontal, stack, vertical,\n\nedge​\nedge_between, strahler,\n\nEDP-related operators​\ndiff, diff2,\n\nFiles-related operators​\nagent_file, copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_agent, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_shape, is_simulation, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, shape_file, simulation_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,\n\nGamaMetaType​\ntype_of,\n\nGamaSVGFile​\nimage,\n\nGraphs-related operators​\nadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,\n\nGrid-related operators​\nas_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,\n\nImageOperators​\n*, antialiased, blend, blurred, brighter, clipped_with, darker, grayscale, horizontal_flip, image, matrix, rotated_by, sharpened, snapshot, tinted_with, vertical_flip, with_height, with_size, with_width,\n\nIterator operators​\naccumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,\n\nList-related operators​\nall_indexes_of, copy_between, index_of, last_index_of,\n\nLogical operators​\n:, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,\n\nMap comparaison operators​\nfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,\n\nMap-related operators​\nas_map, create_map, index_of, last_index_of,\n\nMatrix-related operators​\n-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, flatten, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,\n\nmulticriteria operators​\nelectre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,\n\nPath-related operators​\nagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,\n\nPedestrian​\ngenerate_pedestrian_network,\n\nPoints-related operators​\n-, /, *, +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,\n\nRandom operators​\nbinomial, exp_density, exp_rnd, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,\n\nReverseOperators​\nserialize,\n\nShape​\narc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,\n\nSpatial operators​\n-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, k_nearest_neighbors, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,\n\nSpatial properties operators​\ncovers, crosses, intersects, partially_overlaps, touches,\n\nSpatial queries operators​\nagent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,\n\nSpatial relations operators​\ndirection_between, distance_between, distance_to, path_between, path_to, towards,\n\nSpatial statistical operators​\nhierarchical_clustering, k_nearest_neighbors, simple_clustering_by_distance,\n\nSpatial transformations operators​\n-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,\n\nSpecies-related operators​\nindex_of, last_index_of, of_generic_species, of_species,\n\nStatistical operators​\nauto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, k_nearest_neighbors, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, morrisAnalysis, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, residuals, rms, rSquare, simple_clustering_by_distance, skewness, sobolAnalysis, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,\n\nStrings-related operators​\n+, <, <=, >, >=, at, capitalize, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,\n\nSubModel​\nload_sub_model,\n\nSystem​\n., choose, command, copy, copy_from_clipboard, copy_to_clipboard, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, play_sound, user_confirm, user_input_dialog, wizard, wizard_page,\n\nTime-related operators​\ndate, string,\n\nTypes-related operators​\naction, agent, attributes, BDIPlan, bool, container, conversation, directory, emotion, file, float, gaml_type, geometry, graph, int, kml, list, map, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, topology, unknown,\n\nUser control operators​\nchoose, enter, user_confirm, user_input_dialog, wizard, wizard_page,\n\nOperators​\n\nnb_cycles​\nPossible uses:​\n\nnb_cycles (graph) --->  int\n\nResult:​\nreturns the maximum number of independent cycles in a graph. This number (u) is estimated through the number of nodes (v), links (e) and of sub-graphs (p): u = e - v + p.\nExamples:​\ngraph graphEpidemio <- graph([]); int var1 <- nb_cycles(graphEpidemio); // var1 equals the number of cycles in the graph\nSee also: alpha_index, beta_index, gamma_index, connectivity_index,\n\nneighbors_at​\nPossible uses:​\n\ngeometry neighbors_at float --->  list\nneighbors_at (geometry , float) --->  list\n\nResult:​\na list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the right-hand operand to the left-hand operand (geometry, agent, point).\nComment:​\nThe topology used to compute the neighborhood  is the one of the left-operand if this one is an agent; otherwise the one of the agent applying the operator.\nExamples:​\nlist var0 <- (self neighbors_at (10)); // var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator.\nSee also: neighbors_of, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to, at_distance,\n\nneighbors_of​\nPossible uses:​\n\nfield neighbors_of point --->  list<point>\nneighbors_of (field , point) --->  list<point>\ngraph neighbors_of unknown --->  list\nneighbors_of (graph , unknown) --->  list\ntopology neighbors_of agent --->  list\nneighbors_of (topology , agent) --->  list\nneighbors_of (topology, geometry, float) --->  list\n\nResult:​\na list, containing all the agents of the same species than the argument (if it is an agent) located at a distance inferior or equal to 1 to the right-hand operand agent considering the left-hand operand topology.\nSpecial cases:​\n\na list, containing all the agents of the same species than the left argument (if it is an agent) located at a distance inferior or equal to the third argument to the second argument (agent, geometry or point) considering the first operand topology.\n\nlist var0 <- neighbors_of (topology(self), self,10); // var0 equals all the agents located at a distance lower or equal to 10 to the agent applying the operator considering its topology.\nExamples:​\nlist var1 <- graphEpidemio neighbors_of (node(3)); // var1 equals [node0,node2] list var2 <- graphFromMap neighbors_of node({12,45}); // var2 equals [{1.0,5.0},{34.0,56.0}] list var3 <- topology(self) neighbors_of self; // var3 equals returns all the agents located at a distance lower or equal to 1 to the agent applying the operator considering its topology.\nSee also: predecessors_of, successors_of, neighbors_at, closest_to, overlapping, agents_overlapping, agents_inside, agent_closest_to,\n\nnew_emotion​\nPossible uses:​\n\nnew_emotion (string) --->  emotion\nstring new_emotion predicate --->  emotion\nnew_emotion (string , predicate) --->  emotion\nstring new_emotion float --->  emotion\nnew_emotion (string , float) --->  emotion\nstring new_emotion agent --->  emotion\nnew_emotion (string , agent) --->  emotion\nnew_emotion (string, float, agent) --->  emotion\nnew_emotion (string, float, float) --->  emotion\nnew_emotion (string, predicate, agent) --->  emotion\nnew_emotion (string, float, predicate) --->  emotion\nnew_emotion (string, float, predicate, agent) --->  emotion\nnew_emotion (string, float, float, agent) --->  emotion\nnew_emotion (string, float, predicate, float) --->  emotion\nnew_emotion (string, float, predicate, float, agent) --->  emotion\n\nResult:​\na new emotion with the given properties (at least its name, and eventually intensity, parameters...)\nSpecial cases:​\n\na new emotion with a given name and the predicate it is about\n\nnew_emotion(\"joy\",estFood) new_emotion(\"joy\",agent1)\n\nA decay value value can be added to define a new emotion.\n\nnew_emotion(\"joy\",12.3,4.0)\n\na new emotion with a name and an initial intensity:\n\nnew_emotion(\"joy\",12.3)\n\na new emotion with a given name and the agent which has caused this emotion\n\nnew_emotion(\"joy\",agent1)\n\nVarious combinations are possible to create the emotion: (name,intensity,about), (name,about,cause), (name,intensity,cause)...\n\nnew_emotion(\"joy\",12.3,eatFood) new_emotion(\"joy\",eatFood,agent1) new_emotion(\"joy\",12.3,agent1)\nExamples:​\nnew_emotion(\"joy\") emotion(\"joy\",12.3,eatFood,4,agent1) new_emotion(\"joy\",12.3,eatFood,agent1) emotion(\"joy\", 12.3, 4, agent1) new_emotion(\"joy\",12.3,eatFood,4.0)\n\nnew_folder​\nPossible uses:​\n\nnew_folder (string) --->  file\n\nResult:​\nopens an existing repository or create a new folder if it does not exist.\nSpecial cases:​\n\nIf the specified string does not refer to an existing repository, the repository is created.\nIf the string refers to an existing file, an exception is risen.\n\nExamples:​\nfile dirNewT <- new_folder(\"incl/\");   \t// dirNewT represents the repository \"../incl/\" \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// eventually creates the directory ../incl\nSee also: folder, file, folder_exists,\n\nnew_mental_state​\nPossible uses:​\n\nnew_mental_state (string) --->  mental_state\nstring new_mental_state mental_state --->  mental_state\nnew_mental_state (string , mental_state) --->  mental_state\nstring new_mental_state predicate --->  mental_state\nnew_mental_state (string , predicate) --->  mental_state\nstring new_mental_state emotion --->  mental_state\nnew_mental_state (string , emotion) --->  mental_state\nnew_mental_state (string, mental_state, int) --->  mental_state\nnew_mental_state (string, emotion, int) --->  mental_state\nnew_mental_state (string, mental_state, float) --->  mental_state\nnew_mental_state (string, emotion, float) --->  mental_state\nnew_mental_state (string, predicate, agent) --->  mental_state\nnew_mental_state (string, emotion, agent) --->  mental_state\nnew_mental_state (string, predicate, int) --->  mental_state\nnew_mental_state (string, mental_state, agent) --->  mental_state\nnew_mental_state (string, predicate, float) --->  mental_state\nnew_mental_state (string, emotion, float, agent) --->  mental_state\nnew_mental_state (string, mental_state, float, agent) --->  mental_state\nnew_mental_state (string, mental_state, float, int) --->  mental_state\nnew_mental_state (string, emotion, int, agent) --->  mental_state\nnew_mental_state (string, emotion, float, int) --->  mental_state\nnew_mental_state (string, predicate, int, agent) --->  mental_state\nnew_mental_state (string, predicate, float, int) --->  mental_state\nnew_mental_state (string, mental_state, int, agent) --->  mental_state\nnew_mental_state (string, predicate, float, agent) --->  mental_state\nnew_mental_state (string, mental_state, float, int, agent) --->  mental_state\nnew_mental_state (string, predicate, float, int, agent) --->  mental_state\nnew_mental_state (string, emotion, float, int, agent) --->  mental_state\n\nResult:​\ncreates a new mental state with a given modality (e.g. belief or desire) and various properties (a predicate it is about, a strength, a lifetime, an ower agent  and an emotion it is about\nExamples:​\nnew_mental_state(\"belief\", mental_state1, 12.3, 10, agent1) new_mental_state(\"belief\", mental_state1, 10) new_mental_state(\"belief\",  my_joy, 10) new_mental_state(\"belief\") new_mental_state(\"belief\",raining, 12.3, 10, agent1) new_mental_state(\"belief\", mental_state1, 12.3) new_mental_state(\"belief\", my_joy, 12.3, agent1) new_mental_state(\"belief\", my_joy, 12.3, 10, agent1) new_mental_state(\"belief\", mental_state1, 12.2, agent1) new_mental_state(\"belief\", mental_state1, 12.3, 10) new_mental_state(\"belief\", my_joy, 12.3) new_mental_state(\"belief\", my_joy, 10, agent1) new_mental_state(\"belief\", my_joy, 12.3, 10) new_mental_state(\"belief\", raining, 10, agent1) new_mental_state(\"belief\", mental_state1) new_mental_state(\"belief\", raining) new_mental_state(\"belief\", raining, agent1) new_mental_state(\"belief\", my_joy, agent1) new_mental_state(\"belief\", raining, 12.4, 10) new_mental_state(\"belief\", mental_state1, 10, agent1) new_mental_state(\"belief\", raining, 10) new_mental_state(\"belief\", raining, 12.3, agent1) new_mental_state(\"belief\", mental_state1, agent1) new_mental_state(\"belief\", my_joy) new_mental_state(\"belief\", raining, 0.5)\n\nnew_predicate​\nPossible uses:​\n\nnew_predicate (string) --->  predicate\nstring new_predicate bool --->  predicate\nnew_predicate (string , bool) --->  predicate\nstring new_predicate map --->  predicate\nnew_predicate (string , map) --->  predicate\nstring new_predicate agent --->  predicate\nnew_predicate (string , agent) --->  predicate\nnew_predicate (string, map, bool) --->  predicate\nnew_predicate (string, map, agent) --->  predicate\nnew_predicate (string, map, bool, agent) --->  predicate\n\nResult:​\ncreates a new predicate with a given name and adidtional properties (values, agent causing the predicate, whether it is true...)\nExamples:​\nnew_predicate(\"hasWater\", true) new_predicate(\"people to meet\", [\"time\"::10], true) new_predicate(\"people to meet\", map([\"val1\"::23]) ) new_predicate(\"people to meet\", [\"time\"::10], agentA) new_predicate(\"people to meet\", agent1) new_predicate(\"people to meet\") new_predicate(\"people to meet\", [\"time\"::10], true, agentA)\n\nnew_social_link​\nPossible uses:​\n\nnew_social_link (agent) --->  social_link\nnew_social_link (agent, float, float, float, float) --->  social_link\n\nResult:​\ncreates a new social link with another agent (eventually given additional parameters such as the appreciation, dominance, solidarity, and familiarity values).\nExamples:​\nnew_social_link(agentA) new_social_link(agentA,0.0,-0.1,0.2,0.1)\n\nnode​\nPossible uses:​\n\nnode (unknown) --->  unknown\nunknown node float --->  unknown\nnode (unknown , float) --->  unknown\n\nResult:​\nAllows to create a wrapper (of type unknown) that wraps an actual object and indicates it should be considered as a node of a graph. The second (optional) parameter indicates which weight the node should have in the graph\nComment:​\nUseful only in graph-related operations (addition, removal of nodes, creation of graphs)\n\nnodes​\nPossible uses:​\n\nnodes (container) --->  container\n\nResult:​\nAllows to create a wrapper (of type list) that wraps a list of objects and indicates they should be considered as nodes of a graph\n\nnone_matches​\nPossible uses:​\n\ncontainer none_matches any expression --->  bool\nnone_matches (container , any expression) --->  bool\n\nResult:​\nReturns true if none of the elements of the left-hand operand make the right-hand operand evaluate to true. 'c none_matches each.property' is strictly equivalent to '(c count each.property) = 0'\nComment:​\nIn the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\nSpecial cases:​\n\nIf the left-hand operand is nil, none_matches throws an error.\nIf the left-hand operand is empty, none_matches returns true.\n\nExamples:​\nbool var0 <- [1,2,3,4,5,6,7,8] none_matches (each > 3); // var0 equals false bool var1 <- [1::2, 3::4, 5::6] none_matches (each > 4); // var1 equals false\nSee also: one_matches, all_match, count,\n\nnone_verifies​\nSame signification as none_matches\n\nnorm​\nPossible uses:​\n\nnorm (point) --->  float\n\nResult:​\nthe norm of the vector with the coordinates of the point operand.\nExamples:​\nfloat var0 <- norm({3,4}); // var0 equals 5.0\n\nNorm​\nPossible uses:​\n\nNorm (any) --->  Norm\n\nResult:​\ncasts the operand in a Norm object.\n\nnormal_area​\nPossible uses:​\n\nnormal_area (float, float, float) --->  float\n\nResult:​\nReturns the area to the left of x in the normal distribution with the given mean and standard deviation.\nExamples:​\nfloat var0 <- normal_area(0.9,0,1) with_precision(3); // var0 equals 0.816\n\nnormal_density​\nPossible uses:​\n\nnormal_density (float, float, float) --->  float\n\nResult:​\nReturns the probability of x in the normal distribution with the given mean and standard deviation.\nExamples:​\nfloat var0 <- (normal_density(2,1,1)*100) with_precision 2; // var0 equals 24.2\n\nnormal_inverse​\nPossible uses:​\n\nnormal_inverse (float, float, float) --->  float\n\nResult:​\nReturns the x in the normal distribution with the given mean and standard deviation, to the left of which lies the given area. normal.\nExamples:​\nfloat var0 <- normal_inverse(0.98,0,1) with_precision(2); // var0 equals 2.05\n\nnormalized_rotation​\nPossible uses:​\n\nnormalized_rotation (pair) --->  pair<float,point>\n\nResult:​\nThe rotation normalized according to Euler formalism with a positive angle, such that each rotation has a unique set of parameters (positive angle, normalize axis rotation).\nExamples:​\npair<float,point> var0 <- normalized_rotation(-38.0::{1,1,1}); // var0 equals 38.0::{-0.5773502691896258,-0.5773502691896258,-0.5773502691896258}\nSee also: [rotation_composition, inverse_rotation](OperatorsSZ#rotation_composition, inverse_rotation),\n\nnot​\nSame signification as !\n\nnot​\nPossible uses:​\n\nnot (predicate) --->  predicate\n\nResult:​\ncreate a new predicate with the inverse truth value\nExamples:​\nnot predicate1\n\nobj_file​\nPossible uses:​\n\nobj_file (string) --->  file\nstring obj_file pair<float,point> --->  file\nobj_file (string , pair<float,point>) --->  file\nstring obj_file string --->  file\nobj_file (string , string) --->  file\nobj_file (string, string, pair<float,point>) --->  file\n\nResult:​\nConstructs a file of type obj. Allowed extensions are limited to obj, OBJ\nSpecial cases:​\n\nobj_file(string): This file constructor allows to read an obj file. The associated mlt file have to have the same name as the file to be read.\n\nfile f <- obj_file(\"file.obj\");\n\nobj_file(string,pair<float,point>): This file constructor allows to read an obj file and apply an init rotation to it. The rotationis a pair angle::rotation vector. The associated mlt file have to have the same name as the file to be read.\n\nfile f <- obj_file(\"file.obj\", 90.0::{-1,0,0});\n\nobj_file(string,string): This file constructor allows to read an obj file, using a specific mlt file\n\nfile f <- obj_file(\"file.obj\",\"file.mlt\");\n\nobj_file(string,string,pair<float,point>): This file constructor allows to read an obj file, using a specific mlt file, and apply an init rotation to it. The rotationis a pair angle::rotation vector\n\nfile f <- obj_file(\"file.obj\",\"file.mlt\", 90.0::{-1,0,0});\nSee also: is_obj,\n\nof​\nSame signification as .\n\nof_generic_species​\nPossible uses:​\n\ncontainer of_generic_species species --->  list\nof_generic_species (container , species) --->  list\n\nResult:​\na list, containing the agents of the left-hand operand whose species is that denoted by the right-hand operand and whose species extends the right-hand operand species\nExamples:​\n// species speciesA {} // species sub_speciesA parent: speciesA {} list var2 <- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_generic_species speciesA; // var2 equals [sub_speciesA0,sub_speciesA1,speciesA0,speciesA1] list var3 <- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_generic_species sous_test; // var3 equals [sub_speciesA0,sub_speciesA1] list var4 <- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_species speciesA; // var4 equals [speciesA0,speciesA1] list var5 <- [sub_speciesA(0),sub_speciesA(1),speciesA(2),speciesA(3)] of_species sous_test; // var5 equals [sub_speciesA0,sub_speciesA1]\nSee also: of_species,\n\nof_species​\nPossible uses:​\n\ncontainer of_species species --->  list\nof_species (container , species) --->  list\n\nResult:​\na list, containing the agents of the left-hand operand whose species is the one denoted by the right-hand operand.The expression agents of_species (species self) is equivalent to agents where (species each = species self); however, the advantage of using the first syntax is that the resulting list is correctly typed with the right species, whereas, in the second syntax, the parser cannot determine the species of the agents within the list (resulting in the need to cast it explicitly if it is to be used in an ask statement, for instance).\nSpecial cases:​\n\nif the right operand is nil, of_species returns the right operand\n\nExamples:​\nlist var0 <- (self neighbors_at 10) of_species (species (self)); // var0 equals all the neighboring agents of the same species. list var1 <- [test(0),test(1),node(1),node(2)] of_species test; // var1 equals [test0,test1]\nSee also: of_generic_species,\n\none_matches​\nPossible uses:​\n\ncontainer one_matches any expression --->  bool\none_matches (container , any expression) --->  bool\n\nResult:​\nReturns true if at least one of the elements of the left-hand operand make the right-hand operand evaluate to true.  Returns false if the left-hand operand is empty. 'c one_matches each.property' is strictly equivalent to '(c count each.property) > 0' but faster in most cases (as it is a shortcircuited operator)\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\nSpecial cases:​\n\nif the left-hand operand is nil, one_matches throws an error\n\nExamples:​\nbool var0 <- [1,2,3,4,5,6,7,8] one_matches (each > 3); // var0 equals true bool var1 <- [1::2, 3::4, 5::6] one_matches (each > 4); // var1 equals true\nSee also: none_matches, all_match, count,\n\none_of​\nPossible uses:​\n\none_of (container<KeyType,ValueType>) --->  ValueType\n\nResult:​\none of the values stored in this container  at a random key\nComment:​\nthe one_of operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif the operand is empty, one_of returns nil\nif it is a graph, one_of returns one of the lists of edges\nif it is a file, one_of returns one of the elements of the content of the file (that is also a container)\nif it is a list or a matrix, one_of returns one of the values of the list or of the matrix\n\ninti <- any ([1,2,3]);  // i equals 1, 2 or 3 string sMat <- one_of(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); \t// sMat equals \"c11\",\"c12\",\"c13\", \"c21\",\"c22\" or \"c23\"\n\nif it is a map, one_of returns one the value of a random pair of the map\n\nint im <- one_of ([2::3, 4::5, 6::7]);\t// im equals 3, 5 or 7 bool var3 <- [2::3, 4::5, 6::7].values contains im; // var3 equals true\n\nif it is a population, one_of returns one of the agents of the population\n\nbug b <- one_of(bug);  \t// Given a previously defined species bug, b is one of the created bugs, e.g. bug3\nSee also: contains,\n\none_verifies​\nSame signification as one_matches\n\nor​\nPossible uses:​\n\nbool or any expression --->  bool\nor (bool , any expression) --->  bool\n\nResult:​\na bool value, equal to the logical or between the left-hand operand and the right-hand operand.\nComment:​\nboth operands are always casted to bool before applying the operator. Thus, an expression like 1 or 0 is accepted and returns true.\nExamples:​\nbool var0 <- true or false; // var0 equals true  int a <-3 ; int b <- 4; int c <- 7; bool var2 <- ((a+b) = c ) or ((a+b) > c ); // var2 equals true\nSee also: bool, and, !,\n\nor​\nPossible uses:​\n\npredicate or predicate --->  predicate\nor (predicate , predicate) --->  predicate\n\nResult:​\ncreate a new predicate from two others by including them as subintentions. It's an exclusive \"or\"\nExamples:​\npredicate1 or predicate2\n\nosm_file​\nPossible uses:​\n\nosm_file (string) --->  file\nstring osm_file map<string,list> --->  file\nosm_file (string , map<string,list>) --->  file\n\nResult:​\nConstructs a file of type osm. Allowed extensions are limited to osm, pbf, bz2, gz\nSpecial cases:​\n\nosm_file(string): This file constructor allows to read a osm (.osm, .pbf, .bz2, .gz) file (using WGS84 coordinate system for the data)\n\nfile f <- osm_file(\"file\");\n\nosm_file(string,map<string,list>): This file constructor allows to read an osm (.osm, .pbf, .bz2, .gz) file (using WGS84 coordinate system for the data)The map is used to filter the objects in the file according their attributes: for each key (string) of the map, only the objects that have a value for the  attribute contained in the value set are kept. For an exhaustive list of the attibute of OSM data, see: http://wiki.openstreetmap.org/wiki/Map_Features\n\nvoid var1 <- file f <- osm_file(\"file\", map([\"highway\"::[\"primary\", \"secondary\"], \"building\"::[\"yes\"], \"amenity\"::[]]));; // var1 equals f will contain all the objects of file that have the attibute 'highway' with the value 'primary' or 'secondary', and the objects that have the attribute 'building' with the value 'yes', and all the objects that have the attribute 'aminity' (whatever the value).\nSee also: is_osm,\n\nout_degree_of​\nPossible uses:​\n\ngraph out_degree_of unknown --->  int\nout_degree_of (graph , unknown) --->  int\n\nResult:​\nreturns the out degree of a vertex (right-hand operand) in the graph given as left-hand operand.\nExamples:​\nint var1 <- graphFromMap out_degree_of (node(3)); // var1 equals 4\nSee also: in_degree_of, degree_of,\n\nout_edges_of​\nPossible uses:​\n\ngraph out_edges_of unknown --->  list\nout_edges_of (graph , unknown) --->  list\n\nResult:​\nreturns the list of the out-edges of a vertex (right-hand operand) in the graph given as left-hand operand.\nExamples:​\nlist var1 <- graphFromMap out_edges_of (node(3)); // var1 equals 3\nSee also: in_edges_of,\n\noverlapping​\nPossible uses:​\n\ncontainer<unknown,geometry> overlapping geometry --->  list<geometry>\noverlapping (container<unknown,geometry> , geometry) --->  list<geometry>\n\nResult:​\nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), overlapping the operand (casted as a geometry).\nExamples:​\nlist<geometry> var0 <- [ag1, ag2, ag3] overlapping(self); // var0 equals return the agents among ag1, ag2 and ag3 that overlap the shape of the agent applying the operator. (species1 + species2) overlapping self\nSee also: neighbors_at, neighbors_of, agent_closest_to, agents_inside, closest_to, inside, agents_overlapping,\n\noverlaps​\nPossible uses:​\n\ngeometry overlaps geometry --->  bool\noverlaps (geometry , geometry) --->  bool\n\nResult:​\nA boolean, equal to true if the left-geometry (or agent/point) overlaps the right-geometry (or agent/point).\nSpecial cases:​\n\nif one of the operand is null, returns false.\nif one operand is a point, returns true if the point is included in the geometry\n\nExamples:​\nbool var0 <- polyline([{10,10},{20,20}]) overlaps polyline([{15,15},{25,25}]); // var0 equals true bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); // var1 equals true bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps polyline([{10,10},{20,20}]); // var2 equals true bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) overlaps {15,15}; // var3 equals true\nSee also: disjoint_from, crosses, intersects, partially_overlaps, touches,\n\npair​\nPossible uses:​\n\npair (any) --->  pair\n\nResult:​\ncasts the operand in a pair object.\n\npalette​\nPossible uses:​\n\npalette (list<rgb>) --->  list<rgb>\nmap<rgb,float> palette int --->  list<rgb>\npalette (map<rgb,float> , int) --->  list<rgb>\n\nResult:​\nreturns a list of n colors chosen in the gradient provided. Colors are chosen by interpolating the stops of the gradient (the colors) using their weight, in the order described in the gradient. In case the map<rgb, float> passed in argument is not a gradient but a scale, the colors will be chosen in the set of colors and might appear duplicated in the palette\ntransforms a list of n colors into a palette (necessary for some layers)\n\npartially_overlapping​\nPossible uses:​\n\ncontainer<unknown,geometry> partially_overlapping geometry --->  list<geometry>\npartially_overlapping (container<unknown,geometry> , geometry) --->  list<geometry>\n\nResult:​\nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), partially_overlapping the operand (casted as a geometry).\nExamples:​\nlist<geometry> var0 <- [ag1, ag2, ag3] partially_overlapping(self); // var0 equals the agents among ag1, ag2 and ag3 that partially_overlap the shape of the right-hand argument. list<geometry> var1 <- (species1 + species2) partially_overlapping (self); // var1 equals the agents among species species1 and species2 that partially_overlap the shape of the right-hand argument.\nSee also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,\n\npartially_overlaps​\nPossible uses:​\n\ngeometry partially_overlaps geometry --->  bool\npartially_overlaps (geometry , geometry) --->  bool\n\nResult:​\nA boolean, equal to true if the left-geometry (or agent/point) partially overlaps the right-geometry (or agent/point).\nComment:​\nif one geometry operand fully covers the other geometry operand, returns false (contrarily to the overlaps operator).\nSpecial cases:​\n\nif one of the operand is null, returns false.\n\nExamples:​\nbool var0 <- polyline([{10,10},{20,20}]) partially_overlaps polyline([{15,15},{25,25}]); // var0 equals true bool var1 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polygon([{15,15},{15,25},{25,25},{25,15}]); // var1 equals true bool var2 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps {25,25}; // var2 equals false bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) partially_overlaps polyline([{10,10},{20,20}]); // var3 equals false\nSee also: disjoint_from, crosses, overlaps, intersects, touches,\n\npath​\nPossible uses:​\n\npath (any) --->  path\n\nResult:​\ncasts the operand in a path object.\nSpecial cases:​\n\nif the operand is a path, returns this path\nif the operand is a geometry of an agent, returns a path from the list of points of the geometry\nif the operand is a list, cast each element of the list as a point and create a path from these points\n\npath p <- path([{12,12},{30,30},{50,50}]);\n\npath_between​\nPossible uses:​\n\nlist<agent> path_between container<unknown,geometry> --->  path\npath_between (list<agent> , container<unknown,geometry>) --->  path\ntopology path_between container<unknown,geometry> --->  path\npath_between (topology , container<unknown,geometry>) --->  path\nmap<agent,unknown> path_between container<unknown,geometry> --->  path\npath_between (map<agent,unknown> , container<unknown,geometry>) --->  path\npath_between (map<agent,unknown>, geometry, geometry) --->  path\npath_between (topology, geometry, geometry) --->  path\npath_between (list<agent>, geometry, geometry) --->  path\npath_between (graph, unknown, unknown) --->  path\n\nResult:​\nThe shortest path between two objects according to set of cells with corresponding weights\nThe shortest path between several objects according to set of cells\nThe shortest path between several objects according to set of cells with corresponding weights\nThe shortest path between two objects according to set of cells\nThe shortest path between a list of two objects in a graph\nExamples:​\npath var0 <- path_between (cell_grid as_map (each::each.is_obstacle ? 9999.0 : 1.0), ag1, ag2); // var0 equals A path between ag1 and ag2 passing through the given cell_grid agents with a minimal cost path var1 <- path_between (cell_grid where each.is_free, [ag1, ag2, ag3]); // var1 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents path var2 <- my_topology path_between [ag1, ag2]; // var2 equals A path between ag1 and ag2 path var3 <- my_topology path_between (ag1, ag2); // var3 equals A path between ag1 and ag2 path var4 <- path_between (cell_grid as_map (each::each.is_obstacle ? 9999.0 : 1.0), [ag1, ag2, ag3]); // var4 equals A path between ag1 and ag2 and ag3 passing through the given cell_grid agents with minimal cost path var5 <- path_between (cell_grid where each.is_free, ag1, ag2); // var5 equals A path between ag1 and ag2 passing through the given cell_grid agents path var6 <- path_between (my_graph, ag1, ag2); // var6 equals A path between ag1 and ag2\nSee also: towards, direction_to, distance_between, direction_between, path_to, distance_to,\n\npath_to​\nPossible uses:​\n\npoint path_to point --->  path\npath_to (point , point) --->  path\ngeometry path_to geometry --->  path\npath_to (geometry , geometry) --->  path\n\nResult:​\nA path between two geometries (geometries, agents or points) considering the topology of the agent applying the operator.\nExamples:​\npath var0 <- ag1 path_to ag2; // var0 equals the path between ag1 and ag2 considering the topology of the agent applying the operator\nSee also: towards, direction_to, distance_between, direction_between, path_between, distance_to,\n\npaths_between​\nPossible uses:​\n\npaths_between (graph, pair, int) --->  list<path>\n\nResult:​\nThe K shortest paths between a list of two objects in a graph\nExamples:​\nlist<path> var0 <- paths_between(my_graph, ag1:: ag2, 2); // var0 equals the 2 shortest paths (ordered by length) between ag1 and ag2\n\npbinom​\nSame signification as binomial_sum\n\npchisq​\nSame signification as chi_square\n\npercent_absolute_deviation​\nPossible uses:​\n\nlist<float> percent_absolute_deviation list<float> --->  float\npercent_absolute_deviation (list<float> , list<float>) --->  float\n\nResult:​\npercent absolute deviation indicator for 2 series of values: percent_absolute_deviation(list_vals_observe,list_vals_sim)\nExamples:​\nfloat var0 <- percent_absolute_deviation([200,300,150,150,200],[250,250,100,200,200]); // var0 equals 20.0\n\npercentile​\nSame signification as quantile_inverse\n\npgamma​\nSame signification as gamma_distribution\n\npgm_file​\nPossible uses:​\n\npgm_file (string) --->  file\n\nResult:​\nConstructs a file of type pgm. Allowed extensions are limited to pgm\nSpecial cases:​\n\npgm_file(string): This file constructor allows to read a pgm file\n\nfile f <-pgm_file(\"file.pgm\");\nSee also: is_pgm,\n\nplan​\nPossible uses:​\n\ncontainer<unknown,geometry> plan float --->  geometry\nplan (container<unknown,geometry> , float) --->  geometry\n\nResult:​\nA polyline geometry from the given list of points.\nSpecial cases:​\n\nif the operand is nil, returns the point geometry {0,0}\nif the operand is composed of a single point, returns a point geometry.\n\nExamples:​\ngeometry var0 <- polyplan([{0,0}, {0,10}, {10,10}, {10,0}],10); // var0 equals a polyline geometry composed of the 4 points with a depth of 10.\nSee also: around, circle, cone, link, norm, point, polygone, rectangle, square, triangle,\n\nplay_sound​\nPossible uses:​\n\nplay_sound (string) --->  bool\n\nResult:​\nPlay a wave file\nExamples:​\nbool sound_ok <- play_sound('beep.wav');\n\nplus_days​\nPossible uses:​\n\ndate plus_days int --->  date\nplus_days (date , int) --->  date\n\nResult:​\nAdd a given number of days to a date\nExamples:​\ndate var0 <- date('2000-01-01') plus_days 12; // var0 equals date('2000-01-13')\n\nplus_hours​\nPossible uses:​\n\ndate plus_hours int --->  date\nplus_hours (date , int) --->  date\n\nResult:​\nAdd a given number of hours to a date\nExamples:​\n// equivalent to date1 + 15 #h date var1 <- date('2000-01-01') plus_hours 24; // var1 equals date('2000-01-02')\n\nplus_minutes​\nPossible uses:​\n\ndate plus_minutes int --->  date\nplus_minutes (date , int) --->  date\n\nResult:​\nAdd a given number of minutes to a date\nExamples:​\n// equivalent to date1 + 5 #mn date var1 <- date('2000-01-01') plus_minutes 5 ; // var1 equals date('2000-01-01 00:05:00')\n\nplus_months​\nPossible uses:​\n\ndate plus_months int --->  date\nplus_months (date , int) --->  date\n\nResult:​\nAdd a given number of months to a date\nExamples:​\ndate var0 <- date('2000-01-01') plus_months 5; // var0 equals date('2000-06-01')\n\nplus_ms​\nPossible uses:​\n\ndate plus_ms int --->  date\nplus_ms (date , int) --->  date\n\nResult:​\nAdd a given number of milliseconds to a date\nExamples:​\n// equivalent to date('2000-01-01') + 15 #ms date var1 <- date('2000-01-01') plus_ms 1000 ; // var1 equals date('2000-01-01 00:00:01')\n\nplus_seconds​\nSame signification as +\n\nplus_weeks​\nPossible uses:​\n\ndate plus_weeks int --->  date\nplus_weeks (date , int) --->  date\n\nResult:​\nAdd a given number of weeks to a date\nExamples:​\ndate var0 <- date('2000-01-01') plus_weeks 15; // var0 equals date('2000-04-15')\n\nplus_years​\nPossible uses:​\n\ndate plus_years int --->  date\nplus_years (date , int) --->  date\n\nResult:​\nAdd a given number of years to a date\nExamples:​\ndate var0 <- date('2000-01-01') plus_years 15; // var0 equals date('2015-01-01')\n\npnorm​\nSame signification as normal_area\n\npoint​\nPossible uses:​\n\npoint (any) --->  point\n\nResult:​\ncasts the operand in a point object.\n\npoints_along​\nPossible uses:​\n\ngeometry points_along list<float> --->  list\npoints_along (geometry , list<float>) --->  list\n\nResult:​\nA list of points along the operand-geometry given its location in terms of rate of distance from the starting points of the geometry.\nExamples:​\nlist var0 <-  line([{10,10},{80,80}]) points_along ([0.3, 0.5, 0.9]); // var0 equals the list of following points: [{31.0,31.0,0.0},{45.0,45.0,0.0},{73.0,73.0,0.0}]\nSee also: closest_points_with, farthest_point_to, points_at, points_on,\n\npoints_at​\nPossible uses:​\n\nint points_at float --->  list<point>\npoints_at (int , float) --->  list<point>\n\nResult:​\nA list of left-operand number of points located at a the right-operand distance to the agent location.\nExamples:​\nlist<point> var0 <- 3 points_at(20.0); // var0 equals returns [pt1, pt2, pt3] with pt1, pt2 and pt3 located at a distance of 20.0 to the agent location\nSee also: any_location_in, any_point_in, closest_points_with, farthest_point_to,\n\npoints_in​\nPossible uses:​\n\nfield points_in geometry --->  list<point>\npoints_in (field , geometry) --->  list<point>\n\n\npoints_on​\nPossible uses:​\n\ngeometry points_on float --->  list\npoints_on (geometry , float) --->  list\n\nResult:​\nA list of points of the operand-geometry distant from each other to the float right-operand .\nExamples:​\nlist var0 <-  square(5) points_on(2); // var0 equals a list of points belonging to the exterior ring of the square distant from each other of 2.\nSee also: closest_points_with, farthest_point_to, points_at,\n\npoisson​\nPossible uses:​\n\npoisson (float) --->  int\n\nResult:​\nA value from a random variable following a Poisson distribution (with the positive expected number of occurence lambda as operand).\nComment:​\nThe Poisson distribution is a discrete probability distribution that expresses the probability of a given number of events occurring in a fixed interval of time and/or space if these events occur with a known average rate and independently of the time since the last event, cf. Poisson distribution on Wikipedia.\nExamples:​\nint var0 <- poisson(3.5); // var0 equals a random positive integer\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, rnd, skew_gauss, truncated_gauss, weibull_rnd,\n\npolygon​\nPossible uses:​\n\npolygon (container<unknown,geometry>) --->  geometry\n\nResult:​\nA polygon geometry from the given list of points.\nSpecial cases:​\n\nif the operand is nil, returns the point geometry {0,0}\nif the operand is composed of a single point, returns a point geometry\nif the operand is composed of 2 points, returns a polyline geometry.\n\nExamples:​\ngeometry var0 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]); // var0 equals a polygon geometry composed of the 4 points. float var1 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]).area; // var1 equals 100.0 point var2 <- polygon([{0,0}, {0,10}, {10,10}, {10,0}]).location; // var2 equals point(5.0,5.0,0.0)\nSee also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,\n\npolyhedron​\nPossible uses:​\n\ncontainer<unknown,geometry> polyhedron float --->  geometry\npolyhedron (container<unknown,geometry> , float) --->  geometry\n\nResult:​\nA polyhedron geometry from the given list of points.\nSpecial cases:​\n\nif the operand is nil, returns the point geometry {0,0}\nif the operand is composed of a single point, returns a point geometry\nif the operand is composed of 2 points, returns a polyline geometry.\n\nExamples:​\ngeometry var0 <- polyhedron([{0,0}, {0,10}, {10,10}, {10,0}],10); // var0 equals a polygon geometry composed of the 4 points and of depth 10.\nSee also: around, circle, cone, line, link, norm, point, polyline, rectangle, square, triangle,\n\npolyline​\nSame signification as line\n\npolyplan​\nSame signification as plan\n\npredecessors_of​\nPossible uses:​\n\ngraph predecessors_of unknown --->  list\npredecessors_of (graph , unknown) --->  list\n\nResult:​\nreturns the list of predecessors (i.e. sources of in edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)\nExamples:​\nlist var1 <- graphEpidemio predecessors_of ({1,5}); // var1 equals [] list var2 <- graphEpidemio predecessors_of node({34,56}); // var2 equals [{12;45}]\nSee also: neighbors_of, successors_of,\n\npredicate​\nPossible uses:​\n\npredicate (any) --->  predicate\n\nResult:​\ncasts the operand in a predicate object.\n\npredict​\nPossible uses:​\n\nregression predict list --->  float\npredict (regression , list) --->  float\n\nResult:​\nreturns the value predicted by the regression parameters for a given instance. Usage: predict(regression, instance)\nExamples:​\npredict(my_regression, [1,2,3])\n\nproduct​\nSame signification as mul\n\nproduct_of​\nPossible uses:​\n\ncontainer product_of any expression --->  unknown\nproduct_of (container , any expression) --->  unknown\n\nResult:​\nthe product of the right-hand expression evaluated on each of the elements of the left-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-operand is a map, the keyword each will contain each value\n\nunknown var1 <- [1::2, 3::4, 5::6] product_of (each); // var1 equals 48\nExamples:​\nunknown var0 <- [1,2] product_of (each * 10 ); // var0 equals 200\nSee also: min_of, max_of, sum_of, mean_of,\n\npromethee_DM​\nPossible uses:​\n\nlist<list> promethee_DM list<map<string,unknown>> --->  int\npromethee_DM (list<list> , list<map<string,unknown>>) --->  int\n\nResult:​\nThe index of the best candidate according to the Promethee II method. This method is based on a comparison per pair of possible candidates along each criterion: all candidates are compared to each other by pair and ranked. More information about this method can be found in Behzadian, M., Kazemzadeh, R., Albadvi, A., M., A.: PROMETHEE: A comprehensive literature review on methodologies and applications. European Journal of Operational Research(2010). The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion: A criterion is a map that contains fours elements: a name, a weight, a preference value (p) and an indifference value (q). The preference value represents the threshold from which the difference between two criterion values allows to prefer one vector of values over another. The indifference value represents the threshold from which the difference between two criterion values is considered significant.\nSpecial cases:​\n\nreturns -1 if the list of candidates is nil or empty\n\nExamples:​\nint var0 <- promethee_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: true],[\"name\"::\"price\", \"weight\" :: 1.0,\"p\"::0.5, \"q\"::0.0, \"s\"::1.0, \"maximize\" :: false]]); // var0 equals 1\nSee also: weighted_means_DM, electre_DM, evidence_theory_DM,\n\nproperty_file​\nPossible uses:​\n\nproperty_file (string) --->  file\nstring property_file map<string,string> --->  file\nproperty_file (string , map<string,string>) --->  file\n\nResult:​\nConstructs a file of type property. Allowed extensions are limited to properties\nSpecial cases:​\n\nproperty_file(string): This file constructor allows to read a property file (.properties)\n\nfile f <-property_file(\"file.properties\");\n\nproperty_file(string,map<string,string>): This file constructor allows to store a map in a property file (it does not save it - just store it in memory)\n\nfile f <-property_file(\"file.properties\", map([\"param1\"::1.0,\"param3\"::10.0 ]));\nSee also: is_property,\n\npValue_for_fStat​\nPossible uses:​\n\npValue_for_fStat (float, int, int) --->  float\n\nResult:​\nReturns the P value of F statistic fstat with numerator degrees of freedom dfn and denominator degress of freedom dfd. Uses the incomplete Beta function.\nExamples:​\nfloat var0 <- pValue_for_fStat(1.9,10,12) with_precision(3); // var0 equals 0.145\n\npValue_for_tStat​\nPossible uses:​\n\nfloat pValue_for_tStat int --->  float\npValue_for_tStat (float , int) --->  float\n\nResult:​\nReturns the P value of the T statistic tstat with df degrees of freedom. This is a two-tailed test so we just double the right tail which is given by studentT of -|tstat|.\nExamples:​\nfloat var0 <- pValue_for_tStat(0.9,10) with_precision(3); // var0 equals 0.389\n\npyramid​\nPossible uses:​\n\npyramid (float) --->  geometry\n\nResult:​\nA square geometry which side size is given by the operand.\nComment:​\nthe center of the pyramid is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\n\nExamples:​\ngeometry var0 <- pyramid(5); // var0 equals a geometry as a square with side_size = 5.\nSee also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,\n\nquantile​\nPossible uses:​\n\ncontainer quantile float --->  float\nquantile (container , float) --->  float\n\nResult:​\nReturns the phi-quantile; that is, an element elem for which holds that phi percent of data elements are less than elem. The quantile does not need necessarily to be contained in the data sequence, it can be a linear interpolation. Note that the container holding the values must be sorted first\nExamples:​\nfloat var0 <- quantile([1,3,5,6,9,11,12,13,19,21,22,32,35,36,45,44,55,68,79,80,81,88,90,91,92,100], 0.5); // var0 equals 35.5\n\nquantile_inverse​\nPossible uses:​\n\ncontainer quantile_inverse float --->  float\nquantile_inverse (container , float) --->  float\n\nResult:​\nReturns how many percent of the elements contained in the receiver are <= element. Does linear interpolation if the element is not contained but lies in between two contained elements. Note that the container holding the values must be sorted first\nExamples:​\nfloat var0 <- quantile_inverse([1,3,5,6,9,11,12,13,19,21,22,32,35,36,45,44,55,68,79,80,81,88,90,91,92,100], 35.5) with_precision(2); // var0 equals 0.52\n\nrange​\nPossible uses:​\n\nrange (int) --->  list\nint range int --->  list\nrange (int , int) --->  list\nrange (int, int, int) --->  list\n\nResult:​\nbuilds a list of int representing all contiguous values from zero to the argument. The range can be increasing or decreasing.\nSpecial cases:​\n\nPassing 0 will return a singleton list with 0.\nWhen used with 3 operands, it returns a list of int representing all contiguous values from the first to the second argument, using the step represented by the third argument. The range can be increasing or decreasing. Passing the same value for both will return a singleton list with this value. Passing a step of 0 will result in an exception. Attempting to build infinite ranges (e.g. end > start with a negative step) will similarly not be accepted and yield an exception\n\nlist var0 <- range(0,6,2); // var0 equals [0,2,4,6]\n\nWhen used with 2 operands, it returns the list of int representing all contiguous values from the first to the second argument. Passing the same value for both will return a singleton list with this value\n\nlist var1 <- range(0,2); // var1 equals [0,1,2]\n\nrank_interpolated​\nPossible uses:​\n\ncontainer rank_interpolated float --->  float\nrank_interpolated (container , float) --->  float\n\nResult:​\nReturns the linearly interpolated number of elements in a list less or equal to a given element. The rank is the number of elements <= element. Ranks are of the form {0, 1, 2,..., sortedList.size()}. If no element is <= element, then the rank is zero. If the element lies in between two contained elements, then linear interpolation is used and a non integer value is returned. Note that the container holding the values must be sorted first\nExamples:​\nfloat var0 <- rank_interpolated([1,3,5,6,9,11,12,13,19,21,22,32,35,36,45,44,55,68,79,80,81,88,90,91,92,100], 35); // var0 equals 13.0\n\nread​\nPossible uses:​\n\nread (string) --->  unknown\n\nResult:​\nReads an attribute of the agent. The attribute's name is specified by the operand.\nExamples:​\nunknownagent_name <- read ('name');  // agent_name equals reads the 'name' variable of agent then assigns the returned value to the 'agent_name' variable. \n\nrectangle​\nPossible uses:​\n\nrectangle (point) --->  geometry\nfloat rectangle float --->  geometry\nrectangle (float , float) --->  geometry\npoint rectangle point --->  geometry\nrectangle (point , point) --->  geometry\n\nResult:​\nA rectangle geometry, computed from the operands values (e.g. the 2 side sizes).\nComment:​\nthe center of the rectangle is by default the location of the current agent in which has been called this operator.the center of the rectangle is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\n\nExamples:​\ngeometry var0 <- rectangle({10, 5}); // var0 equals a geometry as a rectangle with width = 10 and height = 5. geometry var1 <- rectangle(10, 5); // var1 equals a geometry as a rectangle with width = 10 and height = 5. geometry var2 <- rectangle({0.0,0.0}, {10.0,10.0}); // var2 equals a geometry as a rectangle with {1.0,1.0} as the upper-left corner, {10.0,10.0} as the lower-right corner.\nSee also: around, circle, cone, line, link, norm, point, polygon, polyline, square, triangle,\n\nreduced_by​\nSame signification as -\n\nregex_matches​\nPossible uses:​\n\nstring regex_matches string --->  list<string>\nregex_matches (string , string) --->  list<string>\n\nResult:​\nReturns the list of sub-strings of the first operand that match the regular expression provided in the second operand\nExamples:​\nlist<string> var0 <- regex_matches(\"colour, color\", \"colou?r\"); // var0 equals ['colour','color']\nSee also: replace_regex,\n\nregression​\nPossible uses:​\n\nregression (any) --->  regression\n\nResult:​\ncasts the operand in a regression object.\n\nremove_duplicates​\nPossible uses:​\n\nremove_duplicates (container) --->  list\n\nResult:​\nproduces a set from the elements of the operand (i.e. a list without duplicated elements)\nSpecial cases:​\n\nif the operand is a graph, remove_duplicates returns the set of nodes\nif the operand is empty, remove_duplicates returns an empty list\n\nlist var1 <- remove_duplicates([]); // var1 equals []\n\nif the operand is a map, remove_duplicates returns the set of values without duplicate\n\nlist var2 <- remove_duplicates([1::3,2::4,3::3,5::7]); // var2 equals [3,4,7]\n\nif the operand is a matrix, remove_duplicates returns a list containing all the elments with duplicated.\n\nlist var3 <- remove_duplicates([[\"c11\",\"c12\",\"c13\",\"c13\"],[\"c21\",\"c22\",\"c23\",\"c23\"]]); // var3 equals [[\"c11\",\"c12\",\"c13\",\"c21\",\"c22\",\"c23\"]]\nExamples:​\nlist var0 <- remove_duplicates([3,2,5,1,2,3,5,5,5]); // var0 equals [3,2,5,1]\n\nremove_node_from​\nPossible uses:​\n\ngeometry remove_node_from graph --->  graph\nremove_node_from (geometry , graph) --->  graph\n\nResult:​\nremoves a node from a graph.\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph. All the edges containing this node are also removed.\nExamples:​\ngraph var0 <- node(0) remove_node_from graphEpidemio; // var0 equals the graph without node(0)\n\nrename_file​\nPossible uses:​\n\nstring rename_file string --->  bool\nrename_file (string , string) --->  bool\n\nResult:​\nrename/move a file or a folder\nExamples:​\nbool rename_file_ok <- rename_file(\"../includes/my_folder\",\"../includes/my_new_folder\");\n\nreplace​\nPossible uses:​\n\nreplace (string, string, string) --->  string\n\nResult:​\nReturns the string obtained by replacing by the third operand, in the first operand, all the sub-strings equal to the second operand\nExamples:​\nstring var0 <- replace('to be or not to be,that is the question','to', 'do'); // var0 equals 'do be or not do be,that is the question'\nSee also: replace_regex,\n\nreplace_regex​\nPossible uses:​\n\nreplace_regex (string, string, string) --->  string\n\nResult:​\nReturns the string obtained by replacing by the third operand, in the first operand, all the sub-strings that match the regular expression of the second operand\nExamples:​\nstring var0 <- replace_regex(\"colour, color\", \"colou?r\", \"col\"); // var0 equals 'col, col'\nSee also: replace,\n\nresiduals​\nPossible uses:​\n\nresiduals (regression) --->  list<float>\n\nResult:​\nReturn the list of residuals for a given regression model\nExamples:​\nresiduals(my_regression)\n\nreverse​\nPossible uses:​\n\nreverse (string) --->  string\nreverse (container<KeyType,ValueType>) --->  container<unknown,unknown>\nreverse (map<K,V>) --->  map\n\nResult:​\nthe operand elements in the reversed order in a copy of the operand.\nComment:​\nthe reverse operator behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a file, reverse returns a copy of the file with a reversed content\nif it is a population, reverse returns a copy of the population with elements in the reversed order\nif it is a graph, reverse returns a copy of the graph (with all edges and vertexes), with all of the edges reversed\nif it is a string, reverse returns a new string with characters in the reversed order\n\nstring var0 <- reverse ('abcd'); // var0 equals 'dcba'\n\nif it is a list, reverse returns a copy of the operand list with elements in the reversed order\n\nlist<int> var1 <- reverse ([10,12,14]); // var1 equals [14, 12, 10]\n\nif it is a map, reverse returns a copy of the operand map with each pair in the reversed order (i.e. all keys become values and values become keys)\n\nmap<int,string> var2 <- reverse (['k1'::44, 'k2'::32, 'k3'::12]); // var2 equals [44::'k1', 32::'k2', 12::'k3']\n\nif it is a matrix, reverse returns a new matrix containing the transpose of the operand.\n\nmatrix<string> var3 <- reverse(matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); // var3 equals matrix([[\"c11\",\"c21\"],[\"c12\",\"c22\"],[\"c13\",\"c23\"]])\nExamples:​\nmap<int,int> m <- [1::111,2::222, 3::333, 4::444]; map var5 <- reverse(m); // var5 equals map([111::1,222::2,333::3,444::4])\n\nrewire_n​\nPossible uses:​\n\ngraph rewire_n int --->  graph\nrewire_n (graph , int) --->  graph\n\nResult:​\nrewires the given count of edges.\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph. If there are too many edges, all the edges will be rewired.\nExamples:​\ngraph var1 <- graphEpidemio rewire_n 10; // var1 equals the graph with 3 edges rewired\n\nrgb​\nPossible uses:​\n\nrgb rgb int --->  rgb\nrgb (rgb , int) --->  rgb\nrgb rgb float --->  rgb\nrgb (rgb , float) --->  rgb\nstring rgb int --->  rgb\nrgb (string , int) --->  rgb\nrgb (int, int, int) --->  rgb\nrgb (int, int, int, float) --->  rgb\nrgb (int, int, int, int) --->  rgb\n\nResult:​\nReturns a color defined by red, green, blue components and an alpha blending value.\nSpecial cases:​\n\nIt can be used with r=red, g=green, b=blue, each between 0 and 255\nIt can be used with a color and an alpha between 0 and 255\nIt can be used with a color and an alpha between 0 and 1\nIt can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0.0 and 1.0)\nIt can be used with a name of color and alpha (between 0 and 255)\nIt can be used with r=red, g=green, b=blue (each between 0 and 255), a=alpha (between 0 and 255)\n\nExamples:​\nrgb var0 <- rgb (255,0,0); // var0 equals #red rgb var1 <- rgb(rgb(255,0,0),125); // var1 equals a light red color rgb var2 <- rgb(rgb(255,0,0),0.5); // var2 equals a light red color rgb var3 <- rgb (255,0,0,0.5); // var3 equals a light red color rgb var4 <- rgb (\"red\"); // var4 equals rgb(255,0,0) rgb var5 <- rgb (255,0,0,125); // var5 equals a light red color\nSee also: hsb,\n\nrgb​\nPossible uses:​\n\nrgb (any) --->  rgb\n\nResult:​\ncasts the operand in a rgb object.\n\nrms​\nPossible uses:​\n\nint rms float --->  float\nrms (int , float) --->  float\n\nResult:​\nReturns the RMS (Root-Mean-Square) of a data sequence. The RMS of data sequence is the square-root of the mean of the squares of the elements in the data sequence. It is a measure of the average size of the elements of a data sequence.\nExamples:​\n list<float> data_sequence <- [6.0, 7.0, 8.0, 9.0];   list<float> squares <- data_sequence collect (each*each);  float var2 <-  rms(length(data_sequence),sum(squares)) with_precision(4) ; // var2 equals 7.5829\n\nrnd​\nPossible uses:​\n\nrnd (int) --->  int\nrnd (float) --->  float\nrnd (point) --->  point\nint rnd int --->  int\nrnd (int , int) --->  int\npoint rnd point --->  point\nrnd (point , point) --->  point\nfloat rnd float --->  float\nrnd (float , float) --->  float\nrnd (float, float, float) --->  float\nrnd (point, point, float) --->  point\nrnd (int, int, int) --->  int\n\nResult:​\nreturns a random value in a range (the type value depends on the operand type): when called with an integer, it returns a random integer in the interval [0, operand]\nComment:​\nto obtain a probability between 0 and 1, use the expression (rnd n) / n, where n is used to indicate the precision\nSpecial cases:​\n\nif the operand is a float, returns an uniformly distributed float random number in [0.0, to]\nif the operand is a point, returns a point with three random float ordinates, each in the interval [0, ordinate of argument]\n\nExamples:​\nint var0 <- rnd (2); // var0 equals 0, 1 or 2 float var1 <- rnd(3.4); // var1 equals a random float between 0.0 and 3.4 float var2 <- rnd (2.0, 4.0, 0.5); // var2 equals a float number between 2.0 and 4.0 every 0.5 int var3 <- rnd (2, 4); // var3 equals 2, 3 or 4 point var4 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}, 1); // var4 equals a point with x = 2.0, y equal to 2.0, 3.0 or 4.0 and z between 0.0 and 10.0 every 1.0 point var5 <- rnd ({2.0, 4.0}, {2.0, 5.0, 10.0}); // var5 equals a point with x = 2.0, y between 2.0 and 4.0 and z between 0.0 and 10.0 point var6 <- rnd ({2.5,3, 0.0}); // var6 equals {x,y} with x in [0.0,2.0], y in [0.0,3.0], z = 0.0 float var7 <- rnd (2.0, 4.0); // var7 equals a float number between 2.0 and 4.0 int var8 <- rnd (2, 12, 4); // var8 equals 2, 6 or 10\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, skew_gauss, truncated_gauss, weibull_rnd,\n\nrnd_choice​\nPossible uses:​\n\nrnd_choice (map<unknown,unknown>) --->  unknown\nrnd_choice (list) --->  int\n\nResult:​\nreturns a key from the map with a probability following the (normalized) distribution described in map values (a form of lottery)\nreturns an index of the given list with a probability following the (normalized) distribution described in the list (a form of lottery)\nExamples:​\nunknown var0 <- rnd_choice([\"toto\"::0.2,\"tata\"::0.5,\"tonton\"::0.3]); // var0 equals 2/10 chances to return \"toto\", 5/10 chances to return \"tata\", 3/10 chances to return \"tonton\" int var1 <- rnd_choice([0.2,0.5,0.3]); // var1 equals 2/10 chances to return 0, 5/10 chances to return 1, 3/10 chances to return 2\nSee also: rnd,\n\nrnd_color​\nPossible uses:​\n\nrnd_color (int) --->  rgb\nint rnd_color int --->  rgb\nrnd_color (int , int) --->  rgb\n\nResult:​\nrgb color\nReturn a random color equivalent to rgb(rnd(first_op, last_op),rnd(first_op, last_op),rnd(first_op, last_op))\nComment:​\nReturn a random color equivalent to rgb(rnd(operand),rnd(operand),rnd(operand))\nExamples:​\nrgb var0 <- rnd_color(255); // var0 equals a random color, equivalent to rgb(rnd(255),rnd(255),rnd(255)) rgb var1 <- rnd_color(100, 200); // var1 equals a random color, equivalent to rgb(rnd(100, 200),rnd(100, 200),rnd(100, 200))\nSee also: rgb, hsb,\n\nrotated_by​\nPossible uses:​\n\ngeometry rotated_by int --->  geometry\nrotated_by (geometry , int) --->  geometry\npoint rotated_by pair --->  point\nrotated_by (point , pair) --->  point\ngeometry rotated_by float --->  geometry\nrotated_by (geometry , float) --->  geometry\ngeometry rotated_by pair --->  geometry\nrotated_by (geometry , pair) --->  geometry\nrotated_by (geometry, float, point) --->  geometry\n\nResult:​\nA geometry resulting from the application of a rotation by the operand angles (degree) along the operand axis (last operand) to the left-hand operand (geometry, agent, point)\nA geometry resulting from the application of a rotation by the right-hand operand angle (degree) to the left-hand operand (geometry, agent, point)\nSpecial cases:​\n\nthe right-hand operand representing  the angle can be a float or an integer\nWhen used  with a  point and  a pair angle::point, it returns a point resulting from the application of the right-hand rotation operand (angles in degree) to the left-hand operand point\n\nExamples:​\ngeometry var0 <- rotated_by(pyramid(10),45.0, {1,0,0}); // var0 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator. geometry var1 <- self rotated_by 45; // var1 equals the geometry resulting from a 45 degrees rotation to the geometry of the agent applying the operator. geometry var2 <- rotated_by(pyramid(10),45.0::{1,0,0}); // var2 equals the geometry resulting from a 45 degrees rotation along the {1,0,0} vector to the geometry of the agent applying the operator.\nSee also: transformed_by, translated_by,\n\nrotated_by​\nPossible uses:​\n\nimage rotated_by float --->  image\nrotated_by (image , float) --->  image\n\nResult:​\nReturns the image rotated using the angle in degrees passed in parameter. A positive angle means a clockwise rotation, and a negative one a counter-clockwise. The original image is left untouched\n\nrotation_composition​\nPossible uses:​\n\nrotation_composition (list<pair>) --->  pair<float,point>\n\nResult:​\nThe rotation resulting from the composition of the rotations in the list, from left to right. Angles are in degrees.\nExamples:​\npair<float,point> var0 <- rotation_composition([38.0::{1,1,1},90.0::{1,0,0}]); // var0 equals 115.22128507898108::{0.9491582126366207,0.31479943993669307,-0.0}\nSee also: inverse_rotation,\n\nround​\nPossible uses:​\n\nround (int) --->  int\nround (float) --->  int\nround (point) --->  point\n\nResult:​\nReturns the rounded value of the operand.\nSpecial cases:​\n\nif the operand is an int, round returns it\n\nExamples:​\nint var0 <- round (0.51); // var0 equals 1 int var1 <- round (100.2); // var1 equals 100 int var2 <- round(-0.51); // var2 equals -1 point var3 <- {12345.78943,  12345.78943, 12345.78943} with_precision 2; // var3 equals {12345.79,12345.79,12345.79}\nSee also: int, with_precision, round,\n\nrow_at​\nPossible uses:​\n\nmatrix<unknown> row_at int --->  list<unknown>\nrow_at (matrix<unknown> , int) --->  list<unknown>\n\nResult:​\nreturns the row at a num_line (right-hand operand)\nExamples:​\nlist<unknown> var0 <- matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]]) row_at 2; // var0 equals [\"el13\",\"el23\",\"el33\"]\nSee also: column_at, columns_list,\n\nrows_list​\nPossible uses:​\n\nrows_list (matrix<unknown>) --->  list<list<unknown>>\n\nResult:​\nreturns a list of the rows of the matrix, with each row as a list of elements\nExamples:​\nlist<list<unknown>> var0 <- rows_list(matrix([[\"el11\",\"el12\",\"el13\"],[\"el21\",\"el22\",\"el23\"],[\"el31\",\"el32\",\"el33\"]])); // var0 equals [[\"el11\",\"el21\",\"el31\"],[\"el12\",\"el22\",\"el32\"],[\"el13\",\"el23\",\"el33\"]]\nSee also: columns_list,\n\nrSquare​\nPossible uses:​\n\nrSquare (regression) --->  float\n\nResult:​\nReturn the value of the adjusted R square for a given regression model\nExamples:​\nrSquare(my_regression)"},{"filePath":"https:--gama-platform.org--wiki-OperatorsSZ.txt","text":"Operators (S to Z)\nThis file is automatically generated from java files. Do Not Edit It.\n\nDefinition​\nOperators in the GAML language are used to compose complex expressions. An operator performs a function on one, two, or n operands (which are other expressions and thus may be themselves composed of operators) and returns the result of this function.\nMost of them use a classical prefixed functional syntax (i.e. operator_name(operand1, operand2, operand3), see below), with the exception of arithmetic (e.g. +, /), logical (and, or), comparison (e.g. >, <), access (., [..]) and pair (::) operators, which require an infixed notation (i.e. operand1 operator_symbol operand1).\nThe ternary functional if-else operator, ? :, uses a special infixed syntax composed with two symbols (e.g. operand1 ? operand2 : operand3). Two unary operators (- and !) use a traditional prefixed syntax that does not require parentheses unless the operand is itself a complex expression (e.g.  - 10, ! (operand1 or operand2)).\nFinally, special constructor operators ({...} for constructing points, [...] for constructing lists and maps) will require their operands to be placed between their two symbols (e.g. {1,2,3}, [operand1, operand2, ..., operandn] or [key1::value1, key2::value2... keyn::valuen]).\nWith the exception of these special cases above, the following rules apply to the syntax of operators:\n\nif they only have one operand, the functional prefixed syntax is mandatory (e.g. operator_name(operand1))\nif they have two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2)) or the infixed syntax (e.g. operand1 operator_name operand2) can be used.\nif they have more than two arguments, either the functional prefixed syntax (e.g. operator_name(operand1, operand2, ..., operand)) or a special infixed syntax with the first operand on the left-hand side of the operator name (e.g. operand1 operator_name(operand2, ..., operand)) can be used.\n\nAll of these alternative syntaxes are completely equivalent.\nOperators in GAML are purely functional, i.e. they are guaranteed to not have any side effects on their operands. For instance, the shuffle operator, which randomizes the positions of elements in a list, does not modify its list operand but returns a new shuffled list.\n\nPriority between operators​\nThe priority of operators determines, in the case of complex expressions composed of several operators, which one(s) will be evaluated first.\nGAML follows in general the traditional priorities attributed to arithmetic, boolean, comparison operators, with some twists. Namely:\n\nthe constructor operators, like ::, used to compose pairs of operands, have the lowest priority of all operators (e.g. a > b :: b > c will return a pair of boolean values, which means that the two comparisons are evaluated before the operator applies. Similarly, [a > 10, b > 5] will return a list of boolean values.\nit is followed by the ?: operator, the functional if-else (e.g.  a > b ? a + 10 : a - 10 will return the result of the if-else).\nnext are the logical operators, and and or (e.g. a > b or b > c will return the value of the test)\nnext are the comparison operators (i.e. >, <, <=, >=, =, !=)\nnext the arithmetic operators in their logical order (multiplicative operators have a higher priority than additive operators)\nnext the unary operators - and !\nnext the access operators . and [] (e.g. {1,2,3}.x > 20 + {4,5,6}.y will return the result of the comparison between the x and y ordinates of the two points)\nand finally the functional operators, which have the highest priority of all.\n\n\nUsing actions as operators​\nActions defined in species can be used as operators, provided they are called on the correct agent. The syntax is that of normal functional operators, but the agent that will perform the action must be added as the first operand.\nFor instance, if the following species is defined:\nspecies spec1 {        int min(int x, int y) {                return x > y ? x : y;        }}\nAny agent instance of spec1 can use min as an operator (if the action conflicts with an existing operator, a warning will be emitted). For instance, in the same model, the following line is perfectly acceptable:\nglobal {        init {                create spec1;                spec1 my_agent <- spec1[0];                int the_min <- my_agent min(10,20); // or min(my_agent, 10, 20);        }}\nIf the action doesn't have any operands, the syntax to use is my_agent the_action(). Finally, if it does not return a value, it might still be used but is considering as returning a value of type unknown (e.g. unknown result <- my_agent the_action(op1, op2);).\nNote that due to the fact that actions are written by modelers, the general functional contract is not respected in that case: actions might perfectly have side effects on their operands (including the agent).\n\nTable of Contents​\n\nOperators by categories​\n\n3D​\nbox, cone3D, cube, cylinder, hexagon, pyramid, set_z, sphere, teapot,\n\nArithmetic operators​\n-, /, ^, *, +, abs, acos, asin, atan, atan2, ceil, cos, cos_rad, div, even, exp, fact, floor, hypot, is_finite, is_number, ln, log, mod, round, signum, sin, sin_rad, sqrt, tan, tan_rad, tanh, with_precision,\n\nBDI​\nadd_values, and, eval_when, get_about, get_agent, get_agent_cause, get_belief_op, get_belief_with_name_op, get_beliefs_op, get_beliefs_with_name_op, get_current_intention_op, get_decay, get_desire_op, get_desire_with_name_op, get_desires_op, get_desires_with_name_op, get_dominance, get_familiarity, get_ideal_op, get_ideal_with_name_op, get_ideals_op, get_ideals_with_name_op, get_intensity, get_intention_op, get_intention_with_name_op, get_intentions_op, get_intentions_with_name_op, get_lifetime, get_liking, get_modality, get_obligation_op, get_obligation_with_name_op, get_obligations_op, get_obligations_with_name_op, get_plan_name, get_predicate, get_solidarity, get_strength, get_super_intention, get_trust, get_truth, get_uncertainties_op, get_uncertainties_with_name_op, get_uncertainty_op, get_uncertainty_with_name_op, get_values, has_belief_op, has_belief_with_name_op, has_desire_op, has_desire_with_name_op, has_ideal_op, has_ideal_with_name_op, has_intention_op, has_intention_with_name_op, has_obligation_op, has_obligation_with_name_op, has_uncertainty_op, has_uncertainty_with_name_op, new_emotion, new_mental_state, new_predicate, new_social_link, not, or, set_about, set_agent, set_agent_cause, set_decay, set_dominance, set_familiarity, set_intensity, set_lifetime, set_liking, set_modality, set_predicate, set_solidarity, set_strength, set_trust, set_truth, with_values,\n\nCasting operators​\nas, as_int, as_matrix, field_with, font, is, is_skill, list_with, matrix_with, species_of, to_gaml, to_geojson, to_list, with_size, with_style,\n\nColor-related operators​\n-, /, *, +, blend, brewer_colors, brewer_palettes, gradient, grayscale, hsb, mean, median, palette, rgb, rnd_color, scale, sum, to_hsb,\n\nComparison operators​\n!=, <, <=, =, >, >=, between,\n\nContainers-related operators​\n-, ::, +, accumulate, all_match, among, as_json_string, at, cartesian_product, collect, contains, contains_all, contains_any, contains_key, count, empty, every, first, first_with, get, group_by, in, index_by, inter, interleave, internal_integrated_value, last, last_with, length, max, max_of, mean, mean_of, median, min, min_of, mul, none_matches, one_matches, one_of, product_of, range, remove_duplicates, reverse, shuffle, sort_by, split, split_in, split_using, sum, sum_of, union, variance_of, where, with_max_of, with_min_of,\n\nDate-related operators​\n-, !=, +, <, <=, =, >, >=, after, before, between, every, milliseconds_between, minus_days, minus_hours, minus_minutes, minus_months, minus_ms, minus_weeks, minus_years, months_between, plus_days, plus_hours, plus_minutes, plus_months, plus_ms, plus_weeks, plus_years, since, to, until, years_between,\n\nDates​\n\nDisplays​\nhorizontal, stack, vertical,\n\nedge​\nedge_between, strahler,\n\nEDP-related operators​\ndiff, diff2,\n\nFiles-related operators​\nagent_file, copy_file, crs, csv_file, delete_file, dxf_file, evaluate_sub_model, file_exists, folder, folder_exists, gaml_file, geojson_file, get, gif_file, gml_file, graph6_file, graphdimacs_file, graphdot_file, graphgexf_file, graphgml_file, graphml_file, graphtsplib_file, grid_file, image_file, is_agent, is_csv, is_dxf, is_gaml, is_geojson, is_gif, is_gml, is_graph6, is_graphdimacs, is_graphdot, is_graphgexf, is_graphgml, is_graphml, is_graphtsplib, is_grid, is_image, is_json, is_obj, is_osm, is_pgm, is_property, is_shape, is_simulation, is_svg, is_text, is_threeds, is_xml, json_file, new_folder, obj_file, osm_file, pgm_file, property_file, read, rename_file, shape_file, simulation_file, step_sub_model, svg_file, text_file, threeds_file, unzip, writable, xml_file, zip,\n\nGamaMetaType​\ntype_of,\n\nGamaSVGFile​\nimage,\n\nGraphs-related operators​\nadd_edge, add_node, adjacency, agent_from_geometry, all_pairs_shortest_path, alpha_index, as_distance_graph, as_edge_graph, as_intersection_graph, as_path, as_spatial_graph, beta_index, betweenness_centrality, biggest_cliques_of, connected_components_of, connectivity_index, contains_edge, contains_vertex, degree_of, directed, edge, edge_between, edge_betweenness, edges, gamma_index, generate_barabasi_albert, generate_complete_graph, generate_random_graph, generate_watts_strogatz, girvan_newman_clustering, grid_cells_to_graph, in_degree_of, in_edges_of, k_spanning_tree_clustering, label_propagation_clustering, layout_circle, layout_force, layout_force_FR, layout_force_FR_indexed, layout_grid, load_shortest_paths, main_connected_component, max_flow_between, maximal_cliques_of, nb_cycles, neighbors_of, node, nodes, out_degree_of, out_edges_of, path_between, paths_between, predecessors_of, remove_node_from, rewire_n, source_of, spatial_graph, strahler, successors_of, sum, target_of, undirected, use_cache, weight_of, with_k_shortest_path_algorithm, with_shortest_path_algorithm, with_weights,\n\nGrid-related operators​\nas_4_grid, as_grid, as_hexagonal_grid, cell_at, cells_in, cells_overlapping, field, grid_at, neighbors_of, path_between, points_in, values_in,\n\nImageOperators​\n*, antialiased, blend, blurred, brighter, clipped_with, darker, grayscale, horizontal_flip, image, matrix, rotated_by, sharpened, snapshot, tinted_with, vertical_flip, with_height, with_size, with_width,\n\nIterator operators​\naccumulate, all_match, as_map, collect, count, create_map, first_with, frequency_of, group_by, index_by, last_with, max_of, mean_of, min_of, none_matches, one_matches, product_of, sort_by, sum_of, variance_of, where, where, where, with_max_of, with_min_of,\n\nList-related operators​\nall_indexes_of, copy_between, index_of, last_index_of,\n\nLogical operators​\n:, !, ?, add_3Dmodel, add_geometry, add_icon, and, or, xor,\n\nMap comparaison operators​\nfuzzy_kappa, fuzzy_kappa_sim, kappa, kappa_sim, percent_absolute_deviation,\n\nMap-related operators​\nas_map, create_map, index_of, last_index_of,\n\nMatrix-related operators​\n-, /, ., *, +, append_horizontally, append_vertically, column_at, columns_list, determinant, eigenvalues, flatten, index_of, inverse, last_index_of, row_at, rows_list, shuffle, trace, transpose,\n\nmulticriteria operators​\nelectre_DM, evidence_theory_DM, fuzzy_choquet_DM, promethee_DM, weighted_means_DM,\n\nPath-related operators​\nagent_from_geometry, all_pairs_shortest_path, as_path, load_shortest_paths, max_flow_between, path_between, path_to, paths_between, use_cache,\n\nPedestrian​\ngenerate_pedestrian_network,\n\nPoints-related operators​\n-, /, *, +, <, <=, >, >=, add_point, angle_between, any_location_in, centroid, closest_points_with, farthest_point_to, grid_at, norm, points_along, points_at, points_on,\n\nRandom operators​\nbinomial, exp_density, exp_rnd, flip, gamma_density, gamma_rnd, gamma_trunc_rnd, gauss, generate_terrain, lognormal_density, lognormal_rnd, lognormal_trunc_rnd, poisson, rnd, rnd_choice, sample, shuffle, skew_gauss, truncated_gauss, weibull_density, weibull_rnd, weibull_trunc_rnd,\n\nReverseOperators​\nserialize,\n\nShape​\narc, box, circle, cone, cone3D, cross, cube, curve, cylinder, ellipse, elliptical_arc, envelope, geometry_collection, hexagon, line, link, plan, polygon, polyhedron, pyramid, rectangle, sphere, square, squircle, teapot, triangle,\n\nSpatial operators​\n-, *, +, add_point, agent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, angle_between, any_location_in, arc, around, as_4_grid, as_driving_graph, as_grid, as_hexagonal_grid, at_distance, at_location, box, centroid, circle, clean, clean_network, closest_points_with, closest_to, cone, cone3D, convex_hull, covering, covers, cross, crosses, crossing, crs, CRS_transform, cube, curve, cylinder, direction_between, disjoint_from, distance_between, distance_to, ellipse, elliptical_arc, envelope, farthest_point_to, farthest_to, geometry_collection, gini, hexagon, hierarchical_clustering, IDW, inside, inter, intersects, inverse_rotation, k_nearest_neighbors, line, link, masked_by, moran, neighbors_at, neighbors_of, normalized_rotation, overlapping, overlaps, partially_overlapping, partially_overlaps, path_between, path_to, plan, points_along, points_at, points_on, polygon, polyhedron, pyramid, rectangle, rotated_by, rotation_composition, round, scaled_to, set_z, simple_clustering_by_distance, simplification, skeletonize, smooth, sphere, split_at, split_geometry, split_lines, square, squircle, teapot, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, touches, touching, towards, transformed_by, translated_by, triangle, triangulate, union, using, voronoi, with_precision, without_holes,\n\nSpatial properties operators​\ncovers, crosses, intersects, partially_overlaps, touches,\n\nSpatial queries operators​\nagent_closest_to, agent_farthest_to, agents_at_distance, agents_covering, agents_crossing, agents_inside, agents_overlapping, agents_partially_overlapping, agents_touching, at_distance, closest_to, covering, crossing, farthest_to, inside, neighbors_at, neighbors_of, overlapping, partially_overlapping, touching,\n\nSpatial relations operators​\ndirection_between, distance_between, distance_to, path_between, path_to, towards,\n\nSpatial statistical operators​\nhierarchical_clustering, k_nearest_neighbors, simple_clustering_by_distance,\n\nSpatial transformations operators​\n-, *, +, as_4_grid, as_grid, as_hexagonal_grid, at_location, clean, clean_network, convex_hull, CRS_transform, inverse_rotation, normalized_rotation, rotated_by, rotation_composition, scaled_to, simplification, skeletonize, smooth, split_geometry, split_lines, to_GAMA_CRS, to_rectangles, to_segments, to_squares, to_sub_geometries, transformed_by, translated_by, triangulate, voronoi, with_precision, without_holes,\n\nSpecies-related operators​\nindex_of, last_index_of, of_generic_species, of_species,\n\nStatistical operators​\nauto_correlation, beta, binomial_coeff, binomial_complemented, binomial_sum, build, chi_square, chi_square_complemented, correlation, covariance, dbscan, distribution_of, distribution2d_of, dtw, durbin_watson, frequency_of, gamma, gamma_distribution, gamma_distribution_complemented, geometric_mean, gini, harmonic_mean, hierarchical_clustering, incomplete_beta, incomplete_gamma, incomplete_gamma_complement, k_nearest_neighbors, kmeans, kurtosis, log_gamma, max, mean, mean_deviation, median, min, moment, moran, morrisAnalysis, mul, normal_area, normal_density, normal_inverse, predict, pValue_for_fStat, pValue_for_tStat, quantile, quantile_inverse, rank_interpolated, residuals, rms, rSquare, simple_clustering_by_distance, skewness, sobolAnalysis, split, split_in, split_using, standard_deviation, student_area, student_t_inverse, sum, t_test, variance,\n\nStrings-related operators​\n+, <, <=, >, >=, at, capitalize, char, contains, contains_all, contains_any, copy_between, date, empty, first, in, indented_by, index_of, is_number, last, last_index_of, length, lower_case, regex_matches, replace, replace_regex, reverse, sample, shuffle, split_with, string, upper_case,\n\nSubModel​\nload_sub_model,\n\nSystem​\n., choose, command, copy, copy_from_clipboard, copy_to_clipboard, copy_to_clipboard, dead, enter, eval_gaml, every, is_error, is_reachable, is_warning, play_sound, user_confirm, user_input_dialog, wizard, wizard_page,\n\nTime-related operators​\ndate, string,\n\nTypes-related operators​\naction, agent, attributes, BDIPlan, bool, container, conversation, directory, emotion, file, float, gaml_type, geometry, graph, int, kml, list, map, matrix, mental_state, message, Norm, pair, path, point, predicate, regression, rgb, Sanction, skill, social_link, species, topology, unknown,\n\nUser control operators​\nchoose, enter, user_confirm, user_input_dialog, wizard, wizard_page,\n\nOperators​\n\nsample​\nPossible uses:​\n\nsample (any expression) --->  string\nstring sample any expression --->  string\nsample (string , any expression) --->  string\nsample (list, int, bool) --->  list\nsample (list, int, bool, list) --->  list\n\nResult:​\ntakes a sample of the specified size from the elements of x using either with or without replacement\ntakes a sample of the specified size from the elements of x using either with or without replacement with given weights\nExamples:​\nlist var0 <- sample([2,10,1],2,false); // var0 equals [10,1] list var1 <- sample([2,10,1],2,false,[0.1,0.7,0.2]); // var1 equals [10,2]\n\nSanction​\nPossible uses:​\n\nSanction (any) --->  Sanction\n\nResult:​\ncasts the operand in a Sanction object.\n\nscale​\nPossible uses:​\n\nscale (map<rgb,unknown>) --->  map<float,rgb>\nscale (map<rgb,unknown>, float, float) --->  map<float,rgb>\n\nResult:​\nSimilar to gradient(map<rgb, float>) but reorders the colors based on their weight and does not normalize them, so as to effectively represent a color scale (i.e. a correspondance between a range of value and a color that implicitly begins with the lowest value)For instance scale([#red::10, #green::0, #blue::30]) would produce the reverse map and associate #green to the interval 0-10, #red to 10-30, and #blue above 30. The main difference in usages is that, for instance in the definition of a mesh to display, a gradient will produce interpolated colors to accomodate for the intermediary values, while a scale will stick to the colors defined.\nExpects a gradient, i.e. a map<rgb,float>, where values represent the different stops of the colors. First normalizes the passed gradient, and then applies the resulting weights to the interval represented by min and max, so as to return a scale (i.e. absolute values instead of the stops\nSee also: gradient,\n\nscaled_by​\nSame signification as *\n\nscaled_to​\nPossible uses:​\n\ngeometry scaled_to point --->  geometry\nscaled_to (geometry , point) --->  geometry\n\nResult:​\nallows to restrict the size of a geometry so that it fits in the envelope {width, height, depth} defined by the second operand\nExamples:​\ngeometry var0 <- shape scaled_to {10,10}; // var0 equals a geometry corresponding to the geometry of the agent applying the operator scaled so that it fits a square of 10x10\n\nselect​\nSame signification as where\n\nserialize​\nPossible uses:​\n\nserialize (agent) --->  string\nserialize (unknown) --->  string\nagent serialize string --->  string\nserialize (agent , string) --->  string\nserialize (agent, string, bool) --->  string\n\nResult:​\nSerializes any agent/simulation into a string, using the format passed in parameter (either 'binary', 'xml' or 'json'). The result is not compressed.The result of this operator can be then used in the from: facet of restore or create statements\nSerializes any agent/simulation into a string, using the default 'binary' format. The result is not compressed.The result of this operator can be then used in the from: facet of restore or create statements\nSerializes any item into a string, using the default 'xml' format. Agents and simulations are serialized using the default 'binary' format when not specified\nSerializes any agent/simulation into a string, using the format passed in parameter (either 'binary', 'xml' or 'json'). The result is compressed if the last parameter is true.The result of this operator can be then used in the from: facet of restore or create statements\nSee also: , deserialize,\n\nset_about​\nPossible uses:​\n\nemotion set_about predicate --->  emotion\nset_about (emotion , predicate) --->  emotion\n\nResult:​\nchange the about value of the given emotion\nExamples:​\nemotion set_about predicate1\n\nset_agent​\nPossible uses:​\n\nsocial_link set_agent agent --->  social_link\nset_agent (social_link , agent) --->  social_link\n\nResult:​\nchange the agent value of the given social link\nExamples:​\nsocial_link set_agent agentA\n\nset_agent_cause​\nPossible uses:​\n\npredicate set_agent_cause agent --->  predicate\nset_agent_cause (predicate , agent) --->  predicate\nemotion set_agent_cause agent --->  emotion\nset_agent_cause (emotion , agent) --->  emotion\n\nResult:​\nchange the agentCause value of the given predicate\nchange the agentCause value of the given emotion\nExamples:​\npredicate set_agent_cause agentA new_emotion set_agent_cause agentA\n\nset_decay​\nPossible uses:​\n\nemotion set_decay float --->  emotion\nset_decay (emotion , float) --->  emotion\n\nResult:​\nchange the decay value of the given emotion\nExamples:​\nemotion set_decay 12\n\nset_dominance​\nPossible uses:​\n\nsocial_link set_dominance float --->  social_link\nset_dominance (social_link , float) --->  social_link\n\nResult:​\nchange the dominance value of the given social link\nExamples:​\nsocial_link set_dominance 0.4\n\nset_familiarity​\nPossible uses:​\n\nsocial_link set_familiarity float --->  social_link\nset_familiarity (social_link , float) --->  social_link\n\nResult:​\nchange the familiarity value of the given social link\nExamples:​\nsocial_link set_familiarity 0.4\n\nset_intensity​\nPossible uses:​\n\nemotion set_intensity float --->  emotion\nset_intensity (emotion , float) --->  emotion\n\nResult:​\nchange the intensity value of the given emotion\nExamples:​\nemotion set_intensity 12\n\nset_lifetime​\nPossible uses:​\n\nmental_state set_lifetime int --->  mental_state\nset_lifetime (mental_state , int) --->  mental_state\n\nResult:​\nchange the lifetime value of the given mental state\nExamples:​\nmental state set_lifetime 1\n\nset_liking​\nPossible uses:​\n\nsocial_link set_liking float --->  social_link\nset_liking (social_link , float) --->  social_link\n\nResult:​\nchange the liking value of the given social link\nExamples:​\nsocial_link set_liking 0.4\n\nset_modality​\nPossible uses:​\n\nmental_state set_modality string --->  mental_state\nset_modality (mental_state , string) --->  mental_state\n\nResult:​\nchange the modality value of the given mental state\nExamples:​\nmental state set_modality belief\n\nset_predicate​\nPossible uses:​\n\nmental_state set_predicate predicate --->  mental_state\nset_predicate (mental_state , predicate) --->  mental_state\n\nResult:​\nchange the predicate value of the given mental state\nExamples:​\nmental state set_predicate pred1\n\nset_solidarity​\nPossible uses:​\n\nsocial_link set_solidarity float --->  social_link\nset_solidarity (social_link , float) --->  social_link\n\nResult:​\nchange the solidarity value of the given social link\nExamples:​\nsocial_link set_solidarity 0.4\n\nset_strength​\nPossible uses:​\n\nmental_state set_strength float --->  mental_state\nset_strength (mental_state , float) --->  mental_state\n\nResult:​\nchange the strength value of the given mental state\nExamples:​\nmental state set_strength 1.0\n\nset_trust​\nPossible uses:​\n\nsocial_link set_trust float --->  social_link\nset_trust (social_link , float) --->  social_link\n\nResult:​\nchange the trust value of the given social link\nExamples:​\nsocial_link set_familiarity 0.4\n\nset_truth​\nPossible uses:​\n\npredicate set_truth bool --->  predicate\nset_truth (predicate , bool) --->  predicate\n\nResult:​\nchange the is_true value of the given predicate\nExamples:​\npredicate set_truth false\n\nset_z​\nPossible uses:​\n\ngeometry set_z container<unknown,float> --->  geometry\nset_z (geometry , container<unknown,float>) --->  geometry\nset_z (geometry, int, float) --->  geometry\n\nResult:​\nSets the z ordinate of the n-th point of a geometry to the value provided by the third argument\nExamples:​\ntriangle(3) set_z [5,10,14] set_z (triangle(3), 1, 3.0)\n\nshape_file​\nPossible uses:​\n\nshape_file (string) --->  file\nstring shape_file int --->  file\nshape_file (string , int) --->  file\nstring shape_file string --->  file\nshape_file (string , string) --->  file\nstring shape_file bool --->  file\nshape_file (string , bool) --->  file\nshape_file (string, int, bool) --->  file\nshape_file (string, string, bool) --->  file\n\nResult:​\nConstructs a file of type shape. Allowed extensions are limited to shp, SHP\nSpecial cases:​\n\nshape_file(string): This file constructor allows to read a shapefile (.shp) file\n\nfile f <- shape_file(\"file.shp\");\n\nshape_file(string,int): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code, as an int (epsg code)\n\nfile f <- shape_file(\"file.shp\", \"32648\");\n\nshape_file(string,string): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code (epg,...,), as a string\n\nfile f <- shape_file(\"file.shp\", \"EPSG:32648\");\n\nshape_file(string,bool): This file constructor allows to read a shapefile (.shp) file and take a potential z value (not taken in account by default)\n\nfile f <- shape_file(\"file.shp\", true);\n\nshape_file(string,int,bool): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code, as an int (epsg code) and take a potential z value (not taken in account by default)\n\nfile f <- shape_file(\"file.shp\", \"32648\", true);\n\nshape_file(string,string,bool): This file constructor allows to read a shapefile (.shp) file and specifying the coordinates system code (epg,...,), as a string and take a potential z value (not taken in account by default)\n\nfile f <- shape_file(\"file.shp\", \"EPSG:32648\",true);\nSee also: is_shape,\n\nsharpened​\nPossible uses:​\n\nsharpened (image) --->  image\n\nResult:​\nApplication of a sharpening filter to the image passed in parameter. This operation can be applied multiple times. The original image is left untouched\n\nshuffle​\nPossible uses:​\n\nshuffle (matrix) --->  matrix\nshuffle (container) --->  list\nshuffle (string) --->  string\n\nResult:​\nThe elements of the operand in random order.\nSpecial cases:​\n\nif the operand is empty, returns an empty list (or string, matrix)\n\nExamples:​\nmatrix var0 <- shuffle (matrix([[\"c11\",\"c12\",\"c13\"],[\"c21\",\"c22\",\"c23\"]])); // var0 equals matrix([[\"c12\",\"c21\",\"c11\"],[\"c13\",\"c22\",\"c23\"]]) (for example) list var1 <- shuffle ([12, 13, 14]); // var1 equals [14,12,13] (for example) string var2 <- shuffle ('abc'); // var2 equals 'bac' (for example)\nSee also: reverse,\n\nsignum​\nPossible uses:​\n\nsignum (int) --->  int\nsignum (float) --->  int\n\nResult:​\nReturns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a number\nReturns -1 if the argument is negative, +1 if it is positive, 0 if it is equal to zero or not a number\nExamples:​\nint var0 <- signum(-12); // var0 equals -1 int var1 <- signum(14); // var1 equals 1 int var2 <- signum(0); // var2 equals 0 int var3 <- signum(-12.8); // var3 equals -1 int var4 <- signum(14.5); // var4 equals 1 int var5 <- signum(0.0); // var5 equals 0\n\nsimple_clustering_by_distance​\nPossible uses:​\n\ncontainer<unknown,agent> simple_clustering_by_distance float --->  list<list<agent>>\nsimple_clustering_by_distance (container<unknown,agent> , float) --->  list<list<agent>>\n\nResult:​\nA list of agent groups clustered by distance considering a distance min between two groups.\nExamples:​\nlist<list<agent>> var0 <- [ag1, ag2, ag3, ag4, ag5] simpleClusteringByDistance 20.0; // var0 equals for example, can return [[ag1, ag3], [ag2], [ag4, ag5]]\nSee also: hierarchical_clustering,\n\nsimple_clustering_by_envelope_distance​\nSame signification as simple_clustering_by_distance\n\nsimplification​\nPossible uses:​\n\ngeometry simplification float --->  geometry\nsimplification (geometry , float) --->  geometry\n\nResult:​\nA geometry corresponding to the simplification of the operand (geometry, agent, point) considering a tolerance distance.\nComment:​\nThe algorithm used for the simplification is Douglas-Peucker\nExamples:​\ngeometry var0 <- self simplification 0.1; // var0 equals the geometry resulting from the application of the Douglas-Peuker algorithm on the geometry of the agent applying the operator with a tolerance distance of 0.1.\n\nsimulation_file​\nPossible uses:​\n\nsimulation_file (string) --->  file\n\nResult:​\nConstructs a file of type simulation. Allowed extensions are limited to gsim, simulation\nSpecial cases:​\n\nsimulation_file(string): File containing \ta saved simulation. Three internal formats are supported: json, xml and java binary serialisation protocol\n\nSee also: is_simulation,\n\nsin​\nPossible uses:​\n\nsin (float) --->  float\nsin (int) --->  float\n\nResult:​\nReturns the value (in [-1,1]) of the sinus of the operand (in decimal degrees). The argument is casted to an int before being evaluated.\nSpecial cases:​\n\nOperand values out of the range [0-359] are normalized.\n\nExamples:​\nfloat var0 <- sin(360) with_precision 10 with_precision 10; // var0 equals 0.0 float var1 <- sin (0); // var1 equals 0.0\nSee also: cos, tan,\n\nsin_rad​\nPossible uses:​\n\nsin_rad (float) --->  float\n\nResult:​\nReturns the value (in [-1,1]) of the sinus of the operand (in radians).\nExamples:​\nfloat var0 <- sin_rad(0); // var0 equals 0.0 float var1 <- sin_rad(#pi/2); // var1 equals 1.0\nSee also: cos_rad, tan_rad,\n\nsince​\nPossible uses:​\n\nsince (date) --->  bool\nany expression since date --->  bool\nsince (any expression , date) --->  bool\n\nResult:​\nReturns true if the current_date of the model is after (or equal to) the date passed in argument. Synonym of 'current_date >= argument'. Can be used, like 'after', in its composed form with 2 arguments to express the lowest boundary of the computation of a frequency. However, contrary to 'after', there is a subtle difference: the lowest boundary will be tested against the frequency as well\nExamples:​\nreflex when: since(starting_date) {}  \t// this reflex will always be run every(2#days) since (starting_date + 1#day) // the computation will return true 1 day after the starting date and every two days after this reference date\n\nskeletonize​\nPossible uses:​\n\nskeletonize (geometry) --->  list<geometry>\ngeometry skeletonize float --->  list<geometry>\nskeletonize (geometry , float) --->  list<geometry>\nskeletonize (geometry, float, float) --->  list<geometry>\nskeletonize (geometry, float, float, bool) --->  list<geometry>\n\nResult:​\nA list of geometries (polylines) corresponding to the skeleton of the operand geometry (geometry, agent)\nSpecial cases:​\n\nIt can be used with 2 additional float operands: the tolerances for the clipping and for the triangulation\nIt can be used with 3 additional float operands: the tolerance for the clipping, the  tolerance for the triangulation, and the approximation for the clipping.\nIt can be used with 1 additional float operand: the tolerance for the clipping.\n\nExamples:​\nlist<geometry> var0 <- skeletonize(self); // var0 equals the list of geometries corresponding to the skeleton of the geometry of the agent applying the operator.\n\nskew​\nSame signification as skewness\n\nskew_gauss​\nPossible uses:​\n\nskew_gauss (float, float, float, float) --->  float\n\nResult:​\nA value from a skew normally distributed random variable with min value (the minimum skewed value possible), max value (the maximum skewed value possible), skew (the degree to which the values cluster around the mode of the distribution; higher values mean tighter clustering) and bias (the tendency of the mode to approach the min, max or midpoint value; positive values bias toward max, negative values toward min).The algorithm was taken from http://stackoverflow.com/questions/5853187/skewing-java-random-number-generation-toward-a-certain-number\nExamples:​\nfloat var0 <- skew_gauss(0.0, 1.0, 0.7,0.1); // var0 equals 0.1729218460343077\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, truncated_gauss, weibull_rnd,\n\nskewness​\nPossible uses:​\n\nskewness (list) --->  float\n\nResult:​\nreturns skewness value computed from the operand list of values\nSpecial cases:​\n\nif the length of the list is lower than 3, returns NaN\n\nExamples:​\nfloat var0 <- skewness ([1,2,3,4,5]); // var0 equals 0.0\n\nskill​\nPossible uses:​\n\nskill (any) --->  skill\n\nResult:​\ncasts the operand in a skill object.\n\nsmooth​\nPossible uses:​\n\ngeometry smooth float --->  geometry\nsmooth (geometry , float) --->  geometry\n\nResult:​\nReturns a 'smoothed' geometry, where straight lines are replaces by polynomial (bicubic) curves. The first parameter is the original geometry, the second is the 'fit' parameter which can be in the range 0 (loose fit) to 1 (tightest fit).\nExamples:​\ngeometry var0 <- smooth(square(10), 0.0); // var0 equals a 'rounded' square\n\nsnapshot​\nPossible uses:​\n\nsnapshot (string) --->  image\nagent snapshot string --->  image\nsnapshot (agent , string) --->  image\nsnapshot (agent, string, point) --->  image\n\nResult:​\nTakes a snapshot of the display whose name is passed in parameter and returns the image. The search for the display begins in the agent passed in parameter and, if not found, its experiment. The size of the snapshot will be that of the viewReturns nil if no display can be found or the snapshot cannot be taken.\nTakes a snapshot of the display whose name is passed in parameter and returns the image. The search for the display begins in the current agent's simulation and, if not found, its experiment. Returns nil if no display can be found or the snapshot cannot be taken.\nTakes a snapshot of the display whose name is passed in parameter and returns the image. The search for the display begins in the agent passed in parameter and, if not found, its experiment. A custom size (a point representing width x height) can be given Returns nil if no display can be found or the snapshot cannot be taken.\n\nsobolAnalysis​\nPossible uses:​\n\nsobolAnalysis (string, string, int) --->  string\n\nResult:​\nReturn a string containing the Report of the sobol analysis for the corresponding .csv file and save this report in a txt file.\n\nsocial_link​\nPossible uses:​\n\nsocial_link (any) --->  social_link\n\nResult:​\ncasts the operand in a social_link object.\n\nsolid​\nSame signification as without_holes\n\nsort​\nSame signification as sort_by\n\nsort_by​\nPossible uses:​\n\ncontainer sort_by any expression --->  list\nsort_by (container , any expression) --->  list\n\nResult:​\nReturns a list, containing the elements of the left-hand operand sorted in ascending order by the value of the right-hand operand when it is evaluated on them.\nComment:​\nthe left-hand operand is casted to a list before applying the operator. In the right-hand operand, the keyword each can be used to represent, in turn, each of the elements.\nSpecial cases:​\n\nif the left-hand operand is nil, sort_by throws an error. If the sorting function returns values that cannot be compared, an error will be thrown as well\n\nExamples:​\nlist var0 <- [1,2,4,3,5,7,6,8] sort_by (each); // var0 equals [1,2,3,4,5,6,7,8] list var2 <- g2 sort_by (length(g2 out_edges_of each) ); // var2 equals [node9, node7, node10, node8, node11, node6, node5, node4] list var3 <- (list(node) sort_by (round(node(each).location.x)); // var3 equals [node5, node1, node0, node2, node3] list var4 <- [1::2, 5::6, 3::4] sort_by (each); // var4 equals [2, 4, 6]\nSee also: group_by,\n\nsource_of​\nPossible uses:​\n\ngraph source_of unknown --->  unknown\nsource_of (graph , unknown) --->  unknown\n\nResult:​\nreturns the source of the edge (right-hand operand) contained in the graph given in left-hand operand.\nSpecial cases:​\n\nif the lef-hand operand (the graph) is nil, throws an Exception\n\nExamples:​\ngraph graphEpidemio <- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] ); unknown var1 <- graphEpidemio source_of(edge(3)); // var1 equals node1 graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); point var3 <- graphFromMap source_of(link({1,5},{12,45})); // var3 equals {1,5}\nSee also: target_of,\n\nspatial_graph​\nPossible uses:​\n\nspatial_graph (container) --->  graph\n\nResult:​\nallows to create a spatial graph from a container of vertices, without trying to wire them. The container can be empty. Emits an error if the contents of the container are not geometries, points or agents\nSee also: graph,\n\nspecies​\nPossible uses:​\n\nspecies (any) --->  species\n\nResult:​\ncasts the operand in a species object.\nSpecial cases:​\n\nif the operand is nil, returns nil;\nif the operand is an agent, returns its species;\nif the operand is a string, returns the species with this name (nil if not found);\notherwise, returns nil\n\nExamples:​\nspecies var0 <- species(self); // var0 equals the species of the current agent species var1 <- species('node'); // var1 equals node species var2 <- species([1,5,9,3]); // var2 equals nil species var3 <- species(node1); // var3 equals node\n\nspecies_of​\nPossible uses:​\n\nspecies_of (unknown) --->  species\n\nResult:​\ncasting of the operand to a species.\nSpecial cases:​\n\nif the operand is nil, returns nil;\nif the operand is an agent, returns its species;\nif the operand is a string, returns the species with this name (nil if not found);\notherwise, returns nil\n\nExamples:​\nspecies var0 <- species(self); // var0 equals the species of the current agent species var1 <- species('node'); // var1 equals node species var2 <- species([1,5,9,3]); // var2 equals nil species var3 <- species(node1); // var3 equals node\n\nsphere​\nPossible uses:​\n\nsphere (float) --->  geometry\n\nResult:​\nA sphere geometry which radius is equal to the operand.\nComment:​\nthe centre of the sphere is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if the operand is lower or equal to 0.\n\nExamples:​\ngeometry var0 <- sphere(10); // var0 equals a geometry as a circle of radius 10 but displays a sphere.\nSee also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,\n\nsplit​\nPossible uses:​\n\nsplit (list<unknown>) --->  list<list<unknown>>\n\nResult:​\nSplits a list of numbers into n=(1+3.3*log10(elements)) bins. The splitting is strict (i.e. elements are in the ith bin if they are strictly smaller than the ith bound)\nExamples:​\nlist<list<unknown>> var0 <- split([1.0,2.0,1.0,3.0,1.0,2.0]); // var0 equals [[1.0,1.0,1.0],[2.0,2.0],[3.0]]\nSee also: split_in, split_using,\n\nsplit_at​\nPossible uses:​\n\ngeometry split_at point --->  list<geometry>\nsplit_at (geometry , point) --->  list<geometry>\n\nResult:​\nThe two part of the left-operand lines split at the given right-operand point\nSpecial cases:​\n\nif the left-operand is a point or a polygon, returns an empty list\n\nExamples:​\nlist<geometry> var0 <- polyline([{1,2},{4,6}]) split_at {7,6}; // var0 equals [polyline([{1.0,2.0},{7.0,6.0}]), polyline([{7.0,6.0},{4.0,6.0}])]\n\nsplit_geometry​\nPossible uses:​\n\ngeometry split_geometry float --->  list<geometry>\nsplit_geometry (geometry , float) --->  list<geometry>\ngeometry split_geometry point --->  list<geometry>\nsplit_geometry (geometry , point) --->  list<geometry>\nsplit_geometry (geometry, int, int) --->  list<geometry>\n\nResult:​\nA list of geometries that result from the decomposition of the geometry by square cells of the given side size (geometry, size). It can be used to split in rectangles by giving a point or 2 integer values as operand.\nExamples:​\nlist<geometry> var0 <- to_squares(self, 10.0); // var0 equals the list of the geometries corresponding to the decomposition of the geometry by squares of side size 10.0 list<geometry> var1 <- to_rectangles(self, 10,20); // var1 equals the list of the geometries corresponding to the decomposition of the geometry of the agent applying the operator list<geometry> var2 <- to_rectangles(self, {10.0, 15.0}); // var2 equals the list of the geometries corresponding to the decomposition of the geometry by rectangles of size 10.0, 15.0\n\nsplit_in​\nPossible uses:​\n\nlist<unknown> split_in int --->  list<list<unknown>>\nsplit_in (list<unknown> , int) --->  list<list<unknown>>\nsplit_in (list<unknown>, int, bool) --->  list<list<unknown>>\n\nResult:​\nSplits a list of numbers into n bins defined by n-1 bounds between the minimum and maximum values found in the first argument. The splitting is strict (i.e. elements are in the ith bin if they are strictly smaller than the ith bound)\nSplits a list of numbers into n bins defined by n-1 bounds between the minimum and maximum values found in the first argument. The boolean argument controls whether or not the splitting is  strict (if true, elements are in the ith bin if they are strictly smaller than the ith bound)\nExamples:​\nlist<float> li <- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list<list<unknown>> var1 <- split_in(li,3); // var1 equals [[1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0],[19.9],[35.9,40.0]] list<float> l <- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list<list<unknown>> var3 <- split_in(l,3, true); // var3 equals [[1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0],[19.9],[35.9,40.0]]\nSee also: split, split_using,\n\nsplit_lines​\nPossible uses:​\n\nsplit_lines (container<unknown,geometry>) --->  list<geometry>\ncontainer<unknown,geometry> split_lines bool --->  list<geometry>\nsplit_lines (container<unknown,geometry> , bool) --->  list<geometry>\n\nResult:​\nA list of geometries resulting after cutting the lines at their intersections. if the last boolean operand is set to true, the split lines will import the attributes of the initial lines\nA list of geometries resulting after cutting the lines at their intersections.\nExamples:​\nlist<geometry> var0 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); // var0 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}]) list<geometry> var1 <- split_lines([line([{0,10}, {20,10}]), line([{0,10}, {20,10}])]); // var1 equals a list of four polylines: line([{0,10}, {10,10}]), line([{10,10}, {20,10}]), line([{10,0}, {10,10}]) and line([{10,10}, {10,20}])\n\nsplit_using​\nPossible uses:​\n\nlist<unknown> split_using list<unknown> --->  list<list<unknown>>\nsplit_using (list<unknown> , list<unknown>) --->  list<list<unknown>>\nsplit_using (list<unknown>, list<unknown>, bool) --->  list<list<unknown>>\n\nResult:​\nSplits a list of numbers into n+1 bins using a set of n bounds passed as the second argument. The splitting is strict (i.e. elements are in the ith bin if they are strictly smaller than the ith bound), when no boolean attribute is specified.\nExamples:​\nlist<float> li <- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list<list<unknown>> var1 <- split_using(li,[1.0,3.0,4.2]); // var1 equals [[],[1.0],[3.1],[5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]] list<float> l <- [1.0,3.1,5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]; list<list<unknown>> var3 <- split_using(l,[1.0,3.0,4.2], true); // var3 equals [[],[1.0],[3.1],[5.2,6.0,9.2,11.1,12.0,13.0,19.9,35.9,40.0]]\nSee also: split, split_in,\n\nsplit_with​\nPossible uses:​\n\nstring split_with string --->  list\nsplit_with (string , string) --->  list\nsplit_with (string, string, bool) --->  list\n\nResult:​\nReturns a list containing the sub-strings (tokens) of the left-hand operand delimited by each of the characters of the right-hand operand.\nComment:​\nDelimiters themselves are excluded from the resulting list.\nSpecial cases:​\n\nwhen used  with an  additional boolean operand, it returns a list containing the sub-strings (tokens) of the left-hand operand delimited either by each of the characters of the right-hand operand (false) or by the whole right-hand operand (true).\n\nExamples:​\nlist var0 <- 'aa::bb:cc' split_with ('::', true); // var0 equals ['aa','bb:cc'] list var1 <- 'aa::bb:cc' split_with ('::', false); // var1 equals ['aa','bb','cc'] list var2 <- 'to be or not to be,that is the question' split_with ' ,'; // var2 equals ['to','be','or','not','to','be','that','is','the','question']\n\nsqrt​\nPossible uses:​\n\nsqrt (int) --->  float\nsqrt (float) --->  float\n\nResult:​\nReturns the square root of the operand.\nSpecial cases:​\n\nif the operand is negative, an exception is raised\n\nExamples:​\nfloat var0 <- sqrt(4); // var0 equals 2.0 float var1 <- sqrt(4); // var1 equals 2.0\n\nsquare​\nPossible uses:​\n\nsquare (float) --->  geometry\n\nResult:​\nA square geometry which side size is equal to the operand.\nComment:​\nthe centre of the square is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\n\nExamples:​\ngeometry var0 <- square(10); // var0 equals a geometry as a square of side size 10. float var1 <- var0.area; // var1 equals 100.0\nSee also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, triangle,\n\nsquircle​\nPossible uses:​\n\nfloat squircle float --->  geometry\nsquircle (float , float) --->  geometry\n\nResult:​\nA mix of square and circle geometry (see : http://en.wikipedia.org/wiki/Squircle), which side size is equal to the first operand and power is equal to the second operand\nComment:​\nthe center of the ellipse is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if the side operand is lower or equal to 0.\n\nExamples:​\ngeometry var0 <- squircle(4,4); // var0 equals a geometry as a squircle of side 4 with a power of 4.\nSee also: around, cone, line, link, norm, point, polygon, polyline, super_ellipse, rectangle, square, circle, ellipse, triangle,\n\nstack​\nPossible uses:​\n\nstack (list<int>) --->  unknown<string>\nstack (map<unknown,int>) --->  unknown<string>\n\nResult:​\nCreates a stack layout node. Stacks can only contain one or several indices of displays (without weight)\nCreates a stack layout node. Accepts the same argument as horizontal or vertical (a map of display indices and weights) but the weights are not taken into account\n\nstandard_deviation​\nPossible uses:​\n\nstandard_deviation (container) --->  float\n\nResult:​\nthe standard deviation on the elements of the operand. See Standard_deviation for more details.\nComment:​\nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded.\nExamples:​\nfloat var0 <- standard_deviation ([4.5, 3.5, 5.5, 7.0]); // var0 equals 1.2930100540985752\nSee also: mean, mean_deviation,\n\nstep_sub_model​\nPossible uses:​\n\nstep_sub_model (agent) --->  int\n\nResult:​\nLoad a submodel\nComment:​\nloaded submodel\n\nstrahler​\nPossible uses:​\n\nstrahler (graph) --->  map\n\nResult:​\nretur for each edge, its strahler number\n\nstring​\nPossible uses:​\n\ndate string string --->  string\nstring (date , string) --->  string\nstring (date, string, string) --->  string\n\nResult:​\nconverts a date to astring following a custom pattern. The pattern can use \"%Y %M %N %D %E %h %m %s %z\" for outputting years, months, name of month, days, name of days, hours, minutes, seconds and the time-zone. A null or empty pattern will return the complete date as defined by the ISO date & time format. The pattern can also follow the pattern definition found here, which gives much more control over the format of the date: https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns. Different patterns are available by default as constants: #iso_local, #iso_simple, #iso_offset, #iso_zoned and #custom, which can be changed in the preferences\nExamples:​\nstring(#now, 'yyyy-MM-dd', 'en') string(#now, 'yyyy-MM-dd')\n\nstudent_area​\nPossible uses:​\n\nfloat student_area int --->  float\nstudent_area (float , int) --->  float\n\nResult:​\nReturns the area to the left of x in the Student T distribution with the given degrees of freedom.\nExamples:​\nfloat var0 <- student_area(1.64,3) with_precision(2); // var0 equals 0.9\n\nstudent_t_inverse​\nPossible uses:​\n\nfloat student_t_inverse int --->  float\nstudent_t_inverse (float , int) --->  float\n\nResult:​\nReturns the value, t, for which the area under the Student-t probability density function (integrated from minus infinity to t) is equal to x.\nExamples:​\nfloat var0 <- student_t_inverse(0.9,3) with_precision(2); // var0 equals 1.64\n\nsubtract_days​\nSame signification as minus_days\n\nsubtract_hours​\nSame signification as minus_hours\n\nsubtract_minutes​\nSame signification as minus_minutes\n\nsubtract_months​\nSame signification as minus_months\n\nsubtract_ms​\nSame signification as minus_ms\n\nsubtract_seconds​\nSame signification as -\n\nsubtract_weeks​\nSame signification as minus_weeks\n\nsubtract_years​\nSame signification as minus_years\n\nsuccessors_of​\nPossible uses:​\n\ngraph successors_of unknown --->  list\nsuccessors_of (graph , unknown) --->  list\n\nResult:​\nreturns the list of successors (i.e. targets of out edges) of the given vertex (right-hand operand) in the given graph (left-hand operand)\nExamples:​\nlist var1 <- graphEpidemio successors_of ({1,5}); // var1 equals [{12,45}] list var2 <- graphEpidemio successors_of node({34,56}); // var2 equals []\nSee also: predecessors_of, neighbors_of,\n\nsum​\nPossible uses:​\n\nsum (container) --->  unknown\nsum (graph) --->  float\n\nResult:​\nthe sum of all the elements of the operand\nComment:​\nthe behavior depends on the nature of the operand\nSpecial cases:​\n\nif it is a population or a list of other types: sum transforms all elements into float and sums them\nif it is a map, sum returns the sum of the value of all elements\nif it is a file, sum returns the sum of the content of the file (that is also a container)\nif it is a graph, sum returns the total weight of the graph\nif it is a matrix of int, float or object, sum returns the sum of all the numerical elements (i.e. all elements for integer and float matrices)\nif it is a matrix of other types: sum transforms all elements into float and sums them\nif it is a list of colors: sum will sum them and return the blended resulting color\nif it is a list of int or float: sum returns the sum of all the elements\n\nint var0 <- sum ([12,10,3]); // var0 equals 25\n\nif it is a list of points: sum returns the sum of all points as a point (each coordinate is the sum of the corresponding coordinate of each element)\n\nunknown var1 <- sum([{1.0,3.0},{3.0,5.0},{9.0,1.0},{7.0,8.0}]); // var1 equals {20.0,17.0}\nSee also: mul,\n\nsum_of​\nPossible uses:​\n\ncontainer sum_of any expression --->  unknown\nsum_of (container , any expression) --->  unknown\n\nResult:​\nthe sum of the right-hand expression evaluated on each of the elements of the left-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-operand is a map, the keyword each will contain each value\n\nunknown var1 <- [1::2, 3::4, 5::6] sum_of (each + 3); // var1 equals 21\nExamples:​\nunknown var0 <- [1,2] sum_of (each * 100 ); // var0 equals 300\nSee also: min_of, max_of, product_of, mean_of,\n\nsvg_file​\nPossible uses:​\n\nsvg_file (string) --->  file\n\nResult:​\nConstructs a file of type svg. Allowed extensions are limited to svg\nSpecial cases:​\n\nsvg_file(string): This file constructor allows to read a svg file\n\nfile f <-svg_file(\"file.svg\");\nSee also: is_svg,\n\nt_test​\nPossible uses:​\n\nlist t_test list --->  float\nt_test (list , list) --->  float\n\nResult:​\nReturns the observed significance level, or p-value, associated with a two-sample, two-tailed t-test comparing the means of the two input lists.The number returned is the smallest significance level at which one can reject the null hypothesis\nExamples:​\nfloat var0 <- t_test([10.0,5.0,1.0, 3.0],[1.0,10.0,5.0,1.0]); // var0 equals 0.01\n\ntan​\nPossible uses:​\n\ntan (float) --->  float\ntan (int) --->  float\n\nResult:​\nReturns the value (in [-1,1]) of the trigonometric tangent of the operand (in decimal degrees).\nSpecial cases:​\n\nOperand values out of the range [0-359] are normalized. Notice that tan(360) does not return 0.0 but -2.4492935982947064E-16\nThe tangent is only defined for any real number except 90 + k * 180 (k an positive or negative integer). Nevertheless notice that tan(90) returns 1.633123935319537E16 (whereas we could except infinity).\n\nExamples:​\nfloat var0 <- tan (0); // var0 equals 0.0 float var1 <- tan(90); // var1 equals 1.633123935319537E16\nSee also: cos, sin,\n\ntan_rad​\nPossible uses:​\n\ntan_rad (float) --->  float\n\nResult:​\nReturns the value (in [-1,1]) of the trigonometric tangent of the operand (in radians).\nExamples:​\nfloat var0 <- tan_rad(0); // var0 equals 0.0\nSee also: cos_rad, sin_rad,\n\ntanh​\nPossible uses:​\n\ntanh (float) --->  float\ntanh (int) --->  float\n\nResult:​\nReturns the value (in the interval [-1,1]) of the hyperbolic tangent of the operand (which can be any real number, expressed in decimal degrees).\nExamples:​\nfloat var0 <- tanh(0); // var0 equals 0.0 float var1 <- tanh(100); // var1 equals 1.0\n\ntarget_of​\nPossible uses:​\n\ngraph target_of unknown --->  unknown\ntarget_of (graph , unknown) --->  unknown\n\nResult:​\nreturns the target of the edge (right-hand operand) contained in the graph given in left-hand operand.\nSpecial cases:​\n\nif the lef-hand operand (the graph) is nil, returns nil\n\nExamples:​\ngraph graphEpidemio <- generate_barabasi_albert( [\"edges_species\"::edge,\"vertices_specy\"::node,\"size\"::3,\"m\"::5] ); unknown var1 <- graphEpidemio source_of(edge(3)); // var1 equals node1 graph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); unknown var3 <- graphFromMap target_of(link({1,5},{12,45})); // var3 equals {12,45}\nSee also: source_of,\n\nteapot​\nPossible uses:​\n\nteapot (float) --->  geometry\n\nResult:​\nA teapot geometry which radius is equal to the operand.\nComment:​\nthe centre of the teapot is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns a point if the operand is lower or equal to 0.\n\nExamples:​\ngeometry var0 <- teapot(10); // var0 equals a geometry as a circle of radius 10 but displays a teapot.\nSee also: around, cone, line, link, norm, point, polygon, polyline, rectangle, square, triangle,\n\ntext_file​\nPossible uses:​\n\ntext_file (string) --->  file\nstring text_file list<string> --->  file\ntext_file (string , list<string>) --->  file\n\nResult:​\nConstructs a file of type text. Allowed extensions are limited to txt, data, text\nSpecial cases:​\n\ntext_file(string): This file constructor allows to read a text file (.txt, .data, .text)\n\nfile f <-text_file(\"file.txt\");\n\ntext_file(string,list<string>): This file constructor allows to store a list of string in a text file (it does not save it - just store it in memory)\n\nfile f <-text_file(\"file.txt\", [\"item1\",\"item2\",\"item3\"]);\nSee also: is_text,\n\nTGauss​\nSame signification as truncated_gauss\n\nthreeds_file​\nPossible uses:​\n\nthreeds_file (string) --->  file\n\nResult:​\nConstructs a file of type threeds. Allowed extensions are limited to 3ds, max\nSpecial cases:​\n\nthreeds_file(string): This file constructor allows to read a 3DS Max file. Only loads vertices and faces\n\nthreeds_file f <- threeds_file(\"file\");\nSee also: is_threeds,\n\ntinted_with​\nPossible uses:​\n\nimage tinted_with rgb --->  image\ntinted_with (image , rgb) --->  image\ntinted_with (image, rgb, float) --->  image\n\nResult:​\nReturns the image tinted using the color passed in parameter. This effectively multiplies the colors of the image by it. The original image is left untouched\nReturns the image tinted using the color passed in parameter and a factor between 0 and 1, determining the transparency of the dyeing to apply. The original image is left untouched\n\nto​\nSame signification as until\nPossible uses:​\n\ndate to date --->  list<date>\nto (date , date) --->  list<date>\n\nResult:​\nbuilds an interval between two dates (the first inclusive and the second exclusive, which behaves like a read-only list of dates. The default step between two dates is the step of the model\nComment:​\nThe default step can be overruled by using the every operator applied to this interval\nExamples:​\ndate('2000-01-01') to date('2010-01-01') // builds an interval between these two dates (date('2000-01-01') to date('2010-01-01')) every (#day) // builds an interval between these two dates which contains all the days starting from the beginning of the interval. Beware that using every with #month or #year will produce odd results, as these pseudo-constants are not constant; only the first value will be used to compute the intervals (if current_date is set to a month of February, #month will only represent 28 or 29 days depending on whether it is a leap year or not !). If such intervals need to be built, it is recommended to usea generative way, for instance a loop using the 'plus_years' or 'plus_months' operators to build a list of dates\nSee also: every,\n\nto_GAMA_CRS​\nPossible uses:​\n\nto_GAMA_CRS (geometry) --->  geometry\ngeometry to_GAMA_CRS string --->  geometry\nto_GAMA_CRS (geometry , string) --->  geometry\n\nSpecial cases:​\n\nreturns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by given CRS\n\ngeometry var0 <- to_GAMA_CRS({121,14}, \"EPSG:4326\"); // var0 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS\n\nreturns the geometry corresponding to the transformation of the given geometry to the GAMA CRS (Coordinate Reference System) assuming the given geometry is referenced by the current CRS, the one corresponding to the world's agent one\n\ngeometry var1 <- to_GAMA_CRS({121,14}); // var1 equals a geometry corresponding to the agent geometry transformed into the GAMA CRS\n\nto_gaml​\nPossible uses:​\n\nto_gaml (unknown) --->  string\n\nResult:​\nreturns the literal description of an expression or description -- action, behavior, species, aspect, even model -- in gaml\nExamples:​\nstring var0 <- to_gaml(0); // var0 equals '0' string var1 <- to_gaml(3.78); // var1 equals '3.78' string var2 <- to_gaml({23, 4.0}); // var2 equals '{23.0,4.0,0.0}' string var3 <- to_gaml(rgb(255,0,125)); // var3 equals 'rgb (255, 0, 125,255)' string var4 <- to_gaml('hello'); // var4 equals \"'hello'\" string var5 <- to_gaml(a_graph); // var5 equals ([((1 as node)::(3 as node))::(5 as edge),((0 as node)::(3 as node))::(3 as edge),((1 as node)::(2 as node))::(1 as edge),((0 as node)::(2 as node))::(2 as edge),((0 as node)::(1 as node))::(0 as edge),((2 as node)::(3 as node))::(4 as edge)] as map ) as graph string var6 <- to_gaml(node1); // var6 equals  1 as node\n\nto_geojson​\nPossible uses:​\n\nto_geojson (any expression, string, any expression) --->  string\n\nResult:​\nreturns geojson of species with crs\nExamples:​\nstring var0 <- to_geojson(boat,\"EPSG:4326\",[\"color\"]); // var0 equals {\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[100.51155642068785,3.514781609095577E-4,0.0]},\"properties\":{},\"id\":\"0\"}]}\n\nto_hsb​\nPossible uses:​\n\nto_hsb (rgb) --->  list<float>\n\nResult:​\nConverts a Gama color to hsb (h=hue, s=saturation, b=brightness) value\nExamples:​\nlist<float> var0 <- to_hsb (#cyan); // var0 equals [0.5,1.0,1.0]\n\nto_list​\nPossible uses:​\n\nto_list (unknown) --->  list\n\nResult:​\ncasts the operand to a list, making an explicit copy if it is already a list or a subtype of list (interval, population, etc.)\nSee also: list,\n\nto_rectangles​\nSame signification as split_geometry\nPossible uses:​\n\nto_rectangles (geometry, point, bool) --->  list<geometry>\nto_rectangles (geometry, int, int, bool) --->  list<geometry>\n\nResult:​\nA list of rectangles of the size corresponding to the given dimension that result from the decomposition of the geometry into rectangles (geometry, dimension, overlaps), if overlaps = true, add the rectangles that overlap the border of the geometry\nExamples:​\nlist<geometry> var0 <- to_rectangles(self, {10.0, 15.0}, true); // var0 equals the list of rectangles of size {10.0, 15.0} corresponding to the discretization into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept list<geometry> var1 <- to_rectangles(self, 5, 20, true); // var1 equals the list of rectangles corresponding to the discretization by a grid of 5 columns and 20 rows into rectangles of the geometry of the agent applying the operator. The rectangles overlapping the border of the geometry are kept\n\nto_segments​\nPossible uses:​\n\nto_segments (geometry) --->  list<geometry>\n\nResult:​\nA list of a segments resulting from the decomposition of the geometry (or its contours for polygons) into sgements\nExamples:​\nlist<geometry> var0 <- to_segments(line([{10,10},{80,10},{80,80}])); // var0 equals [line([{10,10},{80,10}]), line([{80,10},{80,80}])]\n\nto_squares​\nSame signification as split_geometry\nPossible uses:​\n\nto_squares (geometry, float, bool) --->  list<geometry>\nto_squares (geometry, int, bool) --->  list<geometry>\nto_squares (geometry, int, bool, float) --->  list<geometry>\n\nResult:​\nA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps, precision_coefficient), if overlaps = true, add the squares that overlap the border of the geometry, coefficient_precision should be close to 1.0\nA list of squares of the size corresponding to the given size that result from the decomposition of the geometry into squares (geometry, size, overlaps), if overlaps = true, add the squares that overlap the border of the geometry\nA list of a given number of squares from the decomposition of the geometry into squares (geometry, nb_square, overlaps), if overlaps = true, add the squares that overlap the border of the geometry\nExamples:​\nlist<geometry> var0 <- to_squares(self, 10, true, 0.99); // var0 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list<geometry> var1 <- to_squares(self, 10.0, true); // var1 equals the list of squares of side size 10.0 corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept list<geometry> var2 <- to_squares(self, 10, true); // var2 equals the list of 10 squares corresponding to the discretization into squares of the geometry of the agent applying the operator. The squares overlapping the border of the geometry are kept\n\nto_sub_geometries​\nPossible uses:​\n\ngeometry to_sub_geometries list<float> --->  list<geometry>\nto_sub_geometries (geometry , list<float>) --->  list<geometry>\nto_sub_geometries (geometry, list<float>, float) --->  list<geometry>\n\nResult:​\nA list of geometries resulting after spliting the geometry into sub-geometries.\nExamples:​\nlist<geometry> var0 <- to_sub_geometries(rectangle(10, 50), [0.1, 0.5, 0.4]); // var0 equals a list of three geometries corresponding to 3 sub-geometries list<geometry> var1 <- to_sub_geometries(rectangle(10, 50), [0.1, 0.5, 0.4], 1.0); // var1 equals a list of three geometries corresponding to 3 sub-geometries using cubes of 1m size\n\nto_triangles​\nSame signification as triangulate\n\ntokenize​\nSame signification as split_with\n\ntopology​\nPossible uses:​\n\ntopology (any) --->  topology\n\nResult:​\ncasts the operand in a topology object.\nSpecial cases:​\n\nif the operand is a topology, returns the topology itself;\nif the operand is a spatial graph, returns the graph topology associated;\nif the operand is a population, returns the topology of the population;\nif the operand is a shape or a geometry, returns the continuous topology bounded by the geometry;\nif the operand is a matrix, returns the grid topology associated\nif the operand is another kind of container, returns the multiple topology associated to the container\notherwise, casts the operand to a geometry and build a topology from it.\n\nExamples:​\ntopology var0 <- topology(0); // var0 equals nil topology(a_graph)\t--: Multiple topology in POLYGON ((24.712119771887785 7.867357373616512, 24.712119771887785 61.283226839310565, 82.4013676510046  7.867357373616512)) at location[53.556743711446195;34.57529210646354]\nSee also: geometry,\n\ntouches​\nPossible uses:​\n\ngeometry touches geometry --->  bool\ntouches (geometry , geometry) --->  bool\n\nResult:​\nA boolean, equal to true if the left-geometry (or agent/point) touches the right-geometry (or agent/point).\nComment:​\nreturns true when the left-operand only touches the right-operand. When one geometry covers partially (or fully) the other one, it returns false.\nSpecial cases:​\n\nif one of the operand is null, returns false.\n\nExamples:​\nbool var0 <- {15,15} touches {15,15}; // var0 equals false bool var1 <- polyline([{10,10},{20,20}]) touches {10,10}; // var1 equals true bool var2 <- polyline([{10,10},{20,20}]) touches polyline([{10,10},{5,5}]); // var2 equals true bool var3 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches polygon([{15,15},{15,25},{25,25},{25,15}]); // var3 equals false bool var4 <- polygon([{10,10},{10,20},{20,20},{20,10}]) touches {10,15}; // var4 equals true\nSee also: disjoint_from, crosses, overlaps, partially_overlaps, intersects,\n\ntouching​\nPossible uses:​\n\ncontainer<unknown,geometry> touching geometry --->  list<geometry>\ntouching (container<unknown,geometry> , geometry) --->  list<geometry>\n\nResult:​\nA list of agents or geometries among the left-operand list, species or meta-population (addition of species), touching the operand (casted as a geometry).\nExamples:​\nlist<geometry> var0 <- [ag1, ag2, ag3] toucing(self); // var0 equals the agents among ag1, ag2 and ag3 that touch the shape of the right-hand argument. list<geometry> var1 <- (species1 + species2) touching (self); // var1 equals the agents among species species1 and species2 that touch the shape of the right-hand argument.\nSee also: neighbors_at, neighbors_of, closest_to, overlapping, agents_overlapping, inside, agents_inside, agent_closest_to,\n\ntowards​\nPossible uses:​\n\ngeometry towards geometry --->  float\ntowards (geometry , geometry) --->  float\n\nResult:​\nThe direction (in degree) between the two geometries (geometries, agents, points) considering the topology of the agent applying the operator.\nExamples:​\nfloat var0 <- ag1 towards ag2; // var0 equals the direction between ag1 and ag2 and ag3 considering the topology of the agent applying the operator\nSee also: distance_between, distance_to, direction_between, path_between, path_to,\n\ntrace​\nPossible uses:​\n\ntrace (matrix) --->  float\n\nResult:​\nThe trace of the given matrix (the sum of the elements on the main diagonal).\nExamples:​\nfloat var0 <- trace(matrix([[1,2],[3,4]])); // var0 equals 5\n\ntransformed_by​\nPossible uses:​\n\ngeometry transformed_by point --->  geometry\ntransformed_by (geometry , point) --->  geometry\n\nResult:​\nA geometry resulting from the application of a rotation and a scaling (right-operand : point {angle(degree), scale factor} of the left-hand operand (geometry, agent, point)\nExamples:​\ngeometry var0 <- self transformed_by {45, 0.5}; // var0 equals the geometry resulting from 45 degrees rotation and 50% scaling of the geometry of the agent applying the operator.\nSee also: rotated_by, translated_by,\n\ntranslated_by​\nPossible uses:​\n\ngeometry translated_by point --->  geometry\ntranslated_by (geometry , point) --->  geometry\n\nResult:​\nA geometry resulting from the application of a translation by the right-hand operand distance to the left-hand operand (geometry, agent, point)\nExamples:​\ngeometry var0 <- self translated_by {10,10,10}; // var0 equals the geometry resulting from applying the translation to the left-hand geometry (or agent).\nSee also: rotated_by, transformed_by,\n\ntranslated_to​\nSame signification as at_location\n\ntranspose​\nPossible uses:​\n\ntranspose (matrix) --->  matrix\n\nResult:​\nThe transposition of the given matrix\nExamples:​\nmatrix var0 <- transpose(matrix([[5,-3],[6,-4]])); // var0 equals matrix([[5,6],[-3,-4]])\n\ntriangle​\nPossible uses:​\n\ntriangle (float) --->  geometry\nfloat triangle float --->  geometry\ntriangle (float , float) --->  geometry\n\nResult:​\nA triangle geometry which side size is given by the operand.\nA triangle geometry which the base and height size are given by the operand.\nComment:​\nthe center of the triangle is by default the location of the current agent in which has been called this operator.the center of the triangle is by default the location of the current agent in which has been called this operator.\nSpecial cases:​\n\nreturns nil if the operand is nil.\nreturns nil if one of the operand is nil.\n\nExamples:​\ngeometry var0 <- triangle(5); // var0 equals a geometry as a triangle with side_size = 5. geometry var1 <- triangle(5, 10); // var1 equals a geometry as a triangle with a base of 5m and a height of 10m.\nSee also: around, circle, cone, line, link, norm, point, polygon, polyline, rectangle, square,\n\ntriangulate​\nPossible uses:​\n\ntriangulate (geometry) --->  list<geometry>\ntriangulate (list<geometry>) --->  list<geometry>\ngeometry triangulate float --->  list<geometry>\ntriangulate (geometry , float) --->  list<geometry>\ntriangulate (geometry, float, float) --->  list<geometry>\ntriangulate (geometry, float, float, bool) --->  list<geometry>\n\nResult:​\nA list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point, use_approx_clipping) with the given tolerance for the clipping and for the triangulation with using an approximate clipping is the last operand is true\nA list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point)\nA list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point) with the given tolerance for the clipping and for the triangulation\nA list of geometries (triangles) corresponding to the Delaunay triangulation of the operand geometry (geometry, agent, point) with the given tolerance for the clipping\nA list of geometries (triangles) corresponding to the Delaunay triangulation computed from the list of polylines\nExamples:​\nlist<geometry> var0 <- triangulate(self,0.1, 1.0, true); // var0 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list<geometry> var1 <- triangulate(self); // var1 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list<geometry> var2 <- triangulate(self,0.1, 1.0); // var2 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list<geometry> var3 <- triangulate(self, 0.1); // var3 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator. list<geometry> var4 <- triangulate([line([{0,50},{100,50}]), line([{50,0},{50,100}])); // var4 equals the list of geometries (triangles) corresponding to the Delaunay triangulation of the geometry of the agent applying the operator.\n\ntruncated_gauss​\nPossible uses:​\n\ntruncated_gauss (list) --->  float\ntruncated_gauss (point) --->  float\n\nResult:​\nA random value from a normally distributed random variable in the interval ]mean - standardDeviation; mean + standardDeviation[.\nSpecial cases:​\n\nif the operand is a list, only the two first elements are taken into account as [mean, standardDeviation]\nwhen truncated_gauss is called with a list of only one element mean, it will always return 0.0\nwhen the operand is a point, it is read as {mean, standardDeviation}\n\nExamples:​\nfloat var0 <- truncated_gauss ([0.5, 0.0]); // var0 equals 0.5 float var1 <- truncated_gauss ({0, 0.3}); // var1 equals a float between -0.3 and 0.3\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, weibull_rnd, gamma_trunc_rnd, weibull_trunc_rnd, lognormal_trunc_rnd,\n\ntype_of​\nPossible uses:​\n\ntype_of (unknown) --->  any GAML type<unknown>\n\nResult:​\nReturns the GAML type of the operand\nExamples:​\nstring var0 <- string(type_of(\"a string\")); // var0 equals \"string\" string var1 <- string(type_of([1,2,3,4,5])); // var1 equals \"list<int>\" geometry g0 <- to_GAMA_CRS({121,14}, \"EPSG:4326\");  string var3 <- string(type_of(g0)); // var3 equals \"point\"\n\nundirected​\nPossible uses:​\n\nundirected (graph) --->  graph\n\nResult:​\nthe operand graph becomes an undirected graph.\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph.\nSee also: directed,\n\nunion​\nSame signification as +\nPossible uses:​\n\nunion (container<unknown,geometry>) --->  geometry\ncontainer union container --->  list\nunion (container , container) --->  list\n\nResult:​\nreturns a new list containing all the elements of both containers without duplicated elements.\nSpecial cases:​\n\nif the left or right operand is nil, union throws an error\nif the right-operand is a container of points, geometries or agents, returns the geometry resulting from the union all the geometries\n\nExamples:​\nlist var0 <- [1,2,3,4,5,6] union [2,4,9]; // var0 equals [1,2,3,4,5,6,9] list var1 <- [1,2,3,4,5,6] union [0,8]; // var1 equals [1,2,3,4,5,6,0,8] list var2 <- [1,3,2,4,5,6,8,5,6] union [0,8]; // var2 equals [1,3,2,4,5,6,8,0] geometry var3 <- union([geom1, geom2, geom3]); // var3 equals a geometry corresponding to union between geom1, geom2 and geom3\nSee also: inter, +,\n\nunknown​\nPossible uses:​\n\nunknown (any) --->  unknown\n\nResult:​\ncasts the operand in a unknown object.\n\nuntil​\nPossible uses:​\n\nuntil (date) --->  bool\nany expression until date --->  bool\nuntil (any expression , date) --->  bool\n\nResult:​\nReturns true if the current_date of the model is before (or equel to) the date passed in argument. Synonym of 'current_date <= argument'\nExamples:​\nreflex when: until(starting_date) {} \t// This reflex will be run only once at the beginning of the simulation\n\nunzip​\nPossible uses:​\n\nstring unzip string --->  bool\nunzip (string , string) --->  bool\n\nResult:​\nUnzip a given zip file into a given folder. Returns true if the file is well unzipped\nExamples:​\nbool unzip_ok <- unzip([\"../includes/my_folder\"], \"folder.zip\";\n\nupper_case​\nPossible uses:​\n\nupper_case (string) --->  string\n\nResult:​\nConverts all of the characters in the string operand to upper case\nExamples:​\nstring var0 <- upper_case(\"Abc\"); // var0 equals 'ABC'\nSee also: lower_case,\n\nuse_cache​\nPossible uses:​\n\ngraph use_cache bool --->  graph\nuse_cache (graph , bool) --->  graph\n\nResult:​\nif the second operand is true, the operand graph will store in a cache all the previously computed shortest path (the cache be cleared if the graph is modified).\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph.\nSee also: path_between,\n\nuser_confirm​\nPossible uses:​\n\nstring user_confirm string --->  bool\nuser_confirm (string , string) --->  bool\n\nResult:​\nAsks the user to confirm a choice. The two string are used to specify the title and the message of the dialog box.\nExamples:​\nbool confirm <- user_confirm(\"Confirm\",\"Please confirm\");\n\nuser_input_dialog​\nPossible uses:​\n\nuser_input_dialog (list) --->  map<string,unknown>\nstring user_input_dialog list --->  map<string,unknown>\nuser_input_dialog (string , list) --->  map<string,unknown>\nuser_input_dialog (string, list, font) --->  map<string,unknown>\nuser_input_dialog (string, list, font, rgb) --->  map<string,unknown>\nuser_input_dialog (string, list, font, rgb, bool) --->  map<string,unknown>\n\nResult:​\nAsks the user for some values and returns a map containing these values. Takes a string and a list of calls to the enter() or choose() operators as arguments. The string is used to specify the message of the dialog box. The list is used to specify the parameters the user can enter. Finally, the font of the title can be specified as well as the background color\nAsks the user for some values and returns a map containing these values. Takes a string and a list of calls to the enter() or choose() operators as arguments. The string is used to specify the message of the dialog box. The list is used to specify the parameters the user can enter. Finally, the font of the title can be specified\nAsks the user for some values and returns a map containing these values. Takes a string and a list of calls to the enter() or choose() operators as arguments. The string is used to specify the message of the dialog box. The list is used to specify the parameters the user can enter. Finally, the font of the title can be specified, as well as the background color and whether the title and close button of the dialog should be displayed or not\nAsks the user for some values and returns a map containing these values. Takes a string and a list of calls to the enter() or choose() operators as arguments. The string is used to specify the message of the dialog box. The list is to specify the parameters the user can enter\nExamples:​\nmap<string,unknown> values_no_title <- user_input_dialog([enter('Number',100), enter('Location',point, {10, 10})]); create bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))]; map<string,unknown> values2 <- user_input_dialog('Enter number of agents and locations',[enter('Number',100), enter('Location',point, {10, 10})], font('Helvetica', 18)); create bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))]; map<string,unknown> values2 <- user_input_dialog('Enter number of agents and locations',[enter('Number',100), enter('Location',point, {10, 10})], font('Helvetica', 18)); create bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))]; map<string,unknown> values2 <- user_input_dialog('Enter number of agents and locations',[enter('Number',100), enter('Location',point, {10, 10})], font('Helvetica', 18), #blue, true); create bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))]; map<string,unknown> values2 <- user_input_dialog('Enter number of agents and locations',[enter('Number',100), enter('Location',point, {10, 10})]); create bug number: int(values2 at \"Number\") with: [location:: (point(values2 at \"Location\"))];\n\nusing​\nPossible uses:​\n\nany expression using topology --->  unknown\nusing (any expression , topology) --->  unknown\n\nResult:​\nAllows to specify in which topology a spatial computation should take place.\nSpecial cases:​\n\nhas no effect if the topology passed as a parameter is nil\n\nExamples:​\nunknown var0 <- (agents closest_to self) using topology(world); // var0 equals the closest agent to self (the caller) in the continuous topology of the world\n\nvalues_in​\nPossible uses:​\n\nfield values_in geometry --->  list<float>\nvalues_in (field , geometry) --->  list<float>\n\n\nvariance​\nPossible uses:​\n\nvariance (container) --->  float\nvariance (float) --->  float\nvariance (int, float, float) --->  float\n\nResult:​\nthe variance of the elements of the operand. See Variance for more details.\nReturns the variance from a standard deviation.\nReturns the variance of a data sequence. That is (sumOfSquares - mean*sum) / size with mean = sum/size.\nComment:​\nThe operator casts all the numerical element of the list into float. The elements that are not numerical are discarded. In the example we consider variance of [1,3,5,7]. The size is 4, the sum is 1+3+5+7=16 and the sum of squares is 84.The variance is (84- 16^2/4)/4. CQFD.\nExamples:​\nfloat var0 <- variance ([4.5, 3.5, 5.5, 7.0]); // var0 equals 1.671875 int var1 <- int(variance([1,3,5,6,9,11,12,13])); // var1 equals 17 int var2 <- int(variance(4,16,84)); // var2 equals 5\nSee also: mean, median,\n\nvariance_of​\nPossible uses:​\n\ncontainer variance_of any expression --->  unknown\nvariance_of (container , any expression) --->  unknown\n\nResult:​\nthe variance of the right-hand expression evaluated on each of the elements of the left-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nExamples:​\nfloat var0 <- [1,2,3,4,5,6] variance_of each with_precision 2; // var0 equals 2.92\nSee also: min_of, max_of, sum_of, product_of,\n\nvertical​\nPossible uses:​\n\nvertical (map<unknown,int>) --->  unknown<string>\n\nResult:​\nCreates a vertical layout node (a sash). Sashes can contain any number (> 1) of other elements: stacks, horizontal or vertical sashes, or display indices. Each element is represented by a pair in the map, where the key is the element and the value its weight within the sash\n\nvertical_flip​\nPossible uses:​\n\nvertical_flip (image) --->  image\n\nResult:​\nReturns an image flipped vertically by reflecting the original image around the x axis. The original image is left untouched\n\nvoronoi​\nPossible uses:​\n\nvoronoi (list<point>) --->  list<geometry>\nlist<point> voronoi geometry --->  list<geometry>\nvoronoi (list<point> , geometry) --->  list<geometry>\n\nResult:​\nA list of geometries corresponding to the Voronoi diagram built from the list of points (with eventually a given  clip).\nExamples:​\nlist<geometry> var0 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}], square(300)); // var0 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points with a square of 300m side size as clip. list<geometry> var1 <- voronoi([{10,10},{50,50},{90,90},{10,90},{90,10}]); // var1 equals the list of geometries corresponding to the Voronoi Diagram built from the list of points.\n\nweibull_density​\nPossible uses:​\n\nweibull_density (float, float, float) --->  float\n\nResult:​\nweibull_density(x,shape,scale) returns the probability density function (PDF) at the specified point x of the Weibull distribution with the given shape and scale.\nExamples:​\nfloat var0 <- weibull_rnd(1,2,3) ; // var0 equals 0.731\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, lognormal_density, gamma_density,\n\nweibull_rnd​\nPossible uses:​\n\nfloat weibull_rnd float --->  float\nweibull_rnd (float , float) --->  float\n\nResult:​\nreturns a random value from a Weibull distribution with specified values of the shape (alpha) and scale (beta) parameters. See https://mathworld.wolfram.com/WeibullDistribution.html for more details (equations 1 and 2).\nExamples:​\nfloat var0 <- weibull_rnd(2,3) ; // var0 equals 0.731\nSee also: binomial, gamma_rnd, gauss_rnd, lognormal_rnd, poisson, rnd, skew_gauss, truncated_gauss, weibull_trunc_rnd,\n\nweibull_trunc_rnd​\nPossible uses:​\n\nweibull_trunc_rnd (float, float, float, float) --->  float\nweibull_trunc_rnd (float, float, float, bool) --->  float\n\nResult:​\nreturns a random value from a truncated Weibull distribution (in a range or given only one boundary) with specified values of the shape (alpha) and scale (beta) parameters. See https://mathworld.wolfram.com/WeibullDistribution.html for more details (equations 1 and 2).\nSpecial cases:​\n\nwhen 2 float operands are specified, they are taken as mininimum and maximum values for the result\n\nweibull_trunc_rnd(2,3,0.0,5.0)\n\nwhen 1 float and a boolean (isMax) operands are specified, the float value represents the single boundary (max if the boolean is true, min otherwise),\n\nweibull_trunc_rnd(2,3,5,true)\nSee also: weibull_rnd, gamma_trunc_rnd, lognormal_trunc_rnd, truncated_gauss,\n\nweight_of​\nPossible uses:​\n\ngraph weight_of unknown --->  float\nweight_of (graph , unknown) --->  float\n\nResult:​\nreturns the weight of the given edge (right-hand operand) contained in the graph given in right-hand operand.\nComment:​\nIn a localized graph, an edge has a weight by default (the distance between both vertices).\nSpecial cases:​\n\nif the left-operand (the graph) is nil, returns nil\nif the right-hand operand is not an edge of the given graph, weight_of checks whether it is a node of the graph and tries to return its weight\nif the right-hand operand is neither a node, nor an edge, returns 1.\n\nExamples:​\ngraph graphFromMap <-  as_edge_graph([{1,5}::{12,45},{12,45}::{34,56}]); float var1 <- graphFromMap weight_of(link({1,5},{12,45})); // var1 equals 1.0\n\nweighted_means_DM​\nPossible uses:​\n\nlist<list> weighted_means_DM list<map<string,unknown>> --->  int\nweighted_means_DM (list<list> , list<map<string,unknown>>) --->  int\n\nResult:​\nThe index of the candidate that maximizes the weighted mean of its criterion values. The first operand is the list of candidates (a candidate is a list of criterion values); the second operand the list of criterion (list of map)\nSpecial cases:​\n\nreturns -1 is the list of candidates is nil or empty\n\nExamples:​\nint var0 <- weighted_means_DM([[1.0, 7.0],[4.0,2.0],[3.0, 3.0]], [[\"name\"::\"utility\", \"weight\" :: 2.0],[\"name\"::\"price\", \"weight\" :: 1.0]]); // var0 equals 1\nSee also: promethee_DM, electre_DM, evidence_theory_DM,\n\nwhere​\nPossible uses:​\n\nspecies where any expression --->  list\nwhere (species , any expression) --->  list\nlist where any expression --->  list\nwhere (list , any expression) --->  list\ncontainer where any expression --->  list\nwhere (container , any expression) --->  list\n\nResult:​\na list containing all the elements of the left-hand operand that make the right-hand operand evaluate to true.\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-hand operand is nil, where throws an error\nif the left-operand is a map, the keyword each will contain each value\n\nlist var4 <- [1::2, 3::4, 5::6] where (each >= 4); // var4 equals [4, 6]\nExamples:​\nlist var0 <- [1,2,3,4,5,6,7,8] where (each > 3); // var0 equals [4, 5, 6, 7, 8]  list var2 <- g2 where (length(g2 out_edges_of each) = 0 ); // var2 equals [node9, node7, node10, node8, node11] list var3 <- (list(node) where (round(node(each).location.x) > 32); // var3 equals [node2, node3]\nSee also: first_with, last_with,\n\nwith_height​\nPossible uses:​\n\nimage with_height int --->  image\nwith_height (image , int) --->  image\n\nResult:​\nApplies a proportional scaling to the image passed in parameter to return a new scaled image with the corresponding height. A height of 0 will return nil, a height equal to the height of the image will return the original image. Automatic scaling and resizing methods are used. The original image is left untouched\n\nwith_k_shortest_path_algorithm​\nPossible uses:​\n\ngraph with_k_shortest_path_algorithm string --->  graph\nwith_k_shortest_path_algorithm (graph , string) --->  graph\n\nResult:​\nchanges the K shortest paths computation algorithm of the given graph\nComment:​\nthe right-hand operand can be #Yen and #Bhandari to use the associated algorithm.\nExamples:​\nthe_graph <- the_graph with_k_shortest_path_algorithm #Yen;\n\nwith_max_of​\nPossible uses:​\n\ncontainer with_max_of any expression --->  unknown\nwith_max_of (container , any expression) --->  unknown\n\nResult:​\none of elements of the left-hand operand that maximizes the value of the right-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-hand operand is nil, with_max_of returns the default value of the right-hand operand\n\nExamples:​\nunknown var0 <- [1,2,3,4,5,6,7,8] with_max_of (each ); // var0 equals 8 unknown var2 <- g2 with_max_of (length(g2 out_edges_of each)  ) ; // var2 equals node4 unknown var3 <- (list(node) with_max_of (round(node(each).location.x)); // var3 equals node3 unknown var4 <- [1::2, 3::4, 5::6] with_max_of (each); // var4 equals 6\nSee also: where, with_min_of,\n\nwith_min_of​\nPossible uses:​\n\ncontainer with_min_of any expression --->  unknown\nwith_min_of (container , any expression) --->  unknown\n\nResult:​\none of elements of the left-hand operand that minimizes the value of the right-hand operand\nComment:​\nin the right-hand operand, the keyword each can be used to represent, in turn, each of the right-hand operand elements.\nSpecial cases:​\n\nif the left-hand operand is nil, with_max_of returns the default value of the right-hand operand\n\nExamples:​\nunknown var0 <- [1,2,3,4,5,6,7,8] with_min_of (each ); // var0 equals 1 unknown var2 <- g2 with_min_of (length(g2 out_edges_of each)  ); // var2 equals node11 unknown var3 <- (list(node) with_min_of (round(node(each).location.x)); // var3 equals node0 unknown var4 <- [1::2, 3::4, 5::6] with_min_of (each); // var4 equals 2\nSee also: where, with_max_of,\n\nwith_precision​\nPossible uses:​\n\nfloat with_precision int --->  float\nwith_precision (float , int) --->  float\ngeometry with_precision int --->  geometry\nwith_precision (geometry , int) --->  geometry\npoint with_precision int --->  point\nwith_precision (point , int) --->  point\n\nResult:​\nRounds off the value of left-hand operand to the precision given by the value of right-hand operand\nA geometry corresponding to the rounding of points of the operand considering a given precison.\nRounds off the ordinates of the left-hand point to the precision given by the value of right-hand operand\nExamples:​\nfloat var0 <- 12345.78943 with_precision 2; // var0 equals 12345.79 float var1 <- 123 with_precision 2; // var1 equals 123.00 geometry var2 <- self with_precision 2; // var2 equals the geometry resulting from the rounding of points of the geometry with a precision of 0.1. point var3 <- {12345.78943, 12345.78943, 12345.78943} with_precision 2 ; // var3 equals {12345.79, 12345.79, 12345.79}\nSee also: round,\n\nwith_shortest_path_algorithm​\nPossible uses:​\n\ngraph with_shortest_path_algorithm string --->  graph\nwith_shortest_path_algorithm (graph , string) --->  graph\n\nResult:​\nchanges the shortest path computation algorithm of the given graph\nComment:​\nthe right-hand operand can be #Djikstra, #BidirectionalDijkstra, #BellmannFord, #FloydWarshall, #Astar, #NBAStar, #NBAStarApprox, #DeltaStepping, #CHBidirectionalDijkstra, #TransitNodeRouting to use the associated algorithm.\nExamples:​\nroad_network <- road_network with_shortestpath_algorithm #TransitNodeRouting;\n\nwith_size​\nPossible uses:​\n\nfont with_size int --->  font\nwith_size (font , int) --->  font\n\nResult:​\nCreates a new font from an existing font, with a new size in points\nExamples:​\nfont var0 <- font ('Helvetica Neue',12, #bold + #italic) with_size 24; // var0 equals a bold and italic face of the Helvetica Neue family with a size of 24 points\n\nwith_size​\nPossible uses:​\n\nwith_size (image, int, int) --->  image\n\nResult:​\nApplies a non-proportional scaling to the image passed in parameter to return a new scaled image with the corresponding width and height. A height of 0 or a width of 0 will return nil. If the width and height parameters are repectively equal to the width and height of the original image, it is returned. Automatic scaling and resizing methods are used. The original image is left untouched\n\nwith_style​\nPossible uses:​\n\nfont with_style int --->  font\nwith_style (font , int) --->  font\n\nResult:​\nCreates a new font from an existing font, with a new style: either #bold, #italic or #plain or a combination (addition) of them.\nExamples:​\nfont var0 <- font ('Helvetica Neue',12, #bold + #italic) with_style #plain; // var0 equals a plain face of the Helvetica Neue family with a size of 12 points\n\nwith_values​\nPossible uses:​\n\npredicate with_values map --->  predicate\nwith_values (predicate , map) --->  predicate\n\nResult:​\nchange the parameters of the given predicate\nExamples:​\npredicate with_values [\"time\"::10]\n\nwith_weights​\nPossible uses:​\n\ngraph with_weights map --->  graph\nwith_weights (graph , map) --->  graph\ngraph with_weights list --->  graph\nwith_weights (graph , list) --->  graph\n\nResult:​\nreturns the graph (left-hand operand) with weight given in the map (right-hand operand).\nComment:​\nWARNING / side effect: this operator modifies the operand and does not create a new graph. It also re-initializes the path finder\nSpecial cases:​\n\nif the right-hand operand is a list, assigns the n elements of the list to the n first edges. Note that the ordering of edges may change overtime, which can create some problems...\nif the left-hand operand is a map, the map should contains pairs such as: vertex/edge::double\n\ngraph_from_edges (list(ant) as_map each::one_of (list(ant))) with_weights (list(ant) as_map each::each.food)\n\nwith_width​\nPossible uses:​\n\nimage with_width int --->  image\nwith_width (image , int) --->  image\n\nResult:​\nApplies a proportional scaling to the image passed in parameter to  return a new scaled image with the corresponding width. A width of 0 will return nil, a width equal to the width of the image will return the original image. Automatic scaling and resizing methods are used. The original image is left untouched\n\nwithout_holes​\nPossible uses:​\n\nwithout_holes (geometry) --->  geometry\n\nResult:​\nA geometry corresponding to the operand geometry (geometry, agent, point) without its holes\nExamples:​\ngeometry var0 <- solid(self); // var0 equals the geometry corresponding to the geometry of the agent applying the operator without its holes. float var1 <- without_holes(polygon([{0,50}, {0,0}, {50,0}, {50,50}, {0,50}]) - square(10) at_location {10,10}).area; // var1 equals 2500.0\n\nwizard​\nPossible uses:​\n\nstring wizard list<map<string,unknown>> --->  map<string,map<string,unknown>>\nwizard (string , list<map<string,unknown>>) --->  map<string,map<string,unknown>>\nwizard (string, action, list<map<string,unknown>>) --->  map<string,map<string,unknown>>\n\nResult:​\nBuild a wizard and return the values enter by the user as a map of map [\"title page 1\"::[\"var1\"::1,\"var2\"::2]]. Takes a string, an action and a list of calls to the wizard_page() operator. The first string is used to specify the title. The action to describe when the wizard is supposed to be finished. A classic way of defining the action is bool eval_finish(map<string,map> input_map) {return input_map[\"page1\"][\"file\"] != nil;}. The list is to specify the wizard pages.\nBuild a wizard and return the values enter by the user as a map of map [\"title page 1\"::[\"var1\"::1,\"var2\"::2]]. Takes a string, a list of calls to the wizard_page() operator. The first string is used to specify the title. The list is to specify the wizard pages.\nExamples:​\nmap results <-  wizard(\"My wizard\",eval_finish, [wizard_page(\"page1\",\"enter info\" ,[enter(\"var1\",string)], font(\"Arial\", 10))]); map results <-  wizard(\"My wizard\",[wizard_page(\"page1\",\"enter info\" ,[enter(\"var1\",string)], font(\"Arial\", 10))]);\n\nwizard_page​\nPossible uses:​\n\nwizard_page (string, string, list) --->  map<string,unknown>\nwizard_page (string, string, list, font) --->  map<string,unknown>\n\nResult:​\nBuild a wizard page. Takes two strings and a list of calls to the enter() or choose() operators. The first string is used to specify the title, the second the description of the dialog box. The list is to specify the parameters the user can enter\nBuild a wizard page. Takes two strings, a list of calls to the enter() or choose() operators and a font as arguments. The first string is used to specify the title, the second the description of the dialog box. The list is to specify the parameters the user can enter. The font is used to specify the font\nExamples:​\nmap results <-  wizard(\"My wizard\",[wizard_page(\"page1\",\"enter info\" ,[enter(\"var1\",string)])]); map results <-  wizard(\"My wizard\",[wizard_page(\"page1\",\"enter info\" ,[enter(\"var1\",string)], font(\"Arial\", 10))]);\n\nwritable​\nPossible uses:​\n\nfile writable bool --->  file\nwritable (file , bool) --->  file\n\nResult:​\nMarks the file as read-only or not, depending on the second boolean argument, and returns the first argument\nComment:​\nA file is created using its native flags. This operator can change them. Beware that this change is system-wide (and not only restrained to GAMA): changing a file to read-only mode (e.g. \"writable(f, false)\")\nExamples:​\nfile var0 <- shape_file(\"../images/point_eau.shp\") writable false; // var0 equals returns a file in read-only mode\nSee also: file,\n\nxml_file​\nPossible uses:​\n\nxml_file (string) --->  file\n\nResult:​\nConstructs a file of type xml. Allowed extensions are limited to xml\nSpecial cases:​\n\nxml_file(string): This file constructor allows to read a xml file\n\nfile f <-xml_file(\"file.xml\");\nSee also: is_xml,\n\nxor​\nPossible uses:​\n\nbool xor bool --->  bool\nxor (bool , bool) --->  bool\n\nResult:​\na bool value, equal to the logical xor between the left-hand operand and the right-hand operand. False when they are equal\nComment:​\nboth operands are always casted to bool before applying the operator. Thus, an expression like 1 xor 0 is accepted and returns true.\nExamples:​\nbool var0 <- xor(true,false); // var0 equals true bool var1 <- xor(false,false); // var1 equals false bool var2 <- xor(false,true); // var2 equals true bool var3 <- xor(true,true); // var3 equals false bool var4 <- true xor true; // var4 equals false\nSee also: or, and, !,\n\nyears_between​\nPossible uses:​\n\ndate years_between date --->  int\nyears_between (date , date) --->  int\n\nResult:​\nProvide the exact number of years between two dates. This number can be positive or negative (if the second operand is smaller than the first one)\nExamples:​\nint var0 <- years_between(date('2000-01-01'), date('2010-01-01')); // var0 equals 10\n\nzip​\nPossible uses:​\n\nlist<string> zip string --->  bool\nzip (list<string> , string) --->  bool\n\nResult:​\nZip a given list of files or folders. Returns true if the files are well zipped\nExamples:​\nbool zip_ok <- zip([\"../includes/my_folder\"], \"folder.zip\";"},{"filePath":"https:--gama-platform.org--wiki-OptimizingModels.txt","text":"Optimizing ModelsThis page aims at presenting some tips to optimize the memory footprint or the execution time of a model in GAMA.\nNote:  since GAMA 1.6.1, some optimizations have become obsolete because they have been included in the compiler. They have, then, been removed from this page. For instance, writing 'rgb(0,0,0)' is now compiled directly as '#black'.\nTable of contents​\n\nBenchmarking\nScheduling\nGrid\n\nOptimization Facets\n\nuse_regular_agents\nuse_individual_shapes\n\n\n\n\nOperators\n\nList operators\n\nfirst_with\nwhere / count\n\n\nSpatial operators\n\ncontainer of agents in closest_to, at_distance, overlapping, inside\nAccelerate  with a first spatial filtering\n\n\n\n\nDisplays\n\nshape\ncircle vs square / sphere vs cube\nOpenGL refresh facets\n\n\n\nBenchmarking​\nIn order to optimize a model, it is important to exactly know which part of the model take times. It is thus possible to benchmark the global execution of the model using the benchmark facet of the experiment statement: it will produce a global report on the number of times any keyword has been used and how long has been spent to execute them.\nexperiment Benchmarking type: gui benchmark: true { }\nbenchmark is also a statement that can be used on a block of codes to evaluate its execution. In addition, it provides the possibility to run the block of code several times to get more accurate results.\nglobal {    init {\tcreate people number: 300;    }\t    reflex neighboorhood {\tbenchmark \"Benchmark of closest_to operator\" repeat: 100 {\t    ask people {\t\tdo get_closest_people;\t    }\t}    }}\nFinally the manual way to evaluate the execution of a code could be using the machine_time built-in global variable that gives the current time in milliseconds. Then to compute the time taken by a statement, a possible way is to write:\nfloat t <- machine_time;// here a block of instructions that you consider as \"critical\"// ...write \"duration of the last instructions: \" + (machine_time - t);\nScheduling​\nIf you have a species of agents that, once created, are not supposed to do anything more (i.e. no behavior, no reflex, their actions triggered by other agents, their attributes being simply read and written by other agents), such as a \"data\" grid, or agents representing a \"background\" (from a shape file, etc.), consider using the schedules: [] facet on the definition of their species. This trick allows to tell GAMA to not schedule any of these agents.\ngrid my_grid height: 100 width: 100 schedules: []  {      ...}\nThe schedules facet is dynamically computed (even if the agents are not scheduled), so, if you happen to define agents that only need to be scheduled every x cycles, or depending on a condition, you can also write schedules to implement this. For instance, the following species will see its instances scheduled every 10 steps and only if a certain condition is met:\nspecies my_species schedules: (every 10) ? (condition ? my_species : []) : []  {     ...}\nIn the same way, modelers can use the frequency facet to define when the agents of a species are going to be activated. By setting this facet to 0, the agents are never activated.\nspecies my_species frequency: 0 {     ...}\nGrid​\nOptimization Facets​\nIn this section, we present some facets that allow to optimize the use of grid (in particular in terms of memories). Note that all these facet can be combined (see the Life model from the Models library).\nuse_regular_agents​\nIf false, then a special class of agents is used. This special class of agents used less memories but has some limitation: the agents cannot inherit from a \"normal\" species, they cannot have sub-populations, their name cannot be modified, etc.\ngrid cell width: 50 height: 50 use_regular_agents: false ;\nuse_individual_shapes​\nIf false, then only one geometry is used for all agents. This facet allows to gain a lot of memory, but should not be used if the geometries of the agents are often activated (for instance, by an aspect).\ngrid cell width: 50 height: 50 use_individual_shapes: false ;\t\nParallel execution​\nThe grid statement can also specify whether the agents of the grid are computed in parallel, using the facet parallel. This could increase (depending on the computation) the execution time.\nOperators​\nList operators​\nfirst_with​\nIt is sometimes necessary to randomly select an element of a list that verifies a given condition.\nMany modelers use the one_of and the where operators to do this:\nbug one_big_bug <- one_of (bug where (each.size > 10));\nWhereas it is often more optimized to use the shuffle operator to shuffle the list, then the first_with operator to select the first element that verifies the condition:\nbug one_big_bug <- shuffle(bug) first_with (each.size > 10);\nwhere / count​\nIt is quite common to want to count the number of elements of a list or a container that verify a condition.\nThe obvious to do it is:\nint n <- length(my_container where (each.size > 10));\nThis will however create an intermediary list before counting it, and this operation can be time consuming if the number of elements is important. To alleviate this problem, GAMA includes an operator called count that will count the elements that verify the condition by iterating directly on the container (no useless list created):\nint n <- my_container count (each.size > 10);\nSpatial operators​\ncontainer of agents in closest_to, at_distance, overlapping, inside​\nSeveral spatial query operators (such as closest_to, at_distance, overlapping or inside) allow to restrict the agents being queried to a container of agents. For instance, one can write:\nagent closest_agent <- a_container_containing_agents closest_to self;\nThis expression is formally equivalent to :\nagent closest_agent <- a_container_containing_agent with_min_of (each distance_to self);\nBut it is much faster if your container is large, as it will query the agents using a spatial index (instead of browsing through the whole container). Note that in some cases, when you have a small number of agents, the first syntax will be faster. The same applies to the other operators.\nNow consider a very common case: you need to restrict the agents being queried, not to a container, but to a species (which, actually, acts as a container in most cases). For instance, you want to know which predator is the closest to the current agent. If we apply the pattern above, we would write:\npredator closest_predator <- predator with_min_of (each distance_to self);\nor\npredator closest_predator <- list(predator) closest_to self;\nBut these two operators can be painfully slow if your species has many instances (even in the second form). In that case, always prefer using directly the species as the left member:\npredator closest_ predator <- predator closest_to self;\nNot only is the syntax clearer, but the speed gain can be phenomenal because, in that case, the list of instances is not used (we just check if the agent is an instance of the left species).\nHowever, what happens if one wants to query instances belonging to 2 or more species? If we follow our reasoning, the immediate way to write it would be (if predator 1 and predator 2 are two species):\nagent closest_agent <- (list(predator1) + list(predator2)) closest_to self; \nor, more simply:\nagent closest_agent <- (predator1 + predator2) closest_to self;\nThe first syntax suffers from the same problem than the previous syntax: GAMA has to browse through the list (created by the concatenation of the species populations) to filter agents. The solution, then, is again to use directly the species, as GAMA is clever enough to create a temporary \"fake\" population out of the concatenation of several species, which can be used exactly like a list of agents, but provides the advantages of a species population (no iteration made during filtering).\nAccelerate closest_to with a first spatial filtering​\nThe closest_to operator can sometimes be slow if numerous agents are concerned by this query. If the modeler is just interested in a small subset of agents, it is possible to apply a first spatial filtering on the agent list by using the at_distance operator.\nFor example, if the modeler wants first to do a spatial filtering of 10m:\nagent closest_agent <- (predator1 at_distance 10) closest_to self;\nTo be sure to find an agent, the modeler can use a test statement:\nagent closest_agent <- (predator1 at_distance 10) closest_to self;if (closest_agent = nil) {closest_agent  <- predator1 closest_to self;}\nDisplays​\nshape​\nIt is quite common to want to display an agent as a circle or a square. A common mistake is to mix up the shape to draw and the geometry of the agent in the model. If the modeler just wants to display a particular shape, he/she should not modify the agent geometry (i.e. its shape attribute, which is a point by default), but just specify the shape to draw in the agent aspect.\nspecies bug {     int size <- rnd(100);\t      aspect circle {          draw circle(2) color: #blue;      }}\ncircle vs square / sphere vs cube​\nNote that in OpenGL and Java2D (the two rendering subsystems used in GAMA), creating and drawing a circle geometry is more time consuming than creating and drawing a square (or a rectangle). In the same way, drawing a sphere is more time consuming than drawing a cube. Hence, if you want to optimize your model displays and if the rendering does not explicitly need \"rounded\" agents, try to use squares/cubes rather than circles/spheres.\nOpenGL refresh facets​\nIn OpenGL display, it is possible to specify that it is not necessary to refresh a layer with the facet refresh. If a species of agents is never modified in terms of visualization (location, shape or color), you can set refresh to false. Example:\ndisplay city_display_opengl type: opengl{     species building aspect: base refresh: false;     species road aspect: base refresh: false;     species people aspect: base;}"},{"filePath":"https:--gama-platform.org--wiki-OptimizingModelsSection.txt","text":"Optimizing ModelsNow you are becoming more comfortable with GAML, it is time to think about how the runtime works, to be able to run some more optimized models. Indeed, if you already tried to write some models by yourself using GAML, you could have noticed that the execution time depends a lot of how you implemented your model!\nWe will first present you in this part some runtime concepts (and present you the species facet scheduler), and we will then show you some tips to optimize your models (how to increase performances using scheduler, grids, displays and how to choose your operators)."},{"filePath":"https:--gama-platform.org--wiki-ParametersView.txt","text":"Parameters ViewIn the case of an experiment, the modeler can define the parameters s/he wants to be able to modify to explore the simulation, and thus the ones he wants to be able to display and alter in the GUI interface.\nIt important to notice that all modifications made in the parameters will be taken into account in case of simulation reload only. Launch of a new experiment from the model perspective will erase the modifications.\nTable of contents​\n\nParameters View\n\nParameters View\nModification of parameters values\n\n\n\nParameters View​\nThe modeler can define parameters that can be displayed in the GUI and that are sorted by categories. Note that the interface will depend on the data type of the parameter: e.g. for string parameters, a simple text box will be displayed whereas a color selector will be available for color parameters. It can also depend on the way the parameter is defined: an integer or a float parameter will be displayed with a slider if its min and max values are defined, and a simple text field otherwise. The parameter's value displayed is the initial value provided to the variables associated with the parameters in the model.\n\nThe above parameters view is generated from the following code:\nglobal{\tint i;\tfloat f;\tstring s;\tlist l;\tmatrix m;\tpair p;\trgb c;}experiment maths type: gui {    parameter \"my_integer\" var: i <- 0 category:\"Simple types\";    parameter \"my_float\" var: f <- 0.0 category:\"Simple types\";    parameter \"my_string\" var: s <- \"\" category:\"Simple types\";    parameter \"my_list\" var: l <- [] category:\"Complex types\";    parameter \"my_matrix\" var: m <- matrix([[1,2],[3,4]]) category:\"Complex types\";    parameter \"my_pair\" var: p <- 3::5 category:\"Complex types\";    parameter \"my_color\" var: c <- #green category:\"Complex types\";    output {}}\nClick on Edit button in case of list or map parameters or the color or matrix will open an additional window to modify the parameter value.\nThe model Library models > Visualization and User Interaction > GUI Design > Interactive Elements.gaml exemplifies all the possible way of displaying parameters (and other interactive elements). Even interactive elements (buttons or parameters will a behavior associated with a value change) can be added to the Parameter View.\n\nModification of parameters values​\nThe modeler can modify the parameter values. After modifying the parameter values, you can reload the simulation by clicking on the top-right circular arrow button.\nIt is important to understand that modification of a parameter value is immediately taken into account in the simulation: the value of the variable in the model is modified. BUT the effect on the simulation will depend on the use of this variable in the model:\n\nif the variable is used at initialization of the simulation (e.g. it contains the number of agents to be created), then a change of its value will not be visible in the simulation running as it is not used,\nif the variable is used during the simulation (e.g. the pheromones evaporation rate in ants models), a change in the parameter view will have an impact on the simulation behavior.\n\nYou can also add a new simulation to the old one, using those new parameters, by clicking on the top-right plus symbol button.\nIf he wants to come back to the initial value of parameters, he can click on the top-right red curved arrow of the parameters view.\n"},{"filePath":"https:--gama-platform.org--wiki-PlatformDocumentation.txt","text":"PlatformGAMA consists of a single application that is based on the RCP architecture provided by Eclipse. Within this single application software, often referred to as a platform, users can undertake, without the need of additional third-parties softwares, most of the activities related to modeling and simulation, namely editing models and simulating, visualizing and exploring them using dedicated tools.\nFirst-time users may however be intimidated by the apparent complexity of the platform, so this part of the documentation has been designed to ease their first contact with it, by clearly identifying tasks of interest to modelers and how they can be accomplished within GAMA.\nIt is accomplished by firstly providing some background about important notions found throughout the platform, especially those of workspace and projects and explaining how to organize and navigate through models. Then we take a look at the edition of models and its various tools and components (dedicated editors and related tools, of course, but also validators). Finally, we show how to run experiments on these models and what support the user interface can provide to users in this task."},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey.txt","text":"Predator PreyThis tutorial presents the structure of a GAMA model as well as the use of a grid topology. In particular, this tutorial shows how to define a basic model, to define \"grid agents\" which are able to move within the constraints. It also introduces the displays and agents' aspect.\nAll the files related to this tutorial (images and models) are available in the Models Library (project Tutorials/Predator Prey).\nContent​\nModel Overview​\nIn this model, three types of entities are considered: preys, predators and vegetation cells. Preys\neat grass on the vegetation cells and predators eat preys. At each simulation step, grass grows on the vegetation cells. Concerning the predators and preys, at each simulation step, they move (to a neighbor cell), eat, die if they do not have enough energy, and eventually reproduce.\n\nStep List​\nThis tutorial is composed of 13 steps corresponding to 13 models which are incremental representation of the same model, starting with the simplest model 1 and finishing with the latest one, model 13. For each step, we will present its purpose, an explicit formulation and the corresponding GAML code of the model.\n\nBasic model (prey agents)\nDynamic of the vegetation (grid)\nBehavior of the prey agent\nUse of Inspectors/monitors\nPredator agents (parent species)\nBreeding of prey and predator agents\nAgent display (aspect)\nComplex behaviors for the preys and predators\nAdding of a stopping condition\nDefinition of charts\nWriting files\nImage loading (raster data)\nExploration of the model\n"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step1.txt","text":"1. Basic ModelContent​\nThis first step Illustrates how to write a model in GAMA. In particular, it describes how to structure a model and how to define species - that are the key components of GAMA models.\nFormulation​\n\nDefinition of the prey species\nDefinition of a nb_preys_init parameter\nCreation of nb_preys_init prey agents randomly located in the environment (size: 100x100)\n\nModel Definition​\nModel structure​\nA GAMA model is composed of three types of sections:\n\nglobal: this section, that is unique, defines the \"world\" agent, a special agent of a GAMA model. It represents all that is global to the model: dynamics, variables, actions. In addition, it allows to initialize the simulation (init block).\nspecies and grid: these sections define the species of agents composing the model. Grid is defined in the following model step \"vegetation dynamic\";\nexperiment: these sections define the execution context of the simulations. In particular, it defines the input (parameters) and output (displays, files...) of a model.\n\nMore details about the different sections of a GAMA model can be found here.\nSpecies​\nA species represents a \"prototype\" of agents: it defines their common properties.\nA species definition requires the definition of three different elements:\n\nthe internal state of its agents (attributes)\ntheir behavior\nhow they are displayed (aspects)\n\nInternal state​\nAn attribute is defined as follows: the type of the attribute and name. Numerous types of attributes are available: int (integer), float (floating-point number), string, bool (boolean, true or false), point (coordinates), list, pair, map, file, matrix, species of agents, rgb (color), graph, path...\n\nOptional facets: <- (initial value), update (value recomputed at each step of the simulation), function:{..} (value computed each time the variable is used), min, max\n\nIn addition to the attributes the modeler explicitly defines, species \"inherits\" other attributes called \"built-in\" variables:\n\nA name (name): the identifier of the species.\nA shape (shape): the default shape of the agents to be constructed after the species. It can be a point, a polygon, etc..\nA location (location): the centroid of its shape.\n\nBehavior​\nIn this first model, we define one species of agents: the prey species. For the moment, the agents of this species will not have any particular behavior, they will just exist and be displayed.\nDisplay​\nAn agent aspects have to be defined. An aspect is a way to display the agents of a species: aspect aspect_name {...}.\nIn the block of an aspect, it is possible to draw:\n\nA geometry: for instance, the shape of the agent (but it may be a different one, for instance, a disk instead of a complex polygon)\nAn image: to draw icons\nA text: to draw a text\n\nIn order to display our prey agents we define two attributes:\n\nsize of type float, with for initial value:1.0\ncolor of type rgb, with for initial value: #blue. It is possible to get a color value by using the symbol # + color name: e.g. #blue, #red, #white, #yellow, #magenta, #pink...\n\nPrey species code​\nFor the moment, we only define an aspect for this species. We want to display for each prey agent a circle of radius size and color color. We then use the statement draw with a circle shape.\nspecies prey {    float size <- 1.0 ;    rgb color <- #blue;\t\t    aspect base {\tdraw circle(size) color: color ;    }} \nglobal section​\nThe global section represents a specific agent, called world. Defining this agent follows the same principle as any agent and is, thus, defined after a species.\nThe world agent represents everything that is global to the model: dynamics, variables...\nIt allows to initialize simulations (init block): the world is always created and initialized first when a simulation is launched (before any other agents). The geometry (shape) of the world agent is by default a square with 100m for side size, but can be redefined if necessary (see the Road traffic tutorial).\nglobal attributes​\nIn the current model, we will only have a certain number of preys thus we need to hold this number in a global or world's variable of type integer (int) which can be done as follows:\nglobal {    int nb_preys_init <- 200;}\nModel initialization​\nThe init section of the global block allows initializing the model which is executing certain commands, here we will create nb_preys_init number of prey agents. We use the statement create  to create agents of a specific species: create species_name + :\n\nnumber: number of agents to create (int, 1 by default)\nfrom: GIS file to use to create the agents (optional, string or file)\nreturns: list of created agents (list)\n\nDefinition of the init block in order to create nb_preys_init prey agents:\ninit {    create prey number: nb_preys_init ;}\nexperiment​\nAn experiment block defines how a model can be simulated (executed). Several experiments can be defined for a given model. They are defined using : experiment exp_name type: gui/batch { [input] [output]}\n\ngui: experiment with a graphical interface, which displays its input parameters and outputs.\nbatch: Allows to set up a series of simulations (w/o graphical interface).\n\nIn our model, we define a gui experiment called prey_predator :\nexperiment prey_predator type: gui {}\ninput​\nExperiments can define (input) parameters. A parameter definition allows to make the value of a global variable definable by the user through the graphic interface.\nA parameter is defined as follows:\nparameter title var: global_var category: cat;\n\ntitle: string to display\nvar: reference to a global variable (defined in the global section)\ncategory: string used to «store» the operators on the UI - optional\n<-: init value - optional\nmin: min value - optional\nmax: min value - optional\n\nNote that the init, min and max values can be defined in the global variable definition.\nIn the experiment, the definition of a parameter from the global variable nb_preys_init:\nexperiment prey_predator type: gui {    parameter \"Initial number of preys: \" var: nb_preys_init min: 1 max: 1000 category: \"Prey\" ;}\noutput​\nOutput blocks are defined in an experiment and define how to visualize a simulation (with one or more display blocks that define separate windows). Each display can be refreshed independently by defining the facet refresh nb (int) (the display will be refreshed every nb steps of the simulation).\nEach display can include different layers (like in a GIS):\n\nAgents species: species my_species aspect: my_aspect;\nAgents lists: agents layer_name value: agents_list aspect: my_aspect;\nImages: image image_file;\nCharts: see later.\n\nNote that it is possible to define a opengl display (for 3D display) by using the facet type: opengl.\nIn our model, we define a display to draw the prey agents.\noutput {    display main_display {        species prey aspect: base ;    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2001.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step10.txt","text":"10. ChartsThis 10th step illustrates how to define charts.\nFormulation​\n\nAddition of a new display to visualize:\n\nOne chart representing the evolution of the quantity of prey and predator agents over time.\nTwo histograms representing the energy distribution of the prey and predator agents.\n\n\n\nModel Definition​\noutput​\nGAMA can display various chart types:\n\nTime series\nPie charts\nHistograms\n\nA chart must be defined in a display: it behaves exactly like any other layer.\nDefinition of a chart:\nchart chart_name type: chart_type {    [data]}\nThe data to draw are defined inside the chart block as follow, using the data statement:\ndata data_legend value: data_value\nWe add a new display called Population_information that refreshes every 5 simulation steps.\nInside this display, we define 3 charts: one of type series (i.e. time series chart), two of type histogram:\n\n\n\"Species evolution\"; background: white; size: {1, 0.5}; position: {0, 0}\n\ndata1: nb_preys; color : blue\ndata2: nb_predators; color : red\n\n\n\n\"Prey Energy Distribution\"; background: lightGray; size: {0.5, 0.5}; position: {0, 0.5}\n\ndata \"]0;0.25]\": number of preys with (each.energy <= 0.25) ;\ndata \"]0.25;0.5]\": number of preys with ((each.energy > 0.25) and (each.energy <= 0.5)) ;\ndata \"]0.5;0.75]\": number of preys with ((each.energy > 0.5) and (each.energy <= 0.75)) ;\ndata \"]0.75;1]\": number of preys with  (each.energy > 0.75) ;\n\n\n\n\"Predator Energy Distribution\"; background: lightGray; size: {0.5, 0.5}; position: {0.5, 0.5}\n\ndata \"]0;0.25]\": number of predators with (each.energy <= 0.25) ;\ndata \"]0.25;0.5]\": number of predators with ((each.energy > 0.25) and (each.energy <= 0.5)) ;\ndata \"]0.5;0.75]\": number of predators with ((each.energy > 0.5) and (each.energy <= 0.75)) ;\ndata \"]0.75;1]\": number of predators with  (each.energy > 0.75) ;\n\n\n\nTo evaluate the value of the data of the two histogram, we use the operator list count condition that returns the number of elements of list for which the condition is true.\ndisplay Population_information refresh:every(5#cycles) {    chart \"Species evolution\" type: series size: {1,0.5} position: {0, 0} {\tdata \"number_of_preys\" value: nb_preys color: #blue ;\tdata \"number_of_predator\" value: nb_predators color: #red ;    }    chart \"Prey Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0, 0.5} {\tdata \"]0;0.25]\" value: prey count (each.energy <= 0.25) color:#blue;\tdata \"]0.25;0.5]\" value: prey count ((each.energy > 0.25) and (each.energy <= 0.5)) color:#blue;\tdata \"]0.5;0.75]\" value: prey count ((each.energy > 0.5) and (each.energy <= 0.75)) color:#blue;\tdata \"]0.75;1]\" value: prey count (each.energy > 0.75) color:#blue;    }    chart \"Predator Energy Distribution\" type: histogram background: #lightgray size: {0.5,0.5} position: {0.5, 0.5} {\tdata \"]0;0.25]\" value: predator count (each.energy <= 0.25) color: #red ;\tdata \"]0.25;0.5]\" value: predator count ((each.energy > 0.25) and (each.energy <= 0.5)) color: #red ;\tdata \"]0.5;0.75]\" value: predator count ((each.energy > 0.5) and (each.energy <= 0.75)) color: #red ;\tdata \"]0.75;1]\" value: predator count (each.energy > 0.75) color: #red;    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2010.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step11.txt","text":"11. Writing FilesThis 11th step illustrates how to save data in a text file.\nFormulation​\n\nAt each simulation step, write in a text file:\n\nThe time step\nThe number of prey and predator agents\nThe min and max energy of the prey and predator agents\n\n\n\nModel Definition​\nglobal section​\nThe main way to write data inside a file is to use the save statement:\nsave my_data type: file_type to: file_name;\nWith:\n\nmy_data: depends on the data to save and of the type of file\nfile_type : string\nfile_name : string\n\nThere are 3 main possible types:\n\nshp (shapefile - GIS data): in that case, my_data is treated as a list of agents or geometries: all their geometries are saved in the file (with some variables as attributes),\ntxt (text): in that case, my_data is treated as a string, which is written directly in the file,\ncsv: in that case, my_data is treated as a list of values: [val1, val2, val3], that will be written in the file, separated by the , separator.\n\nWe use this statement (in a global reflex called save_result) to write:\n\nThe cycle step: use of the cycle keyword that returns the current simulation step.\nThe number of prey and predator agents: use of nb_preys and nb_predators variables.\nThe min and max energy of the prey and predator agents: use of list min_of expression and list max_of expression keywords.\n\nreflex save_result when: (nb_preys > 0) and (nb_predators > 0){    save (\"cycle: \"+ cycle + \"; nbPreys: \" + nb_preys\t  + \"; minEnergyPreys: \" + (prey min_of each.energy)\t  + \"; maxSizePreys: \" + (prey max_of each.energy) \t  + \"; nbPredators: \" + nb_predators           \t  + \"; minEnergyPredators: \" + (predator min_of each.energy)          \t  + \"; maxSizePredators: \" + (predator max_of each.energy)) \t  to: \"results.txt\" type: \"text\" rewrite: (cycle = 0) ? true : false;}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2011.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step12.txt","text":"12. Image loadingThis 12th step illustrates how to load an image file and to use it to initialize a grid.\nFormulation​\n\nBuilding of the initial environment (food and food_prod of the cells) from an image file.\n\nModel Definition​\nglobal variable​\nWe add a new global variable to store the image data:\nfile map_init <- image_file(\"../includes/data/raster_map.png\");\nThe image file is here: \nYou have to copy it in your project folder: includes/data/.\nModel initialization​\nIn order to have a more complex environment, we want to use this image as the initialization of the environment. The food level available in a vegetation_cell will be based on the green level of the corresponding pixel in the image. You will be able to use such a process to represent an existing real environment in your model.\nWe modify the global init of the model in order to cast the image file in a matrix.\nFirst of all, when the variable map_init is defined from an image file (or a csv file), it can be manipulated directly as a matrix, with the dimensions of the image (here it is a 50x50 image, which matches with the grid size). In the case we need to resize the image, we can use the file as_matrix  {nb_cols, nb_lines} operator that allows converting a file (image, csv) to a matrix composed of nb_cols columns and nb_lines lines.\nConcerning the manipulation of a matrix, it is possible to obtain the element [i,j] of a matrix by using my_matrix [i,j].\nA grid can be view as a spatial matrix: each cell of a grid has two built-in variables grid_x and grid_y that represent the column and line indexes of the cell.\ninit {    create prey number: nb_preys_init ;    create predator number: nb_predators_init ;    ask vegetation_cell {\tcolor <- rgb (map_init at {grid_x,grid_y}) ;\tfood <- 1 - (((color as list) at 0) / 255) ;\tfood_prod <- food / 100 ;     }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2012.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step13.txt","text":"13. Model explorationThis 13th step illustrates how to explore the model using a batch experiment.\nFormulation​\n\nAddition of a new experiment of type batch.\nDefinition of the parameters to be explored.\nDefinition of the exploration method.\n\nModel Definition​\nThe model itself (the global and the various species) will be modified. We will simply add a new experiment to define a new way of launching the simulation.\nbatch experiment​\nWe will thus add a new experiment in the file. The specificity of this experiment will be its type: we will define a batch experiment, instead of a gui (as done until now). This experiment will not manage any display but will run several simulations to explore the parameter space (depending on the exploration method).\nexperiment Optimization type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {    ...}\nA batch experiment comes with more facets:\n\nrepeat: the number of simulations to launch for a single parameter configuration,\nkeep_seed: set whether the seed of the random number generator is the same for each first replication (the first simulation run for a given parameter configuration),\nuntil: define the simulation stop condition.\n\nParameters definition​\nWe now need to define the parameters to explore: similarly to gui experiment, parameters are taken among the global variables. In a batch experiment, it is necessary to define their value range (using the among facet or the min, max, and step ones).\nparameter \"Prey max transfer:\" var: prey_max_transfer min: 0.05 max: 0.5 step: 0.05 ;parameter \"Prey energy reproduce:\" var: prey_energy_reproduce min: 0.05 max: 0.75 step: 0.05;parameter \"Predator energy transfer:\" var: predator_energy_transfer min: 0.1 max: 1.0 step: 0.1 ;parameter \"Predator energy reproduce:\" var: predator_energy_reproduce min: 0.1 max: 1.0 step: 0.1;\nExploration method​\nFinally, the exploration method has to be specified (the default method is exhaustive exploration). GAMA provides several methods, detailed in this page.\nWe choose here the Tabu search method, defined by:\nmethod tabu maximize: nb_preys + nb_predators iter_max: 10 tabu_list_size: 3;\nSave exploration results​\nIn a previous step, we introduced the save of results at each step of a simulation. When exploring a model, it could be interesting to save results after each simulation.\nTo this purpose, we will use again the save statement but in a reflex of the experiment and not a reflex of the model. In a batch experiment, the reflexes are executed after all the replications for a single parameter configuration. The built-in simulations variable contains all the simulations; we can thus ask them the results we want to save. In addition, we save the parameter values to keep track.\nWe will use the save statement to save the results as a csv file (as it is easier to manipulate by analysis software, such as R). We can thus save a list of values:\nreflex save_results_explo {    ask simulations {\tsave [int(self),prey_max_transfer,prey_energy_reproduce,predator_energy_transfer,predator_energy_reproduce,self.nb_predators,self.nb_preys]           to: \"results.csv\" type: \"csv\" rewrite: (int(self) = 0) ? true : false header: true;    }\t\t}\nThis saved for each simulation its self.nb_predators and self.nb_preys. Note that self here is mandatory!\nDeal with the simulation stop​\nAn issue we will have with the model is that it already has a stop condition: it pauses when either the number of preys or the number of predators become zero. We will introduce a new global variable is_batch to specify whether the simulation is in batch mode or not. In batch mode, the reflex stop_simulation should not be executed.\nglobal {    ...    bool is_batch <- false;    ...    reflex stop_simulation when: ((nb_preys = 0) or (nb_predators = 0)) and !is_batch {\tdo pause ;    } }\nThis variable should thus now be initialized by default to false (so in the init block of the model) and in the batch experiment to true.\nexperiment Optimization type: batch repeat: 2 keep_seed: true until: ( time > 200 ) {    ...    parameter \"Batch mode:\" var: is_batch <- true;    ...}\nConclusion​\nCongratulations, you have completed your first GAMA models! Now, you have enough knowledge to create many models that includes: dynamic grid-based environment, moving and interacting agents and the needed visualization to make good use of your simulation. Feel free to use this knowledge to create your very own models! Or perhaps you want to continue your study with the more advanced tutorials?\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2013.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step2.txt","text":"2. Vegetation DynamicThis second step presents the idea of environment or topological space. Defining a \"vegetation\" environment allows to define the movement of the preys through dynamic variables (use of the update facet). We will also discover more about displays.\nFormulation​\n\nDefinition of a grid (for the vegetation)\nDefinition of a dynamic for each cell (food production)\nDisplay of the cell color according to the quantity of food\nLocalization of the prey agents on the cells (at its center)\n\nModel Definition​\ngrid​\nIn GAMA, grids are specific agent species with a particular topology. First, a grid allows yet constrains the movement of other (moving) agents but they can have variables and behaviors.\nA grid is defined as follows:\ngrid grid_name width: nb_cols height: nb_lines neighbors: 4/6/8 {    ...}\nWith:\n\nwidth: number of cells along the x-axis\nheight: number of cells along the y-axis\nneighbors: neighborhood type (4 - Von Neumann, 6 - hexagon or 8 - Moore)\n\nIn our model, we define a grid species, called vegetation_cell composed of 50x50 cells and with a Von Neumann neighborhood.\nIn order for each grid agents (or cell of the grid) to represent the vegetation, we provide them with four variables:\n\nmax_food: maximum food that a cell can contain -> type: float ; init value: 1.0.\nfood_prod: food produced at each simulation step -> type: float ; init value: random number between 0 and 0.01.\nfood: current quantity of food -> type: float ; init value: random number between 0 and 1.0; at each simulation step: food <- food + food_prod.\ncolor: color of the cell -> type: rgb ; init value: color computed according to the food value: more the food value is close to 1.0, greener the color is, more the food value is close to 0,  whiter the color is; update: computation of the new color depending on the current level of food (at each simulation step).\n\nThe update facet allows to give a behavior to the agents. Indeed, at each simulation step, each agent is activated (by default, in its creation order) and first applies for each dynamic variable (in their definition order) its update expression. In the present case, it allows us to link the displayed color of the cell to its food level.\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {    float max_food <- 1.0 ;    float food_prod <- rnd(0.01) ;    float food <- rnd(1.0) max: max_food update: food + food_prod;    rgb color <- rgb(int(255 * (1 - food)), 255, int(255 * (1 - food)))          update: rgb(int(255 * (1 - food)), 255, int(255 * (1 - food))) ;}\nThere are several ways to define colors in GAML:\n\nthe simplest way consists in using the symbol # + the color name (for a limited set of  colors): #blue, #red...\nAnother way consists in defining the 3 RGB integer values: rgb(red, green, blue) with red, green and blue between 0 and 255 (as we used in the current model): rgb(0,0,0)  for black, rgb(255,255,255) for white, rgb(255,0,0) for red, rgb(0,255,0) for green, or  rgb(0,0,255) for blue.\n\nprey agents​\nIn order to relate our prey agents to the vegetation cell grid, we add them with one new attribute: my_cell of type vegetation_cell and for init value one of the vegetation_cell (chosen randomly).\nspecies prey {    ...    vegetation_cell my_cell <- one_of (vegetation_cell) ;} \nIt is possible to obtain the list of all agents of a given species by using the name of the species while one_of to pick one element randomly from this list.\nWe linked each prey agent to a vegetation_cell but we need to locate them onto the cell. To do so, we set the prey location as equals to the location of the vegetation cell (i.e. its centroid), we use in the init block the <- statement that allows to modify the value of a variable:\nspecies prey {    ...    init {        location <- my_cell.location;    }}\ndisplay​\nIn order to visualize the vegetation, we need to add it to the display. We use for that the statement grid with the optional facet border to draw the border of the cells. Note that grid agents have built-in aspect thus it is not necessary to define one: it is a square with the color attribute as value.\n   output {       display main_display {           grid vegetation_cell border: #black;           species prey aspect: base ;       }   }\nNote that the layers in a display work like layers in a GIS; the drawing order will be respected. In our model, the prey agents will be drawn above the vegetation_cell grid thus they need to be declared afterward.\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2002.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step3.txt","text":"3. Prey Agent BehaviorThis third step illustrates how to define the behaviors of prey agents and the concept of spatial topology.\nFormulation​\n\nRandom movement of the prey agents to a distance of 2 cells (Von Neumann neighborhood).\nAt each step, the prey agents loss energy.\nAt each step, the prey agents eat food if there is food on the cell on which they are localized (with a max of max_transfer) and gain energy.\nIf a prey agent has no more energy, it dies.\n\nModel Definition​\nParameters​\nTo define the behavior for the prey agents, we add to them three new parameters:\n\nThe max energy of the prey agents.\nThe maximum energy that can a prey agent consume from vegetation per step.\nThe energy used by a prey agent at each time step.\n\nAs we consider these parameters to be global to all preys, we define them in the global section as follows:\nfloat prey_max_energy <- 1.0;float prey_max_transfer <- 0.1;float prey_energy_consum <- 0.05;\nYet we may allow the user to change their values through the user interface. To do so, we add the following definition of parameters within the experiment section:\nparameter \"Prey max energy: \" var: prey_max_energy category: \"Prey\" ;parameter \"Prey max transfer: \" var: prey_max_transfer  category: \"Prey\" ;parameter \"Prey energy consumption: \" var: prey_energy_consum  category: \"Prey\" ;\nvegetation_cell grid​\nWe add a new variable for the vegetation_cell grid called neighbors2, that contains for each vegetation cell the list of the neighbor vegetation cells (at a distance of 2 - Von Neumann neighborhood). We will use these neighbors list for the movement of the prey. Note that the attribute neighbors is a built-in attribute of any grid agent (it contains the agents of the grid at a distance 1).\ngrid vegetation_cell width: 50 height: 50 neighbors: 4 {    ...    list<vegetation_cell> neighbors2 <- self neighbors_at 2;}\nNote that the result of the operator neighbors_at dist depends on the type of topology of the agent applying this operator:\n\nFor a grid topology (grid species), the operator returns the neighbor cells (with a Von Neumann or Moore neighborhood).\nFor a continuous topology, the operator returns the list of agents of which the shape is located at a distance equals or inferior dist meters to the agent shape.\nInside a graph topology, it returns the agents separated by only one edge from the calling agent (independently of their spatial location).\n\nAlso, note the use of the self pseudo-variable which is a reference to the agent currently executing the statement.\nPrey agents​\nWe copy the values of the three global parameters into the prey species in order for it to be available for each agent and possibly modified locally.\nspecies prey {   ...   float max_energy <- prey_max_energy ;   float max_transfer <- prey_max_transfer ;   float energy_consum <- prey_energy_consum ;   ...}\t\t\nThe energy used by each prey at each timestep is randomly computed initially (within ]0;max_energy]).\nspecies prey {    ...    float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy ;    ...}    \nIn order to define the movement behavior of preys, we will add a reflex. A reflex is a block of statements (that can be defined in global or any species) that will be automatically executed at each simulation step if its condition is true, it is defined as follows:\nreflex reflex_name when: condition {...}\nThe when facet is optional: when it is omitted, the reflex is activated at each time step. Note that if several reflexes are defined for a species, the reflexes will be activated following their definition order.\nWe define a first reflex called basic_move that allows the prey agents to choose (randomly) a new vegetation_cell in the neighborhood of my_cell and to move to this cell.\nspecies prey {    ...    reflex basic_move {         my_cell <- one_of (my_cell.neighbors2) ;        location <- my_cell.location ;    }}\nWe define a second reflex called eat that will only be activated when there is food in my_cell and that will allow the prey agents to eat food and gain energy. In order to store the energy gain by the eating (that equals to the minimum between the max_transfer value and the quantity of food available in my_cell), we define a local variable called energy_transfer.  A local variable is a variable that will only exist within this block: once it has been executed, the variable is forgotten. To define it, we have to use the following statement:\nvar_type var_name <- value; \nThus, the reflex eat is defined by:\nspecies prey {    ...    reflex eat when: my_cell.food > 0 {         float energy_transfer <- min([max_transfer, my_cell.food]) ;        my_cell.food <- my_cell.food - energy_transfer ;        energy <- energy + energy_transfer ;    }}\nWe define a third reflex for the prey agent: when the agent has no more energy, it dies (application of the built-in die action):\nspecies prey {    ...    reflex die when: energy <= 0 {        do die ;    }}\nNote that an action is a capability available to the agents of a species (what they can do). It is a block of statements that can be used and reused whenever needed. Some actions, called primitives, are directly coded in Java: for instance, the die action defined for all the agents.\n\nAn action can accept arguments. For instance, write takes an argument called message.\nAn action can return a result.\n\nThere are two ways to call an action: using a statement or as part of an expression\n\nfor actions that do not return a result:\n\ndo action_name arg1: v1 arg2: v2;\n\nfor actions that return a result:\n\nmy_var <- self action_name (arg1:v1, arg2:v2);\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2003.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step4.txt","text":"4. Inspectors and MonitorsThis fourth step illustrates how to monitor more precisely the simulation. Practically, we will define monitors to follow the evolution of specific variables (or expressions) whereas inspectors allow the user to follow the state of a given agent (or a species).\nFormulation​\n\nAdding of a monitor to follow the evolution of the number of prey agents\n\nModel Definition​\nglobal variable​\nWe add a new global variable:\n\nnb_preys: returns, each time it is called, the current number of (live) prey agents\n\nTo do so we use the ->{expression} facet which returns the value of expression, each time it is called.\nWe use as well the operator length that returns the number of elements in a list.\nThus, in the global section, we add the nb_preys global variable:\nint nb_preys -> {length (prey)};\nmonitor​\nA monitor allows users to follow the value of an arbitrary expression in GAML. It has to be defined in an output section. A monitor is defined as follows:\nmonitor monitor_name value: an_expression refresh: every(nb_steps);\nWith:\n\nvalue: mandatory, that value will be displayed in the monitor.\nrefresh: bool, optional: if the expression is true, compute (default is true).\n\nIn this model, we define a monitor to follow the value of the variable nb_preys:\nmonitor \"number of preys\" value: nb_preys;\ninspector​\nInspectors allow to obtain information about a species or an agent. There are two kinds of agent information features:\n\nSpecies browser: provides information about all the agents of a species. Available in the Agents menu.\n\n\n\nAgent inspector: provides information about one specific agent. Also allows to change the values of its variables during the simulation. Available from the Agents menu, by right_clicking on a display, in the species inspector, or when inspecting another agent. It provides also the possibility to «highlight» the inspected agent.\n\n\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2004.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step5.txt","text":"5. Predator AgentThis fifth step illustrates how to use parent species. Indeed, prey and predators share a few common features thus we will define a generic species that will regroup all the common elements (variables, behaviors, and aspects) between the prey and the predator species.\nFormulation​\n\nDefinition of a new generic species: generic_species.\nDefinition of a new species: predator.\npredator agents move randomly.\nAt each simulation step, a predator agent can eat a prey that is localized at its grid cell.\n\nModel Definition​\nparameters​\nWe add four new parameters related to predator agents:\n\nThe init number of predator agents.\nThe max energy of the predator agents.\nThe energy gained by a predator agent while eating a prey agent.\nThe energy consumed by a predator agent at each time step.\n\nWe define four new global variables in the global section:\nglobal {    ...    int nb_predators_init <- 20;    float predator_max_energy <- 1.0;    float predator_energy_transfer <- 0.5;    float predator_energy_consum <- 0.02;}\nWe define then the four corresponding parameters in the experiment:\nparameter \"Initial number of predators: \" var: nb_predators_init min: 0 max: 200 category: \"Predator\" ;parameter \"Predator max energy: \" var: predator_max_energy category: \"Predator\" ;parameter \"Predator energy transfer: \" var: predator_energy_transfer  category: \"Predator\" ;parameter \"Predator energy consumption: \" var: predator_energy_consum  category: \"Predator\" ;\nparent species​\nA species can have a parent species: it automatically gets all the variables, skill and actions/reflex of the parent species.\nWe define a species called generic_species that is the parent of the species prey and predator:\n\nThis species integrates all of the common feature between the prey and predator species:\n\nthe variables:\n\nsize\ncolor\nmax_energy\nmax_transfer\nenergy_consum\nmy_cell\nenergy\n\n\nthe behaviors:\n\nbasic_move reflex\neat reflex\ndie reflex\n\n\nthe actions:\n\nenergy_from_eat action\n\n\nthe aspect:\n\nbase aspect\n\n\n\nAs the eat behavior depends on the species (prey eats on vegetation_cell, whereas predator agents eat prey agents), we introduce an action energy_from_eat that will be redefined in each child species. Each species will implement its own eating behavior, returning the amount of energy it gets from this action.\nWe remind that an action is a capability available to the agents (what they can do). It is a block of statements that can be used and reused whenever needed.\n\nAn action can accept arguments.\nAn action can return a result (statement return).\n\nThere are two ways of calling an action: using a statement do or as part of an expression:\n\nfor actions that do not return a result:\n\ndo action_name (arg1: v1 arg2: v2);do action_name (v1, v2);\n\nfor actions that return a result (which is stored in my_var):\n\nmy_var <- action_name (arg1:v1, arg2:v2);my_var <- action_name (v1, v2);\nThus the generic_species will have the following code. Note that the action energy_from_eat is also defined in this species, but with a default result (return 0.0).\nspecies generic_species {    float size <- 1.0;    rgb color  ;    float max_energy;    float max_transfer;    float energy_consum;    vegetation_cell my_cell <- one_of (vegetation_cell) ;    float energy <- rnd(max_energy) update: energy - energy_consum max: max_energy ;\t    init {\tlocation <- my_cell.location;    }\t\t    reflex basic_move {\tmy_cell <- one_of (my_cell.neighbors2) ;\tlocation <- my_cell.location ;    }\t\t    reflex eat {\tenergy <- energy + energy_from_eat();    }    reflex die when: energy <= 0 {\tdo die;    }    float energy_from_eat {\treturn 0.0;    } \t    aspect base {\tdraw circle(size) color: color ;    }}\nprey species​\nWe specialize the prey species from the generic_species species:\n\ndefinition of the initial value of the agent variables.\ndefinition of the specific eat action: if the current cell contains some food, the prey agent will take either all this food or the max_transfer value (if the amount of food is greater than the maximum value the prey can take).\n\nspecies prey parent: generic_species {    rgb color <- #blue;     float max_energy <- prey_max_energy ;    float max_transfer <- prey_max_transfer ;    float energy_consum <- prey_energy_consum ;\t\t    float energy_from_eat {\tfloat energy_transfer <- 0.0;\tif(my_cell.food > 0) {\t    energy_transfer <- min([max_transfer, my_cell.food]);\t    my_cell.food <- my_cell.food - energy_transfer;\t} \t\t\t\treturn energy_transfer;    }}\npredator species​\nAs done for the prey species, we specialize the predator species from the generic_species species:\n\ndefinition of the initial value of the agent variables.\ndefinition of the specific eat action: first, the agent computes the list of prey agents contained by my_cell (reachable_preys variable); if it is not empty, it chooses one of the elements of this list, it kills it (i.e. asks it to die) and returns the energy_transfer variable (that will be added to its own energy).\n\nspecies predator parent: generic_species {    rgb color <- #red ;    float max_energy <- predator_max_energy ;    float energy_transfer <- predator_energy_transfer ;    float energy_consum <- predator_energy_consum ;    float energy_from_eat {\tlist<prey> reachable_preys <- prey inside (my_cell);\t\tif(! empty(reachable_preys)) {\t    ask one_of (reachable_preys) {\t\tdo die;\t    }\t    return energy_transfer;\t}\treturn 0.0;    }}\nNote that we used the ask statement. This statement allows to make a remote agent executes a list of statements.\nUse of the ask statement as follows:\nask one_agent { }\nor\nask agents_list { }\nWe used as well the species/agent list inside geometry/agent operator. This operator returns all the agents of the specified species (or from the specified agent list) that are inside the given geometry or agent geometry.\nglobal init block​\nLike in the previous model, in the init block of the model, we create nb_predators_init.\nglobal {    ...    init {        create prey number: nb_preys_init ;        create predator number: nb_predators_init ;    }}\nmonitor​\nLike in the previous model, we define a monitor to display the number of predator agents.\nDefinition of a global variable nb_predator that returns the current number of predator agents:\nglobal {    ...    int nb_predators -> {length (predator)};    ...}\nDefinition of the corresponding monitor:\nmonitor \"number of predators\" value: nb_predators ;\ndisplay​\nAlso, do not forget to add the line to display predators in your simulation\ndisplay main_display {    ...    species predator aspect: base ;}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2005.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step6.txt","text":"6. BreedingSo far we have created agents only during the initialization of the simulation. In this sixth step, we illustrate how to create new agents during a simulation of a dynamic species.\nFormulation​\n\nAdding of a reproduce behavior for the prey and predator species:\n\nWhen an agent has enough energy, it has a certain probability to have a certain number of offspring.\nThe energy of the offspring is equal to the parent energy divided by the number of offspring.\nThe parent gets the same energy as its offspring.\n\n\n\nModel Definition​\nparameters​\nWe add six new parameters related to breeding:\n\nThe reproduction probability for prey agents\nThe max number of offspring for prey agents\nThe minimum energy to reproduce for prey agents\nThe reproduction probability for predator agents\nThe max number of offspring for predator agents\nThe minimum energy to reproduce for predator agents\n\nWe define six new global variables in the global section:\nglobal {    ...    float prey_proba_reproduce <- 0.01;    int prey_nb_max_offsprings <- 5;     float prey_energy_reproduce <- 0.5;     float predator_proba_reproduce <- 0.01;    int predator_nb_max_offsprings <- 3;    float predator_energy_reproduce <- 0.5;    ...}\nWe define then the six corresponding parameters in the experiment:\nparameter \"Prey probability reproduce: \" var: prey_proba_reproduce category: \"Prey\" ;parameter \"Prey nb max offsprings: \" var: prey_nb_max_offsprings category: \"Prey\" ;parameter \"Prey energy reproduce: \" var: prey_energy_reproduce category: \"Prey\" ;parameter \"Predator probability reproduce: \" var: predator_proba_reproduce category: \"Predator\" ;parameter \"Predator nb max offsprings: \" var: predator_nb_max_offsprings category: \"Predator\" ;parameter \"Predator energy reproduce: \" var: predator_energy_reproduce category: \"Predator\" ;\nparent species​\nThe reproduction dynamics is the same for both prey and predator species, it can thus be implemented only once inside the parent species. But the values of the parameters will depend on the species, and thus have to be set with different values inside each of them.\nWe add three new variables for the generic_species:\n\nproba_reproduce\nnb_max_offsprings\nenergy_reproduce\n\nWe add as well a new reflex called reproduce:\n\nthis reflex is activated only when:\n\nThe energy of the agent is greater or equals to energy_reproduce\nAND according to the probability proba_reproduce: for this second condition, we use the flip(proba) operator that returns true according to the probability proba (false otherwise).\n\n\nthis reflex creates nb_offsprings (random number between 1 and nb_max_offsprings) new agents of the species of the agent using the create statement: we use a species casting operator on the current agent.\n\nthe created agents are initialized as follows:\n\nmy_cell: my_cell of the agent creating the agents,\nlocation: location of my_cell,\nenergy: energy of the agent creating the agents (use of keyword myself) divided by the number of offsprings.\n\n\n\n\nafter the agent creation, the reflex updates the energy value of the current agent with the value: energy / nb_offsprings.\n\nspecies generic_species {    ...    float proba_reproduce ;    int nb_max_offsprings;    float energy_reproduce;    ...     reflex reproduce when: (energy >= energy_reproduce) and (flip(proba_reproduce)) {        int nb_offsprings <- rnd(1, nb_max_offsprings);        create species(self) number: nb_offsprings {            my_cell <- myself.my_cell ;            location <- my_cell.location ;            energy <- myself.energy / nb_offsprings ;        }        energy <- energy / nb_offsprings ;    }}\nNote that two keywords (pseudo-variables) can be used to make explicit references to some agents:\n\nThe agent that is currently executing the statements inside the block (for example a newly created agent): self\nThe agent that is executing the statement that contains this block (for instance, the agent that has called the create statement): myself\n\nprey species​\nWe specialize the prey species from the generic_species species as follows:\n\ndefinition of the initial value of the agent variables\n\n   species prey parent: generic_species {      ...      float proba_reproduce <- prey_proba_reproduce ;      int nb_max_offsprings <- prey_nb_max_offsprings ;      float energy_reproduce <- prey_energy_reproduce ;      ...   }\npredator species​\nAs done for the prey species, we specialize the predator species from the generic_species species:\n\ndefinition of the initial value of the agent variables:\n\n   species predator parent: generic_species {      ...      float proba_reproduce <- predator_proba_reproduce ;      int nb_max_offsprings <- predator_nb_max_offsprings ;      float energy_reproduce <- predator_energy_reproduce ;      ...   }\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2006.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step7.txt","text":"7. Agent AspectIn this seventh step, we will focus on the display and more specifically the aspects of the agents: how they are represented. It can be a simple shape (circle, square, etc.), an icon, a polygon (see later GIS support).\nFormulation​\n\nDefinition of two new aspects for the prey and predator agents:\n\nA icon\nA square with information about the agent energy\n\n\nUse of the icon aspect as default aspect for the prey and predator agents.\n\nModel Definition​\nparent species​\nWe add a new variable of type image_file (a particular kind of file) called my_icon to the generic_species.\nWe define as well two new aspects:\n\nicon: draw the image given by the variable my_icon,\ninfo: draw a square of side size size and color color and draw as a text the energy of the agent (with a precision of 2 digits).\n\nspecies generic_species {    ...    image_file my_icon;    ...    aspect base {        draw circle(size) color: color ;    }    aspect icon {        draw my_icon size: 2 * size ;    }    aspect info {        draw square(size) color: color ;        draw string(energy with_precision 2) size: 3 color: #black ;    }}\nprey species​\nWe specialize the prey species from the generic_species species as follows:\n\ndefinition of the initial value of the agent variables:\n\nspecies prey parent: generic_species {    ...      image_file my_icon <- image_file(\"../includes/data/sheep.png\") ;    ...}\nThe image file is here: .\nYou have to copy it in your project folder: includes/data/.\npredator species​\nAs done for the prey species, we specialize the predator species from the generic_species species:\n\ndefinition of the initial value of the agent variables:\n\nspecies predator parent: generic_species {    ...    image_file my_icon <- image_file(\"../includes/data/wolf.png\") ;    ...}\nThe image file is here: .\nYou have to copy it in your project folder: includes/data/.\ndisplay​\nWe change the default aspect of the prey and predator agents to icon aspect.\noutput {    display main_display {        grid vegetation_cell lines: #black ;        species prey aspect: icon ;        species predator aspect: icon ;    }}\nWe define a new display called info_display that displays the prey and predator agents with the info aspect.\noutput {    display info_display {\tgrid vegetation_cell lines: #black ;        species prey aspect: info;        species predator aspect: info;    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2007.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step8.txt","text":"8. Complex BehaviorThis eighth step illustrates how to define more complex actions, how to use conditional statements and iterator operators over containers.\nFormulation​\n\nDefinition of more complex behaviors for prey and predator agents:\n\nThe preys agents are moving to the cell containing the highest quantity of food.\nThe predator agents are moving if possible to a cell that contains preys, otherwise to a random cell.\n\n\n\nModel Definition​\nparent species​\nWe modify the basic_move reflex of the generic_species in order to give the prey and predator more complex behaviors: instead of choosing a random vegetation cell in the neighborhood, the agents will choose a vegetation cell (still in the neighborhood) thanks to a choose_cell action. This action will return an empty (nil) value in the parent species and will be specialized for each species.\nspecies generic_species {    ...    reflex basic_move {\tmy_cell <- choose_cell();\tlocation <- my_cell.location;     } \t    vegetation_cell choose_cell {\treturn nil;    }    ...}\nprey species​\nWe specialize the choose_cell action for the prey species: the agent will choose the vegetation cell of the neighborhood (list my_cell.neighbors2) that maximizes the quantity of food.\nNote that GAMA offers numerous operators to manipulate lists and containers:\n\nUnary operators: min, max, sum...\nBinary operators:\n\nwhere: returns a sub-list where all the elements verify the condition defined in the right operand.\nfirst_with: returns the first element of the list that verifies the condition defined in the right operand.\n...\n\n\n\nIn the case of binary operators, each element (of the first operand list) can be accessed with the pseudo-variable each.\nThus the choose_cell action of the prey species is defined by:\nspecies prey parent: generic_species {    ...      vegetation_cell choose_cell {        return (my_cell.neighbors2) with_max_of (each.food);    }    ...}\npredator species​\nWe specialize the choose_cell species for the predator species: the agent will choose, if possible, a vegetation cell of the neighborhood (list my_cell.neighbors2) that contains at least a prey agent; otherwise it will choose a random cell.\nWe use for this action the first_with operator on the list of neighbor vegetation cells (my_cell.neighbors2) with the following condition: the list of prey agents contained in the cell is not empty. Note that we use the shuffle operator to randomize the order of the list of the neighbor cells.\nIf all the neighbor cells are empty, then the agent chooses a random cell in the neighborhood (one_of (my_cell.neighbors2)).\nGAMA contains statements that allow executing blocks depending on some conditions:\nif condition1 {...} else if condition2{...} ... else {...} \nThis statement means that if condition1 = true then the first block is executed; otherwise, if condition2 = true, then it is the second block, etc. When no conditions are satisfied and an else block is defined (it is optional), this latter is executed.\nWe then write the choose_cell action as follows:\nspecies predator parent: generic_species {    ...    vegetation_cell choose_cell {        vegetation_cell my_cell_tmp <- shuffle(my_cell.neighbors2) first_with (!(empty (prey inside (each))));\tif my_cell_tmp != nil {\t    return my_cell_tmp;\t} else {\t    return one_of (my_cell.neighbors2);\t}     }    ...}\nNote there is ternary operator allowing to directly use a conditioned structure to evaluate a variable:\ncondition ? value1 : value2\nif condition is true, then returns value1; otherwise, returns value2.\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2008.gaml"},{"filePath":"https:--gama-platform.org--wiki-PredatorPrey_step9.txt","text":"9. Stopping conditionThis 9th step illustrates how to use the pause action to stop a simulation.\nFormulation​\n\nAddition of a stopping condition for the simulation: when there is no more prey or predator agents, the simulation stops\n\nModel Definition​\nWe add a new reflex that stops the simulation if the number of preys or the number of predators is zero.\nglobal {    ...    reflex stop_simulation when: (nb_preys = 0) or (nb_predators = 0) {        do pause ;    } }\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Predator%20Prey/models/Model%2009.gaml"},{"filePath":"https:--gama-platform.org--wiki-Preferences.txt","text":"PreferencesVarious preferences are accessible in GAMA to allow users and modelers to personalize their working environment, runtime options and simulation displays. This section reviews the different preference tabs available in the current version of GAMA, as well as how to access the preferences and settings inherited by GAMA from Eclipse.\nPlease note that, as default behavior the preferences specific to GAMA will be shared, on the same machine, and for the same user, among all the workspaces managed by GAMA. If you want your preferences to be workspace specific you have to turn use_global_preference_store preferences to false using tags\nTable of contents​\n\nManage preferences\n\nPreferences panel\nWithin model\nTags\n\n\nPreferences\n\nInterface\nEditors\nExecution\nDisplays\nData and Operators\nExperimental\nManage preferences in GAML\nAdvanced Preferences\n\n\n\nManage preferences​\nThere is three different way to specify the preferences you want Gama to use. The first, and most intuitive way, is to open preference panel in the user interface of Gama. The second is to specify preferences within your model (global) using gaml syntax, like in this example model code. Last and least intuitive for modelers, is to use tags when launching Gama either from git or command line. The three methods are exposed below.\nPreferences panel​\nTo open the preferences dialog of GAMA, either click on the small \"form\" button on the top-left corner of the window or select \"Preferences...\" from the Gama, \"Help\" or \"Views\" menu depending on your OS.\n\nWithin model​\nTo modify one or several preferences for a specific execution of a model, one can use gaml references to the corresponding preferences and directly assigne the desired value. For instance, if you want your batch experiment to use all core when simulation are running in parallel, you can add this line to the init block of your model gama.pref_parallel_simulations_all <- true;. The same can be done for every preferences. A non exhaustive list, with code example can be found here; while having the mouse pointer over preferences in the preference panel, display the associated name.\nTags​\nThe last way to customize preferences attached to Gama is to use tags. Those are passed to the Gama execution (when Gama is launched) using the eclipse syntax: -Dname_of_the_preference=true/false where name_of_the_preference is the name of the variable associated with the preference, and true/false one of the possible value for the preference (which is not limited to boolean but can be number, specific string or any value type). There is two main ways to input those tags: with Gama git using eclipse Run configuration, in tab called Arguments and when launching Gama from the java command line (e.g. see the headless-game.sh to have an example).\nInterface​\nThe Interface pane gathers all the preferences related to the appearance and behavior of the elements of the Graphical User Interface of GAMA.\n\n\nStartup\n\nDisplay welcome page: if true, and if no editors are opened, the welcome page is displayed when opening GAMA.\nRemember GAMA windows size and position: if true, the windows size and position will be saved.\nMaximize GAMA window: if true, the GAMA window is open with the maximal dimensions at startup.\nAsk before rebuilding a corrupted workspace: if true, GAMA will ask if the user want to rebuild a detected corrupted workspace.\nAsk before using a workspace created by another version: if true, GAMA will ask if the user want to use the workspace detected as generated from another version of GAMA.\nOpen a model or an experiment at startup: if true, GAMA display a model or an experiment at startup.\n\nChoose the model to open at startup: Model to open at startup.\nChoose the experiment to run at startup: Experiment to run at startup.\n\n\n\n\nMenus\n\nBreak down agents in menu every: when inspecting a large number of agents, this preference sets how many should be displayed before the decision is made to separate the population in sub-menus.\nSort operators menu by: among [category, name], this preference sets how the operators should be displayed in the menu \"Model\" > \"Operators\" (available only in Modeling perspective, when a model editor is active).\nSort colors menu by: among [RGB value, Name, Brightness, Luminescence], this sets how are sorted the colors in the menu \"Model\" > \"Colors\" (available only in Modeling perspective, when a model editor is active).\nReverse order: if true, reverse the sort order of colors sets above.\nGroup colors: if true, the colors in the previous menu are displays in several sub-menus.\n\n\nConsole\n\nMax. number of characters to display in the console (-1 means no limit)\nMax. number of characters to keep when paused (-1 means no limit)\nWrap long lines (can slow down output)\n\n\nSimulations\n\nAppend the name of simulations to their outputs: if true, the name of the simulation is added after the name of the display or monitor (interesting in case of multi-simulations).\nColor of Simulation X in the UI (console, view tabs): each simulation has a specific color. This is particularly interesting in case of a multi-simulations experiment to identify the displays of each simulation and its console messages.\n\n\nAppearance\n\nFollow OS theme : if true, GAMA theme will match the OS theme.\nLight theme : if true, GAMA theme will be Light.\nHighlight in yellow the title of value editors when they change\nShapefile viewer fill color\nShapefile viewer line color\nImage viewer background color: Background color for the image viewer (when you select an image from the model explorer for example)\nDisplay metadata in navigator: if true, GAMA provides some metadata (orange, in parenthesis) after the name of files in the navigator: for a GAML model, it is the number of experiments; for data files, it depends on the kind of data: (for shapefiles) number of objects, CRS and dimensions of the bounding box, (for csv) the dimensions of the table, the delimiter, the data type ...\n\n\n\nEditors​\nMost of the settings and preferences regarding editors can also be found in the advanced preferences.\n\n\nOptions\n\nShow warning markers in the editor: if false, the warning will only be available from the Validation View.\nShow information markers in the editor: if false, the information will only be available from the Validation View.\nSave all editors when switching perspectives\nHide editors when switching to simulation perspectives (can be overridden in the 'layout' statement)\nApplying formatting on save: if true, every time a model file is saved, its code is formatted.\nSave all model files before launching an experiment\nDrag files and resources as references in GAML files: a GAML model file is dropped in another file as an import and other resources as the definition of a variable accessing to this resource.\nAsk before saving each file\n\n\nEdition\n\nAutomatically close single quotes '..'\nAutomatically close double quotes \"..\"\nAutomatically close curly brackets {..}\nAutomatically close square brackets [..]\nAutomatically close parentheses (..)\nTurn on colorization of code sections: if true, it activates the colorization of code blocks in order to improve the visual understanding of the code structure.\nFont of editors\nBackground color of editors\nMark occurrences of symbols: if true, when a symbol is selected, all its other occurrences are also highlighted.\nAlways display experiments as a menu bar rather than button: if true, all experiment will be displayed in a single menu bar rather than having a button for each experiment.\nDisplay experiments as a menu bar when the combined width of the buttons exceed the width of the toolbar: if true, display a menu bar instead of having a button for each experiment when the total width of the buttons exceed the width of the toolbar.\n\n\n\nExecution​\nThis pane gathers all the preferences related to the execution of experiments, memory management, the errors management, and the parallelism.\n\n\nExperiments: various settings regarding the execution of experiments.\n\nAuto-run experiments when they are launched: see this page.\nAsk to close the previous simulation before launching a new one: if false, previous simulations (if any) will be closed without warning.\nSet the step duration slider incrementation to linear. If false set to logarithmic: if true, the slider will follow a linear incrementation. If false, the slider will follow a logarithmic incrementation.\nSynchronize outputs with the simulation: if true, simulation cycles will wait for the displays to have finished their rendering before passing to the next cycle (this setting can be changed on an individual basis dynamically here).\n\n\nParameters\n\nAutomatically expand the parameters categories : if true, automatically expand the parameters categories.\nDisplay monitors in the parameters view : if true, display monitors within the parameters view.\nInclude random number generation parameters in the parameters view : if true, display the random number generator in the parameter view.\n\n\nTests\n\nSorts the results of tests by severity\nRun tests at each start of the platform\nInclude user-defined tests in the tests suite\nOnly display (in the UI and in headless runs) failed and aborted tests\n\n\nMemory: a given amount of memory (RAM) is allocated to the execution of GAMA (it has to be set in the Gama.ini file). The allocated memory size should be chosen in accordance with the requirements of the model that is developed and the other applications running in your OS.\n\nMonitor memory and emit a warning if it is low: a warning will appear during an experiment run when the memory is low.\nTrigger warnings when the percentage of available memory is below\nInterval (in seconds) at which memory should be monitored\nIf true, when running out of memory, GAMA will try to close the experiment, otherwise it exits\n\nThe max memory allocated in Megabytes. It can be modified in Eclipse (developer version) or in Gama.ini file\n\n\n\n\nRuntime errors: how to manage and consider simulation errors.\n\nShow execution errors: whether errors should be displayed or not.\nShow errors thrown in displays and outputs: the code defined inside the aspect block of a species will be executed each time the agents are repainted in a display. In particular, when the displays are not synchronized, some errors can occur due to some inconsistency between the model and the display (e.g. drawing a dead agent). As a consequence, the code executed inside an aspect should be limited as much as possible.\nNumber of errors to display: how many errors should be displayed at once\nDisplay most recent first: errors will be sorted in the inverse chronological order if true.\nStop simulation at first error: if false, the simulations will display the errors and continue (or try to).\nTreat warnings as errors: if true, no more distinction is made between warnings (which do not stop the simulation) and errors (which can potentially stop it).\nAutomatically open an editor and point at the faulty part of the model if an error or a warning is thrown\nText color of errors\nText color of warnings\n\n\nParallelism: various settings regarding the parallel execution of experiments.\n\nMake experiments run simulations in parallel: if true, in the case of a multi-simulations experiment, the simulation will be executed in parallel (note that the number of simulations that can be executed in parallel will depend on the number of threads to use).\nIn batch, allows to run simulations with all available processors [WARNING: disables reflexes and permanent display of batch experiments]\nMake grids schedule their agents in parallel: the agents of grid species will be executed in parallel. Depending on the model, this could increase the simulation speed, but the modeler cannot have any control over the execution order of the agents.\nMake species schedule their agents in parallel\nNumber under which agents are executed sequentially\nMax. number of threads to use (available processors: 8)\n\n\n\nDisplays​\n\n\nPresentation and Behavior of Graphical Display Views\n\nDefault layout of display views: among [None, stacked, Split, Horizontal, Vertical]. When an experiment defines several displays, they are by default (layout None) opened in the same View. This preference can set automatically this layout. A layout statement can also be used in experiment to redefine programmatically the layout of display views.\nDisplay a border around display views\nContinue to draw displays when in Modeling perspective: if true, when the simulation is running and the modeler chooses to switch to the Modeling perspective the displays are still updated. This is particularly relevant for displays showing plots of data over time.\nEnable fast snapshots (uncomplete when the display is obscured but much faster)\nShow the display top toolbar: this could also be configured manually for each display (cf displays related page).\nShow the display bottom overlay: this could also be configured manually for each display (cf displays related page).\n\n\nCharts Preferences\n\nDisplay 'flat' histograms: if false, the histograms are displayed in a 3D style.\nKeep values in memory (to save them as csv)\nDisplay grid lines: in charts (and in particular series), if true, a grid is displayed in background.\nResolution of the charts (from 0, small but fast, to 1, best but resource consuming)\n\n\nDefault Rendering Properties: various properties of displays\n\nDefault rendering method (Java2D for 2D, OpenGL for 3D): use either 'Java2D' or 'OpenGL' if nothing is specified in the declaration of a display.\nApply antialiasing: if true, displays are drawn using antialiasing, which is slower but renders a better quality of image and text (this setting can be changed on an individual basis dynamically here).\nDefault background color: indicates which color to use when none is specified in the declaration of a display.\nDefault highlight color: indicates which color to use for highlighting agents in the displays.\nDefault shape of agents: a choice between shape (which represents the actual geometrical shape of the agent) and geometrical operators (circle, square, triangle, point, cube, sphere etc.) as default shape to display agents when no aspect is defined.\nDefault size of agents: what size to use. This expression must be constant.\nDefault color of agents: what color to use.\nDefault font to use in 'draw'\n\n\nOpenGL Rendering Properties: various properties specific to OpenGL-based displays\n\nOnly display visible agents (faster, may create visual oddities)\nDraw 3D axes: if true, the shape of the world and the 3 axes are drawn\nDraw rotation axes: if true, a sphere appears when rotating the scene to illustrate the rotations.\nDefault line width (facet width of draw): the value is used in draw statement that draws a line without specifying the width facet.\nNumber of slices of circular geometries: when a circular geometry (circle, sphere, cylinder) is displayed, it needs to be discretized in a given number of slices.\nAdd a small increment to the z ordinate of objects to fight visual artefacts: if true, add a small increment to objects to prevent visual artifacts to form when two or more objects have the same z ordinate.\nOrient the textures according to the geometry on which they are displayed (may create visual oddities): if true, the textures will be displayed following the orientation of the geometry they are displayed on.\nSet the zoom factor (0 for slow, 1 fast): this determines the speed of the zoom (in and out), and thus its precision.\nSet the sensitivity of the keyboard movements (0 for slow, 1 fast): this determines the speed of the keyboard movement, and thus its precision.\nSet the sensitivity of mouse/trackpad (0 for slow, 1 fast): this determines the speed of the mouse/trackpad movement, and thus their precision.\nLimit the number of frames per second\n\nMax. number of frames per second\n\n\nUse Numeric Keypad (2,4,6,8) for camera interaction: use these numeric keys to make quick rotations.\nDefault camera when none is specified: choose the camera to be used when none are specified.\nUse GAMA image cache when building textures in OpenGL (potentially faster when running several simulations, but uses more memory)\nSet the default intensity of the ambient and default lights (from 0, completely dark, to 255, completely light)\n\n\n\nData and Operators​\nThese preferences pertain to the use of external libraries or data with GAMA.\n\n\nHttp connections\n\nConnection timeout (in ms): set the connection timeout when the model tries to access a resource on the web. This value is used to decide when to give up the connection try to an HTTP server in case of response absence.\nRead timeout (in ms): similar to connection timeout, but related to the time GAMA will wait for a response in case of reading demand.\nNumber of times to retry if connection cannot be established\nEmpty the local cache of files downloaded from the web: if true, after having downloaded the files and used them in the model, the files will be deleted.\n\n\nRandom Number Generation: all the options pertaining to generating random numbers in simulations\n\nDefault random number generator: the name of the generator to use by default (if none is specified in the model).\nDefine a default seed: whether or not a default seed should be used if none is specified in the model  (otherwise it is chosen randomly by GAMA)\nDefault seed value (0 is undefined): the value of this default seed\n\n\nOptimizations\n\nOptimize the 'at_distance' operator: an optimisation that considers the number of elements on each side and changes the loop to consider the fastest case.\nOptimize the path computation operators and goto action (but with possible 'jump' issues): when an agent is not already on a path, simplifies its choice of the closest segment to choose and makes it jump directly on it rather than letting it move towards the segment.\nTolerance for the comparison of points: depending on the way they are computed, 2 points who should be the same, could not be equal. This preference allows to be more tolerant in the way points are compared.\nIn-memory shapefile mapping (optimizes access to shapefile data in exchange for increased memory usage)\n\n\nGIS Coordinate Reference Systems (http://spatialreference.org/ref/epsg/ for EPSG codes): settings about CRS to use when loading or saving GIS files\n\nLet GAMA decide which CRS to use to project GIS data: if true, GAMA will decide which CRS, based on input, should be used to project GIS data. Default is true (i.e. GAMA will always try to find the relevant CRS, and, if none can be found, will fall back one the one provided below)\n...or use the following CRS (EPSG code): choose a CRS that will be applied to all GIS data when projected in the models. Please refer to http://spatialreference.org/ref/epsg/ for a list of EPSG codes. If the option above is false, then the use of this CRS will be enforced in all models.Otherwise, GAMA will first try to find the most relevant CRS and then fall back on this one.\nWhen no .prj file or CRS is supplied, consider GIS data to be already projected in the CRS: if true, GIS data that is not accompanied by a CRS information will be considered as projected using the above code.\n...or use the following CRS (EPSG code): choose a CRS that will represent the default code for loading uninformed GIS data.\nWhen no CRS is provided, save the GIS data with the current CRS: if true, saving GIS data will use the projected CRS unless a CRS is provided.\n...or use the following CRS (EPSG code): otherwise, you might enter a CRS to use to save files.\n\n\nCSV Files\n\nDefault separator for strings : set the separator used to separate strings in CSV Files.\nDefault separator for fields : set the separator used to separate fields in CSV Files.\n\n\nManagement of dates: some preferences for default values related to the dates in GAMA.\n\nCustom date pattern (https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimerFormatter.html#patterns)\nDefault date pattern for writing dates (i.e. string(date1))\nDefault starting date of models: set the default value of the global variable starting_date.\nDefault time step of models: define the default duration of a simulation step, i.e. the value of the variable step (by default, it is set to 1s).\n\n\n\nExperimental​\nThese features have not been fully tested. Enable them at your own risks.\n\n\nAutomatically add the plugins required to compile and run a model when editing it\nVerify that the required plugins are present before compiling a model\nOptimize spatial queries: add agents only when necessary in the quadtree (still experimental)\nForces the spatial index to synchronize its operations. Useful for interactive models where the users interface or parallel models with concurrency errors. Note that it may slow down simulations with a lot of mobile agents\n\nManage preferences in GAML​\nAll these preferences can be accessed (set or read) directly in a GAML model. To share your preferences with others (e.g. when you report an issue), you can simply export your preferences in a GAML model. Importing preferences will set your preferences from an external GAML file.\n\nWhen you export your preferences, the GAML file will look like the following code. It contains 2 experiments: one to display all the preferences in the console and the other one to set your preferences will the values written in the model.\nmodel preferencesexperiment 'Display Preferences' type: gui {init {\t//Append the name of simulations to their outputs\twrite sample(gama.pref_append_simulation_name);\t//Display grid lines\twrite sample(gama.pref_chart_display_gridlines);\t//Monitor memory and emit a warning if it is low\twrite sample(gama.pref_check_memory);\t//Max. number of characters to keep when paused (-1 = unlimited)\twrite sample(gama.pref_console_buffer);\t//Max. number of characters to display (-1 = unlimited)\twrite sample(gama.pref_console_size);\t//Wrap long lines (can slow down output)\twrite sample(gama.pref_console_wrap);\t//Custom date pattern (https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns)\twrite sample(gama.pref_date_custom_formatter);// ...\nAdvanced Preferences​\nThe set of preferences described above are specific to GAMA. But there are other preferences or settings that are inherited from the Eclipse underpinnings of GAMA, which concern either the \"core\" of the platform (workspace, editors, updates, etc.) or plugins (like SVN, for instance) that are part of the distribution of GAMA.\nThese \"advanced\" preferences are accessible by clicking on the \"Advanced...\" button in the Preferences view.\n\nDepending on what is installed, the second view that appears will contain a tree of options on the left and preference pages on the right. Contrary to the first set of preferences, please note that these preferences will be saved in the current workspace, which means that changing workspace will revert them to their default values. It is, however, possible to import them in the new workspace using of the wizards provided in the standard \"Import...\" command (see here).\n"},{"filePath":"https:--gama-platform.org--wiki-PseudoVariables.txt","text":"Pseudo-variablesThe expressions known as pseudo-variables are special read-only variables that are not declared anywhere (at least not in a species), and which represent a value that changes depending on the context of execution.\nTable of contents​\n\nPseudo-variables\n\nself\nmyself\neach\nsuper\n\n\n\nself​\nThe pseudo-variable self always holds a reference to the agent executing the current statement.\n\nExample (sets the friend attribute of another random agent of the same species to self and conversely):\n\nfriend potential_friend <- one_of (species(self) - self);if potential_friend != nil {    potential_friend.friend <- self;    friend <- potential_friend;}\nsuper​\nThe pseudo-variable super behaves exactly in the same way as self except when calling an action, in which case it represents an indirection to the parent species. It is mainly used for allowing to call inherited actions within redefined ones. For instance:\nspecies parent {    int add(int a, int b) {        return a + b;    }}species child parent: parent {    int add(int a, int b) {        // Calls the action defined in 'parent' with modified arguments        return super.add(a + 20, b + 20);    }}\nmyself​\nmyself plays the same role as self but in remotely-executed code (ask, create, capture and release statements), where it represents the calling agent when the code is executed by the remote agent.\n\nExample (asks the first agent of my species to set its color to my color):\n\nask first (species (self)){    color <- myself.color;}\n\nExample (create 10 new agents of the species of my species, share the energy between them, turn them towards me, and make them move 4 times to get closer to me):\n\ncreate species (self) number: 10 {   energy <- myself.energy / 10.0;   loop times: 4 {       heading <- towards (myself);       do move;   }}\neach​\neach is available only in the right-hand argument of iterators.  It is a pseudo-variable that represents, in turn, each of the elements of the left-hand container. It can then take any type depending on the context.\n\nExample:\n\nlist<string> names <- my_species collect each.name;  // each is of type my_speciesint max <- max(['aa', 'bbb', 'cccc'] collect length(each)); // each is of type string"},{"filePath":"https:--gama-platform.org--wiki-Recipes.txt","text":"RecipesUnderstanding the structure of models in GAML and gaining some insight of the language is required, but is usually not sufficient to build correct models or models that need to deal with specific approaches (like equation-based modeling). This section is intended to provide readers with practical \"how to\"s on various subjects, ranging from the use of database access to the design of agent communication languages. It is by no means exhaustive, and will progressively be extended with more \"recipes\" in the future, depending on the concrete questions asked by users."},{"filePath":"https:--gama-platform.org--wiki-RegularSpecies.txt","text":"Regular speciesRegular species are composed of attributes, actions, reflex, aspect, etc... They describe the behavior of our agents. You can instantiate as much as you want agents from a regular species, and you can define as much as you want different regular species. You can see a species as a \"class\" in OOP.\nIndex​\n\nDeclaration\nBuilt-in Attributes\nSpecies built-in Attributes\nBuilt-in Actions\nThe init statement\nThe aspect statement\nInstantiate an agent\n\nDeclaration​\nThe regular species declaration starts with the keyword species followed by the name (or followed by the facet name:) :\nspecies my_specie {}\nDirectly in the \"species\" scope, you have to declare all your attributes (or \"member\" in OOP). You declare them exactly the way you declare basic variables. Those attributes are accessible wherever you want inside the species scope.\nspecies my_specie {    int variableA;}\nBuilt-in attributes​\nAs for the global species, some attributes exist already by default in a regular species. Here is the list of built-in attributes:\n\nname (type: string) is used to name your agent. By default, the name is equal to the name of your species + an incremental number. This name is the one visible on the species inspector.\nlocation (type: point) is used to control the position of your agent. It refers to the center of the envelope of the shape associated with the agent.\nshape (type: geometry) is used to describe the geometry of your agent. If you want to use some intersection operator between agents, for instance, it is this geometry that is computed (nb: it can be totally different from the aspect you want to display for your agent!). By default, the shape is a point.\nhost (type: agent) is used when your agent is part of another agent. We will see this concept a bit further, in the topic multi-level architecture.\nmembers (type: list of agents) contain the agents for the population(s) of which the receiver agent is a direct host.\n\nAll those built-in attributes can be accessed in both reading and writing very easily:\nspecies my_species {    init {        name <- \"custom_name\";\tlocation <- {0,1};\tshape <- rectangle(5,1);    }}\nAll those built-in attributes are attributes of an agent (an instance of a species).\nNotice that the world agent is also an agent! It has all the built-in attributes declared above. The world agent is defined inside the global scope. From the global scope then, you can for example access to the center of the envelope of the world shape:\nglobal{    init {    \twrite location; // writes {50.0,50.0,0.0}    }}\nSpecies built-in Attributes​\nSpecies have also their own attributes, which can be accessed with the following syntax (read-only) :\nname_of_your_species.attribute_you_want\nHere is the list of those attributes:\n\nname: (type: string) returns the name of your species.\nattributes: (type: list of string) returns the list of the names of the attributes of your species.\nactions: (type: list of string) returns the list of the names of the actions defined in your species.\naspects: (type: list of string) returns the list of the names of the aspects defined in your species.\npopulation: (type: list) returns the list of agents that belong to this species.\nsubspecies: (type: list of string) returns the list of species that inherit directly from this species (we will talk about the concept of inheritance later)\nparent (type: species) returns its parent species if it belongs to the model, or nil otherwise (we will talk about the concept of inheritance later)\n\nAs an example, the following code illustrates all these attributes:\nmodel NewModelglobal {    init {\tcreate my_species ;    }}species my_species {    int att1;\t    init {\tcreate my_micro_species;\t\t\twrite species(self).name;        // write in the console: my_species\twrite species(self).attributes;          // write in the console: ['name','shape','location','peers','host','agents','members','att1','my_micro_species']\twrite species(self).actions;             // write in the console: ['a1','a2','die','debug','_step_','tell','_init_','error','write']\twrite species(self).aspects;             // write in the console: ['asp1]\twrite species(self).population;          // write in the console: [my_species(0)]\twrite species(self).subspecies;          // write in the console: []\twrite species(self).microspecies;        // write in the console: [my_micro_species]\t\t\twrite species(self).parent;              // write in the console: nil    }\t    reflex r1 {}    reflex r2 {}\t    action a1 {}    action a2 {}\t    species my_micro_species {}\t    aspect asp1 {}}experiment name type: gui {}\nBuilt-in actions​\nSome actions are defined by default for a minimal agent. We already saw quickly the action write, used to display a message in the console.\nAnother very useful built-in action is the action die, used to destroy an agent.\nspecies my_species{    reflex being_killed {        do debug(\"I will disappear from the simulation\");        do die;    }}\nHere is the list of the other built-in actions which you can find in the documentation: debug, tell, _init_, and _step_.\nThe 2 actions _init_and _step_ are very important, as they allow the modeler to change totally the agents' dynamics:\n\nwhen the action _init_ is defined in a species, it will be called instead of the init block.\nwhen the action _step_ is defined in a species, it will be called at each simulation step instead of the species' behaviors (e.g. instead of the reflexes blocks).\n\nThe init statement​\nAfter declaring all the attributes of your species, you can define an initial state (before launching the simulation). It can be seen as the \"constructor of the class\" in OOP.\nspecies my_species {    int variableA;    init {        variableA <- 5;    }}\nThe aspect statement​\nInside each species, you can define one or several aspects. This block allows you to define how you want your species to be represented in the simulation.\nEach aspect has a special name (so that they can be called from the experiment). Once again, you can name your aspect by using the facet name:, or simply by naming it just after the aspect keyword.\nspecies my_species {    aspect standard_aspect {    }}\nYou can then define your aspect by using the statement draw. You can then choose a geometry for your aspect, an image, a text (facet text), and its color (facet color)... It is common to have several draw statement in an aspect to enrich its display. We invite you to read the documentation about the draw statement to know more about.\nspecies my_species {    aspect standard_aspect {        draw circle(1) color:#blue border: #black;    }}\nIn the experiment block, you have to tell the program to display a particular species with a particular aspect (nb: you can also choose to display your species with several aspects in the same display).\nexperiment my_experiment type: gui {    output{        display my_display {            species my_species aspect:standard_aspect;        }    }}\nNow there is only one thing missing to display our agent: we have to instantiate them.\nInstantiate an agent​\nAs already said quickly in the last session, the instantiation of the agents is most often in the init scope of the global species (this is not mandatory of course. You can instantiate your agents from an action/behavior of any species). Use the statement create to instantiate an agent:\n\nThe first element given to the create statement (i.e. the facet species) is used to specify which species you want to instantiate.\nThe facet number is used to tell how many agents you want to create.\nThe facet with is used to specify some default values for some attributes of your instance. For example, you can specify the location.\n\nglobal {    init{        create my_species number: 1 with: (location:{0,0},vA:8);    }}species my_species {    int vA;}\nHere is an example of a model that displays an agent with a circle aspect in the center of the environment:\nmodel display_one_agentglobal{    float worldDimension <- 50#m;    geometry shape <- square(worldDimension);    init{        point center <- {worldDimension/2,worldDimension/2};        create my_species number: 1 with: (location:center);    }}species my_species {    aspect standard_aspect {        draw circle(1#m);    }}experiment my_experiment type:gui {    output{        display myDisplay {            species my_species aspect:standard_aspect;        }    }}"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel.txt","text":"Road TrafficThis tutorial has for goal to present the use of GIS data and complex geometries. In particular, this tutorial shows how to load gis data, to agentify them and to use a network of polylines to constraint the movement of agents. All the files related to this tutorial (shapefiles and models) are available in the Library models (Tutorials, Road Traffic).\nIf you are not familiar with agent-based models or GAMA, we advise you to have a look at the prey-predator model first.\nModel Overview​\nThe model built in this tutorial concerns the study of road traffic in a small city. Two layers of GIS data are used: a road layer (polylines) and a building layer (polygons). The building GIS data contain an attribute: the 'NATURE' of each building: a building can be either 'Residential' or 'Industrial'. In this model, people agents are moving along the road network. Each morning, they are going to an industrial building to work, and each night they are coming back home. Each time a people agent takes a road, it wears it out. More a road is worn out, more a people agent takes time to go all over it. The town council is able to repair some roads.\n\nStep List​\nThis tutorial is composed of 7 steps corresponding to 7 models which are incremental representation of the same model, starting with the simplest model 1 and finishing with the latest one, model 7. For each step, we will present its purpose, an explicit formulation, and the corresponding GAML code.\n\nLoading of GIS data (buildings and roads)\nDefinition of people agents\nMovement of the people agents\nDefinition of weight for the road network\nDynamic update of the road network\nDefinition of a chart display\nAutomatic repair of roads\n"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel_step1.txt","text":"1. Loading of GIS DataThis first step Illustrates how to load GIS data (shapefiles) and to read attributes from GIS data.\nFormulation​\n\nSet the time duration of a time step to 10 minutes.\nLoad, agentify and display two layers of GIS data (building and road). Agentifying a GIS element will allow us to give it a behavior later on (thus not being simply a static/passive object).\nRead the 'NATURE' attribute of the building data: the buildings of 'Residential' type will be colored in gray, the buildings of 'Industrial' type will be color in blue.\n\nModel Definition​\nspecies​\nIn this first model, we have to define two species of agents: the building agents and the road ones. These agents will not have a particular behavior (for the moment), they will just be displayed.\nFor each of these species, we define a new attribute: color of type rgb, with for initial value: \"black\" for the road agent and \"gray\" (by default) for the building agent. Concerning the building species, we define a second attribute named type representing the type of the building (\"Residential\" or \"Industrial\").\nAt last, we define an aspect for these species. In this model, we want to represent the geometry of the agent, we then use the statement draw that allows to draw a given geometry. In order to draw the geometry of the agent, we use the attribute shape (which is a built-in attribute of all agents).\nspecies building {    string type;     rgb color <- #gray  ;\t    aspect base {\tdraw shape color: color ;    }}species road  {    rgb color <- #black ;\t    aspect base {\tdraw shape color: color ;    }}\nParameters​\nGAMA allows to automatically read GIS data that are formatted as shapefiles. In order to let the user chooses his/her shapefiles, we define three parameters. One allowing the user to choose the road shapefile, one allowing him/her to choose the building shapefile, and, at last, one allowing him/her to choose the bounds shapefile. We will come back later on the notion of \"bounds\" in GAMA.\nDefinition of the three global variables of type file concerning the GIS files:\nglobal {    file shape_file_buildings <- file(\"../includes/building.shp\");    file shape_file_roads <- file(\"../includes/road.shp\");    file shape_file_bounds <- file(\"../includes/bounds.shp\");}\nAll shapefiles are available in the model library (under Library models -> Tutorials -> Road Traffic) or you can download them by following this GitHub link.\nIn the experiment section, we add three parameters to allow the user to change the shapefile used directly through the UI:\nexperiment road_traffic type: gui {    parameter \"Shapefile for the buildings:\" var: shape_file_buildings category: \"GIS\" ;    parameter \"Shapefile for the roads:\" var: shape_file_roads category: \"GIS\" ;    parameter \"Shapefile for the bounds:\" var: shape_file_bounds category: \"GIS\" ;}\nAgentification of GIS data​\nIn GAMA, the agentification of GIS data is very straightforward: it only requires to use the create command with the from facet to pass the shapefile. Each object of the shapefile will be directly used to instantiate an agent of the specified species. The reading of an attribute in a shapefile is also very simple. It only requires to use the with facet: the argument of this facet is a dictionary of which the keys are the names of the agent attributes and the value the read operator followed by the name of the shapefile attribute (\"NATURE\" in our case).\nIn the init block of the global block, we create the road and building agents from the shapefiles. Concerning the building agents, we read the \"NATURE\" attribute of the shapefile to initiate the value of the type attribute. If the type attribute is equal to \"Industrial\" set the color attribute to \"blue\".\nglobal {    ...    init {        create building from: shape_file_buildings with: [type::read (\"NATURE\")] {            if type=\"Industrial\" {                color <- #blue ;            }        }        create road from: shape_file_roads ;    }} \nTime step​\nIn GAMA, by default, a time step represents 1 second. It is possible to redefine this value by overriding the step global variable. This value of the time step is used by the moving primitives of GAMA.\nIn our model, we define that a step represents 10 minutes. Note that it is possible to define the unit of a value by using # + unit name, e.g. #mn for minutes or #km for kilometers.\nglobal {    ...    float step <- 10 #mn;    ...}\nEnvironment​\nBuilding a GIS environment in GAMA requires nothing special, just to define the bounds of the environment, i.e. the geometry of the world agent. It is possible to use a shapefile to automatically define it by computing its envelope. In this model, we use a specific shapefile to define it. However, it would be possible to use the road shapefile to define it and let GAMA computes its envelope automatically.\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2001.gaml"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel_step2.txt","text":"2. People AgentsThis second step illustrates how to obtain a random point inside a geometry. We will also define some moving agent called people.\nFormulation​\n\nDefine a new species of agents: the people agents. The people agents have a point for geometry and are represented by a yellow circle of radius 10m.\nAt initialization, 100 people agents are created. Each people agent is placed inside a building of type 'Residential' (randomly selected).\n\nModel Definition​\nspecies​\nWe define a new species of agents: the people agents. In this model, these agents will not have a specific behavior yet. They will be just displayed. Thus, we just have to define an aspect for the agents. We want to represent the people agents by a yellow circle of radius 10m. We then use the circle operator to define the shape to draw in the draw command, with the expected inner color (facet color) and border color (facet border).\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2002.gaml"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel_step3.txt","text":"3. Movement of PeopleThis third step presents how to create a road system from GIS data. More precisely, it shows how to build a graph from a list of polylines and to constrain the movement of an agent according to this graph.\nFormulation​\n\nFor each people agent, definition of 2 new attributes: living_place (building of type 'Residential') and working_place (building of type 'Industrial').\nFor each people agent: definition of start_work and end_work hours attributes that respectively represent when the agent leaves its house to go to work and when it leaves its working place to go back home. These hours will be randomly defined between 6 AM (min_work_start) and 8 AM (max_work_start) for start_work and 4 PM (min_work_end) and 8 PM (max_work_end) for end_work.\nFor each people agent: definition of an objective attribute: this one can 'go home' or 'working'.\nFor each people agent: define a speed. The speed will be randomly defined between 1 km/h (min_speed) and 5 km/h (max_speed).\nThe people agents move along the road, taking the shortest path.\nAll the previously introduced values will be defined in global attributes.\n\nModel Definition​\npeople agents​\nFirst, we have to change the skill of the people agents: as we want to use an action of the moving skill (goto), we will provide the people agents with this skill. A skill is a built-in module that provide the modeler a self-contain and relevant set of actions and variables.\nspecies people skills: [moving] {    ...}\nThen, we have to add new attributes to the people agents: living_place, working_place, start_work, end_work and objective. In addition, we will add a the_target variable that will represent the point toward which the agent will be currently moving.\nspecies people skills: [moving]{    rgb color <- #yellow ;    building living_place <- nil ;    building working_place <- nil ;    int start_work ;    int end_work  ;    string objective ;     point the_target <- nil ;          ...}\nWe define two reflexes that allow to change the objective (and the_target) of the agent at the start_work and end_work hours. Concerning the_target value, we choose a random point in the objective building (working_place or living_place) by using the any_location_in operator. The attribute current_date is a built-in global attribute of type date that is automatically incremented from the starting_date of the simulation by step value.\nspecies people skills: [moving]{      ...    reflex time_to_work when: current_date.hour = start_work and objective = \"resting\" {        objective <- \"working\" ;\tthe_target <- any_location_in (working_place);    }\t\t    reflex time_to_go_home when: current_date.hour = end_work and objective = \"working\" {        objective <- \"resting\" ;\tthe_target <- any_location_in (living_place);     }     ...}\nAt last, we define a reflex that allows the agent to move. If a target point is defined (the_target != nil), the agent moves toward its target using the goto action (provided by the moving skill). Note that we specified a graph to constraint the movement of the agents on the road network with the facet on. We will see later how this graph is built. The agent uses the shortest path (according to the graph) to go to the target point. When the agent arrives at its destination (the_target = self.location), the target is set to nil (the agent will stop moving).\nspecies people skills: [moving]{    ...    reflex move when: the_target != nil {\tdo goto target: the_target on: the_graph ; \tif the_target = location {\t    the_target <- nil ;\t}    }}\nParameters​\nWe add several parameters (and thus global variables) (min_work_start, max_work_start, min_work_end, max_work_end, min_speed and max_speed) and two global variables: the_graph (graph computed from the road network). In addition, we set the starting date in order that the simulation starts at midnight.\nIn the global section:\nglobal {    ...    date starting_date <- date(\"2019-09-01-00-00-00\");    int min_work_start <- 6;    int max_work_start <- 8;    int min_work_end <- 16;     int max_work_end <- 20;     float min_speed <- 1.0 #km / #h;    float max_speed <- 5.0 #km / #h;     graph the_graph;    ...}\nIn the experiment section, we add a parameter statement for each global variable we want to have as a parameter:\nexperiment road_traffic type: gui {    ...     parameter \"Earliest hour to start work\" var: min_work_start category: \"People\" min: 2 max: 8;    parameter \"Latest hour to start work\" var: max_work_start category: \"People\" min: 8 max: 12;    parameter \"Earliest hour to end work\" var: min_work_end category: \"People\" min: 12 max: 16;    parameter \"Latest hour to end work\" var: max_work_end category: \"People\" min: 16 max: 23;    parameter \"minimal speed\" var: min_speed category: \"People\" min: 0.1 #km/#h ;    parameter \"maximal speed\" var: max_speed category: \"People\" max: 10 #km/#h;    ...}\nInitialization​\nFirst, we need to compute from the road agents, a graph for the moving of the people agents. The operator as_edge_graph allows doing that. It automatically builds from a set of agents or geometries a graph where the agents are the edges of the graph, a node represent the extremities of the agent geometry.\nglobal {    init {        ...        create road from: shape_file_roads ;        the_graph <- as_edge_graph(road);        ...    }\nWe randomly assign one working place and one house to each people agent. To simplify the GAML code, we define two temporary variables: the list of buildings of type 'Residential' and the list of buildings of type 'Industrial' (by using the where command). At the creation of each people agent, we initialize its speed (built-in attribute coming from the moving skill), start_work and end_work to each people agent (according to the min and max values defined in the global). We define as well an initial objective (\"resting\"). Concerning the definition of the living_place and working_place, these ones are randomly chosen among the residential_buildings and industrial_buildings lists.\n    init {        ...        list<building> residential_buildings <- building where (each.type=\"Residential\");        list<building>  industrial_buildings <- building  where (each.type=\"Industrial\") ;        create people number: nb_people {\t    speed <- rnd(min_speed, max_speed);\t    start_work <- rnd (min_work_start, max_work_start);\t    end_work <- rnd(min_work_end, max_work_end);            living_place <- one_of(residential_buildings) ;            working_place <- one_of(industrial_buildings) ;            objective <- \"resting\";            location <- any_location_in (living_place);        }    ...    }\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2003.gaml"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel_step4.txt","text":"4. Weight for Road NetworkThe present model will introduce how to design a road system, or graph, based on the road GIS data and provide each edge a weight representing the destruction level of the road.\nFormulation​\n\nAdd a destruction_coeff variable to the road agent. The value of this variable is higher or equal to 1 or lower or equal to 2. At initialization, the value of this variable is randomly defined between 1 and 2.\nIn the road network graph, more a road is worn out (destruction_coeff high), more a people agent takes time to go all over it. Then the value of the arc representing the road in the graph is equal to \"length of the road * destruction_coeff\".\nThe color of the road depends on the destruction_coeff. If \"destruction_coeff = 1\", the road is green, if \"destruction_coeff = 2\", the road is red.\n\nModel Definition​\nroad agent​\nWe add a destruction_coeff variable which initial value is randomly defined between 1 and 2 and which have a max of 2. The color of the agent will depend on this variable. In order to simplify the GAML code, we define a new variable  colorValue that represents the value of red color and that will be defined between 0 and 255.\nspecies road  {    float destruction_coeff <- rnd(1.0,2.0) max: 2.0;    int colorValue <- int(255*(destruction_coeff - 1)) update: int(255*(destruction_coeff - 1));    rgb color <- rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0)  update: rgb(min([255, colorValue]),max ([0, 255 - colorValue]),0) ;    ...}\nweighted road network​\nIn GAMA, adding a weight for a graph is very simple, we use the with_weights operator with the graph for left-operand and a weight map for the right-operand. The weight map contains the weight of each edge: [edge1::weight1, edge2:: weight2,...]. In this model, the weight will be equal to the length of the road (perimeter of the polyline) its destruction coefficient.\n    init {        ...        create road from: shape_file_roads ;        map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));        the_graph <- as_edge_graph(road) with_weights weights_map;        ...    }\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2004.gaml"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel_step5.txt","text":"5. Dynamic weightsThis 5th step illustrates how to obtain the shortest path from a point to another one and to update the weights of an existing graph.\nFormulation​\n\nAt initialization, the value of the destruction_coeff of the road agents will be equal to 1.\nAdd a new parameter: the destroy parameter that represents the value of destruction when a people agent takes a road. By default, it is equal to 0.02.\nWhen a people agent arrive at its destination (home or work), it updates the destruction_coeff of the road agents it took to reach its destination:  \"destruction_coeff = destruction_coeff - destroy\". Then, the graph is updated.\n\nModel Definition​\nglobal section​\nWe add the destroy parameter.\nIn the global section, we define the destroy variable:\nfloat destroy <- 0.02;\nIn the experiment section, we add a parameter:\nparameter \"Value of destruction when a people agent takes a road\" var: destroy category: \"Road\" ;\nWe define a new reflex that updates the graph at each simulation step. For that, we use the with_weights operator. This operator allows to update the weights of an existing graph.\nglobal {    ...    reflex update_graph{        map<road,float> weights_map <- road as_map (each:: (each.destruction_coeff * each.shape.perimeter));        the_graph <- the_graph with_weights weights_map;     }}\npeople agents​\nAt each time-step, after a people agent has moved over one or multiple road segments, it updates the value of the destruction coefficient of road agents crossed (i.e. roads belonging to the path followed). We have for that to set the argument return_path to true in the goto action to obtain the path followed, then to compute the list of agents concerned by this path with the operator agent_from_geometry.\nspecies people skills: [moving]{    ...    reflex move when: the_target != nil {\tpath path_followed <- goto(target: the_target, on:the_graph, return_path: true);\tlist<geometry> segments <- path_followed.segments;\tloop line over: segments {\t    float dist <- line.perimeter;\t    ask road(path_followed agent_from_geometry line) { \t\tdestruction_coeff <- destruction_coeff + (destroy * dist / shape.perimeter);\t    }\t}\tif the_target = location {\t    the_target <- nil ;\t}    }    ...}\t\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2005.gaml"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel_step6.txt","text":"6. ChartsThis 6th step illustrates how to display charts.\nFormulation​\n\nAdd a chart to display the evolution of the road destruction: the mean value of the destruction_coeff of the road agents, and its max value (refreshed every 10 simulation steps).\nAdd a chart to display the activity of the people agent (working or staying home, refreshed every 10 simulation steps).\n\nModel Definition​\nchart display​\nFirst, we add a chart of type series to display the road destruction evolution. To compute the mean of the destruction_coeff, we combine the mean and collect operators. collect takes a container and an expression as operands and will compute a new list, each element being the evaluation on the container operand of the expression. mean computes the average of all the elements of a list. For the max, we use the max_of operator. (Note that the operator mean_of also exists to replace mean and collect).\n     output {         display chart_display refresh:every(10#cycles) {             chart \"Road Status\" type: series size: {1, 0.5} position: {0, 0} {                 data \"Mean road destruction\" value: mean (road collect each.destruction_coeff) style: line color: #green ;\t         data \"Max road destruction\" value: road max_of each.destruction_coeff style: line color: #red ;\t     }             ...         }     }\nSecond, we add a chart of type pie to display the activity of the people agents. We use for that the objective variable of the people agents and the count operator that allows computing the number of elements of a list that verify a condition.\n    output {      ...      display chart_display refresh: every(10#cycles) {          ...          chart \"People Objectif\" type: pie style: exploded size: {1, 0.5} position: {0, 0.5}{\t       data \"Working\" value: people count (each.objective=\"working\") color: #magenta ;\t       data \"Resting\" value: people count (each.objective=\"resting\") color: #blue ;\t  }     }   }\nWe chose to display the 2 charts on the same display. As a consequence, we specified the size and position of each of them to define the layout of this display.\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2006.gaml"},{"filePath":"https:--gama-platform.org--wiki-RoadTrafficModel_step7.txt","text":"7. Automatic Road RepairThis 7th step illustrates how to select in a list of elements that optimizes a given function.\nFormulation​\n\nAdd a new parameter, repair_time, that is equal to 2.\nEvery repair_time, the road with the highest destruction_coeff value is repaired (set its destruction_coeff to 1).\n\nModel Definition​\nparameters​\nWe add a new parameter: the repair_time.\nIn the global section, we define the repair_time variable:\nint repair_time <- 2 ;\nIn the experiment section, we define the associated parameter:\nparameter \"Number of steps between two road repairs\" var: repair_time category: \"Road\" ;\nroad repairing​\nWe have to add a reflex method in the global section that is triggered every repair_time hours. This reflex selects, thanks to the with_max_of operator the road agent with the highest destruction_coeff value, then sets this value at 1.\nglobal {    ...    reflex repair_road when: every(repair_time #hour) {\troad the_road_to_repair <- road with_max_of (each.destruction_coeff) ;\task the_road_to_repair {\t    destruction_coeff <- 1.0 ;\t}    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/Road%20Traffic/models/Model%2007.gaml"},{"filePath":"https:--gama-platform.org--wiki-RunningExperiments.txt","text":"Running ExperimentsRunning an experiment is the only way, in GAMA, to execute simulations on a model. Experiments can be run in different ways.\n\nThe first, and most common way, consists in launching an experiment from the Modeling perspective, using the user interface proposed by the simulation perspective to run simulations.\nThe second way, detailed on this page, allows to automatically launch an experiment when opening GAMA, subsequently using the same user interface.\nThe last way, known as running headless experiments, does not make use of the user interface and allows to manipulate GAMA entirely from the command line.\n\nAll three ways are strictly equivalent in terms of computations (with the exception of the last one omitting all the computations necessary to render simulations on displays or in the UI). They simply differ by their usage:\n\nThe first one is heavily used when designing models or demonstrating several models.\nThe second is intended to be used when demonstrating or experimenting a single model.\nThe last one is useful when running large sets of simulations, especially over networks or grids of computers.\n\nGeneric knowledge to start GAMA Headless​\nThere are two ways to run a GAMA experiment in headless mode: using a dedicated bash wrapper (recommended) or directly from the command line.\nBash Wrapper​\nThe file can be found in the headless directory located inside the GAMA's installed folder. It is named gama-headless.sh on macOS and Linux, or gama-headless.bat on Windows.\n bash gama-headless.sh [m/c/t/hpc/v] $1 $2\n\n\nwith:\n\n$1 input parameter file : an xml file determining experiment parameters and attended outputs\n$2 output directory path : a directory which contains simulation results (numerical data and simulation snapshot)\noptions [-m/c/t/hpc/v]\n\n-m memory : memory allocated to gama\n-c : console mode, the simulation description could be written with the stdin\n-t : tunneling mode, simulation description are read from the stdin, simulation results are printed out in stdout\n-hpc nb_of_cores : allocate a specific number of cores for the experiment plan\n-v : verbose mode. trace are displayed in the console\n\n\n\n\n\nFor example (using the provided sample), navigate in your terminal to the headless folder inside your GAMA root folder and type:\n\n\nbash gama-headless.sh samples/predatorPrey.xml outputHeadLess\nAs specified in predatorPrey.xml, this command runs the prey - predator model for 1000 steps and record a screenshot of the main display every 5 steps. The screenshots are recorded in the directory outputHeadLess (under the GAMA root folder).\nNote that the current directory to run gama-headless command must be $GAMA_PATH/headless\nJava Command​\njava -cp $GAMA_CLASSPATH -Xms512m -Xmx2048m -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 $1 $2\n\nwith:\n\n$GAMA_CLASSPATH GAMA classpath: contains the relative or absolute path of jars inside the GAMA plugin directory and jars created by users\n$1 input parameter file: an XML file determining experiment parameters and attended outputs\n$2 output directory path: a directory which contains simulation results (numerical data and simulation snapshot)\n\n\n\nNote that the output directory is created during the experiment and should not exist before."},{"filePath":"https:--gama-platform.org--wiki-RunningHeadless.txt","text":"Running HeadlessWhat is GAMA Headless​\nThe headless mode gives the possibility run one or multiple instances of GAMA without any user interface so that models and experiments can be launched on a grid or a cluster. Without GUI, the memory footprint, as well as the speed of the simulations, are usually greatly improved.\nIn this mode, GAMA can only be used to run experiments. Editing or managing models is not possible. In order to launch experiments and still benefit from a user interface (which can be used to prepare headless experiments), launch GAMA normally (see here) and refer to this page for instructions.\nDifferent headless modes​\n\nThe first and oldest way, called Legacy mode and detailed here, consists in explicitly writing your full experiment plan (i.e each simulation you want to run, with each parameter sets) in an XML file. This way of using the Headless was the first implementation of the headless inside GAMA.\nThe second way, called Headless Batch and detailed on this page, allows launching a GAML batch experiment in headless mode (i.e. without having to open GAMA's interface). This way is the most natural way to use the headless as it works exactly like in GUI Batch mode.\nThe last way, called Headless Server and described there, let you open an interactive GAMA headless server on which you can dynamically send experiments to run. This last mode is interesting for using GAMA as back-end of other project like web projects.\n\nGeneral knowledge about using GAMA Headless​\nThere are two ways to run a GAMA experiment in headless mode: using a dedicated bash wrapper (recommended) or directly from the command line.\nBash Wrapper (recommended)​\nThe wrapper file can be found in the headless directory located inside Gama's installed folder. It is named gama-headless.sh on macOS and Linux, or gama-headless.bat on Windows.\nYou can start using it like so :\n./gama-headless.sh [m/c/hpc/v] [launchingMode]\nwith:\n\ngeneral headless options [-m/c/hpc/v]:\n\n-m memory : memory allocated to gama (e.g. -m 8g to set it at 8GiB)\n-c : console mode, the simulation description could be written with the stdin\n-hpc nb_of_cores : limit to a specific number of cores the number of simulation running in parallel (eg. -hpc 3 to limit GAMA at using 3 cores/running 3 simulation at a time)\n-v : verbose mode. trace are displayed in the console\n\n\nlaunchingMode will depend on which headless mode you'll use and explained in following pages\n\nYou also can display general help on every options with this command:\n./gama-headless.sh -help\nWhich, for release 1.9.2, will output:\n******************************************************************* GAMA version 1.9.2                                             ** http://gama-platform.org                                       ** (c) 2007-2023 UMI 209 UMMISCO IRD/SU & Partners                *******************************************************************Welcome to Gama-platform.org version GAMA 1.9.2sh ./gama-headless.sh [Options]List of available options:\t=== Headless Options ===\t\t-m [mem]                     -- allocate memory (ex 2048m)\t\t-c                           -- start the console to write xml parameter file\t\t-v                           -- verbose mode\t\t-hpc [core]                  -- set the number of core available for experimentation\t\t-socket [socketPort]         -- start socket pipeline to interact with another framework\t\t-p                           -- start pipeline to interact with another framework\t=== Infos ===\t\t-help                        -- get the help of the command line\t\t-version                     -- get the the version of gama\t=== Library Runner ===\t\t-validate                    -- invokes GAMA to validate models present in built-in library and plugins\t\t-test                        -- invokes GAMA to execute the tests present in built-in library and plugins and display their results\t=== GAMA Headless Runner ===\t\t-batch [experimentName] [modelFile.gaml]\t\t                             -- Run batch experiment in headless mode\t\t-xml [experimentName] [modelFile.gaml] [xmlOutputFile.xml]\t\t                             -- build an xml parameter file from a model\t\t[xmlHeadlessFile.xml] [outputDirectory]\t\t                             -- default usage of GAMA headless\nJava Command (hard)​\nAs GAMA is developed in Java, you can start the Headless mode by load appropriate bundle and starting it like this:\njava -cp $GAMA_CLASSPATH -Xms512m -Xmx2048m -Djava.awt.headless=true org.eclipse.core.launcher.Main -application msi.gama.headless.id4 [options]\nwith:\n\n$GAMA_CLASSPATH: contains the relative or absolute path of jars inside the GAMA plugin directory and jars created by users\noptions as explained above and in following pages\n\nNote that we recommend you to open bash wrapper to have more detailed about how we imagine starting GAMA in headless mode."},{"filePath":"https:--gama-platform.org--wiki-RuntimeConcepts.txt","text":"Runtime ConceptsWhen a model is being simulated, a number of algorithms are applied, for instance, to determine the order in which to run the different agents, or the order in which the initialization of agents is performed, etc. This section details some of them, which can be important when building models and understanding how they will be effectively simulated.\nTable of contents​\n\nSimulation initialization\nAgents Creation\nAgents Step\nSchedule Agents\n\nSimulation initialization​\nOnce the user launches an experiment, GAMA starts by creating an experiment agent that will manage the initialization of the simulation(s). For each simulation, first, it creates a world agent.\nIt initializes all its attributes with their init values. This includes its shape (that will be used as the environment of the simulation).\nIf a species of type grid exists in the model, agents of this species are created.\nFinally, the init statement of the global is executed. It should include the creation of all the other agents of regular species of the simulation. After their creation and initialization, they are added in the list members the world (that contains all the micro-agent of the world).\nAgents Creation​\nExcept grid agents, other agents are created using the create statement. It is used to allocate memory for each agent and to initialize all its attributes.\nIf no explicit initialization exists for an attribute, it will get the default value corresponding to its type.\nThe initialization of an attribute can be located at several places in the code; they are executed in the following order (which means that, if several ways are used, the attribute will finally have the value of the last applied one):\n\nin the attribute declaration, using the init or <- facet.\nusing the from: or with facet of the create statement.\nin the init block of the species.\nin the embedded block of the create statement.\n\nAgents Step​\nWhen an agent is asked to step, it means that it is expected to:\n\nupdate its variables (facet update in the variable declaration),\nrun its behaviors (reflex, state...),\nstep its micro-agents (if any).\n\nstep of agent agent_a    {        species_a <- agent_a.species        architecture_a <- species_a.architecture        ask architecture_a to step agent_a {             ask agent_a to update species_a.variables             ask agent_a to run architecture_a.behaviors        }        ask each micro-population mp of agent_a to step {            list<agent> sub-agents <- mp.compute_agents_to_schedule            ask each agent_b of sub-agents to step //... recursive call...        }    }\nNotice that, using architecture to manage the behavior of agents, is only a possibility provided by GAMA to ease the development of a model. Modelers who need precise control on the agents' step can:\n\nredefine the _step_ action of the species, in order to explicit how the agents will behave,\nimplement no behavior in the species (but only action). The execution of agents can thus be controlled from a reflex of the global that can control the execution of each of them.\n\nSchedule Agents​\nThe global scheduling of agents is then simply the application of this previous step to the experiment agent, keeping in mind that this agent has only one micro-population (of simulation agents, each instance of the model species), and that the simulation(s) inside this population contain(s), in turn, all the \"regular\" populations of agents of the model.\nTo influence this schedule, then, one possible way is to change the way populations compute their lists of agents to schedule, which can be done in a model by providing custom definitions to the schedules facet of one or several species.\nA practical application of this facet is to reduce simulation artifacts created by the default scheduling of populations, which is sequential (i.e. their agents are executed in turn in their order of creation). To enable pseudo-parallel scheduling based on a random scheduling recomputed at each step, one has simply to define the corresponding species like in the following example:\nspecies A schedules: shuffle(A) {...}\nMoving further, it is possible to enable completely random scheduling, that will eliminate the sequential scheduling of populations, by defining a custom species acting as a scheduler of the agents (that will be executed after the world agent):\nglobal {...}species scheduler schedules: shuffle(A + B + C);species A schedules: [] {...}species B schedules: [] {...}species C schedules: [] {...}\nIt is important to suppress the population-based scheduling to avoid having agents being scheduled 2 times (one time in the custom definition, one time by their population). Note that it is not necessary to create a scheduler agent.\nOther schemes are possible. For instance, the following definition will completely suppress the default scheduling mechanism to replace it with a custom scheduler that will execute the world, then all agents of species A in a random way and then all agents of species B in their order of creation:\nglobal {...} species scheduler schedules: shuffle(A) + B; // explicit scheduling in the worldspecies A schedules [];species B schedules: [];\nComplex conditions can be used to express which agents need to be scheduled at each step. For instance, in the following definition, only agents of A that return true to a particular condition are scheduled:\nspecies A schedules: A where each.can_be_scheduled() {    bool can_be_scheduled() {         ...         returns true_or_false;    }}\nBe aware that enabling a custom scheduling can potentially end up in non-functional simulations. For example, the following definition will result in an infinite loop (which will trigger a stack overflow at some point):\nglobal {} // The world is normally scheduled...species my_scheduler schedules: [world]; // ... but schedules itself again as a consequence of scheduling the micro-species 'my_scheduler'\nNote that schedules facet will not be taken into account when it is added to the global. It is thus not possible to unschedule the world agent."},{"filePath":"https:--gama-platform.org--wiki-Save-and-restore-simulations.txt","text":"Save and Restore simulationsLast version of GAMA has introduced new features to save the state of a simulation at a given simulation cycle. This has two main applications:\n\nThe possibility to save the state of a simulation\nThe possibility to restore a simulation from this file.\nThe possibility to go backward to an older state of a simulation.\n\nSave a simulation​\nexperiment saveSimu type: gui {\treflex store when: cycle = 5 {\t\t\t\twrite \"================ START SAVE + self \" + \" - \" + cycle ;\t\t\t\twrite \"Save of simulation : \" + save_simulation('saveSimu.gsim');\t\twrite \"================ END SAVE + self \" + \" - \" + cycle ;\t\t\t\t}\t\t\toutput {\t\tdisplay main_display {\t\t\tspecies road aspect: geom;\t\t\tspecies people aspect: base;\t\t\t\t\t\t\t\t}\t}\t}\nRestore a simulation​\nexperiment reloadSavedSimuOnly type: gui {\t\taction _init_ {\t\tcreate simulation from: saved_simulation_file(\"saveSimu.gsim\");\t\t}\toutput {\t\tdisplay main_display {\t\t\tspecies road aspect: geom;\t\t\tspecies people aspect: base;\t\t\t\t\t\t\t\t}\t}\t}\nMemorize simulation​\nmodel memorizeglobal {\tinit{\t\tcreate people number:1;\t\t}}\tspecies people skills: [moving] {\t\t\tinit{\t\tlocation <- {50, 50};\t\t\t}\treflex movement {\t\tlocation <- {location.x + 1,location.y};\t}\t\t\taspect base {\t\tdraw circle(5) color: color;\t\tdraw \"\"+cycle;\t}}experiment memorizeExp type: memorize {\toutput {\t\tdisplay map {\t\t\tspecies people aspect: base;\t\t}\t}}"},{"filePath":"https:--gama-platform.org--wiki-StartWithGAML.txt","text":"Start with GAMLIn this part, we will present you some basic concepts of GAML that will help you a lot for the next pages.\nYou will first learn how to organize a standard model, then you will learn about some basis about GAML, such as how to declare a variable, how to use the basic operators, how to write a conditional structure or a loop, how to manipulate containers and how to generate random values."},{"filePath":"https:--gama-platform.org--wiki-Statements.txt","text":"Statements\nThis file is automatically generated from java files. Do Not Edit It.\n\nTable of Contents​\n=, abort, action, add, agents, annealing, ask, aspect, assert, benchmark, betad, break, browse, camera, capture, catch, category, chart, conscious_contagion, continue, coping, create, data, datalist, default, diffuse, diffusion, display, display_grid, do, draw, else, emotional_contagion, enforcement, enter, equation, error, event, exit, experiment, exploration, focus, focus_on, genetic, global, graphics, grid, highlight, hill_climbing, if, image_layer, init, inspect, invoke, law, layout, let, light, loop, match, match_between, match_one, match_regex, mesh, migrate, monitor, morris, norm, output, output_file, overlay, parameter, perceive, permanent, plan, pso, put, reactive_tabu, reflex, release, remove, restore, return, rotation, rule, rule, run, sanction, save, set, setup, sobol, socialize, solve, species, species_layer, start_simulation, state, status, stochanalyse, switch, tabu, task, test, text, trace, transition, try, unconscious_contagion, user_command, user_init, user_input, user_panel, using, Variable_container, Variable_number, Variable_regular, warn, write,\nStatements by kinds​\n\nBatch method\n\nannealing, betad, exploration, genetic, hill_climbing, morris, pso, reactive_tabu, sobol, stochanalyse, tabu,\n\n\nBehavior\n\nabort, aspect, coping, init, norm, plan, reflex, rule, sanction, state, task, test, user_init, user_panel,\n\n\nExperiment\n\nexperiment,\n\n\nLayer\n\nagents, camera, chart, display_grid, event, graphics, image_layer, light, mesh, overlay, rotation, species_layer,\n\n\nOutput\n\nbrowse, display, inspect, layout, monitor, output, output_file, permanent,\n\n\nParameter\n\nparameter,\n\n\nSequence of statements or action\n\naction, ask, benchmark, capture, catch, create, default, else, enter, equation, exit, if, loop, match, match_between, match_one, match_regex, migrate, perceive, release, run, setup, start_simulation, switch, trace, transition, try, user_command, using,\n\n\nSingle statement\n\n=, add, assert, break, category, conscious_contagion, continue, data, datalist, diffuse, diffusion, do, draw, emotional_contagion, enforcement, error, focus, focus_on, highlight, invoke, law, let, put, remove, restore, return, rule, save, set, socialize, solve, status, text, unconscious_contagion, user_input, warn, write,\n\n\nSpecies\n\nglobal, grid, species,\n\n\nVariable (container)\n\nVariable_container,\n\n\nVariable (number)\n\nVariable_number,\n\n\nVariable (regular)\n\nVariable_regular,\n\n\n\nStatements by embedment​\n\nBehavior\n\nadd, ask, assert, benchmark, capture, conscious_contagion, create, diffuse, do, emotional_contagion, enforcement, error, focus, focus_on, highlight, if, inspect, let, loop, migrate, put, release, remove, restore, return, run, save, set, socialize, solve, start_simulation, status, switch, trace, transition, try, unconscious_contagion, using, warn, write,\n\n\nEnvironment\n\nspecies,\n\n\nExperiment\n\naction, annealing, betad, category, exploration, genetic, hill_climbing, morris, output, parameter, permanent, pso, reactive_tabu, reflex, rule, setup, sobol, state, stochanalyse, tabu, task, test, text, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular,\n\n\nLayer\n\nadd, ask, benchmark, do, draw, error, focus_on, highlight, if, let, loop, put, remove, set, status, switch, trace, try, using, warn, write,\n\n\nModel\n\naction, aspect, coping, equation, experiment, law, norm, output, perceive, plan, reflex, rule, rule, run, sanction, setup, species, start_simulation, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular,\n\n\nOutput\n\nask, if,\n\n\nSequence of statements or action\n\nadd, ask, assert, assert, benchmark, break, capture, conscious_contagion, continue, create, data, datalist, diffuse, do, draw, emotional_contagion, enforcement, error, focus, focus_on, highlight, if, inspect, let, loop, migrate, put, release, remove, restore, return, save, set, socialize, solve, status, switch, trace, transition, try, unconscious_contagion, using, warn, write,\n\n\nSingle statement\n\nrun, start_simulation,\n\n\nSpecies\n\naction, aspect, coping, equation, law, norm, perceive, plan, reflex, rule, rule, run, sanction, setup, species, start_simulation, state, task, test, user_command, user_init, user_panel, Variable_container, Variable_number, Variable_regular,\n\n\naction\n\nassert, return,\n\n\naspect\n\ndraw,\n\n\nchart\n\nadd, ask, data, datalist, do, put, remove, set, using,\n\n\ndisplay\n\nagents, camera, chart, display_grid, event, graphics, image_layer, light, mesh, overlay, rotation, species_layer,\n\n\nequation\n\n=,\n\n\nfsm\n\nstate, user_panel,\n\n\nif\n\nelse,\n\n\noutput\n\ndisplay, inspect, layout, monitor, output_file,\n\n\nparallel_bdi\n\ncoping, rule,\n\n\npermanent\n\ndisplay, inspect, monitor, output_file,\n\n\nprobabilistic_tasks\n\ntask,\n\n\nrules\n\nrule,\n\n\nsimple_bdi\n\ncoping, rule,\n\n\nsorted_tasks\n\ntask,\n\n\nspecies_layer\n\nspecies_layer,\n\n\nstate\n\nenter, exit,\n\n\nswitch\n\ndefault, match,\n\n\ntest\n\nassert,\n\n\ntry\n\ncatch,\n\n\nuser_command\n\nuser_input,\n\n\nuser_first\n\nuser_panel,\n\n\nuser_init\n\nuser_panel,\n\n\nuser_last\n\nuser_panel,\n\n\nuser_only\n\nuser_panel,\n\n\nuser_panel\n\nuser_command,\n\n\nweighted_tasks\n\ntask,\n\n\n\nGeneral syntax​\nA statement represents either a declaration or an imperative command. It consists in a keyword, followed by specific facets, some of them mandatory (in bold), some of them optional. One of the facet names can be omitted (the one denoted as omissible). It has to be the first one.\nstatement_keyword expression1 facet2: expression2 ... ;orstatement_keyword facet1: expression1 facet2: expression2 ...;\nIf the statement encloses other statements, it is called a sequence statement, and its sub-statements (either sequence statements or single statements) are declared between curly brackets, as in:\nstatement_keyword1 expression1 facet2: expression2... { // a sequence statement     statement_keyword2 expression1 facet2: expression2...;  // a single statement     statement_keyword3 expression1 facet2: expression2...;}\n\n=\nFacets​\n\nright (float), (omissible) : the right part of the equation (it is mandatory that it can be evaluated as a float\nleft (any type): the left part of the equation (it should be a variable or a call to the diff() or diff2() operators)\n\nDefinition​\nAllows to implement an equation in the form function(n, t) = expression. The left function is only here as a placeholder for enabling a simpler syntax and grabbing the variable as its left member.\nUsages​\n\nThe syntax of the = statement is a bit different from the other statements. It has to be used as follows (in an equation):\n\nfloat t; float S; float I; equation SI {     diff(S,t) = (- 0.3 * S * I / 100);    diff(I,t) = (0.3 * S * I / 100); } \n\nSee also: equation, solve,\n\nEmbedments​\n\nThe = statement is of type: Single statement\nThe = statement can be embedded into: equation,\nThe = statement embeds statements:\n\n\naction​\nFacets​\n\nname (an identifier), (omissible) : identifier of the action\nindex (a datatype identifier): if the action returns a map, the type of its keys\nof (a datatype identifier): if the action returns a container, the type of its elements\ntype (a datatype identifier): the action returned type\nvirtual (boolean): whether the action is virtual (defined without a set of instructions) (false by default)\n\nDefinition​\nAllows to define in a species, model or experiment a new action that can be called elsewhere.\nUsages​\n\nThe simplest syntax to define an action that does not take any parameter and does not return anything is:\n\naction simple_action {    // [set of statements] }\n\nIf the action needs some parameters, they can be specified betwee, braquets after the identifier of the action:\n\naction action_parameters(int i, string s){    // [set of statements using i and s] }\n\nIf the action returns any value, the returned type should be used instead of the \"action\" keyword. A return statement inside the body of the action statement is mandatory.\n\nint action_return_val(int i, string s){    // [set of statements using i and s]    return i + i; }\n\nIf virtual: is true, then the action is abstract, which means that the action is defined without body. A species containing at least one abstract action is abstract. Agents of this species cannot be created. The common use of an abstract action is to define an action that can be used by all its sub-species, which should redefine all abstract actions and implements its body.\n\nspecies parent_species {    int virtual_action(int i, string s); }  species children parent: parent_species {    int virtual_action(int i, string s) {       return i + i;    } }\n\nSee also: do,\n\nEmbedments​\n\nThe action statement is of type: Sequence of statements or action\nThe action statement can be embedded into: Species, Experiment, Model,\nThe action statement embeds statements: assert,  return,\n\n\nadd​\nFacets​\n\nto (any type in [container, species, agent, geometry]): an expression that evaluates to a container\nitem (any type), (omissible) : any expression to add in the container\nall (any type): Allows to either pass a container so as to add all its element, or 'true', if the item to add is already a container.\nat (any type): position in the container of added element\n\nDefinition​\nAllows to add, i.e. to insert, a new element in a container (a list, matrix, map, ...).Incorrect use: The addition of a new element at a position out of the bounds of the container will produce a warning and let the container unmodified. If all: is specified, it has no effect if its argument is not a container, or if its argument is 'true' and the item to add is not a container. In that latter case\nUsages​\n\nThe new element can be added either at the end of the container or at a particular position.\n\nadd expr to: expr_container;    // Add at the end add expr at: expr to: expr_container;   // Add at position expr\n\nCase of a list, the expression in the facet at: should be an integer.\n\nlist<int> workingList <- []; add 0 at: 0 to: workingList ; // workingList equals [0] add 10 at: 0 to: workingList ; // workingList equals [10,0] add 20 at: 2 to: workingList ; // workingList equals [10,0,20] add 50 to: workingList; // workingList equals [10,0,20,50] add [60,70] all: true to: workingList; // workingList equals [10,0,20,50,60,70]\n\nCase of a map: As a map is basically a list of pairs key::value, we can also use the add statement on it. It is important to note that the behavior of the statement is slightly different, in particular in the use of the at facet, which denotes the key of the pair.\n\nmap<string,string> workingMap <- []; add \"val1\" at: \"x\" to: workingMap; // workingMap equals [\"x\"::\"val1\"]\n\nIf the at facet is omitted, a pair (expr_item::expr_item) will be added to the map. An important exception is the case where the expr_item is a pair: in this case the pair is added.\n\nadd \"val2\" to: workingMap; // workingMap equals [\"x\"::\"val1\", \"val2\"::\"val2\"] add \"5\"::\"val4\" to: workingMap;  // workingMap equals [\"x\"::\"val1\", \"val2\"::\"val2\", \"5\"::\"val4\"]\n\nNotice that, as the key should be unique, the addition of an item at an existing position (i.e. existing key) will only modify the value associated with the given key.\n\nadd \"val3\" at: \"x\" to: workingMap; // workingMap equals [\"x\"::\"val3\", \"val2\"::\"val2\", \"5\"::\"val4\"]\n\nOn a map, the all facet will add all value of a container  in the map (so as pair val_cont::val_cont)\n\nadd [\"val4\",\"val5\"] all: true at: \"x\" to: workingMap; // workingMap equals [\"x\"::\"val3\", \"val2\"::\"val2\", \"5\"::\"val4\",\"val4\"::\"val4\",\"val5\"::\"val5\"]\n\nIn case of a graph, we can use the facets node, edge and weight to add a node, an edge or weights to the graph. However, these facets are now considered as deprecated, and it is advised to use the various edge(), node(), edges(), nodes() operators, which can build the correct objects to add to the graph\n\ngraph g <- as_edge_graph([{1,5}::{12,45}]); add edge: {1,5}::{2,3} to: g; list var <- g.vertices; // var equals [{1,5},{12,45},{2,3}] list var <- g.edges; // var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})] add node: {5,5} to: g; list var <- g.vertices; // var equals [{1.0,5.0},{12.0,45.0},{2.0,3.0},{5.0,5.0}] list var <- g.edges; // var equals [polyline({1.0,5.0}::{12.0,45.0}),polyline({1.0,5.0}::{2.0,3.0})]\n\nCase of a matrix: this statement can not be used on matrix. Please refer to the statement put.\nSee also: put, remove,\n\nEmbedments​\n\nThe add statement is of type: Single statement\nThe add statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,\nThe add statement embeds statements:\n\n\nagents​\nFacets​\n\nvalue (container): the set of agents to display\nname (a label), (omissible) : Human readable title of the layer\naspect (an identifier): the name of the aspect that should be used to display the species\nfading (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.\nrefresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, useful in case of agents that do not move)\nrotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.\nselectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true\nsize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\ntrace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.\ntransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)\nvisible (boolean): Defines whether this layer is visible or not\n\nDefinition​\nagents allows the modeler to display only the agents that fulfill a given condition.\nUsages​\n\nThe general syntax is:\n\ndisplay my_display {    agents layer_name value: expression [additional options]; }\n\nFor instance, in a segregation model, agents will only display unhappy agents:\n\ndisplay Segregation {    agents agentDisappear value: people as list where (each.is_happy = false) aspect: with_group_color; }\n\nSee also: display, chart, event, graphics, display_grid, image_layer, overlay, species_layer,\n\nEmbedments​\n\nThe agents statement is of type: Layer\nThe agents statement can be embedded into: display,\nThe agents statement embeds statements:\n\n\nannealing​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\naggregation (a label), takes values in: {min, max}: the agregation method\ninit_solution (map): init solution: key: name of the variable, value: value of the variable\nmaximize (float): the value the algorithm tries to maximize\nminimize (float): the value the algorithm tries to minimize\nnb_iter_cst_temp (int): number of iterations per level of temperature\ntemp_decrease (float): temperature decrease coefficient. At each iteration, the current temperature is multiplied by this coefficient.\ntemp_end (float): final temperature\ntemp_init (float): initial temperature\n\nDefinition​\nThis algorithm is an implementation of the Simulated Annealing algorithm. See the wikipedia article and [batch161 the batch dedicated page].\nUsages​\n\nAs other batch methods, the basic syntax of the annealing statement uses method annealing instead of the expected annealing name: id :\n\nmethod annealing [facet: value];\n\nFor example:\n\nmethod annealing temp_init: 100  temp_end: 1 temp_decrease: 0.5 nb_iter_cst_temp: 5 maximize: food_gathered;\nEmbedments​\n\nThe annealing statement is of type: Batch method\nThe annealing statement can be embedded into: Experiment,\nThe annealing statement embeds statements:\n\n\nask​\nFacets​\n\ntarget (any type in [container, agent]), (omissible) : an expression that evaluates to an agent or a list of agents\nas (species): an expression that evaluates to a species\nparallel (any type in [boolean, int]): (experimental) setting this facet to 'true' will allow 'ask' to use concurrency when traversing the targets; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is false by default.\n\nDefinition​\nAllows an agent, the sender agent (that can be the [Sections161#global world agent]), to ask another (or other) agent(s) to perform a set of statements. If the value of the target facet is nil or empty, the statement is ignored.\nUsages​\n\nAsk  a set of receiver agents, stored in a container, to perform a block of statements. The block is evaluated in the context of the agents' species\n\nask ${receiver_agents} {      ${cursor} }\n\nAsk  one agent to perform a block of statements. The block is evaluated in the context of the agent's species\n\nask ${one_agent} {      ${cursor} }\n\nIf the species of the receiver agent(s) cannot be determined, it is possible to force it using the as facet. An error is thrown if an agent is not a direct or undirect instance of this species\n\nask ${receiver_agent(s)} as: ${a_species_expression} {      ${cursor} }\n\nTo ask a set of agents to do something only if they belong to a given species, the of_species operator can be used. If none of the agents belong to the species, nothing happens\n\nask ${receiver_agents} of_species ${species_name} {      ${cursor} }\n\nAny statement can be declared in the block statements. All the statements will be evaluated in the context of the receiver agent(s), as if they were defined in their species, which means that an expression like self will represent the receiver agent and not the sender. If the sender needs to refer to itself, some of its own attributes (or temporary variables) within the block statements, it has to use the keyword myself.\n\nspecies animal {     float energy <- rnd (1000) min: 0.0;     reflex when: energy > 500 { // executed when the energy is above the given threshold          list<animal> others <- (animal at_distance 5); // find all the neighboring animals in a radius of 5 meters          float shared_energy  <- (energy - 500) / length (others); // compute the amount of energy to share with each of them          ask others { // no need to cast, since others has already been filtered to only include animals               if (energy < 500) { // refers to the energy of each animal in others                    energy <- energy + myself.shared_energy; // increases the energy of each animal                    myself.energy <- myself.energy - myself.shared_energy; // decreases the energy of the sender               }          }     } }\n\nIf the species of the receiver agent cannot be determined, it is possible to force it by casting the agent. Nothing happens if the agent cannot be casted to this species\n\nEmbedments​\n\nThe ask statement is of type: Sequence of statements or action\nThe ask statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer, Output,\nThe ask statement embeds statements:\n\n\naspect​\nFacets​\n\nname (an identifier), (omissible) : identifier of the aspect (it can be used in a display to identify which aspect should be used for the given species). Two special names can also be used: 'default' will allow this aspect to be used as a replacement for the default aspect defined in preferences; 'highlighted' will allow the aspect to be used when the agent is highlighted as a replacement for the default (application of a color)\n\nDefinition​\nAspect statement is used to define a way to draw the current agent. Several aspects can be defined in one species. It can use attributes to customize each agent's aspect. The aspect is evaluate for each agent each time it has to be displayed.\nUsages​\n\nAn example of use of the aspect statement:\n\nspecies one_species { \tint a <- rnd(10); \taspect aspect1 { \t\tif(a mod 2 = 0) { draw circle(a);} \t\telse {draw square(a);} \t\tdraw text: \"a= \" + a color: #black size: 5; \t} }\nEmbedments​\n\nThe aspect statement is of type: Behavior\nThe aspect statement can be embedded into: Species, Model,\nThe aspect statement embeds statements: draw,\n\n\nassert​\nFacets​\n\nvalue (boolean), (omissible) : a boolean expression. If its evaluation is true, the assertion is successful. Otherwise, an error (or a warning) is raised.\nlabel (string): a string displayed instead of the failed expression in order to customize the error or warning if the assertion is false\nwarning (boolean): if set to true, makes the assertion emit a warning instead of an error\n\nDefinition​\nAllows to check if the evaluation of a given expression returns true. If not, an error (or a warning) is raised. If the statement is used inside a test, the error is not propagagated but invalidates the test (in case of a warning, it partially invalidates it). Otherwise, it is normally propagated\nUsages​\n\nAny boolean expression can be used\n\nassert (2+2) = 4; assert self != nil; int t <- 0; assert is_error(3/t); (1 / 2) is float\n\nif the 'warn:' facet is set to true, the statement emits a warning (instead of an error) in case the expression is false\n\nassert 'abc' is string warning: true\n\nSee also: test, setup, is_error, is_warning,\n\nEmbedments​\n\nThe assert statement is of type: Single statement\nThe assert statement can be embedded into: test, action, Sequence of statements or action, Behavior, Sequence of statements or action,\nThe assert statement embeds statements:\n\n\nbenchmark​\nFacets​\n\nmessage (any type), (omissible) : A message to display alongside the results. Should concisely describe the contents of the benchmark\nrepeat (int): An int expression describing how many executions of the block must be handled. The output in this case will return the min, max and average durations\n\nDefinition​\nDisplays in the console the duration in ms of the execution of the statements included in the block. It is possible to indicate, with the 'repeat' facet, how many times the sequence should be run\nUsages​\nEmbedments​\n\nThe benchmark statement is of type: Sequence of statements or action\nThe benchmark statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe benchmark statement embeds statements:\n\n\nbetad​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\noutputs (list): The list of output variables to analyse\nreport (string): The path to the file where the Betad report will be written\nsampling (an identifier): The sampling method to build parameters sets that must be factorial based to some extends - available are saltelli and default uniform\nfactorial (list): The number of automated steps to swip over, when step facet is missing in parameter definition. Default is 9\nresults (string): The path to the file where the automatic batch report will be written\nsample (int): The number of sample required.\n\nDefinition​\nThis algorithm runs an exploration with a given sampling to compute BetadKu - see doi: 10.1007/s10588-021-09358-5\nUsages​\n\nFor example:\n\nmethod sobol sample_size:100 outputs:['my_var'] report:'../path/to/report/file.txt'; \nEmbedments​\n\nThe betad statement is of type: Batch method\nThe betad statement can be embedded into: Experiment,\nThe betad statement embeds statements:\n\n\nbreak​\nFacets​\nDefinition​\nbreak allows to interrupt the current sequence of statements.\nUsages​\nEmbedments​\n\nThe break statement is of type: Single statement\nThe break statement can be embedded into: Sequence of statements or action,\nThe break statement embeds statements:\n\n\ncamera​\nFacets​\n\nname (string), (omissible) : The name of the camera. Will be used to populate a menu with the other camera presets. Can provide a value to the 'camera:' facet of the display, which specifies which camera to use.Using the special constant #default will make it the default of the surrounding display\ndistance (float): If the 'location:' facet is not defined, defines the distance (in world units) that separates the camera from its target. If 'location:' is defined, especially if it is using a symbolic position, allows to specify the distance to keep from the target. If neither 'location:' or 'distance:' is defined, the default distance is the maximum between the width and the height of the world\ndynamic (boolean): If true, the location, distance and target are automatically recomputed every step. Default is false. When true, will also set 'locked' to true, to avoid interferences from users\nlens (any type in [float, int]): Allows to define the lens -- field of view in degrees -- of the camera. Between 0 and 360. Defaults to 45°\nlocation (any type in [point, string]): Allows to define the location of the camera in the world, i.e. from where it looks at its target. If 'distance:' is specified, the final location is translated on the target-camera axis to respect the distance. Can be a (possibly dynamically computed) point or a symbolic position (#from_above, #from_left, #from_right, #from_up_right, #from_up_left, #from_front, #from_up_front) that will be dynamically recomputed if the target movesIf 'location:' is not defined, it will be that of the default camera (#from_top, #from_left...) defined in the preferences.\nlocked (boolean): If true, the user cannot modify the camera location and target by interacting with the display. It is automatically set when the camera is dynamic, so that the display can 'follow' the coordinates; but it can also be used with fixed coordinates to 'focus' the display on a specific scene\ntarget (any type in [point, agent, geometry]): Allows to define the target of the camera (what does it look at). It can be a point (in world coordinates), a geometry or an agent, in which case its (possibly dynamic) location it used as the target. This facet can be complemented by 'distance:' and/or 'location:' to specify from where the target is looked at. If 'target:' is not defined, the default target is the centroid of the world shape.\n\nDefinition​\ncamera allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way. Several preset cameras are provided and accessible in the preferences (to choose the default) or in GAML using the keywords #from_above, #from_left, #from_right, #from_up_right, #from_up_left, #from_front, #from_up_front, #isometric.These cameras are unlocked (so that they can be manipulated by the user), look at the center of the world from a symbolic position, and the distance between this position and the target is equal to the maximum of the width and height of the world's shape. These preset cameras can be reused when defining new cameras, since their names can become symbolic positions for them. For instance: camera 'my_camera' location: #from_top distance: 10; will lower (or extend) the distance between the camera and the center of the world to 10. camera 'my_camera' locked: true location: #from_up_front target: people(0); will continuously follow the first agent of the people species from the up-front position.\nUsages​\n\nSee also: display, agents, chart, event, graphics, display_grid, image_layer, species_layer,\n\nEmbedments​\n\nThe camera statement is of type: Layer\nThe camera statement can be embedded into: display,\nThe camera statement embeds statements:\n\n\ncapture​\nFacets​\n\ntarget (any type in [agent, container]), (omissible) : an expression that is evaluated as an agent or a list of the agent to be captured\nas (species): the species that the captured agent(s) will become, this is a micro-species of the calling agent's species\nreturns (a new identifier): a list of the newly captured agent(s)\n\nDefinition​\nAllows an agent to capture other agent(s) as its micro-agent(s).\nUsages​\n\nThe preliminary for an agent A to capture an agent B as its micro-agent is that the A's species must defined a micro-species which is a sub-species of B's species (cf. [Species161#Nesting_species Nesting species]).\n\nspecies A { ... } species B { ...    species C parent: A {    ...    } ... }\n\nTo capture all \"A\" agents as \"C\" agents, we can ask an \"B\" agent to execute the following statement:\n\ncapture list(B) as: C;\n\nDeprecated writing:\n\ncapture target: list (B) as: C;\n\nSee also: release,\n\nEmbedments​\n\nThe capture statement is of type: Sequence of statements or action\nThe capture statement can be embedded into: Behavior, Sequence of statements or action,\nThe capture statement embeds statements:\n\n\ncatch​\nFacets​\nDefinition​\nThis statement cannot be used alone\nUsages​\n\nSee also: try,\n\nEmbedments​\n\nThe catch statement is of type: Sequence of statements or action\nThe catch statement can be embedded into: try,\nThe catch statement embeds statements:\n\n\ncategory​\nFacets​\n\nname (a label), (omissible) : The title of the category displayed in the UI\ncolor (rgb): The background color of the category in the UI\nexpanded (boolean): Whether the category is initially expanded or not\n\nDefinition​\nAllows to define a category of parameters that will serve to group parameters in the UI. The category can be declared as initially expanded or closed (overriding the corresponding preference) and with a background color\nUsages​\nEmbedments​\n\nThe category statement is of type: Single statement\nThe category statement can be embedded into: Experiment,\nThe category statement embeds statements:\n\n\nchart​\nFacets​\n\nname (string), (omissible) : the identifier of the chart layer\naxes (rgb): the axis color\nbackground (rgb): the background color\ncolor (rgb): Text color\ngap (float): minimum gap between bars (in proportion)\nlabel_background_color (rgb): Color of the label background (for Pie chart)\nlabel_font (any type in [string, font]): Label font face. Either the name of a font face or a font\nlabel_text_color (rgb): Color of the label text (for Pie chart)\nlegend_font (any type in [string, font]): Legend font face. Either the name of a font face or a font\nmemorize (boolean): Whether or not to keep the values in memory (in order to produce a csv file, for instance). The default value, true, can also be changed in the preferences\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\nreverse_axes (boolean): reverse X and Y axis (for example to get horizental bar charts\nseries_label_position (an identifier), takes values in: {default, none, legend, onchart, yaxis, xaxis}: Position of the Series names: default (best guess), none, legend, onchart, xaxis (for category plots) or yaxis (uses the first serie name).\nsize (point): the layer resize factor: {1,1} refers to the original size whereas {0.5,0.5} divides by 2 the height and the width of the layer. In case of a 3D layer, a 3D point can be used (note that {1,1} is equivalent to {1,1,0}, so a resize of a layer containing 3D objects with a 2D points will remove the elevation)\nstyle (an identifier), takes values in: {line, area, bar, dot, step, spline, stack, 3d, ring, exploded, default}: The sub-style style, also default style for the series.\ntick_font (any type in [string, font]): Tick font face. Either the name of a font face or a font. When used for a series chart, it will set the font of values on the axes, but When used with a pie, it will modify the font of messages associated to each pie section.\ntick_line_color (rgb): the tick lines color\ntitle_font (any type in [string, font]): Title font face. Either the name of a font face or a font\ntitle_visible (boolean): chart title visible\ntransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)\ntype (an identifier), takes values in: {xy, scatter, histogram, series, pie, radar, heatmap, box_whisker}: the type of chart. It could be histogram, series, xy, pie, radar, heatmap or box whisker. The difference between series and xy is that the former adds an implicit x-axis that refers to the numbers of cycles, while the latter considers the first declaration of data to be its x-axis.\nvisible (boolean): Defines whether this layer is visible or not\nx_label (string): the title for the X axis\nx_log_scale (boolean): use Log Scale for X axis\nx_range (any type in [float, int, point, list]): range of the x-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).\nx_serie (any type in [list, float, int]): for series charts, change the default common x serie (simulation cycle) for an other value (list or numerical).\nx_serie_labels (any type in [list, float, int, a label]): change the default common x series labels (replace x value or categories) for an other value (string or numerical).\nx_tick_line_visible (boolean): X tick line visible\nx_tick_unit (float): the tick unit for the y-axis (distance between horizontal lines and values on the left of the axis).\nx_tick_values_visible (boolean): X tick values visible\ny_label (string): the title for the Y axis\ny_log_scale (boolean): use Log Scale for Y axis\ny_range (any type in [float, int, point, list]): range of the y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).\ny_serie_labels (any type in [list, float, int, a label]): for heatmaps/3d charts, change the default y serie for an other value (string or numerical in a list or cumulative).\ny_tick_line_visible (boolean): Y tick line visible\ny_tick_unit (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).\ny_tick_values_visible (boolean): Y tick values visible\ny2_label (string): the title for the second Y axis\ny2_log_scale (boolean): use Log Scale for second Y axis\ny2_range (any type in [float, int, point, list]): range of the second y-axis. Can be a number (which will set the axis total range) or a point (which will set the min and max of the axis).\ny2_tick_unit (float): the tick unit for the x-axis (distance between vertical lines and values bellow the axis).\n\nDefinition​\nchart allows modeler to display a chart: this enables to display specific values of the model at each iteration. GAMA can display various chart types: time series (series), pie charts (pie) and histograms (histogram).\nUsages​\n\nThe general syntax is:\n\ndisplay chart_display {    chart \"chart name\" type: series [additional options] {       [Set of data, datalists statements]    } }\n\nSee also: display, agents, event, graphics, display_grid, image_layer, overlay, quadtree, species_layer, text,\n\nEmbedments​\n\nThe chart statement is of type: Layer\nThe chart statement can be embedded into: display,\nThe chart statement embeds statements: add,  ask,  data,  datalist,  do,  put,  remove,  set,  using,\n\n\nconscious_contagion​\nFacets​\n\nemotion_created (emotion): the emotion that will be created with the contagion\nemotion_detected (emotion): the emotion that will start the contagion\nname (an identifier), (omissible) : the identifier of the unconscious contagion\ncharisma (float): The charisma value of the perceived agent (between 0 and 1)\ndecay (float): The decay value of the emotion added to the agent\nintensity (float): The intensity value of the emotion added to the agent\nreceptivity (float): The receptivity value of the current agent (between 0 and 1)\nthreshold (float): The threshold value to make the contagion\nwhen (boolean): A boolean value to get the emotion only with a certain condition\n\nDefinition​\nenables to directly add an emotion of a perceived species if the perceived agent gets a particular emotion.\nUsages​\n\nOther examples of use:\n\nconscious_contagion emotion_detected:fear emotion_created:fearConfirmed; conscious_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;\nEmbedments​\n\nThe conscious_contagion statement is of type: Single statement\nThe conscious_contagion statement can be embedded into: Behavior, Sequence of statements or action,\nThe conscious_contagion statement embeds statements:\n\n\ncontinue​\nFacets​\nDefinition​\ncontinue allows to skip the remaining statements inside a loop and an ask and directly move to the next element. Inside a switch, it has the same effect as break.\nUsages​\nEmbedments​\n\nThe continue statement is of type: Single statement\nThe continue statement can be embedded into: Sequence of statements or action,\nThe continue statement embeds statements:\n\n\ncoping​\nFacets​\n\nname (an identifier), (omissible) : The name of the rule\nbelief (predicate): The mandatory belief\nbeliefs (list): The mandatory beliefs\ndesire (predicate): The mandatory desire\ndesires (list): The mandatory desires\nemotion (emotion): The mandatory emotion\nemotions (list): The mandatory emotions\nideal (predicate): The mandatory ideal\nideals (list): The mandatory ideals\nlifetime (int): the lifetime value of the mental state created\nnew_belief (predicate): The belief that will be added\nnew_beliefs (list): The belief that will be added\nnew_desire (predicate): The desire that will be added\nnew_desires (list): The desire that will be added\nnew_emotion (emotion): The emotion that will be added\nnew_emotions (list): The emotion that will be added\nnew_ideal (predicate): The ideal that will be added\nnew_ideals (list): The ideals that will be added\nnew_uncertainties (list): The uncertainty that will be added\nnew_uncertainty (predicate): The uncertainty that will be added\nobligation (predicate): The mandatory obligation\nobligations (list): The mandatory obligations\nparallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.\nremove_belief (predicate): The belief that will be removed\nremove_beliefs (list): The belief that will be removed\nremove_desire (predicate): The desire that will be removed\nremove_desires (list): The desire that will be removed\nremove_emotion (emotion): The emotion that will be removed\nremove_emotions (list): The emotion that will be removed\nremove_ideal (predicate): The ideal that will be removed\nremove_ideals (list): The ideals that will be removed\nremove_intention (predicate): The intention that will be removed\nremove_obligation (predicate): The obligation that will be removed\nremove_obligations (list): The obligation that will be removed\nremove_uncertainties (list): The uncertainty that will be removed\nremove_uncertainty (predicate): The uncertainty that will be removed\nstrength (any type in [float, int]): The stregth of the mental state created\nthreshold (float): Threshold linked to the emotion.\nuncertainties (list): The mandatory uncertainties\nuncertainty (predicate): The mandatory uncertainty\nwhen (boolean):\n\nDefinition​\nenables to add or remove mantal states depending on the emotions of the agent, after the emotional engine and before the cognitive or normative engine.\nUsages​\n\nOther examples of use:\n\ncoping emotion: new_emotion(\"fear\") when: flip(0.5) new_desire: new_predicate(\"test\");\nEmbedments​\n\nThe coping statement is of type: Behavior\nThe coping statement can be embedded into: simple_bdi, parallel_bdi, Species, Model,\nThe coping statement embeds statements:\n\n\ncreate​\nFacets​\n\nspecies (any type in [species, agent]), (omissible) : an expression that evaluates to a species, the species of the agents to be created. In the case of simulations, the name 'simulation', which represents the current instance of simulation, can also be used as a proxy to their species\nas (species): optionally indicates a species into which to cast the created agents.\nfrom (any type): an expression that evaluates to a localized entity, a list of localized entities, a string (the path of a file), a file (shapefile, a .csv, a .asc or a OSM file) or a container returned by a request to a database\nnumber (int): an expression that evaluates to an int, the number of created agents\nreturns (a new identifier): a new temporary variable name containing the list of created agents (a list, even if only one agent has been created)\nwith (map): an expression that evaluates to a map, for each pair the key is a species attribute and the value the assigned value\n\nDefinition​\nAllows an agent to create number agents of species species, to create agents of species species from a shapefile or to create agents of species species from one or several localized entities (discretization of the localized entity geometries).\nUsages​\n\nIts simple syntax to create an_int agents of species a_species is:\n\ncreate a_species number: an_int; create species_of(self) number: 5 returns: list5Agents;\n\nIn GAML modelers can create agents of species a_species (with two attributes type and nature with types corresponding to the types of the shapefile attributes) from a shapefile the_shapefile while reading attributes 'TYPE_OCC' and 'NATURE' of the shapefile. One agent will be created by object contained in the shapefile:\n\ncreate a_species from: the_shapefile with: [type:: read('TYPE_OCC'), nature::read('NATURE')];\n\nIn order to create agents from a .csv file, facet header can be used to specified whether we can use columns header:\n\ncreate toto from: \"toto.csv\" header: true with:[att1::read(\"NAME\"), att2::read(\"TYPE\")]; or create toto from: \"toto.csv\" with:[att1::read(0), att2::read(1)]; //with read(int), the index of the column\n\nSimilarly to the creation from shapefile, modelers can create agents from a set of geometries. In this case, one agent per geometry will be created (with the geometry as shape)\n\ncreate species_of(self) from: [square(4), circle(4)]; \t// 2 agents have been created, with shapes respectively square(4) and circle(4)\n\nCreated agents are initialized following the rules of their species. If one wants to refer to them after the statement is executed, the returns keyword has to be defined: the agents created will then be referred to by the temporary variable it declares. For instance, the following statement creates 0 to 4 agents of the same species as the sender, and puts them in the temporary variable children for later use.\n\ncreate species (self) number: rnd (4) returns: children; ask children {         // ... }\n\nIf one wants to specify a special initialization sequence for the agents created, create provides the same possibilities as ask. This extended syntax is:\n\ncreate a_species number: an_int {      [statements] }\n\nThe same rules as in ask apply. The only difference is that, for the agents created, the assignments of variables will bypass the initialization defined in species. For instance:\n\ncreate species(self) number: rnd (4) returns: children {      set location <- myself.location + {rnd (2), rnd (2)}; // tells the children to be initially located close to me      set parent <- myself; // tells the children that their parent is me (provided the variable parent is declared in this species)  }\n\nDeprecated uses:\n\n// Simple syntax create species: a_species number: an_int;\n\nIf number equals 0 or species is not a species, the statement is ignored.\n\nEmbedments​\n\nThe create statement is of type: Sequence of statements or action\nThe create statement can be embedded into: Behavior, Sequence of statements or action,\nThe create statement embeds statements:\n\n\ndata​\nFacets​\n\nlegend (string), (omissible) : The legend of the chart\nvalue (any type in [float, point, list]): The value to output on the chart\naccumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)\ncolor (any type in [rgb, list]): color of the serie, for heatmap can be a list to specify [minColor,maxColor] or [minColor,medColor,maxColor]\nfill (boolean): Marker filled (true) or not (false)\nline_visible (boolean): Whether lines are visible or not\nmarker (boolean): marker visible or not\nmarker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker\nmarker_size (float): Size in pixels of the marker\nstyle (an identifier), takes values in: {line, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)\nthickness (float): The thickness of the lines to draw\nuse_second_y_axis (boolean): Use second y axis for this serie\nx_err_values (any type in [float, list]): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\ny_err_values (any type in [float, list]): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\ny_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)\n\nDefinition​\nThis statement allows to describe the values that will be displayed on the chart.\nUsages​\nEmbedments​\n\nThe data statement is of type: Single statement\nThe data statement can be embedded into: chart, Sequence of statements or action,\nThe data statement embeds statements:\n\n\ndatalist​\nFacets​\n\nvalue (list): the values to display. Has to be a matrix, a list or a List of List. Each element can be a number (series/histogram) or a list with two values (XY chart)\nlegend (list), (omissible) : the name of the series: a list of strings (can be a variable with dynamic names)\naccumulate_values (boolean): Force to replace values at each step (false) or accumulate with previous steps (true)\ncolor (list): list of colors, for heatmaps can be a list of [minColor,maxColor] or [minColor,medColor,maxColor]\nfill (boolean): Marker filled (true) or not (false), same for all series.\nline_visible (boolean): Line visible or not (same for all series)\nmarker (boolean): marker visible or not\nmarker_shape (an identifier), takes values in: {marker_empty, marker_square, marker_circle, marker_up_triangle, marker_diamond, marker_hor_rectangle, marker_down_triangle, marker_hor_ellipse, marker_right_triangle, marker_vert_rectangle, marker_left_triangle}: Shape of the marker. Same one for all series.\nmarker_size (list): the marker sizes to display. Can be a list of numbers (same size for each marker of the series) or a list of list (different sizes by point)\nstyle (an identifier), takes values in: {line, area, bar, dot, step, spline, stack, 3d, ring, exploded}: Style for the serie (if not the default one sepecified on chart statement)\nthickness (float): The thickness of the lines to draw\nuse_second_y_axis (boolean): Use second y axis for this serie\nx_err_values (list): the X Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\ny_err_values (list): the Y Error bar values to display. Has to be a List. Each element can be a number or a list with two values (low and high value)\ny_minmax_values (list): the Y MinMax bar values to display (BW charts). Has to be a List. Each element can be a number or a list with two values (low and high value)\n\nDefinition​\nadd a list of series to a chart. The number of series can be dynamic (the size of the list changes each step). See Ant Foraging (Charts) model in ChartTest for examples.\nUsages​\nEmbedments​\n\nThe datalist statement is of type: Single statement\nThe datalist statement can be embedded into: chart, Sequence of statements or action,\nThe datalist statement embeds statements:\n\n\ndefault​\nFacets​\n\nvalue (any type), (omissible) : The value or values this statement tries to match\n\nDefinition​\nUsed in a switch match structure, the block prefixed by default is executed only if no other block has matched (otherwise it is not).\nUsages​\n\nSee also: switch, match,\n\nEmbedments​\n\nThe default statement is of type: Sequence of statements or action\nThe default statement can be embedded into: switch,\nThe default statement embeds statements:\n\n\ndiffuse​\nFacets​\n\nvar (an identifier), (omissible) : the variable to be diffused. If diffused over a field, then this name will serve to identify the diffusion\non (any type in [species, field, list]): the list of agents (in general cells of a grid), or a field on which the diffusion will occur\navoid_mask (boolean): if true, the value will not be diffused in the masked cells, but will be restitute to the neighboring cells, multiplied by the proportion value (no signal lost). If false, the value will be diffused in the masked cells, but masked cells won't diffuse the value afterward (lost of signal). (default value : false)\ncycle_length (int): the number of diffusion operation applied in one simulation step\nmask (matrix): a matrix that masks the diffusion ( created from an image for instance). The cells corresponding to the values smaller than \"-1\" in the mask matrix will not diffuse, and the other will diffuse.\nmatrix (matrix): the diffusion matrix (\"kernel\" or \"filter\" in image processing). Can have any size, as long as dimensions are odd values.\nmethod (an identifier), takes values in: {convolution, dot_product}: the diffusion method. One of 'convolution' or 'dot_product'\nmin (float): if a value is smaller than this value, it will not be diffused. By default, this value is equal to 0.0. This value cannot be smaller than 0.\npropagation (a label), takes values in: {diffusion, gradient}: represents both the way the signal is propagated and the way to treat multiple propagation of the same signal occurring at once from different places. If propagation equals 'diffusion', the intensity of a signal is shared between its neighbors with respect to 'proportion', 'variation' and the number of neighbors of the environment places (4, 6 or 8). I.e., for a given signal S propagated from place P, the value transmitted to its N neighbors is : S' = (S / N / proportion) - variation. The intensity of S is then diminished by S * proportion on P. In a diffusion, the different signals of the same name see their intensities added to each other on each place. If propagation equals 'gradient', the original intensity is not modified, and each neighbors receives the intensity : S / proportion - variation. If multiple propagation occur at once, only the maximum intensity is kept on each place. If 'propagation' is not defined, it is assumed that it is equal to 'diffusion'.\nproportion (float): a diffusion rate\nradius (int): a diffusion radius (in number of cells from the center)\nvariation (float): an absolute value to decrease at each neighbors\n\nDefinition​\nThis statements allows a value to diffuse among a species on agents (generally on a grid) depending on a given diffusion matrix.\nUsages​\n\nA basic example of diffusion of the variable phero defined in the species cells, given a diffusion matrix math_diff is:\n\nmatrix<float> math_diff <- matrix([[1/9,1/9,1/9],[1/9,1/9,1/9],[1/9,1/9,1/9]]); diffuse var: phero on: cells matrix: math_diff;\n\nThe diffusion can be masked by obstacles, created from a bitmap image:\n\ndiffuse var: phero on: cells matrix: math_diff mask: mymask;\n\nA convenient way to have an uniform diffusion in a given radius is (which is equivalent to the above diffusion):\n\ndiffuse var: phero on: cells proportion: 1/9 radius: 1;\nEmbedments​\n\nThe diffuse statement is of type: Single statement\nThe diffuse statement can be embedded into: Behavior, Sequence of statements or action,\nThe diffuse statement embeds statements:\n\n\ndisplay​\nFacets​\n\nname (a label), (omissible) : the identifier of the display\nantialias (boolean): Indicates whether to use advanced antialiasing for the display or not. The default value is the one indicated in the preferences of GAMA ('false' is its factory default). Antialising produces smoother outputs, but comes with a cost in terms of speed and memory used.\nautosave (any type in [boolean, point, string]): Allows to save this display on disk. This facet accepts bool, point or string values. If it is false or nil, nothing happens. 'true' will save it at a resolution of 500x500 with a standard name (containing the name of the model, display, resolution, cycle and time). A non-nil point will change that resolution. A non-nil string will keep 500x500 and change the filename (if it is not dynamically built, the previous file will be erased). Note that setting autosave to true in a display will synchronize all the displays defined in the experiment\naxes (boolean): Allows to enable/disable the drawing of the world shape and the ordinate axes. Default can be configured in Preferences\nbackground (rgb): Allows to fill the background of the display with a specific color\ncamera (string): Allows to define the name of the camera to use. Default value is 'default'. Accepted values are (1) the name of one of the cameras defined using the 'camera' statement or (2) one of the preset cameras, accessible using constants: #from_above, #from_left, #from_right, #from_up_left, #from_up_right, #from_front, #from_up_front, #isometric\nfullscreen (any type in [boolean, int]): Indicates, when using a boolean value, whether or not the display should cover the whole screen (default is false). If an integer is passed, specifies also the screen to use: 0 for the primary monitor, 1 for the secondary one, and so on and so forth. If the monitor is not available, the first one is used\nkeystone (container): Set the position of the 4 corners of your screen ([topLeft,topRight,botLeft,botRight]), in (x,y) coordinate ( the (0,0) position is the top left corner, while the (1,1) position is the bottom right corner). The default value is : [{0,0},{1,0},{0,1},{1,1}]\nlight (boolean): Allows to enable/disable the light at once. Default is true\northographic_projection (boolean): Allows to enable/disable the orthographic projection. Default can be configured in Preferences\nparent (an identifier): Declares that this display inherits its layers and attributes from the parent display named as the argument. Expects the identifier of the parent display or a string if the name of the parent contains spaces\nrefresh (boolean): Indicates the condition under which this output should be refreshed (default is true)\nshow_fps (boolean): Allows to enable/disable the drawing of the number of frames per second\ntoolbar (any type in [boolean, rgb]): Indicates whether the top toolbar of the display view should be initially visible or not. If a color is passed, then the background of the toolbar takes this color\ntype (a label): Allows to use either Java2D (for planar models) or OpenGL (for 3D models) as the rendering subsystem\nvirtual (boolean): Declaring a display as virtual makes it invisible on screen, and only usable for display inheritance\nz_far (float): Set the distances to the far depth clipping planes. Must be positive.\nz_near (float): Set the distances to the near depth clipping planes. Must be positive.\n\nDefinition​\nA display refers to an independent and mobile part of the interface that can display species, images, texts or charts.\nUsages​\n\nThe general syntax is:\n\ndisplay my_display [additional options] { ... }\n\nEach display can include different layers (like in a GIS).\n\ndisplay gridWithElevationTriangulated type: opengl ambient_light: 100 { \tgrid cell elevation: true triangulation: true; \tspecies people aspect: base; }\nEmbedments​\n\nThe display statement is of type: Output\nThe display statement can be embedded into: output, permanent,\nThe display statement embeds statements: agents,  camera,  chart,  display_grid,  event,  graphics,  image_layer,  light,  mesh,  overlay,  rotation,  species_layer,\n\n\ndisplay_grid​\nFacets​\n\nspecies (species), (omissible) : the species of the agents in the grid\nborder (rgb): the color to draw lines (borders of cells)\nelevation (any type in [matrix, float, int, boolean]): Allows to specify the elevation of each cell, if any. Can be a matrix of float (provided it has the same size than the grid), an int or float variable of the grid species, or simply true (in which case, the variable called 'grid_value' is used to compute the elevation of each cell)\ngrayscale (boolean): if true, givse a grey value to each polygon depending on its elevation (false by default)\nhexagonal (boolean):\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.\nrefresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)\nrotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.\nselectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true\nsize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\nsmooth (boolean): Applies a simple convolution (box filter) to smooth out the terrain produced by this field. Does not change the values of course.\ntext (boolean): specify whether the attribute used to compute the elevation is displayed on each cells (false by default)\ntexture (file): Either file  containing the texture image to be applied on the grid or, if not specified, the use of the image composed by the colors of the cells\ntransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)\ntriangulation (boolean): specifies whther the cells will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default)\nvisible (boolean): Defines whether this layer is visible or not\nwireframe (boolean): if true displays the grid in wireframe using the lines color\n\nDefinition​\ndisplay_grid is used using the grid keyword. It allows the modeler to display in an optimized way all cell agents of a grid (i.e. all agents of a species having a grid topology).\nUsages​\n\nThe general syntax is:\n\ndisplay my_display {    grid ant_grid lines: #black position: { 0.5, 0 } size: {0.5,0.5}; }\n\nTo display a grid as a DEM:\n\ndisplay my_display {     grid cell texture: texture_file text: false triangulation: true elevation: true; }\n\nSee also: display, agents, chart, event, graphics, image, overlay, species_layer,\n\nEmbedments​\n\nThe display_grid statement is of type: Layer\nThe display_grid statement can be embedded into: display,\nThe display_grid statement embeds statements:\n\n\ndo​\nFacets​\n\naction (an identifier), (omissible) : the name of an action or a primitive\ninternal_function (any type):\nwith (map): a map expression containing the parameters of the action\n\nDefinition​\nAllows the agent to execute an action or a primitive.  For a list of primitives available in every species, see this [BuiltIn161 page]; for the list of primitives defined by the different skills, see this [Skills161 page]. Finally, see this [Species161 page] to know how to declare custom actions.\nUsages​\n\nThe simple syntax (when the action does not expect any argument and the result is not to be kept) is:\n\ndo name_of_action_or_primitive;\n\nIn case the action expects one or more arguments to be passed, they are defined by using facets (enclosed tags or a map are now deprecated):\n\ndo name_of_action_or_primitive arg1: expression1 arg2: expression2;\n\nIn case the result of the action needs to be made available to the agent, the action can be called with the agent calling the action (self when the agent itself calls the action) instead of do; the result should be assigned to a temporary variable:\n\ntype_returned_by_action result <- self name_of_action_or_primitive [];\n\nIn case of an action expecting arguments and returning a value, the following syntax is used:\n\ntype_returned_by_action result <- self name_of_action_or_primitive [arg1::expression1, arg2::expression2];\n\nDeprecated uses: following uses of the do statement (still accepted) are now deprecated:\n\n// Simple syntax:  do action: name_of_action_or_primitive;  // In case the result of the action needs to be made available to the agent, the `returns` keyword can be defined; the result will then be referred to by the temporary variable declared in this attribute: do name_of_action_or_primitive returns: result; do name_of_action_or_primitive arg1: expression1 arg2: expression2 returns: result; type_returned_by_action result <- name_of_action_or_primitive(self, [arg1::expression1, arg2::expression2]);  // In case the result of the action needs to be made available to the agent let result <- name_of_action_or_primitive(self, []);  // In case the action expects one or more arguments to be passed, they can also be defined by using enclosed `arg` statements, or the `with` facet with a map of parameters: do name_of_action_or_primitive with: [arg1::expression1, arg2::expression2];  or  do name_of_action_or_primitive {      arg arg1 value: expression1;      arg arg2 value: expression2;      ... }\nEmbedments​\n\nThe do statement is of type: Single statement\nThe do statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,\nThe do statement embeds statements:\n\n\ndraw​\nFacets​\n\ngeometry (any type), (omissible) : any type of data (it can be geometry, image, text)\nanchor (point): Only used when perspective: true in OpenGL. The anchor point of the location with respect to the envelope of the text to draw, can take one of the following values: #center, #top_left, #left_center, #bottom_left, #bottom_center, #bottom_right, #right_center, #top_right, #top_center; or any point between {0,0} (#bottom_left) and {1,1} (#top_right)\nat (point): location where the shape/text/icon is drawn\nbegin_arrow (any type in [int, float]): the size of the arrow, located at the beginning of the drawn geometry\nborder (any type in [rgb, boolean]): if used with a color, represents the color of the geometry border. If set to false, expresses that no border should be drawn. If not set, the borders will be drawn using the color of the geometry.\ncolor (any type in [rgb, container]): the color to use to display the object. In case of images, will try to colorize it. You can also pass a list of colors : in that case, each color will be matched to its corresponding vertex.\ndepth (float): (only if the display type is opengl) Add an artificial depth to the geometry previously defined (a line becomes a plan, a circle becomes a cylinder, a square becomes a cube, a polygon becomes a polyhedron with height equal to the depth value). Note: This only works if the geometry is not a point\nend_arrow (any type in [int, float]): the size of the arrow, located at the end of the drawn geometry\nfont (any type in [font, string]): the font used to draw the text, if any. Applying this facet to geometries or images has no effect. You can construct here your font with the operator \"font\". ex : font:font(\"Helvetica\", 20 , #plain)\nlighted (boolean): Whether the object should be lighted or not (only applicable in the context of opengl displays)\nperspective (boolean): Whether to render the text in perspective or facing the user. Default is in perspective.\nprecision (float): (only if the display type is opengl and only for text drawing) controls the accuracy with which curves are rendered in glyphs. Between 0 and 1, the default is 0.1. Smaller values will output much more faithful curves but can be considerably slower, so it is better if they concern text that does not change and can be drawn inside layers marked as 'refresh: false'\nrotate (any type in [float, int, pair]): orientation of the shape/text/icon; can be either an int/float (angle) or a pair float::point (angle::rotation axis). The rotation axis, when expressed as an angle, is by defaut {0,0,1}\nsize (any type in [float, point]): Size of the shape/icon/image to draw, expressed as a bounding box (width, height, depth; if expressed as a float, represents the box as a cube). Does not apply to texts: use a font with the required size instead\ntexture (any type): the texture(s) that should be applied to the geometry. Either a path to a file or a list of paths\nwidth (float): The line width to use for drawing this object\nwireframe (boolean): a condition specifying whether to draw the geometry in wireframe or not\n\nDefinition​\ndraw is used in an aspect block to express how agents of the species will be drawn. It is evaluated each time the agent has to be drawn. It can also be used in the graphics block.\nUsages​\n\nAny kind of geometry as any location can be drawn when displaying an agent (independently of his shape)\n\naspect geometryAspect { \tdraw circle(1.0) empty: !hasFood color: #orange ; }\n\nImage or text can also be drawn\n\naspect arrowAspect { \tdraw \"Current state= \"+state at: location + {-3,1.5} color: #white font: font('Default', 12, #bold) ; \tdraw file(ant_shape_full) rotate: heading at: location size: 5 }\n\nArrows can be drawn with any kind of geometry, using begin_arrow and end_arrow facets, combined with the empty: facet to specify whether it is plain or empty\n\naspect arrowAspect { \tdraw line([{20, 20}, {40, 40}]) color: #black begin_arrow:5; \tdraw line([{10, 10},{20, 50}, {40, 70}]) color: #green end_arrow: 2 begin_arrow: 2 empty: true; \tdraw square(10) at: {80,20} color: #purple begin_arrow: 2 empty: true; }\nEmbedments​\n\nThe draw statement is of type: Single statement\nThe draw statement can be embedded into: aspect, Sequence of statements or action, Layer,\nThe draw statement embeds statements:\n\n\nelse​\nFacets​\nDefinition​\nThis statement cannot be used alone\nUsages​\n\nSee also: if,\n\nEmbedments​\n\nThe else statement is of type: Sequence of statements or action\nThe else statement can be embedded into: if,\nThe else statement embeds statements:\n\n\nemotional_contagion​\nFacets​\n\nemotion_detected (emotion): the emotion that will start the contagion\nname (an identifier), (omissible) : the identifier of the emotional contagion\ncharisma (float): The charisma value of the perceived agent (between 0 and 1)\ndecay (float): The decay value of the emotion added to the agent\nemotion_created (emotion): the emotion that will be created with the contagion\nintensity (float): The intensity value of the emotion created to the agent\nreceptivity (float): The receptivity value of the current agent (between 0 and 1)\nthreshold (float): The threshold value to make the contagion\nwhen (boolean): A boolean value to get the emotion only with a certain condition\n\nDefinition​\nenables to make conscious or unconscious emotional contagion\nUsages​\n\nOther examples of use:\n\nemotional_contagion emotion_detected:fearConfirmed; emotional_contagion emotion_detected:fear emotion_created:fearConfirmed; emotional_contagion emotion_detected:fear emotion_created:fearConfirmed charisma: 0.5 receptivity: 0.5;\nEmbedments​\n\nThe emotional_contagion statement is of type: Single statement\nThe emotional_contagion statement can be embedded into: Behavior, Sequence of statements or action,\nThe emotional_contagion statement embeds statements:\n\n\nenforcement​\nFacets​\n\nname (an identifier), (omissible) : the identifier of the enforcement\nlaw (string): The law to enforce\nnorm (string): The norm to enforce\nobligation (predicate): The obligation to enforce\nreward (string): The positive sanction to apply if the norm has been followed\nsanction (string): The sanction to apply if the norm is violated\nwhen (boolean): A boolean value to enforce only with a certain condition\n\nDefinition​\napply a sanction if the norm specified is violated, or a reward if the norm is applied by the perceived agent\nUsages​\n\nOther examples of use:\n\nfocus var:speed; //where speed is a variable from a species that is being perceived\nEmbedments​\n\nThe enforcement statement is of type: Single statement\nThe enforcement statement can be embedded into: Behavior, Sequence of statements or action,\nThe enforcement statement embeds statements:\n\n\nenter​\nFacets​\nDefinition​\nIn an FSM architecture, enter introduces a sequence of statements to execute upon entering a state.\nUsages​\n\nIn the following example, at the step it enters into the state s_init, the message 'Enter in s_init' is displayed followed by the display of the state name:\n\nstate s_init { \tenter {  \t\twrite \"Enter in\" + state; \t} \twrite state; }\n\nSee also: state, exit, transition,\n\nEmbedments​\n\nThe enter statement is of type: Sequence of statements or action\nThe enter statement can be embedded into: state,\nThe enter statement embeds statements:\n\n\nequation​\nFacets​\n\nname (an identifier), (omissible) : the equation identifier\nparams (list): the list of parameters used in predefined equation systems\nsimultaneously (list): a list of species containing a system of equations (all systems will be solved simultaneously)\nvars (list): the list of variables used in predefined equation systems\n\nDefinition​\nThe equation statement is used to create an equation system from several single equations.\nUsages​\n\nThe basic syntax to define an equation system is:\n\nfloat t; float S; float I; equation SI {     diff(S,t) = (- 0.3 * S * I / 100);    diff(I,t) = (0.3 * S * I / 100); } \n\nIf the type: facet is used, a predefined equation system is defined using variables vars: and parameters params: in the right order. All possible predefined equation systems are the following ones (see [EquationPresentation161 EquationPresentation161] for precise definition of each classical equation system):\n\nequation eqSI type: SI vars: [S,I,t] params: [N,beta]; equation eqSIS type: SIS vars: [S,I,t] params: [N,beta,gamma]; equation eqSIR type:SIR vars:[S,I,R,t] params:[N,beta,gamma]; equation eqSIRS type: SIRS vars: [S,I,R,t] params: [N,beta,gamma,omega,mu]; equation eqSEIR type: SEIR vars: [S,E,I,R,t] params: [N,beta,gamma,sigma,mu]; equation eqLV type: LV vars: [x,y,t] params: [alpha,beta,delta,gamma];\n\nIf the simultaneously: facet is used, system of all the agents will be solved simultaneously.\nSee also: =, solve,\n\nEmbedments​\n\nThe equation statement is of type: Sequence of statements or action\nThe equation statement can be embedded into: Species, Model,\nThe equation statement embeds statements: =,\n\n\nerror​\nFacets​\n\nmessage (string), (omissible) : the message to display in the error.\n\nDefinition​\nThe statement makes the agent output an error dialog (if the simulation contains a user interface). Otherwise displays the error in the console.\nUsages​\n\nThrowing an error\n\nerror 'This is an error raised by ' + self;\nEmbedments​\n\nThe error statement is of type: Single statement\nThe error statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe error statement embeds statements:\n\n\nevent​\nFacets​\n\nname (string), (omissible) : the type of event captured: basic events include #mouse_up, #mouse_down, #mouse_move, #mouse_exit, #mouse_enter, #mouse_menu, #mouse_drag, #arrow_down, #arrow_up, #arrow_left, #arrow_right, #escape, #tab, #enter, #page_up, #page_down or a character\naction (action): The identifier of the action to be executed in the context of the simulation. This action needs to be defined in 'global' or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location\ntype (string): Type of device used to generate events. Defaults to 'default', which encompasses keyboard and mouse\n\nDefinition​\nevent allows to interact with the simulation by capturing mouse or key events and doing an action. The name of this action can be defined with the 'action:' facet, in which case the action needs to be defined in 'global' or in the current experiment, without any arguments. The location of the mouse in the world can be retrieved in this action with the pseudo-constant #user_location. The statements to execute can also be defined in the block at the end of this statement, in which case they will be executed in the context of the experiment\nUsages​\n\nThe general syntax is:\n\nevent [event_type] action: myAction;\n\nFor instance:\n\nglobal {    // ...     action myAction () {       point loc <- #user_location; // contains the location of the mouse in the world       list<agent> selected_agents <- agents inside (10#m around loc); // contains agents clicked by the event              // code written by modelers    } }  experiment Simple type:gui {    display my_display {       event #mouse_up action: myAction;    } }\n\nSee also: display, agents, chart, graphics, display_grid, image_layer, overlay, species_layer,\n\nEmbedments​\n\nThe event statement is of type: Layer\nThe event statement can be embedded into: display,\nThe event statement embeds statements:\n\n\nexit​\nFacets​\nDefinition​\nIn an FSM architecture, exit introduces a sequence of statements to execute right before exiting the state.\nUsages​\n\nIn the following example, at the state it leaves the state s_init, he will display the message 'EXIT from s_init':\n\nstate s_init initial: true { \twrite state; \ttransition to: s1 when: (cycle > 2) { \t\twrite \"transition s_init -> s1\"; \t} \t\texit { \t\twrite \"EXIT from \"+state; \t} \t}\n\nSee also: enter, state, transition,\n\nEmbedments​\n\nThe exit statement is of type: Sequence of statements or action\nThe exit statement can be embedded into: state,\nThe exit statement embeds statements:\n\n\nexperiment​\nFacets​\n\nname (a label), (omissible) : identifier of the experiment\ntitle (a label):\ntype (a label): The type of the experiment: gui, batch, test, etc.\nautorun (boolean): Whether this experiment should be run automatically when launched (false by default)\nbenchmark (boolean): If true, make GAMA record the number of invocations and running time of the statements and operators of the simulations launched in this experiment. The results are automatically saved in a csv file in a folder called 'benchmarks' when the experiment is closed\ncontrol (an identifier): the control architecture used for defining the behavior of the experiment\nkeep_seed (boolean): Allows to keep the same seed between simulations. Mainly useful for batch experiments\nkeep_simulations (boolean): In the case of a batch experiment, specifies whether or not the simulations should be kept in memory for further analysis or immediately discarded with only their fitness kept in memory\nparallel (any type in [boolean, int]): When set to true, use multiple threads to run its simulations. Setting it to n will set the numbers of threads to use\nparent (an identifier): the parent experiment (in case of inheritance between experiments)\nrecord (boolean): Cannot be used in batch experiments. Whether the simulations run by this experiment are recorded so that they be run backward. Boolean expression expected, which will be evaluated by simulations at each cycle, so that the recording can occur based on specific conditions (for instance 'every(10#cycles)'). A value of 'true' will record each step.\nrepeat (int): In the case of a batch experiment, expresses hom many times the simulations must be repeated\nskills (list): the skills attached to the experiment\nuntil (boolean): In the case of a batch experiment, an expression that will be evaluated to know when a simulation should be terminated\nvirtual (boolean): Whether the experiment is virtual (cannot be instantiated, but only used as a parent, false by default)\n\nDefinition​\nDeclaration of a particular type of agent that can manage simulations. If the experiment directly imports a model using the 'model:' facet, this facet must be the first one after the name of the experiment\nUsages​\nEmbedments​\n\nThe experiment statement is of type: Experiment\nThe experiment statement can be embedded into: Model,\nThe experiment statement embeds statements:\n\n\nexploration​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\nfactorial (list): The number of sample required.\nfrom (string): a path to a file where each lines correspond to one parameter set and each colon a parameter\niterations (int): The number of iteration for orthogonal sampling, 5 by default\nlevels (int): The number of levels for morris sampling, 4 by default\nsample (int): The number of sample required, 132 by default\nsampling (string): The name of the sampling method (among saltelli/morris/latinhypercube/orthogonal/uniform/factorial)\nwith (list): the list of parameter sets to explore; a parameter set is defined by a map: key: name of the variable, value: expression for the value of the variable\n\nDefinition​\nThis is the standard batch method. The exploration mode is defined by default when there is no method element present in the batch section. It explores all the combination of parameter values in a sequential way. You can also choose a sampling method for the exploration. See [batch161 the batch dedicated page].\nUsages​\n\nAs other batch methods, the basic syntax of the exploration statement uses method exploration instead of the expected exploration name: id :\n\nmethod exploration;\n\nSimplest example:\n\nmethod exploration;\n\nUsing sampling facet:\n\nmethod exploration sampling:latinhypercube sample:100; \n\nUsing from facet:\n\nmethod exploration from:\"../path/to/my/exploration/plan.csv\"; \n\nUsing with facet:\n\nmethod exploration with:[[\"a\"::0.5, \"b\"::10],[\"a\"::0.1, \"b\"::100]]; \nEmbedments​\n\nThe exploration statement is of type: Batch method\nThe exploration statement can be embedded into: Experiment,\nThe exploration statement embeds statements:\n\n\nfocus​\nFacets​\n\nagent_cause (agent): the agentCause value of the created belief (can be nil\nbelief (predicate): The predicate to focus on the beliefs of the other agent\ndesire (predicate): The predicate to focus on the desires of the other agent\nemotion (emotion): The emotion to focus on the emotions of the other agent\nexpression (any type): an expression that will be the value kept in the belief\nid (string): the identifier of the focus\nideal (predicate): The predicate to focus on the ideals of the other agent\nis_uncertain (boolean): a boolean to indicate if the mental state created is an uncertainty\nlifetime (int): the lifetime value of the created belief\nstrength (any type in [float, int]): The priority of the created predicate\ntruth (boolean): the truth value of the created belief\nuncertainty (predicate): The predicate to focus on the uncertainties of the other agent\nvar (any type in [any type, list, container]): the variable of the perceived agent you want to add to your beliefs\nwhen (boolean): A boolean value to focus only with a certain condition\n\nDefinition​\nenables to directly add a belief from the variable of a perceived species.\nUsages​\n\nOther examples of use:\n\nfocus var:speed /*where speed is a variable from a species that is being perceived*/\nEmbedments​\n\nThe focus statement is of type: Single statement\nThe focus statement can be embedded into: Behavior, Sequence of statements or action,\nThe focus statement embeds statements:\n\n\nfocus_on​\nFacets​\n\nvalue (any type), (omissible) : The agent, list of agents, geometry to focus on\n\nDefinition​\nAllows to focus on the passed parameter in all available displays. Passing 'nil' for the parameter will make all screens return to their normal zoom\nUsages​\n\nFocuses on an agent, a geometry, a set of agents, etc...\n\nfocus_on my_species(0);\nEmbedments​\n\nThe focus_on statement is of type: Single statement\nThe focus_on statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe focus_on statement embeds statements:\n\n\ngenetic​\nFacets​\n\nname (an identifier), (omissible) : The name of this method. For internal use only\naggregation (a label), takes values in: {min, max, avr}: the agregation method\ncrossover_prob (float): crossover probability between two individual solutions\nimprove_sol (boolean): if true, use a hill climbing algorithm to improve the solutions at each generation\nmax_gen (int): number of generations\nmaximize (float): the value the algorithm tries to maximize\nminimize (float): the value the algorithm tries to minimize\nmutation_prob (float): mutation probability for an individual solution\nnb_prelim_gen (int): number of random populations used to build the initial population\npop_dim (int): size of the population (number of individual solutions)\nstochastic_sel (boolean): if true, use a stochastic selection algorithm (roulette) rather a determistic one (keep the best solutions)\n\nDefinition​\nThis is a simple implementation of Genetic Algorithms (GA). See the wikipedia article and [batch161 the batch dedicated page]. The principle of the GA is to search an optimal solution by applying evolution operators on an initial population of solutions. There are three types of evolution operators: crossover, mutation and selection. Different techniques can be applied for this selection. Most of them are based on the solution quality (fitness).\nUsages​\n\nAs other batch methods, the basic syntax of the genetic statement uses method genetic instead of the expected genetic name: id :\n\nmethod genetic [facet: value];\n\nFor example:\n\nmethod genetic maximize: food_gathered pop_dim: 5 crossover_prob: 0.7 mutation_prob: 0.1 nb_prelim_gen: 1 max_gen: 20; \nEmbedments​\n\nThe genetic statement is of type: Batch method\nThe genetic statement can be embedded into: Experiment,\nThe genetic statement embeds statements:\n\n\ngraphics​\nFacets​\n\nname (a label), (omissible) : the human readable title of the graphics\nbackground (rgb): the background color of the layer. Default is none\nborder (rgb): Color to apply to the border of the rectangular shape of the layer. Default is none\nfading (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.\nrefresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)\nrotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.\nsize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\ntrace (any type in [boolean, int]): Allows to aggregate the visualization at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.\ntransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)\nvisible (boolean): Defines whether this layer is visible or not\n\nDefinition​\ngraphics allows the modeler to freely draw shapes/geometries/texts without having to define a species. It works exactly like a species [Aspect161 aspect]: the draw statement can be used in the same way.\nUsages​\n\nThe general syntax is:\n\ndisplay my_display {    graphics \"my new layer\" {       draw circle(5) at: {10,10} color: #red;       draw \"test\" at: {10,10} size: 20 color: #black;    } }\n\nSee also: display, agents, chart, event, graphics, display_grid, image_layer, overlay, species_layer,\n\nEmbedments​\n\nThe graphics statement is of type: Layer\nThe graphics statement can be embedded into: display,\nThe graphics statement embeds statements:\n\n\nhighlight​\nFacets​\n\nvalue (agent), (omissible) : The agent to hightlight\ncolor (rgb): An optional color to highlight the agent. Note that this color will become the default color for further higlight operations\n\nDefinition​\nAllows to highlight the agent passed in parameter in all available displays, optionaly setting a color. Passing 'nil' for the agent will remove the current highlight\nUsages​\n\nHighlighting an agent\n\nhighlight my_species(0) color: #blue;\nEmbedments​\n\nThe highlight statement is of type: Single statement\nThe highlight statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe highlight statement embeds statements:\n\n\nhill_climbing​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\naggregation (a label), takes values in: {min, max, avr}: the agregation method\ninit_solution (map): init solution: key: name of the variable, value: value of the variable\niter_max (int): number of iterations. this number corresponds to the number of \"moves\" in the parameter space. For each move, the algorithm will test the whole neighborhood of the current solution, each neighbor corresponding to a particular set of parameters and thus to a run. Thus, there can be several runs per iteration (maximum: 2^(number of parameters)).\nmaximize (float): the value the algorithm tries to maximize\nminimize (float): the value the algorithm tries to minimize\n\nDefinition​\nThis algorithm is an implementation of the Hill Climbing algorithm. See the wikipedia article and [batch161 the batch dedicated page].\nUsages​\n\nAs other batch methods, the basic syntax of the hill_climbing statement uses method hill_climbing instead of the expected hill_climbing name: id :\n\nmethod hill_climbing [facet: value];\n\nFor example:\n\nmethod hill_climbing iter_max: 50 maximize : food_gathered; \nEmbedments​\n\nThe hill_climbing statement is of type: Batch method\nThe hill_climbing statement can be embedded into: Experiment,\nThe hill_climbing statement embeds statements:\n\n\nif​\nFacets​\n\ncondition (boolean), (omissible) : A boolean expression: the condition that is evaluated.\n\nDefinition​\nAllows the agent to execute a sequence of statements if and only if the condition evaluates to true.\nUsages​\n\nThe generic syntax is:\n\nif bool_expr {     [statements] }\n\nOptionally, the statements to execute when the condition evaluates to false can be defined in a following statement else. The syntax then becomes:\n\nif bool_expr {     [statements] } else {     [statements] } string valTrue <- \"\"; if true { \tvalTrue <- \"true\"; } else { \tvalTrue <- \"false\"; }  // valTrue equals \"true\" string valFalse <- \"\"; if false { \tvalFalse <- \"true\"; } else { \tvalFalse <- \"false\"; }  // valFalse equals \"false\"\n\nifs and elses can be imbricated as needed. For instance:\n\nif bool_expr {     [statements] } else if bool_expr2 {     [statements] } else {     [statements] }\nEmbedments​\n\nThe if statement is of type: Sequence of statements or action\nThe if statement can be embedded into: Behavior, Sequence of statements or action, Layer, Output,\nThe if statement embeds statements: else,\n\n\nimage_layer​\nFacets​\n\nname (any type), (omissible) : the name/path of the image (in the case of a raster image), a matrix of int, an image file\ncolor (rgb): in the case of a shapefile, this the color used to fill in geometries of the shapefile. In the case of an image, it is used to tint the image\ngis (any type in [file, string]): the name/path of the shape file (to display a shapefile as background, without creating agents from it)\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.\nrefresh (boolean): (openGL only) specify whether the image display is refreshed or not. (false by default, true should be used in cases of images that are modified over the simulation)\nrotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.\nsize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\ntransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)\nvisible (boolean): Defines whether this layer is visible or not\n\nDefinition​\nimage_layer allows modeler to display an image (e.g. as background of a simulation). Note that this image will not be dynamically changed or moved in OpenGL, unless the refresh: facet is set to true.\nUsages​\n\nThe general syntax is:\n\ndisplay my_display {    image image_file [additional options]; }\n\nFor instance, in the case of a bitmap image\n\ndisplay my_display {    image \"../images/my_backgound.jpg\"; }\n\nIf you already have your image stored in a matrix\n\ndisplay my_display {    image my_image_matrix; }\n\nOr in the case of a shapefile:\n\ndisplay my_display {    image testGIS gis: \"../includes/building.shp\" color: rgb('blue'); }\n\nIt is also possible to superpose images on different layers in the same way as for species using opengl display:\n\ndisplay my_display {   image \"../images/image1.jpg\";   image \"../images/image2.jpg\";   image \"../images/image3.jpg\" position: {0,0,0.5}; }\n\nSee also: display, agents, chart, event, graphics, display_grid, overlay, species_layer,\n\nEmbedments​\n\nThe image_layer statement is of type: Layer\nThe image_layer statement can be embedded into: display,\nThe image_layer statement embeds statements:\n\n\ninspect​\nFacets​\n\nname (any type), (omissible) : the identifier of the inspector\nattributes (list): the list of attributes to inspect. A list that can contain strings or pair<string,type>, or a mix of them. These can be variables of the species, but also attributes present in the attributes table of the agent. The type is necessary in that case\nrefresh (boolean): Indicates the condition under which this output should be refreshed (default is true)\ntype (an identifier), takes values in: {agent, table}: the way to inspect agents: in a table, or a set of inspectors\nvalue (any type): the set of agents to inspect, could be a species, a list of agents or an agent\n\nDefinition​\ninspect (and browse) statements allows modeler to inspect a set of agents, in a table with agents and all their attributes or an agent inspector per agent, depending on the type: chosen. Modeler can choose which attributes to display. When browse is used, type: default value is table, whereas wheninspect is used, type: default value is agent.\nUsages​\n\nAn example of syntax is:\n\ninspect \"my_inspector\" value: ant attributes: [\"name\", \"location\"];\nEmbedments​\n\nThe inspect statement is of type: Output\nThe inspect statement can be embedded into: output, permanent, Behavior, Sequence of statements or action,\nThe inspect statement embeds statements:\n\n\nlaw​\nFacets​\n\nname (an identifier), (omissible) : The name of the law\nall (boolean): add an obligation for each belief\nbelief (predicate): The mandatory belief\nbeliefs (list): The mandatory beliefs\nlifetime (int): the lifetime value of the mental state created\nnew_obligation (predicate): The predicate that will be added as an obligation\nnew_obligations (list): The list of predicates that will be added as obligations\nparallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.\nstrength (any type in [float, int]): The stregth of the mental state created\nthreshold (float): Threshold linked to the obedience value.\nwhen (boolean):\n\nDefinition​\nenables to add a desire or a belief or to remove a belief, a desire or an intention if the agent gets the belief or/and desire or/and condition mentioned.\nUsages​\n\nOther examples of use:\n\nrule belief: new_predicate(\"test\") when: flip(0.5) new_desire: new_predicate(\"test\");\nEmbedments​\n\nThe law statement is of type: Single statement\nThe law statement can be embedded into: Species, Model,\nThe law statement embeds statements:\n\n\nlayout​\nFacets​\n\nvalue (any type), (omissible) : Either #none, to indicate that no layout will be imposed, or one of the four possible predefined layouts: #stack, #split, #horizontal or #vertical. This layout will be applied to both experiment and simulation display views. In addition, it is possible to define a custom layout using the horizontal() and vertical() operators\nbackground (rgb): Whether the whole interface of GAMA should be colored or not (nil by default)\nconsoles (boolean): Whether the consoles are visible or not (true by default)\ncontrols (boolean): Whether the experiment should show its control toolbar on top or not\neditors (boolean): Whether the editors should initially be visible or not\nnavigator (boolean): Whether the navigator view is visible or not (false by default)\nparameters (boolean): Whether the parameters view is visible or not (true by default)\ntabs (boolean): Whether the displays should show their tab or not\ntoolbars (boolean): Whether the displays should show their toolbar or not\ntray (boolean): Whether the bottom tray is visible or not (true by default)\n\nDefinition​\nRepresents the layout of the display views of simulations and experiments\nUsages​\n\nFor instance, this layout statement will allow to split the screen occupied by displays in four equal parts, with no tabs. Pairs of display::weight represent the number of the display in their order of definition and their respective weight within a horizontal and vertical section\n\nlayout horizontal([vertical([0::5000,1::5000])::5000,vertical([2::5000,3::5000])::5000]) tabs: false;\nEmbedments​\n\nThe layout statement is of type: Output\nThe layout statement can be embedded into: output,\nThe layout statement embeds statements:\n\n\nlet​\nFacets​\n\nname (a new identifier), (omissible) : The name of the variable declared\nindex (a datatype identifier): The type of the index if this declaration concerns a container\nof (a datatype identifier): The type of the contents if this declaration concerns a container\ntype (a datatype identifier): The type of the variable\nvalue (any type): The value assigned to this variable\n\nDefinition​\nAllows to declare a temporary variable of the specified type and to initialize it with a value\nUsages​\nEmbedments​\n\nThe let statement is of type: Single statement\nThe let statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe let statement embeds statements:\n\n\nlight​\nFacets​\n\nname (string), (omissible) : The name of the light source, must be unique (otherwise the last definition prevails). Will be used to populate a menu where light sources can be easily turned on and off. Special names can be used:Using the special constant #ambient will allow to redefine or control the ambient light intensity and presenceUsing the special constant #default will replace the default directional light of the surrounding display\nactive (boolean): a boolean expression telling if the light is on or off. (default value if not specified : true)\nangle (float): the angle of the spot light in degree (only for spot light). (default value : 45)\ndirection (point): the direction of the light (only for direction and spot light). (default value : {0.5,0.5,-1})\ndynamic (boolean): specify if the parameters of the light need to be updated every cycle or treated as constants. (default value : true).\nintensity (any type in [int, rgb]): an int / rgb / rgba value to specify either the color+intensity of the light or simply its intensity. (default value if not specified can be set in the Preferences. If not, it is equal to: (160,160,160,255) ).\nlinear_attenuation (float): the linear attenuation of the positionnal light. (default value : 0)\nlocation (point): the location of the light (only for point and spot light) in model coordinates. Default is {0,0,20}\nquadratic_attenuation (float): the quadratic attenuation of the positionnal light. (default value : 0)\nshow (boolean): If true, draws the light source. (default value if not specified : false).\ntype (string): the type of light to create. A value among {#point, #direction, #spot}\n\nDefinition​\nlight allows to define diffusion lights in your 3D display. They must be given a name, which will help track them in the UI. Two names have however special meanings: #ambient, which designates the ambient luminosity and color of the scene (with a default intensity of (160,160,160,255) or the value set in the Preferences) and #default, which designates the default directional light applied to a scene (with a default medium intensity of (160,160,160,255) or the value set in the Preferences in the direction given by (0.5,0.5,1)). Redefining a light named #ambient or #regular will then modify these default lights (for example changing their color or deactivating them). To be more precise, and given all the default values of the facets, the existence of these two lights is effectively equivalent to redefining:light #ambient intensity: gama.pref_display_light_intensity; light #default type: #direction intensity: gama.pref_display_light_intensity direction: {0.5,0.5,-1};\nUsages​\n\nThe general syntax is:\n\nlight 1 type:point location:{20,20,20} color:255, linear_attenuation:0.01 quadratic_attenuation:0.0001 draw_light:true update:false; light 'spot1' type: #spot location:{20,20,20} direction:{0,0,-1} color:255 angle:25 linear_attenuation:0.01 quadratic_attenuation:0.0001 draw:true dynamic: false; light 'point2' type: #point direction:{1,1,-1} color:255 draw:true dynamic: false;\n\nSee also: display,\n\nEmbedments​\n\nThe light statement is of type: Layer\nThe light statement can be embedded into: display,\nThe light statement embeds statements:\n\n\nloop​\nFacets​\n\nname (a new identifier), (omissible) : a temporary variable name\nfrom (any type in [int, float]): an int or float expression that represents the lower bound of the loop\nover (any type in [container, point]): a list, point, matrix or map expression\nstep (any type in [int, float]): an int or float expression that represents the incrementation of the loop\ntimes (int): an int expression\nto (any type in [int, float]): an int or float expression that represents the higher bound of the loop\nwhile (boolean): a boolean expression\n\nDefinition​\nAllows the agent to perform the same set of statements either a fixed number of times, or while a condition is true, or by progressing in a collection of elements or along an interval of numbers. Be aware that there are no prevention of infinite loops. As a consequence, open loops should be used with caution, as one agent may block the execution of the whole model.\nUsages​\n\nThe basic syntax for repeating a fixed number of times a set of statements is:\n\nloop times: an_int_expression {      // [statements] }\n\nThe basic syntax for repeating a set of statements while a condition holds is:\n\nloop while: a_bool_expression {      // [statements] }\n\nThe basic syntax for repeating a set of statements by progressing over a container of a point is:\n\nloop a_temp_var over: a_collection_expression {      // [statements] }\n\nThe basic syntax for repeating a set of statements while an index iterates over a range of values with a fixed step of 1 is:\n\nloop a_temp_var from: int_expression_1 to: int_expression_2 {      // [statements] }\n\nThe incrementation step of the index can also be chosen:\n\nloop a_temp_var from: int_expression_1 to: int_expression_2 step: int_expression3 {      // [statements] }\n\nIn these latter three cases, the name facet designates the name of a temporary variable, whose scope is the loop, and that takes, in turn, the value of each of the element of the list (or each value in the interval). For example, in the first instance of the \"loop over\" syntax :\n\nint a <- 0; loop i over: [10, 20, 30] {      a <- a + i; } // a now equals 60\n\nThe second (quite common) case of the loop syntax allows one to use an interval of integers or floats. The from and to facets take an int or float expression as arguments, with the first (resp. the last) specifying the beginning (resp. end) of the inclusive interval (i.e. [to, from]). If the step is not defined, it is assumed to be equal to 1 or -1, depending on the direction of the range. If it is defined, its sign will be respected, so that a positive step will never allow the loop to enter a loop from i to j where i is greater than j\n\nlist the_list <-list (species_of (self)); loop i from: 0 to: length (the_list) - 1 {      ask the_list at i {         // ...      } } // every  agent of the list is asked to do something\nEmbedments​\n\nThe loop statement is of type: Sequence of statements or action\nThe loop statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe loop statement embeds statements:\n\n\nmatch​\nFacets​\n\nvalue (any type), (omissible) : The value or values this statement tries to match\n\nDefinition​\nIn a switch...match structure, the value of each match block is compared to the value in the switch. If they match, the embedded statement set is executed. Four kinds of match can be used, equality, containment, betweenness and regex matching\nUsages​\n\nmatch block is executed if the switch value is equals to the value of the match:\n\nswitch 3 {    match 1 {write \"Match 1\"; }    match 3 {write \"Match 2\"; } }\n\nmatch_between block is executed if the switch value is in the interval given in value of the match_between:\n\nswitch 3 {    match_between [1,2] {write \"Match OK between [1,2]\"; }    match_between [2,5] {write \"Match OK between [2,5]\"; } }\n\nmatch_one block is executed if the switch value is equals to one of the values of the match_one:\n\nswitch 3 {    match_one [0,1,2] {write \"Match OK with one of [0,1,2]\"; }    match_between [2,3,4,5] {write \"Match OK with one of [2,3,4,5]\"; } }\n\nSee also: switch, default,\n\nEmbedments​\n\nThe match statement is of type: Sequence of statements or action\nThe match statement can be embedded into: switch,\nThe match statement embeds statements:\n\n\nmesh​\nFacets​\n\nsource (any type in [file, matrix, species]), (omissible) : Allows to specify the elevation of each cell by passing a grid, a raster, image or csv file or directly a matrix of int/float. The dimensions of the field are those of the file or matrix.\nabove (float): Can be used to specify a 'minimal' value under which the render will not render the cells with this value\nborder (rgb): the color to draw lines (borders of cells)\ncolor (any type in [rgb, list, map]): if true, and if neither 'grayscale' or 'texture' are specified, displays the field using the given color or colors. List of colors, palettes (with interpolation), gradients and scales are supported\ngrayscale (boolean): if true, gives a grey color to each polygon depending on its elevation (false by default). Supersedes 'color' if it is defined.\nno_data (float): Can be used to specify a 'no_data' value, forcing the renderer to not render the cells with this value. If not specified, that value will be searched in the field to display\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer.\nrefresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, but should be deactivated if the field is static)\nrotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.\nscale (float): Represents the z-scaling factor, which allows to scale all values of the field.\nsize (any type in [point, float]): Represents the extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions. This latter possibility allows to limit the height of the field. If only a flat value is provided, it is considered implicitly as the z maximal amplitude (or z scaling factor if < 1)\nsmooth (any type in [boolean, int]): Applies a simple convolution (box filter) to smooth out the terrain produced by this field. If true, one pass is done with a simple 3x3 kernel. Otherwise, the user can specify the number of successive passes (up to 4). Specifying 0 is equivalent to passing false\ntext (boolean): specify whether the value that represents the elevation is displayed on each cell (false by default)\ntexture (file): A file  containing the texture image to be applied to the field. If not specified, the field will be displayed either in color or grayscale, depending on the other facets\ntransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)\ntriangulation (boolean): specifies wether the cells of th field will be triangulated: if it is false, they will be displayed as horizontal squares at a given elevation, whereas if it is true, cells will be triangulated and linked to neighbors in order to have a continuous surface (false by default)\nvisible (boolean): Defines whether this layer is visible or not\nwireframe (boolean): if true displays the field in wireframe using the lines color\n\nDefinition​\nAllows the modeler to display in an optimized way a field of values, optionally using elevation. Useful for displaying DEMs, for instance, without having to load them into a grid. Can be fed with a matrix of int/float, a grid, a csv/raster/image file and supports many visualisation options\nUsages​\n\nThe general syntax is:\n\ndisplay my_display {    field a_filename lines: #black position: { 0.5, 0 } size: {0.5,0.5} triangulated: true texture: anothe_file; }\n\nSee also: display, agents, grid, event, graphics, image, overlay, species_layer,\n\nEmbedments​\n\nThe mesh statement is of type: Layer\nThe mesh statement can be embedded into: display,\nThe mesh statement embeds statements:\n\n\nmigrate​\nFacets​\n\nsource (any type in [agent, species, container, an identifier]), (omissible) : can be an agent, a list of agents, a agent's population to be migrated\ntarget (species): target species/population that source agent(s) migrate to.\nreturns (a new identifier): the list of returned agents in a new local variable\n\nDefinition​\nThis command permits agents to migrate from one population/species to another population/species and stay in the same host after the migration. Species of source agents and target species respect the following constraints: (i) they are \"peer\" species (sharing the same direct macro-species), (ii) they have sub-species vs. parent-species relationship.\nUsages​\n\nIt can be used in a 3-levels model, in case where individual agents can be captured into group meso agents and groups into clouds macro agents. migrate is used to allows agents captured by groups to migrate into clouds. See the model 'Balls, Groups and Clouds.gaml' in the library.\n\nmigrate ball_in_group target: ball_in_cloud;\n\nSee also: capture, release,\n\nEmbedments​\n\nThe migrate statement is of type: Sequence of statements or action\nThe migrate statement can be embedded into: Behavior, Sequence of statements or action,\nThe migrate statement embeds statements:\n\n\nmonitor​\nFacets​\n\nname (a label), (omissible) : identifier of the monitor\nvalue (any type): expression that will be evaluated to be displayed in the monitor\ncolor (rgb): Indicates the (possibly dynamic) color of this output (default is a light gray)\nrefresh (boolean): Indicates the condition under which this output should be refreshed (default is true)\n\nDefinition​\nA monitor allows to follow the value of an arbitrary expression in GAML.\nUsages​\n\nAn example of use is:\n\nmonitor \"nb preys\" value: length(prey as list) refresh_every: 5;  \nEmbedments​\n\nThe monitor statement is of type: Output\nThe monitor statement can be embedded into: output, permanent,\nThe monitor statement embeds statements:\n\n\nmorris​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\nlevels (an identifier): Number of level for the Morris method, can't be 1\noutputs (list): The list of output variables to analyze through morris method\nreport (string): The path to the file where the Morris report will be written\nsample (an identifier): The size of the sample for Morris samples\ncsv (string): The path of morris sample .csv file. If don't use, automatic morris sampling will be perform and saved in the corresponding file\nresults (string): The path to the file where the automatic batch report will be written\n\nDefinition​\nThis algorithm runs a Morris exploration - it has been built upon the SILAB librairy - disabled the repeat facet of the experiment\nUsages​\n\nFor example:\n\nmethod morris sample_size:100 nb_levels:4 outputs:['my_var'] report:'../path/to/report.txt;\nEmbedments​\n\nThe morris statement is of type: Batch method\nThe morris statement can be embedded into: Experiment,\nThe morris statement embeds statements:\n\n\nnorm​\nFacets​\n\nname (an identifier), (omissible) : the name of the norm\nfinished_when (boolean): the boolean condition when the norm is finished\ninstantaneous (boolean): indicates if the norm is instananeous\nintention (predicate): the intention triggering the norm\nlifetime (int): the lifetime of the norm\nobligation (predicate): the obligation triggering of the norm\npriority (float): the priority value of the norm\nthreshold (float): the threshold to trigger the norm\nwhen (boolean): the boolean condition when the norm is active\n\nDefinition​\na norm indicates what action the agent has to do in a certain context and with and obedience value higher than the threshold\nUsages​\nEmbedments​\n\nThe norm statement is of type: Behavior\nThe norm statement can be embedded into: Species, Model,\nThe norm statement embeds statements:\n\n\noutput​\nFacets​\n\nautosave (any type in [boolean, string]): Allows to save the whole screen on disk. A value of true/false will save it with the resolution of the physical screen. Passing it a string allows to define the filename Note that setting autosave to true (or to any other value than false) in a display will synchronize all the displays defined in the experiment\nsynchronized (boolean): Indicates whether the displays that compose this output should be synchronized with the simulation cycles\n\nDefinition​\noutput blocks define how to visualize a simulation (with one or more display blocks that define separate windows). It will include a set of displays, monitors and files statements. It will be taken into account only if the experiment type is gui.\nUsages​\n\nIts basic syntax is:\n\nexperiment exp_name type: gui {    // [inputs]    output {       // [display, file, inspect, layout or monitor statements]    } }\n\nSee also: display, monitor, inspect, output_file, layout,\n\nEmbedments​\n\nThe output statement is of type: Output\nThe output statement can be embedded into: Model, Experiment,\nThe output statement embeds statements: display,  inspect,  layout,  monitor,  output_file,\n\n\noutput_file​\nFacets​\n\nname (an identifier), (omissible) : The name of the file where you want to export the data\ndata (string): The data you want to export\nfooter (string): Define a footer for your export file\nheader (string): Define a header for your export file\nrefresh (boolean): Indicates the condition under which this file should be saved (default is true)\nrewrite (boolean): Rewrite or not the existing file\ntype (an identifier), takes values in: {csv, text, xml}: The type of your output data\n\nDefinition​\nRepresents an output that writes the result of expressions into a file\nUsages​\nEmbedments​\n\nThe output_file statement is of type: Output\nThe output_file statement can be embedded into: output, permanent,\nThe output_file statement embeds statements:\n\n\noverlay​\nFacets​\n\nbackground (rgb): the background color of the overlay displayed inside the view (the bottom overlay remains black)\nborder (rgb): Color to apply to the border of the rectangular shape of the overlay. Nil by default\ncenter (any type): an expression that will be evaluated and displayed in the center section of the bottom overlay\ncolor (any type in [list, rgb]): the color(s) used to display the expressions given in the 'left', 'center' and 'right' facets\nleft (any type): an expression that will be evaluated and displayed in the left section of the bottom overlay\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.\nright (any type): an expression that will be evaluated and displayed in the right section of the bottom overlay\nrounded (boolean): Whether or not the rectangular shape of the overlay should be rounded. True by default\nsize (point): extent of the layer in the view from its position. Coordinates in [0,1[ are treated as percentages of the total surface of the view, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Unlike  'position', no elevation can be provided with the z coordinate\ntransparency (float): the transparency rate of the overlay (between 0 -- opaque and 1 -- fully transparent) when it is displayed inside the view. The bottom overlay will remain at 0.75\nvisible (boolean): Defines whether this layer is visible or not\n\nDefinition​\noverlay allows the modeler to display a line to the already existing bottom overlay, where the results of 'left', 'center' and 'right' facets, when they are defined, are displayed with the corresponding color if defined.\nUsages​\n\nTo display information in the bottom overlay, the syntax is:\n\noverlay \"Cycle: \" + (cycle) center: \"Duration: \" + total_duration + \"ms\" right: \"Model time: \" + as_date(time,\"\") color: [#yellow, #orange, #yellow];\n\nSee also: display, agents, chart, event, graphics, display_grid, image, species_layer,\n\nEmbedments​\n\nThe overlay statement is of type: Layer\nThe overlay statement can be embedded into: display,\nThe overlay statement embeds statements:\n\n\nparameter​\nFacets​\n\nvar (an identifier): the name of the variable (that should be declared in global)\nname (a label), (omissible) : The message displayed in the interface\namong (list): the list of possible values that this parameter can take\ncategory (a label): a category label, used to group parameters in the interface\ncolors (list): The colors of the control in the UI. An empty list has no effects. Only used for sliders and switches so far. For sliders, 3 colors will allow to specify the color of the left section, the thumb and the right section (in this order); 2 colors will define the left and right sections only (thumb will be dark green); 1 color will define the left section and the thumb. For switches, 2 colors will define the background for respectively the left 'true' and right 'false' sections. 1 color will define both backgrounds\ndisables (list): a list of global variables whose parameter editors will be disabled when this parameter value is set to true or to a value that casts to true (they are otherwise enabled)\nenables (list): a list of global variables whose parameter editors will be enabled when this parameter value is set to true or to a value that casts to true (they are otherwise disabled)\nextensions (list): Makes only sense for file parameters. A list of file extensions (like 'gaml', 'shp', etc.) that restricts the choice offered to the users to certain file types (folders not concerned). Default is empty, effectively accepting all files\nin_workspace (boolean): Makes only sense for file parameters. Whether the file selector will be restricted to the workspace or not\ninit (any type): the init value\nlabels (list): The labels that will be displayed for switches (instead of True/False)\nmax (any type): the maximum value\nmin (any type): the minimum value\non_change (any type): Provides a block of statements that will be executed whenever the value of the parameter changes\nread_only (boolean): Whether this parameter is read-only or editable\nslider (boolean): Whether or not to display a slider for entering an int or float value. Default is true when max and min values are defined, false otherwise. If no max or min value is defined, setting this facet to true will have no effect\nstep (float): the increment step (mainly used in batch mode to express the variation step between simulation)\ntype (a datatype identifier): the variable type\nunit (a label): the variable unit\nupdates (list): a list of global variables whose parameter editors will be updated when this parameter value is changed (their min, max, step and among values will be updated accordingly if they depend on this parameter. Note that it might lead to some inconsistencies, for instance a parameter value which becomes out of range, or which does not belong anymore to a list of possible values. In these cases, the value of the affected parameter will not change)\n\nDefinition​\nThe parameter statement specifies which global attributes (i) will change through the successive simulations (in batch experiments), (ii) can be modified by user via the interface (in gui experiments). In GUI experiments, parameters are displayed depending on their type.\nUsages​\n\nIn gui experiment, the general syntax is the following:\n\nparameter title var: global_var category: cat;\n\nIn batch experiment, the two following syntaxes can be used to describe the possible values of a parameter:\n\nparameter 'Value of toto:' var: toto among: [1, 3, 7, 15, 100];  parameter 'Value of titi:' var: titi min: 1 max: 100 step: 2; \nEmbedments​\n\nThe parameter statement is of type: Parameter\nThe parameter statement can be embedded into: Experiment,\nThe parameter statement embeds statements:\n\n\nperceive​\nFacets​\n\ntarget (any type in [container, agent]): the list of the agent you want to perceive\nname (an identifier), (omissible) : the name of the perception\nas (species): an expression that evaluates to a species\nemotion (emotion): The emotion needed to do the perception\nin (any type in [float, geometry]): a float or a geometry. If it is a float, it's a radius of a detection area. If it is a geometry, it is the area of detection of others species.\nparallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.\nthreshold (float): Threshold linked to the emotion.\nwhen (boolean): a boolean to tell when does the perceive is active\n\nDefinition​\nAllow the agent, with a bdi architecture, to perceive others agents\nUsages​\n\nthe basic syntax to perceive agents inside a circle of perception\n\nperceive name_of_perception target: the_agents_you_want_to_perceive in: distance when: condition { \t//Here you are in the context of the perceived agents. To refer to the agent who does the perception, use myself. \t//If you want to make an action (such as adding a belief for example), use ask myself{ do the_action} }\nEmbedments​\n\nThe perceive statement is of type: Sequence of statements or action\nThe perceive statement can be embedded into: Species, Model,\nThe perceive statement embeds statements:\n\n\npermanent​\nFacets​\n\nsynchronized (boolean): Indicates whether the displays that compose this output should be synchronized with the simulation cycles\n\nDefinition​\nRepresents the outputs of the experiment itself. In a batch experiment, the permanent section allows to define an output block that will NOT be re-initialized at the beginning of each simulation but will be filled at the end of each simulation.\nUsages​\n\nFor instance, this permanent section will allow to display for each simulation the end value of the food_gathered variable:\n\npermanent { \tdisplay Ants background: rgb('white') refresh_every: 1 { \t\tchart \"Food Gathered\" type: series { \t\t\tdata \"Food\" value: food_gathered; \t\t} \t} }\nEmbedments​\n\nThe permanent statement is of type: Output\nThe permanent statement can be embedded into: Experiment,\nThe permanent statement embeds statements: display,  inspect,  monitor,  output_file,\n\n\nplan​\nFacets​\n\nname (an identifier), (omissible) :\nemotion (emotion):\nfinished_when (boolean):\ninstantaneous (boolean):\nintention (predicate):\npriority (float):\nthreshold (float):\nwhen (boolean):\n\nDefinition​\ndefine an action plan performed by an agent using the BDI engine\nUsages​\nEmbedments​\n\nThe plan statement is of type: Behavior\nThe plan statement can be embedded into: Species, Model,\nThe plan statement embeds statements:\n\n\npso​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\niter_max (int): number of iterations\naggregation (a label), takes values in: {min, max, avr}: the agregation method\nmaximize (float): the value the algorithm tries to maximize\nminimize (float): the value the algorithm tries to minimize\nnum_particles (int): number of particles\nweight_cognitive (float): weight for the cognitive component\nweight_inertia (float): weight for the inertia component\nweight_social (float): weight for the social component\n\nDefinition​\nThis algorithm is an implementation of the Particle Swarm Optimization algorithm. Only usable for numerical paramaters and based on a continuous parameter space search. See the wikipedia article for more details.\nUsages​\n\nAs other batch methods, the basic syntax of the pso statement uses method pso instead of the expected pso name: id :\n\nmethod pso [facet: value];\n\nFor example:\n\nmethod pso iter_max: 50 num_particles: 10 weight_inertia:0.7 weight_cognitive: 1.5 weight_social: 1.5 maximize: food_gathered; \nEmbedments​\n\nThe pso statement is of type: Batch method\nThe pso statement can be embedded into: Experiment,\nThe pso statement embeds statements:\n\n\nput​\nFacets​\n\nin (any type in [container, species, agent, geometry]): an expression that evaluates to a container\nitem (any type), (omissible) : any expression\nall (any type): any expression\nat (any type): any expression\nkey (any type): any expression\n\nDefinition​\nAllows the agent to replace a value in a container at a given position (in a list or a map) or for a given key (in a map). Note that the behavior and the type of the attributes depends on the specific kind of container.\nUsages​\n\nThe allowed parameters configurations are the following ones:\n\nput expr at: expr in: expr_container; put all: expr in: expr_container;\n\nIn the case of a list, the position should be an integer in the bound of the list. The facet all: is used to replace all the elements of the list by the given value.\n\nlist<int>putList <- [1,2,3,4,5];  // putList equals [1,2,3,4,5] put -10 at: 1 in: putList; // putList equals [1,-10,3,4,5] put 10 all: true in: putList; // putList equals [10,10,10,10,10]\n\nIn the case of a matrix, the position should be a point in the bound of the matrix. The facet all: is used to replace all the elements of the matrix by the given value.\n\nmatrix<int>putMatrix <- matrix([[0,1],[2,3]]);  // putMatrix equals matrix([[0,1],[2,3]]) put -10 at: {1,1} in: putMatrix; // putMatrix equals matrix([[0,1],[2,-10]]) put 10 all: true in: putMatrix; // putMatrix equals matrix([[10,10],[10,10]])\n\nIn the case of a map, the position should be one of the key values of the map. Notice that if the given key value does not exist in the map, the given pair key::value will be added to the map. The facet all is used to replace the value of all the pairs of the map.\n\nmap<string,int>putMap <- [\"x\"::4,\"y\"::7];  // putMap equals [\"x\"::4,\"y\"::7] put -10 key: \"y\" in: putMap; // putMap equals [\"x\"::4,\"y\"::-10] put -20 key: \"z\" in: putMap; // putMap equals [\"x\"::4,\"y\"::-10, \"z\"::-20] put -30 all: true in: putMap; // putMap equals [\"x\"::-30,\"y\"::-30, \"z\"::-30]\nEmbedments​\n\nThe put statement is of type: Single statement\nThe put statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,\nThe put statement embeds statements:\n\n\nreactive_tabu​\nFacets​\n\nname (an identifier), (omissible) :\naggregation (a label), takes values in: {min, max, avr}: the agregation method\ncycle_size_max (int): minimal size of the considered cycles\ncycle_size_min (int): maximal size of the considered cycles\ninit_solution (map): init solution: key: name of the variable, value: value of the variable\niter_max (int): number of iterations. this number corresponds to the number of \"moves\" in the parameter space. For each move, the algorithm will test the whole neighborhood of the current solution, each neighbor corresponding to a particular set of parameters and thus to a run. Thus, there can be several runs per iteration (maximum: 2^(number of parameters)).\nmaximize (float): the value the algorithm tries to maximize\nminimize (float): the value the algorithm tries to minimize\nnb_tests_wthout_col_max (int): number of movements without collision before shortening the tabu list\ntabu_list_size_init (int): initial size of the tabu list\ntabu_list_size_max (int): maximal size of the tabu list\ntabu_list_size_min (int): minimal size of the tabu list\n\nDefinition​\nThis algorithm is a simple implementation of the Reactive Tabu Search algorithm ((Battiti et al., 1993)). This Reactive Tabu Search is an enhance version of the Tabu search. It adds two new elements to the classic Tabu Search. The first one concerns the size of the tabu list: in the Reactive Tabu Search, this one is not constant anymore but it dynamically evolves according to the context. Thus, when the exploration process visits too often the same solutions, the tabu list is extended in order to favor the diversification of the search process. On the other hand, when the process has not visited an already known solution for a high number of iterations, the tabu list is shortened in order to favor the intensification of the search process. The second new element concerns the adding of cycle detection capacities. Thus, when a cycle is detected, the process applies random movements in order to break the cycle. See the batch dedicated page.\nUsages​\n\nAs other batch methods, the basic syntax of the reactive_tabu statement uses method reactive_tabu instead of the expected reactive_tabu name: id :\n\nmethod reactive_tabu [facet: value];\n\nFor example:\n\nmethod reactive_tabu iter_max: 50 tabu_list_size_init: 5 tabu_list_size_min: 2 tabu_list_size_max: 10 nb_tests_wthout_col_max: 20 cycle_size_min: 2 cycle_size_max: 20 maximize: food_gathered;\nEmbedments​\n\nThe reactive_tabu statement is of type: Batch method\nThe reactive_tabu statement can be embedded into: Experiment,\nThe reactive_tabu statement embeds statements:\n\n\nreflex​\nFacets​\n\nname (an identifier), (omissible) : the identifier of the reflex\nwhen (boolean): an expression that evaluates a boolean, the condition to fulfill in order to execute the statements embedded in the reflex.\n\nDefinition​\nReflexes are sequences of statements that can be executed by the agent. Reflexes prefixed by the 'reflex' keyword are executed continuously. Reflexes prefixed by 'init' are executed only immediately after the agent has been created. Reflexes prefixed by 'abort' just before the agent is killed. If a facet when: is defined, a reflex is executed only if the boolean expression evaluates to true.\nUsages​\n\nExample:\n\nreflex my_reflex when: flip (0.5){ \t\t//Only executed when flip returns true     write \"Executing the unconditional reflex\"; }\nEmbedments​\n\nThe reflex statement is of type: Behavior\nThe reflex statement can be embedded into: Species, Experiment, Model,\nThe reflex statement embeds statements:\n\n\nrelease​\nFacets​\n\ntarget (any type in [agent, list, attributes]), (omissible) : an expression that is evaluated as an agent/a list of the agents to be released or an agent saved as a map\nas (species): an expression that is evaluated as a species in which the micro-agent will be released\nin (agent): an expression that is evaluated as an agent that will be the macro-agent in which micro-agent will be released, i.e. their new host\nreturns (a new identifier): a new variable containing a list of the newly released agent(s)\n\nDefinition​\nAllows an agent to release its micro-agent(s). The preliminary for an agent to release its micro-agents is that species of these micro-agents are sub-species of other species (cf. [Species161#Nesting_species Nesting species]). The released agents won't be micro-agents of the calling agent anymore. Being released from a macro-agent, the micro-agents will change their species and host (macro-agent).\nUsages​\n\nWe consider the following species. Agents of \"C\" species can be released from a \"B\" agent to become agents of \"A\" species. Agents of \"D\" species cannot be released from the \"A\" agent because species \"D\" has no parent species.\n\nspecies A { ... } species B { ...    species C parent: A {    ...    }    species D {    ...    } ... }\n\nTo release all \"C\" agents from a \"B\" agent, agent \"C\" has to execute the following statement. The \"C\" agent will change to \"A\" agent. The won't consider \"B\" agent as their macro-agent (host) anymore. Their host (macro-agent) will the be the host (macro-agent) of the \"B\" agent.\n\nrelease list(C);\n\nThe modeler can specify the new host and the new species of the released agents:\n\nrelease list (C) as: new_species in: new host;\n\nSee also: capture,\n\nEmbedments​\n\nThe release statement is of type: Sequence of statements or action\nThe release statement can be embedded into: Behavior, Sequence of statements or action,\nThe release statement embeds statements:\n\n\nremove​\nFacets​\n\nfrom (any type in [container, species, agent, geometry]): an expression that evaluates to a container\nitem (any type), (omissible) : any expression to remove from the container\nall (any type): an expression that evaluates to a container. If it is true and if the value a list, it removes the first instance of each element of the list. If it is true and the value is not a container, it will remove all instances of this value.\nindex (any type): any expression, the key at which to remove the element from the container\nkey (any type): any expression, the key at which to remove the element from the container\n\nDefinition​\nAllows the agent to remove an element from a container (a list, matrix, map...).\nUsages​\n\nThis statement should be used in the following ways, depending on the kind of container used and the expected action on it:\n\nremove expr from: expr_container; remove index: expr from: expr_container; remove key: expr from: expr_container; remove all: expr from: expr_container;\n\nIn the case of list, the facet item: is used to remove the first occurence of a given expression, whereas all is used to remove all the occurrences of the given expression.\n\nlist<int> removeList <- [3,2,1,2,3]; remove 2 from: removeList; // removeList equals [3,1,2,3] remove 3 all: true from: removeList; // removeList equals [1,2] remove index: 1 from: removeList; // removeList equals [1]\n\nIn the case of map, the facet key: is used to remove the pair identified by the given key.\n\nmap<string,int> removeMap <- [\"x\"::5, \"y\"::7, \"z\"::7]; remove key: \"x\" from: removeMap; // removeMap equals [\"y\"::7, \"z\"::7] remove 7 all: true from: removeMap; // removeMap equals map([])\n\nIn addition, a map a be managed as a list with pair key as index. Given that, facets item:, all: and index: can be used in the same way:\n\nmap<string,int> removeMapList <- [\"x\"::5, \"y\"::7, \"z\"::7, \"t\"::5]; remove 7 from: removeMapList; // removeMapList equals [\"x\"::5, \"z\"::7, \"t\"::5] remove [5,7] all: true from: removeMapList; // removeMapList equals [\"t\"::5] remove index: \"t\" from: removeMapList; // removeMapList equals map([])\n\nIn the case of a graph, both edges and nodes can be removes using node: and edge facets. If a node is removed, all edges to and from this node are also removed.\n\ngraph removeGraph <- as_edge_graph([{1,2}::{3,4},{3,4}::{5,6}]); remove node: {1,2} from: removeGraph; remove node(1,2) from: removeGraph; list var <- removeGraph.vertices; // var equals [{3,4},{5,6}] list var <- removeGraph.edges; // var equals [polyline({3,4}::{5,6})] remove edge: {3,4}::{5,6} from: removeGraph; remove edge({3,4},{5,6}) from: removeGraph; list var <- removeGraph.vertices; // var equals [{3,4},{5,6}] list var <- removeGraph.edges; // var equals []\n\nIn the case of an agent or a shape, remove allows to remove an attribute from the attributes map of the receiver. However, for agents, it will only remove attributes that have been added dynamically, not the ones defined in the species or in its built-in parent.\n\nglobal {    init {       create speciesRemove;       speciesRemove sR <- speciesRemove(0); \t// sR.a now equals 100       remove key:\"a\" from: sR; \t// sR.a now equals nil    } }  species speciesRemove {    int a <- 100;  }\n\nThis statement can not be used on matrix.\nSee also: add, put,\n\nEmbedments​\n\nThe remove statement is of type: Single statement\nThe remove statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,\nThe remove statement embeds statements:\n\n\nrestore​\nFacets​\n\ntarget (agent), (omissible) : The agent to restore. Its attributes will be replaced by the ones stored in the file or string. No verification is done regarding the compatibility\nfrom (any type in [string, file]): The file or the string from which to restore the agent\n\nDefinition​\nAllows to restore any agent that has been previously serialised or saved to a file, e.g. string s <- serialize(a, 'json'); ...  restore a from: s;  or save simulation to: 'sim.gsim' format: binary; ... restore simulation from: file('sim.gsim') \nUsages​\nEmbedments​\n\nThe restore statement is of type: Single statement\nThe restore statement can be embedded into: Behavior, Sequence of statements or action,\nThe restore statement embeds statements:\n\n\nreturn​\nFacets​\n\nvalue (any type), (omissible) : an expression that is returned\n\nDefinition​\nAllows to immediately stop and tell which value to return from the evaluation of the surrounding action or top-level statement (reflex, init, etc.). Usually used within the declaration of an action. For more details about actions, see the following [Section161 section].\nUsages​\n\nExample:\n\nstring foo {      return \"foo\"; }  reflex {     string foo_result <- foo(); \t// foos_result is now equals to \"foo\" }\n\nIn the specific case one wants an agent to ask another agent to execute a statement with a return, it can be done similarly to:\n\n// In Species A: string foo_different {      return \"foo_not_same\"; } /// .... // In Species B: reflex writing {     string temp <- some_agent_A.foo_different []; \t// temp is now equals to \"foo_not_same\"  }\nEmbedments​\n\nThe return statement is of type: Single statement\nThe return statement can be embedded into: action, Behavior, Sequence of statements or action,\nThe return statement embeds statements:\n\n\nrotation​\nFacets​\n\nangle (any type in [float, int]), (omissible) : Defines the angle of rotation around the axis. No default defined.\naxis (point): The axis of rotation, defined by a vector. Default is {0,0,1} (rotation around the z axis)This facet can be complemented by 'distance:' and/or 'location:' to specify from where the target is looked at. If 'target:' is not defined, the default target is the centroid of the world shape.\ndynamic (boolean): If true, the rotation is applied every step. Default is false.\nlocation (point): Allows to define the center of the rotation. Defaut value is not specified is the center of mass of the world (i.e. {width/2, height/2, max(width, height) / 2})\n\nDefinition​\ncamera allows the modeler to define a camera. The display will then be able to choose among the camera defined (either within this statement or globally in GAMA) in a dynamic way. Several preset cameras are provided and accessible in the preferences (to choose the default) or in GAML using the keywords #from_above, #from_left, #from_right, #from_up_right, #from_up_left, #from_front, #from_up_front.These cameras are unlocked (so that they can be manipulated by the user), look at the center of the world from a symbolic position, and the distance between this position and the target is equal to the maximum of the width and height of the world's shape. These preset cameras can be reused when defining new cameras, since their names can become symbolic positions for them. For instance: camera 'my_camera' location: #from_top distance: 10; will lower (or extend) the distance between the camera and the center of the world to 10. camera 'my_camera' locked: true location: #from_up_front target: people(0); will continuously follow the first agent of the people species from the up-front position.\nUsages​\n\nSee also: display, agents, chart, event, graphics, display_grid, image_layer, species_layer,\n\nEmbedments​\n\nThe rotation statement is of type: Layer\nThe rotation statement can be embedded into: display,\nThe rotation statement embeds statements:\n\n\nrule​\nFacets​\n\nname (an identifier), (omissible) : the identifier of the rule\nwhen (boolean): The condition to fulfill in order to execute the statements embedded in the rule. when: true makes the rule always activable\npriority (float): An optional priority for the rule, which is used to sort activable rules and run them in that order\n\nDefinition​\nA simple definition of a rule (set of statements which execution depend on a condition and a priority).\nUsages​\nEmbedments​\n\nThe rule statement is of type: Behavior\nThe rule statement can be embedded into: rules, Species, Experiment, Model,\nThe rule statement embeds statements:\n\n\nrule​\nFacets​\n\nname (an identifier), (omissible) : The name of the rule\nall (boolean): add a desire for each belief\nbelief (predicate): The mandatory belief\nbeliefs (list): The mandatory beliefs\ndesire (predicate): The mandatory desire\ndesires (list): The mandatory desires\nemotion (emotion): The mandatory emotion\nemotions (list): The mandatory emotions\nideal (predicate): The mandatory ideal\nideals (list): The mandatory ideals\nlifetime (any type in [int, list]): the lifetime value of the mental state created\nnew_belief (predicate): The belief that will be added\nnew_beliefs (list): The belief that will be added\nnew_desire (predicate): The desire that will be added\nnew_desires (list): The desire that will be added\nnew_emotion (emotion): The emotion that will be added\nnew_emotions (list): The emotion that will be added\nnew_ideal (predicate): The ideal that will be added\nnew_ideals (list): The ideals that will be added\nnew_uncertainties (list): The uncertainty that will be added\nnew_uncertainty (predicate): The uncertainty that will be added\nobligation (predicate): The mandatory obligation\nobligations (list): The mandatory obligations\nparallel (any type in [boolean, int]): setting this facet to 'true' will allow 'perceive' to use concurrency with a parallel_bdi architecture; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet is true by default.\nremove_belief (predicate): The belief that will be removed\nremove_beliefs (list): The belief that will be removed\nremove_desire (predicate): The desire that will be removed\nremove_desires (list): The desire that will be removed\nremove_emotion (emotion): The emotion that will be removed\nremove_emotions (list): The emotion that will be removed\nremove_ideal (predicate): The ideal that will be removed\nremove_ideals (list): The ideals that will be removed\nremove_intention (predicate): The intention that will be removed\nremove_obligation (predicate): The obligation that will be removed\nremove_obligations (list): The obligation that will be removed\nremove_uncertainties (list): The uncertainty that will be removed\nremove_uncertainty (predicate): The uncertainty that will be removed\nstrength (any type in [float, int, list]): The stregth of the mental state created\nthreshold (float): Threshold linked to the emotion.\nuncertainties (list): The mandatory uncertainties\nuncertainty (predicate): The mandatory uncertainty\nwhen (boolean):\n\nDefinition​\nenables to add a desire or a belief or to remove a belief, a desire or an intention if the agent gets the belief or/and desire or/and condition mentioned.\nUsages​\nEmbedments​\n\nThe rule statement is of type: Single statement\nThe rule statement can be embedded into: simple_bdi, parallel_bdi, Species, Model,\nThe rule statement embeds statements:\n\n\nrun​\nFacets​\n\nname (string), (omissible) : Indicates the name of the experiment to run\nof (string): Indicates the model containing the experiment to run\ncore (int): Indicates the number of cores to use to run the experiments\nend_cycle (int): Indicates the cycle at which the experiment should stop\nseed (int): Provides a predetermined seed instead of letting GAMA choose one\nwith_output (map): This needs to be docummented\nwith_param (map): The parameters to pass to the new experiment\n\nEmbedments​\n\nThe run statement is of type: Sequence of statements or action\nThe run statement can be embedded into: Behavior, Single statement, Species, Model,\nThe run statement embeds statements:\n\n\nsanction​\nFacets​\n\nname (an identifier), (omissible) :\n\nDefinition​\ndeclare the actions an agent execute when enforcing norms of others during a perception\nUsages​\nEmbedments​\n\nThe sanction statement is of type: Behavior\nThe sanction statement can be embedded into: Species, Model,\nThe sanction statement embeds statements:\n\n\nsave​\nFacets​\n\ndata (any type), (omissible) : the data that will be saved to the file or the file itself to save when data is used in its simplest form\nattributes (any type in [map, list]): Allows to specify the attributes of a shape file or GeoJson file where agents are saved. Can be expressed as a list of string or as a literal map. When expressed as a list, each value should represent the name of an attribute of the shape or agent. The keys of the map are the names of the attributes that will be present in the file, the values are whatever expressions neeeded to define their value.\ncrs (any type): the name of the projection, e.g. crs:\"EPSG:4326\" or its EPSG id, e.g. crs:4326. Here a list of the CRS codes (and EPSG id): http://spatialreference.org\nformat (string): a string representing the format of the output file (e.g. \"shp\", \"asc\", \"geotiff\", \"png\", \"text\", \"csv\"). If the file extension is non ambiguous in facet 'to:', this format does not need to be specified. However, in many cases, it can be useful to do it (for instance, when saving a string to a .pgw file, it is always better to clearly indicate that the expected format is 'text').\nheader (boolean): an expression that evaluates to a boolean, specifying whether the save will write a header if the file does not exist\nrewrite (boolean): a boolean expression specifying whether to erase the file if it exists or append data at the end of it. Only applicable to \"text\" or \"csv\" files. Default is true\nto (string): an expression that evaluates to an string, the path to the file, or directly to a file\n\nDefinition​\nAllows to save data in a file. The type of file can be \"shp\", \"asc\", \"geotiff\", \"text\" or \"csv\".\nUsages​\n\nIts simple syntax is:\n\nsave data to: output_file type: a_type_file;\n\nTo save data in a text file:\n\nsave (string(cycle) + \"->\"  + name + \":\" + location) to: \"save_data.txt\" type: \"text\";\n\nTo save the values of some attributes of the current agent in csv file:\n\nsave [name, location, host] to: \"save_data.csv\" type: \"csv\";\n\nTo save the values of all attributes of all the agents of a species into a csv (with optional attributes):\n\nsave species_of(self) to: \"save_csvfile.csv\" type: \"csv\" header: false;\n\nTo save the geometries of all the agents of a species into a shapefile (with optional attributes):\n\nsave species_of(self) to: \"save_shapefile.shp\" type: \"shp\" attributes: ['nameAgent'::name, 'locationAgent'::location] crs: \"EPSG:4326\";\n\nTo save the grid_value attributes of all the cells of a grid into an ESRI ASCII Raster file:\n\nsave grid to: \"save_grid.asc\" type: \"asc\";\n\nTo save the grid_value attributes of all the cells of a grid into geotiff:\n\nsave grid to: \"save_grid.tif\" type: \"geotiff\";\n\nTo save the grid_value attributes of all the cells of a grid into png (with a worldfile):\n\nsave grid to: \"save_grid.png\" type: \"image\";\n\nThe save statement can be use in an init block, a reflex, an action or in a user command. Do not use it in experiments.\n\nEmbedments​\n\nThe save statement is of type: Single statement\nThe save statement can be embedded into: Behavior, Sequence of statements or action,\nThe save statement embeds statements:\n\n\nset​\nFacets​\n\nname (any type), (omissible) : the name of an existing variable or attribute to be modified\nvalue (any type): the value to affect to the variable or attribute\n\nDefinition​\nAllows to assign a value to the variable or attribute specified\nUsages​\nEmbedments​\n\nThe set statement is of type: Single statement\nThe set statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,\nThe set statement embeds statements:\n\n\nsetup​\nFacets​\nDefinition​\nThe setup statement is used to define the set of instructions that will be executed before every [#test test].\nUsages​\n\nAs every test should be independent from the others, the setup will mainly contain initialization of variables that will be used in each test.\n\nspecies Tester {     int val_to_test;      setup {         val_to_test <- 0;     }      test t1 {        // [set of instructions, including asserts]     } }\n\nSee also: test, assert,\n\nEmbedments​\n\nThe setup statement is of type: Sequence of statements or action\nThe setup statement can be embedded into: Species, Experiment, Model,\nThe setup statement embeds statements:\n\n\nsobol​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\noutputs (list): The list of output variables to analyse through sobol indexes\nreport (string): The path to the file where the Sobol report will be written\nsample (an identifier): The size of the sample for the sobol sequence\npath (string): The path to the saltelli sample csv file. If the file doesn't exist automatic Saltelli sampling will be performed and saved in the corresponding location\nresults (string): The path to the file where the automatic batch report will be written\n\nDefinition​\nThis algorithm runs a Sobol exploration - it has been built upon the moea framework at https://github.com/MOEAFramework/MOEAFramework - disabled the repeat facet of the experiment\nUsages​\n\nFor example:\n\nmethod sobol sample_size:100 outputs:['my_var'] report:'../path/to/report/file.txt'; \nEmbedments​\n\nThe sobol statement is of type: Batch method\nThe sobol statement can be embedded into: Experiment,\nThe sobol statement embeds statements:\n\n\nsocialize​\nFacets​\n\nname (an identifier), (omissible) : the identifier of the socialize statement\nagent (agent): the agent value of the created social link\ndominance (float): the dominance value of the created social link\nfamiliarity (float): the familiarity value of the created social link\nliking (float): the appreciation value of the created social link\nsolidarity (float): the solidarity value of the created social link\ntrust (float): the trust value of the created social link\nwhen (boolean): A boolean value to socialize only with a certain condition\n\nDefinition​\nenables to directly add a social link from a perceived agent.\nUsages​\n\nOther examples of use:\n\ndo socialize;\nEmbedments​\n\nThe socialize statement is of type: Single statement\nThe socialize statement can be embedded into: Behavior, Sequence of statements or action,\nThe socialize statement embeds statements:\n\n\nsolve​\nFacets​\n\nequation (an identifier), (omissible) : the equation system identifier to be numerically solved\nmax_step (float): maximal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value\nmethod (string): integration method (can be one of \"Euler\", \"ThreeEighthes\", \"Midpoint\", \"Gill\", \"Luther\", \"rk4\" or \"dp853\", \"AdamsBashforth\", \"AdamsMoulton\", \"DormandPrince54\", \"GraggBulirschStoer\",  \"HighamHall54\") (default value: \"rk4\") or the corresponding constant\nmin_step (float): minimal step, (used with dp853 method only), (sign is irrelevant, regardless of integration direction, forward or backward), the last step can be smaller than this value\nnSteps (float): Adams-Bashforth and Adams-Moulton methods only. The number of past steps used for computation excluding the one being computed (default value: 2\nscalAbsoluteTolerance (float): allowed absolute error (used with dp853 method only)\nscalRelativeTolerance (float): allowed relative error (used with dp853 method only)\nstep (float): (deprecated) integration step, use with fixed step integrator methods (default value: 0.005*step)\nstep_size (float): integration step, use with fixed step integrator methods (default value: 0.005*step)\nt0 (float): the first bound of the integration interval (defaut value: cycle*step, the time at the begining of the current cycle.)\ntf (float): the second bound of the integration interval. Can be smaller than t0 for a backward integration (defaut value: cycle*step, the time at the begining of the current cycle.)\n\nDefinition​\nSolves all equations which matched the given name, with all systems of agents that should solved simultaneously.\nUsages​\n\nOther examples of use:\n\nsolve SIR method: #rk4 step:0.001;\nEmbedments​\n\nThe solve statement is of type: Single statement\nThe solve statement can be embedded into: Behavior, Sequence of statements or action,\nThe solve statement embeds statements:\n\n\nspecies​\nFacets​\n\nname (an identifier), (omissible) : the identifier of the species\ncell_height (float): (grid only), the height of the cells of the grid\ncell_width (float): (grid only), the width of the cells of the grid\ncompile (boolean):\ncontrol (skill): defines the architecture of the species (e.g. fsm...)\nedge_species (species): In the case of a species defining a graph topology for its instances (nodes of the graph), specifies the species to use for representing the edges\nfile (file): (grid only), a bitmap file that will be loaded at runtime so that the value of each pixel can be assigned to the attribute 'grid_value'\nfiles (list): (grid only), a list of bitmap file that will be loaded at runtime so that the value of each pixel of each file can be assigned to the attribute 'bands'\nfrequency (int): The execution frequency of the species (default value: 1). For instance, if frequency is set to 10, the population of agents will be executed only every 10 cycles.\nheight (int): (grid only),  the height of the grid (in terms of agent number)\nhorizontal_orientation (boolean): (hexagonal grid only),(true by default). Allows use a hexagonal grid with a horizontal or vertical orientation.\nmirrors (any type in [list, species]): The species this species is mirroring. The population of this current species will be dependent of that of the species mirrored (i.e. agents creation and death are entirely taken in charge by GAMA with respect to the demographics of the species mirrored). In addition, this species is provided with an attribute called 'target', which allows each agent to know which agent of the mirrored species it is representing.\nneighbors (int): (grid only), the chosen neighborhood (4, 6 or 8)\noptimizer (string): (grid only),(\"A*\" by default). Allows to specify the algorithm for the shortest path computation (\"BF\", \"Dijkstra\", \"A*\" or \"JPS*\"\nparallel (any type in [boolean, int]): (experimental) setting this facet to 'true' will allow this species to use concurrency when scheduling its agents; setting it to an integer will set the threshold under which they will be run sequentially (the default is initially 20, but can be fixed in the preferences). This facet has a default set in the preferences (Under Performances > Concurrency)\nparent (species): the parent class (inheritance)\nschedules (container): A container of agents (a species, a dynamic list, or a combination of species and containers) , which represents which agents will be actually scheduled when the population is scheduled for execution. Note that the world (or the simulation) is always scheduled first, so there is no need to explicitly mention it. Doing so would result in a runtime error. For instance, 'species a schedules: (10 among a)' will result in a population that schedules only 10 of its own agents every cycle. 'species b schedules: []' will prevent the agents of 'b' to be scheduled. Note that the scope of agents covered here can be larger than the population, which allows to build complex scheduling controls; for instance, defining 'global schedules: [] {...} species b schedules: []; species c schedules: b; ' allows to simulate a model where only the world and the agents of b are scheduled, without even having to create an instance of c.\nskills (list): The list of skills that will be made available to the instances of this species. Each new skill provides attributes and actions that will be added to the ones defined in this species\ntopology (topology): The topology of the population of agents defined by this species. In case of nested species, it can for example be the shape of the macro-agent. In case of grid or graph species, the topology is automatically computed and cannot be redefined\ntorus (boolean): is the topology toric (defaut: false). Needs to be defined on the global species.\nuse_individual_shapes (boolean): (grid only),(true by default). Allows to specify whether or not the agents of the grid will have distinct geometries. If set to false, they will all have simpler proxy geometries\nuse_neighbors_cache (boolean): (grid only),(true by default). Allows to turn on or off the use of the neighbors cache used for grids. Note that if a diffusion of variable occurs, GAMA will emit a warning and automatically switch to a caching version\nuse_regular_agents (boolean): (grid only),(true by default). Allows to specify if the agents of the grid are regular agents (like those of any other species) or minimal ones (which can't have sub-populations, can't inherit from a regular species, etc.)\nvirtual (boolean): whether the species is virtual (cannot be instantiated, but only used as a parent) (false by default)\nwidth (int): (grid only), the width of the grid (in terms of agent number)\n\nDefinition​\nThe species statement allows modelers to define new species in the model. global and grid are speciel cases of species: global being the definition of the global agent (which has automatically one instance, world) and grid being a species with a grid topology.\nUsages​\n\nHere is an example of a species definition with a FSM architecture and the additional skill moving:\n\nspecies ant skills: [moving] control: fsm { }\n\nIn the case of a species aiming at mirroring another one:\n\nspecies node_agent mirrors: list(bug) parent: graph_node edge_species: edge_agent { }\n\nThe definition of the single grid of a model will automatically create gridwidth x gridheight agents:\n\ngrid ant_grid width: gridwidth height: gridheight file: grid_file neighbors: 8 use_regular_agents: false { }\n\nUsing a file to initialize the grid can replace width/height facets:\n\ngrid ant_grid file: grid_file neighbors: 8 use_regular_agents: false { }\nEmbedments​\n\nThe species statement is of type: Species\nThe species statement can be embedded into: Model, Environment, Species,\nThe species statement embeds statements:\n\n\nspecies_layer​\nFacets​\n\nspecies (species), (omissible) : the species to be displayed\naspect (an identifier): the name of the aspect that should be used to display the species\nfading (boolean): Used in conjunction with 'trace:', allows to apply a fading effect to the previous traces. Default is false\nposition (point): position of the upper-left corner of the layer. Note that if coordinates are in [0,1[, the position is relative to the size of the environment (e.g. {0.5,0.5} refers to the middle of the display) whereas it is absolute when coordinates are greater than 1 for x and y. The z-ordinate can only be defined between 0 and 1. The position can only be a 3D point {0.5, 0.5, 0.5}, the last coordinate specifying the elevation of the layer. In case of negative value OpenGl will position the layer out of the environment.\nrefresh (boolean): (openGL only) specify whether the display of the species is refreshed. (true by default, usefull in case of agents that do not move)\nrotate (float): Defines the angle of rotation of this layer, in degrees, around the z-axis.\nselectable (boolean): Indicates whether the agents present on this layer are selectable by the user. Default is true\nsize (point): extent of the layer in the screen from its position. Coordinates in [0,1[ are treated as percentages of the total surface, while coordinates > 1 are treated as absolute sizes in model units (i.e. considering the model occupies the entire view). Like in 'position', an elevation can be provided with the z coordinate, allowing to scale the layer in the 3 directions\ntrace (any type in [boolean, int]): Allows to aggregate the visualization of agents at each timestep on the display. Default is false. If set to an int value, only the last n-th steps will be visualized. If set to true, no limit of timesteps is applied.\ntransparency (float): the transparency level of the layer (between 0 -- opaque -- and 1 -- fully transparent)\nvisible (boolean): Defines whether this layer is visible or not\n\nDefinition​\nThe species_layer statement is used using the species keyword. It allows modeler to display all the agent of a given species in the current display. In particular, modeler can choose the aspect used to display them.\nUsages​\n\nThe general syntax is:\n\ndisplay my_display {    species species_name [additional options]; }\n\nSpecies can be superposed on the same plan (be careful with the order, the last one will be above all the others):\n\ndisplay my_display {    species agent1 aspect: base;    species agent2 aspect: base;    species agent3 aspect: base; }\n\nEach species layer can be placed at a different z value using the opengl display. position:{0,0,0} means the layer will be placed on the ground and position:{0,0,1} means it will be placed at an height equal to the maximum size of the environment.\n\ndisplay my_display type: opengl{    species agent1 aspect: base ;    species agent2 aspect: base position:{0,0,0.5};    species agent3 aspect: base position:{0,0,1}; }\n\nSee also: display, agents, chart, event, graphics, display_grid, image, overlay,\n\nEmbedments​\n\nThe species_layer statement is of type: Layer\nThe species_layer statement can be embedded into: display, species_layer,\nThe species_layer statement embeds statements: species_layer,\n\n\nstart_simulation​\nFacets​\n\nname (string), (omissible) : The name of the experiment to run\nof (string): The path to the model containing the experiment\nseed (int): The seed to use for initializing the random number generator of the new experiment\nwith_param (map): The parameters to pass to the new experiment\n\nEmbedments​\n\nThe start_simulation statement is of type: Sequence of statements or action\nThe start_simulation statement can be embedded into: Behavior, Single statement, Species, Model,\nThe start_simulation statement embeds statements:\n\n\nstate​\nFacets​\n\nname (an identifier), (omissible) : the identifier of the state\nfinal (boolean): specifies whether the state is a final one (i.e. there is no transition from this state to another state) (default value= false)\ninitial (boolean): specifies whether the state is the initial one (default value = false)\n\nDefinition​\nA state, like a reflex, can contains several statements that can be executed at each time step by the agent.\nUsages​\n\nHere is an exemple integrating 2 states and the statements in the FSM architecture:\n\nstate s_init initial: true { \tenter {  \t\twrite \"Enter in\" + state; \t}  \twrite state;  \ttransition to: s1 when: (cycle > 2) { \t\twrite \"transition s_init -> s1\"; \t}  \texit { \t\twrite \"EXIT from \"+state; \t} } state s1 {  \tenter {write 'Enter in '+state;}  \twrite state;  \texit {write 'EXIT from '+state;} }\n\nSee also: enter, exit, transition,\n\nEmbedments​\n\nThe state statement is of type: Behavior\nThe state statement can be embedded into: fsm, Species, Experiment, Model,\nThe state statement embeds statements: enter,  exit,\n\n\nstatus​\nFacets​\n\nmessage (any type), (omissible) : Allows to display a necessarily short message in the status box in the upper left corner. No formatting characters (carriage returns, tabs, or Unicode characters) should be used, but a background color can be specified. The message will remain in place until it is replaced by another one or by nil, in which case the standard status (number of cycles) will be displayed again\ncolor (rgb): The color used for displaying the background of the status message\n\nDefinition​\nThe statement makes the agent output an arbitrary message in the status box.\nUsages​\n\nOutputting a message\n\nstatus (\"This is my status \" + self) color: #yellow;\nEmbedments​\n\nThe status statement is of type: Single statement\nThe status statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe status statement embeds statements:\n\n\nstochanalyse​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\noutputs (list): The list of output variables to analyse\nreport (string): The path to the file where the Sobol report will be written\nresults (string): The path to the file where the automatic batch report will be written\nsample (int): The number of sample required , 10 by default\nsampling (an identifier): The sampling method to build parameters sets. Available methods are: latinhypercube, orthogonal, factorial, uniform, saltelli, morris\n\nDefinition​\nThis algorithm runs an exploration with a given sampling to compute a Stochasticity Analysis\nUsages​\n\nFor example:\n\nmethod stochanalyse sampling:'latinhypercube' outputs:['my_var'] replicat:10 report:'../path/to/report/file.txt'; \nEmbedments​\n\nThe stochanalyse statement is of type: Batch method\nThe stochanalyse statement can be embedded into: Experiment,\nThe stochanalyse statement embeds statements:\n\n\nswitch​\nFacets​\n\nvalue (any type), (omissible) : an expression\n\nDefinition​\nThe \"switch... match\" statement is a powerful replacement for imbricated \"if ... else ...\" constructs. All the blocks that match are executed in the order they are defined, unless one invokes 'break', in which case the switch statement is exited. The block prefixed by default is executed only if none have matched (otherwise it is not).\nUsages​\n\nThe prototypical syntax is as follows:\n\nswitch an_expression {         match value1 {...}         match_one [value1, value2, value3] {...}         match_between [value1, value2] {...}         default {...} }\n\nExample:\n\nswitch 3 {    match 1 {write \"Match 1\"; }    match 2 {write \"Match 2\"; }    match 3 {write \"Match 3\"; }    match_one [4,4,6,3,7]  {write \"Match one_of\"; }    match_between [2, 4] {write \"Match between\"; }    default {write \"Match Default\"; } }\n\nSee also: match, default, if,\n\nEmbedments​\n\nThe switch statement is of type: Sequence of statements or action\nThe switch statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe switch statement embeds statements: default,  match,\n\n\ntabu​\nFacets​\n\nname (an identifier), (omissible) : The name of the method. For internal use only\naggregation (a label), takes values in: {min, max, avr}: the agregation method\ninit_solution (map): init solution: key: name of the variable, value: value of the variable\niter_max (int): number of iterations. this number corresponds to the number of \"moves\" in the parameter space. For each move, the algorithm will test the whole neighborhood of the current solution, each neighbor corresponding to a particular set of parameters and thus to a run. Thus, there can be several runs per iteration (maximum: 2^(number of parameters)).\nmaximize (float): the value the algorithm tries to maximize\nminimize (float): the value the algorithm tries to minimize\ntabu_list_size (int): size of the tabu list\n\nDefinition​\nThis algorithm is an implementation of the Tabu Search algorithm. See the wikipedia article and [batch161 the batch dedicated page].\nUsages​\n\nAs other batch methods, the basic syntax of the tabu statement uses method tabu instead of the expected tabu name: id :\n\nmethod tabu [facet: value];\n\nFor example:\n\nmethod tabu iter_max: 50 tabu_list_size: 5 maximize: food_gathered;\nEmbedments​\n\nThe tabu statement is of type: Batch method\nThe tabu statement can be embedded into: Experiment,\nThe tabu statement embeds statements:\n\n\ntask​\nFacets​\n\nname (an identifier), (omissible) : the identifier of the task\nweight (float): the priority level of the task\n\nDefinition​\nAs reflex, a task is a sequence of statements that can be executed, at each time step, by the agent. If an agent owns several tasks, the scheduler chooses a task to execute based on its current priority weight value.\nUsages​\nEmbedments​\n\nThe task statement is of type: Behavior\nThe task statement can be embedded into: weighted_tasks, sorted_tasks, probabilistic_tasks, Species, Experiment, Model,\nThe task statement embeds statements:\n\n\ntest​\nFacets​\n\nname (an identifier), (omissible) : identifier of the test\n\nDefinition​\nThe test statement allows modeler to define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue.\nUsages​\n\nAn example of use:\n\nspecies Tester {     // set of attributes that will be used in test      setup {         // [set of instructions... in particular initializations]     }      test t1 {        // [set of instructions, including asserts]     } }\n\nSee also: setup, assert,\n\nEmbedments​\n\nThe test statement is of type: Behavior\nThe test statement can be embedded into: Species, Experiment, Model,\nThe test statement embeds statements: assert,\n\n\ntext​\nFacets​\n\nmessage (any type), (omissible) : the text to display.\nbackground (rgb): The color of the background of the text\ncategory (a label): a category label, used to group parameters in the interface\ncolor (rgb): The color with wich the text will be displayed\nfont (any type in [font, string]): the font used to draw the text, which can be built with the operator \"font\". ex : font:font(\"Helvetica\", 20 , #bold)\n\nDefinition​\nThe statement makes an experiment display text in the parameters view.\nUsages​\nEmbedments​\n\nThe text statement is of type: Single statement\nThe text statement can be embedded into: Experiment,\nThe text statement embeds statements:\n\n\ntrace​\nFacets​\nDefinition​\nAll the statements executed in the trace statement are displayed in the console.\nUsages​\nEmbedments​\n\nThe trace statement is of type: Sequence of statements or action\nThe trace statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe trace statement embeds statements:\n\n\ntransition​\nFacets​\n\nto (an identifier): the identifier of the next state\nwhen (boolean), (omissible) : a condition to be fulfilled to have a transition to another given state\n\nDefinition​\nIn an FSM architecture, transition specifies the next state of the life cycle. The transition occurs when the condition is fulfilled. The embedded statements are executed when the transition is triggered.\nUsages​\n\nIn the following example, the transition is executed when after 2 steps:\n\nstate s_init initial: true { \twrite state; \ttransition to: s1 when: (cycle > 2) { \t\twrite \"transition s_init -> s1\"; \t} }\n\nSee also: enter, state, exit,\n\nEmbedments​\n\nThe transition statement is of type: Sequence of statements or action\nThe transition statement can be embedded into: Sequence of statements or action, Behavior,\nThe transition statement embeds statements:\n\n\ntry​\nFacets​\nDefinition​\nAllows the agent to execute a sequence of statements and to catch any runtime error that might happen in a subsequent catch block, either to ignore it (not a good idea, usually) or to safely stop the model\nUsages​\n\nThe generic syntax is:\n\ntry {     [statements] }\n\nOptionally, the statements to execute when a runtime error happens in the block can be defined in a following statement 'catch'. The syntax then becomes:\n\ntry {     [statements] } catch {     [statements] }\nEmbedments​\n\nThe try statement is of type: Sequence of statements or action\nThe try statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe try statement embeds statements: catch,\n\n\nunconscious_contagion​\nFacets​\n\nemotion (emotion): the emotion that will be copied with the contagion\nname (an identifier), (omissible) : the identifier of the unconscious contagion\ncharisma (float): The charisma value of the perceived agent (between 0 and 1)\ndecay (float): The decay value of the emotion added to the agent\nreceptivity (float): The receptivity value of the current agent (between 0 and 1)\nthreshold (float): The threshold value to make the contagion\nwhen (boolean): A boolean value to get the emotion only with a certain condition\n\nDefinition​\nenables to directly copy an emotion present in the perceived species.\nUsages​\n\nOther examples of use:\n\nunconscious_contagion emotion:fearConfirmed;  unconscious_contagion emotion:fearConfirmed charisma: 0.5 receptivity: 0.5;\nEmbedments​\n\nThe unconscious_contagion statement is of type: Single statement\nThe unconscious_contagion statement can be embedded into: Behavior, Sequence of statements or action,\nThe unconscious_contagion statement embeds statements:\n\n\nuser_command​\nFacets​\n\nname (a label), (omissible) : the identifier of the user_command\naction (action): the identifier of the action to be executed. This action should be accessible in the context in which the user_command is defined (an experiment, the global section or a species). A special case is allowed to maintain the compatibility with older versions of GAMA, when the user_command is declared in an experiment and the action is declared in 'global'. In that case, all the simulations managed by the experiment will run the action in response to the user executing the command\ncategory (a label): a category label, used to group parameters in the interface\ncolor (rgb): The color of the button to display\ncontinue (boolean): Whether or not the button, when clicked, should dismiss the user panel it is defined in. Has no effect in other contexts (menu, parameters, inspectors)\nwhen (boolean): the condition that should be fulfilled (in addition to the user clicking it) in order to execute this action\nwith (map): the map of the parameters::values required by the action\n\nDefinition​\nAnywhere in the global block, in a species or in an (GUI) experiment, user_command statements allows to either call directly an existing action (with or without arguments) or to be followed by a block that describes what to do when this command is run.\nUsages​\n\nThe general syntax is for example:\n\nuser_command kill_myself action: some_action with: [arg1::val1, arg2::val2, ...];\n\nSee also: user_init, user_panel, user_input,\n\nEmbedments​\n\nThe user_command statement is of type: Sequence of statements or action\nThe user_command statement can be embedded into: user_panel, Species, Experiment, Model,\nThe user_command statement embeds statements: user_input,\n\n\nuser_init​\nFacets​\n\nname (an identifier), (omissible) : The name of the panel\ninitial (boolean): Whether or not this panel will be the initial one\n\nDefinition​\nUsed in the user control architecture, user_init is executed only once when the agent is created. It opens a special panel (if it contains user_commands statements). It is the equivalent to the init block in the basic agent architecture.\nUsages​\n\nSee also: user_command, user_init, user_input,\n\nEmbedments​\n\nThe user_init statement is of type: Behavior\nThe user_init statement can be embedded into: Species, Experiment, Model,\nThe user_init statement embeds statements: user_panel,\n\n\nuser_input​\nFacets​\n\ninit (any type): the init value\nreturns (a new identifier): a new local variable containing the value given by the user\nname (a label), (omissible) : the displayed name\namong (list): the set of acceptable values, only for string inputs\nmax (float): the maximum value\nmin (float): the minimum value\nslider (boolean): Whether to display a slider or not when applicable\ntype (a datatype identifier): the variable type\n\nDefinition​\nIt allows to let the user define the value of a variable.\nUsages​\n\nOther examples of use:\n\nuser_panel \"Advanced Control\" { \tuser_input \"Location\" returns: loc type: point <- {0,0}; \tcreate cells number: 10 with: [location::loc]; }\n\nSee also: user_command, user_init, user_panel,\n\nEmbedments​\n\nThe user_input statement is of type: Single statement\nThe user_input statement can be embedded into: user_command,\nThe user_input statement embeds statements:\n\n\nuser_panel​\nFacets​\n\nname (an identifier), (omissible) : The name of the panel\ninitial (boolean): Whether or not this panel will be the initial one\n\nDefinition​\nIt is the basic behavior of the user control architecture (it is similar to state for the FSM architecture). This user_panel translates, in the interface, in a semi-modal view that awaits the user to choose action buttons, change attributes of the controlled agent, etc. Each user_panel, like a state in FSM, can have a enter and exit sections, but it is only defined in terms of a set of user_commands which describe the different action buttons present in the panel.\nUsages​\n\nThe general syntax is for example:\n\nuser_panel default initial: true { \tuser_input 'Number' returns: number type: int <- 10; \task (number among list(cells)){ do die; } \ttransition to: \"Advanced Control\" when: every (10); }  user_panel \"Advanced Control\" { \tuser_input \"Location\" returns: loc type: point <- {0,0}; \tcreate cells number: 10 with: [location::loc]; }\n\nSee also: user_command, user_init, user_input,\n\nEmbedments​\n\nThe user_panel statement is of type: Behavior\nThe user_panel statement can be embedded into: fsm, user_first, user_last, user_init, user_only, Species, Experiment, Model,\nThe user_panel statement embeds statements: user_command,\n\n\nusing​\nFacets​\n\ntopology (topology), (omissible) : the topology\n\nDefinition​\nusing is a statement that allows to set the topology to use by its sub-statements. They can gather it by asking the scope to provide it.\nUsages​\n\nAll the spatial operations are topology-dependent (e.g. neighbors are not the same in a continuous and in a grid topology). So using statement allows modelers to specify the topology in which the spatial operation will be computed.\n\nfloat dist <- 0.0; using topology(grid_ant) { \td (self.location distance_to target.location); }\nEmbedments​\n\nThe using statement is of type: Sequence of statements or action\nThe using statement can be embedded into: chart, Behavior, Sequence of statements or action, Layer,\nThe using statement embeds statements:\n\n\nVariable_container​\nFacets​\n\nname (a new identifier), (omissible) : The name of the attribute\n<- (any type): The initial value of the attribute. Same as init:\n-> (any type in [int, float, point, date]): Used to specify an expression that will be evaluated each time the attribute is accessed. Equivalent to 'function:'. This facet is incompatible with both 'init:' and 'update:' and 'on_change:' (or the equivalent final block)\ncategory (a label): Soon to be deprecated. Declare the parameter in an experiment instead\nconst (boolean): Indicates whether this attribute can be subsequently modified or not\nfunction (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. Equivalent to '->'. This facet is incompatible with both 'init:', 'update:' and 'on_change:' (or the equivalent final block)\nindex (a datatype identifier): The type of the key used to retrieve the contents of this attribute\ninit (any type): The initial value of the attribute. Same as <-\nof (a datatype identifier): The type of the contents of this container attribute\non_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes\nparameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead\ntype (a datatype identifier): The type of the attribute\nupdate (any type): An expression that will be evaluated each cycle to compute a new value for the attribute\n\nDefinition​\nDeclaration of an attribute of a species or an experiment\nUsages​\nEmbedments​\n\nThe Variable_container statement is of type: Variable (container)\nThe Variable_container statement can be embedded into: Species, Experiment, Model,\nThe Variable_container statement embeds statements:\n\n\nVariable_number​\nFacets​\n\nname (a new identifier), (omissible) : The name of the attribute\n<- (any type in [int, float, point, date]): The initial value of the attribute. Same as 'init:'\n-> (any type in [int, float, point, date]): Used to specify an expression that will be evaluated each time the attribute is accessed. Equivalent to 'function:'. This facet is incompatible with both 'init:' and 'update:' and 'on_change:' (or the equivalent final block)\namong (list): A list of constant values among which the attribute can take its value\ncategory (a label): Soon to be deprecated. Declare the parameter in an experiment instead\nconst (boolean): Indicates whether this attribute can be subsequently modified or not\nfunction (any type in [int, float, point, date]): Used to specify an expression that will be evaluated each time the attribute is accessed. Equivalent to '->'. This facet is incompatible with both 'init:' and 'update:'\ninit (any type in [int, float, point, date]): The initial value of the attribute. Same as '<-'\nmax (any type in [int, float, point, date]): The maximum value this attribute can take. The value will be automatically clampled if it is higher.\nmin (any type in [int, float, point, date]): The minimum value this attribute can take. The value will be automatically clamped if it is lower.\non_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes\nparameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead\nstep (any type in [int, float, point, date]): A discrete step (used in conjunction with min and max) that constrains the values this variable can take\ntype (a datatype identifier): The type of the attribute, either 'int', 'float', 'point' or 'date'\nupdate (any type in [int, float, point, date]): An expression that will be evaluated each cycle to compute a new value for the attribute\n\nDefinition​\nDeclaration of an attribute of a species or an experiment; this type of attributes accepts min:, max: and step: facets, automatically clamping the value if it is lower than min or higher than max.\nUsages​\nEmbedments​\n\nThe Variable_number statement is of type: Variable (number)\nThe Variable_number statement can be embedded into: Species, Experiment, Model,\nThe Variable_number statement embeds statements:\n\n\nVariable_regular​\nFacets​\n\nname (a new identifier), (omissible) : The name of the attribute\n<- (any type): The initial value of the attribute. Same as init:\n-> (any type in [int, float, point, date]): Used to specify an expression that will be evaluated each time the attribute is accessed. Equivalent to 'function:'. This facet is incompatible with both 'init:' and 'update:' and 'on_change:' (or the equivalent final block)\namong (list): A list of constant values among which the attribute can take its value\ncategory (a label): Soon to be deprecated. Declare the parameter in an experiment instead\nconst (boolean): Indicates whether this attribute can be subsequently modified or not\nfunction (any type): Used to specify an expression that will be evaluated each time the attribute is accessed. This facet is incompatible with both 'init:', 'update:' and 'on_change:' (or the equivalent final block)\nindex (a datatype identifier): The type of the index used to retrieve elements if the type of the attribute is a container type\ninit (any type): The initial value of the attribute. Same as <-\nof (a datatype identifier): The type of the elements contained in the type of this attribute if it is a container type\non_change (any type): Provides a block of statements that will be executed whenever the value of the attribute changes\nparameter (a label): Soon to be deprecated. Declare the parameter in an experiment instead\ntype (a datatype identifier): The type of this attribute. Can be combined with facets 'of' and 'index' to describe container types\nupdate (any type): An expression that will be evaluated each cycle to compute a new value for the attribute\n\nDefinition​\nDeclaration of an attribute of a species or an experiment\nUsages​\nEmbedments​\n\nThe Variable_regular statement is of type: Variable (regular)\nThe Variable_regular statement can be embedded into: Species, Experiment, Model,\nThe Variable_regular statement embeds statements:\n\n\nwarn​\nFacets​\n\nmessage (string), (omissible) : the message to display as a warning.\n\nDefinition​\nThe statement makes the agent output an arbitrary message in the error view as a warning.\nUsages​\n\nEmmitting a warning\n\nwarn \"This is a warning from \" + self;\nEmbedments​\n\nThe warn statement is of type: Single statement\nThe warn statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe warn statement embeds statements:\n\n\nwrite​\nFacets​\n\nmessage (any type), (omissible) : the message to display. Modelers can add some formatting characters to the message (carriage returns, tabs, or Unicode characters), which will be used accordingly in the console.\ncolor (rgb): The color with wich the message will be displayed. Note that different simulations will have different (default) colors to use for this purpose if this facet is not specified\n\nDefinition​\nThe statement makes the agent output an arbitrary message in the console.\nUsages​\n\nOutputting a message\n\nwrite \"This is a message from \" + self;\nEmbedments​\n\nThe write statement is of type: Single statement\nThe write statement can be embedded into: Behavior, Sequence of statements or action, Layer,\nThe write statement embeds statements:\n"},{"filePath":"https:--gama-platform.org--wiki-ThreeD.txt","text":"3D TutorialThis tutorial introduces the 3D features offered by GAMA.\nModel Overview​\n\nStep List​\nThis tutorial is composed of 3 steps corresponding to 3 models which are incremental representation of the same model, starting with the simplest model 1 and finishing with the latest one, model 3. For each step, we will present its purpose, an explicit formulation, and the corresponding GAML code.\n\nBasic model\nMoving cells\nMoving cells with neighbors\n"},{"filePath":"https:--gama-platform.org--wiki-ThreeD_step1.txt","text":"1. Basic ModelIn this first step, we will see how to define a 3D environment and populate it.\nFormulation​\nInitialize a 3D world with a population of cells placed randomly in a 3D 100x100x100 cube.\n\nDefinition of the cell species.\nDefinition of the nb_cells parameter.\nCreation of nb_cells cell agents randomly located in the 3D environment, that is defined as a cub of dimensions: 100x100x100.\n\n\nModel Definition​\nIn this model, we define one species of agent: the cell species. The agents will be just displayed as a blue sphere of radius 1.\nspecies cell {                          aspect default {        draw sphere(1) color: #blue;       }}\nGlobal Section​\nGlobal variables​\nDefinition of a global variable nb_cells of type int representing the number of cell agents.\nglobal {    int nb_cells <- 100;}\nModel initialization​\nDefinition of the init block in order to create nb_cells cell agents. By default, an agent is created with a random location in x and y, and a z value equal to 0. In our case, we want to place the cell agents randomly in the 3D environment so we set a random value for x, y and z.\ncreate cell number: nb_cells {    location <- {rnd(100), rnd(100), rnd(100)};}\nExperiment​\nIn our model, we define a basic gui experiment called Tuto3D :\nexperiment Tuto3D type: gui {}\nInput​\nDefinition of a parameter from the global variable nb_cells :\nexperiment Tuto3D type: gui {    parameter \"Initial number of cells: \" var: nb_cells min: 1 max: 1000 category: \"Cells\";\t}\nOutput​\nIn our model, we define a display to draw the cell agents in a 3D environment.\noutput {    display View1 type:opengl {        species cell;    }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/3D/models/Model%2001.gaml"},{"filePath":"https:--gama-platform.org--wiki-ThreeD_step2.txt","text":"2. Moving CellsThis second step model adds the moving3D skill to the cell agents and simply makes the cell agents move by defining a reflex that will call the action move. We will also add additional visual information to the display.\nFormulation​\n\nRedefining the shape of the world with a 3D Shape.\nAttaching new skills (moving3D) to cell agents.\nModify cell aspect.\nAdd a graphics layer.\n\n\nModel Definition​\nGlobal Section​\nGlobal variable​\nWe use a new global variable called environment_size to define the size of our 3D environment.\nIn the global section, we define the new variable:\nint environment_size <-100;\nThen we redefine the shape of the world (by default the shape of the world is a 100x100 square) as a cube that will have the size defined by the environment_size variable. To do so we change the shape of the world in the global section:\ngeometry shape <- cube(environment_size);\t\nModel initialization​\nWhen we created the cell agents, we want to place them randomly in the 3D environment. To do so we set the location with a random value for x, y and z between 0 and environment_size.\ncreate cell number: nb_cells {   location <- {rnd(environment_size), rnd(environment_size), rnd(environment_size)};       }\nMoving3D skills​\nIn the previous example, we only created cell agents that did not have any behavior. In this step we want to make them move. To do so we add a moving3D skill to the cell species.\nMore information on built-in skills proposed by GAMA can be found here.\nspecies cell skills: [moving3D]{...  \t}\nThen we define a new reflex for the species cell that consists in calling the action move bundled in moving3D skill.\nreflex move {    do move;}\t                    \nFinally we modify a bit the aspect of the sphere to set its size according to the environment_size global variable previously defined.\naspect default {    draw sphere(environment_size*0.01) color: #blue;   }\nExperiment​\nThe experiment is the same as the previous one except that we will display the bounds of the environment by using a graphics layer.\ngraphics \"env\" {    draw cube(environment_size) color: #black wireframe: true;\t}\nOutput​\noutput {    display View1 type:opengl{        graphics \"env\"{            draw cube(environment_size) color: #black wireframe: true;\t        }        species cell;      }}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/3D/models/Model%2002.gaml"},{"filePath":"https:--gama-platform.org--wiki-ThreeD_step3.txt","text":"3. ConnectionsFormulation​\n\nMapping the network of connection\n\n\nModel Definition​\nIn this final step, we will display edges between cells that are within a given distance.\nCells update​\nWe add a new reflex to collect the neighbors of the cell that are within a certain distance:\nspecies cells skills:[moving3D]{...    reflex compute_neighbors {        neighbors <- cells select ((each distance_to self) < 10);    }  \t}\nThen we update the cell aspect as follows. For each element (cells) of the neighbors list, we draw a line between this neighbor's location and the current cell's location.\naspect default {    draw sphere(environment_size*0.01) color: #orange;    loop pp over: neighbors {        draw line([self.location,pp.location]);    }\t}\nComplete Model​\nhttps://github.com/gama-platform/gama/blob/GAMA_1.9.2/msi.gama.models/models/Tutorials/3D/models/Model%2003.gaml"},{"filePath":"https:--gama-platform.org--wiki-Troubleshooting.txt","text":"TroubleshootingThis page exposes some of the most common problems a user may encounter when running GAMA — and offers advices and workarounds for them. It will be regularly enriched with new contents. Note also that the Issues section of the website might contain precious information on crashes and bugs encountered by other users. If neither the workarounds described here nor the solutions provided by other users allow to solve your particular problem, please submit a new issue report to the developers.\nOn Ubuntu (& Linux Systems)​\nWorkaround if OpenGL display crash GAMA​\nIn case GAMA crashes whenever trying to display an OpenGL display or a Java2D, and you are running Ubuntu 21.10 (or earlier), it probably means that you're using Wayland as Display backend. You can fix it by running in a terminal export GDK_BACKEND=x11 and launch GAMA from this same terminal. This workaround is described here and in Issue 3373.\nWrong dark theme​\nGAMA have trouble managing custom GTK theme (specially dark ones, see this issue). The simplest solution is to explicit change the theme to the default Adwaita as an override of the environment variable.\nChange desktop application​\nSimply edit the file at /usr/share/applications/gama-platform.desktop and add GTK_THEME=Adwaita on the line starting by Exec=. You should have something like this :\nExec=env GTK_THEME=Adwaita GDK_BACKEND=x11 /opt/gama-platform/Gama\nSave the file wait a few seconds and restart GAMA normally.\nNote, if you want to force the dark mode, add this instead GTK_THEME=Adwaita:dark\nFrom command line (hard)​\nIf you are starting GAMA from the command line, use this command :\nGTK_THEME=Adwaita /path/to/Gama\nor this one to use the dark theme variant :\nGTK_THEME=Adwaita:dark /path/to/Gama\nOn macOS​\nFirst launch of GAMA should be in GUI mode​\nWhen GAMA has just been downloaded and installed, it needs to be first launched in its GUI version before using it in the headless mode.\nIf it is first launched in the headless mode, GAMA will be damaged and the installed version needs to be removed and re-installed.\nDetached displays \"vanish\" when moved to a secondary monitor (see #3670)​\nThis is a know bug in Eclipse as well, only on macOS. The only workaround consists in (1) detaching the display as usual on the same monitor than GAMA; (2) pressing F3 to display all active windows on screen; (3) grabbing and moving \"by hand\" the window corresponding to the detached display to the second monitor. It will then work as usual.\nOn Windows​\nProblem with some Radeon graphics cards and Opengl display​\nSome Radeon graphics cards may cause GAMA to crash when using Opengl displays. The best solutions in this case are either to switch to java2D display or, if the computer is equipped with two graphics cards, to specify that the other graphics card should be used for GAMA (see here).\nSometimes just setting the second GPU as recommended for GAMA won't be enough and Windows will still try to run it from the Radeon chipset, you can try setting the second GPU as the default GPU for everything, for example with NVIDIA cards, in NVidia control panel you can set it as prefered graphics processor in the Global settings tab.\nAlternatively, it has been reported that installing the latest version of AMD Software: Adrenalin edition (last tried successfully with 22.10.1) solved the problem but at the cost of very slower rendering.\nProblem with java2D displays​\nFor high-DPI screens, it is possible to observe an offset in java2D displays (not centered, not taking the whole panel, with an erroneous mouse location) with some scaling ratios. Changing the scaling factor to 100%, 125%, 150% or 200% should solve the problem.\nGeneral display problems (blurry icons, strange experiment displays, dark icons, blurry text, different appearance on second screen etc.)​\nIn some computer we noticed numerous display problems those are hard to reproduce because they depend on a specific mix between hardware and software.\nIf you ever encounter that kind of issue, there are two ways for you to try and act on them: the high DPI settings and the Windows scaling ratio.\nHigh DPI settings​\nMost of those problems can be solved by setting the right high DPI settings in Windows.\nTo do so, go to your Gama.exe file and right click on it. There chose Properties and then click on the Compatibility tab. Finally click on the Change high DPI settings button:\n\nA new window opens, if you installed gama through the installer you should see the High DPI scaling override option checked and the System value selected.\n\nIf it's not the case, you can try to set it and then in the properties window click on Apply and try to run gama again to see if there's some improvement. If not you can try with different values or to play with the Program DPI setting too.\nScaling ratio​\nMany of those issues are related to the the scaling ratio you are using in your windows. If the previous tip didn't work, you can try to play a bit with your scaling ratios to see if there's any improvement. In general, if you have problems we recommend that you stick to the 100% or 200% as those are the values that works the best from our experience. If you have multiple displays and experience problems when  moving gama from one to another, we also recommend that you use the same scaling ratio for the two displays. If not possible, setting as you main monitor the one were gama is going to run could also solve some issues.\nMemory problems​\nThe most common causes of problems when running GAMA are memory problems. Depending on your activities, on the size of the models you are editing, on the size of the experiments you are running, etc., you have a chance to require more memory than what is currently allocated to GAMA. A typical GAMA installation will need between 2 and 4GB of memory to run \"normally\" and launch small models.\nMemory problems are easy to detect: in the bottom-right corner of its window, GAMA will always display the status of the current memory. The first number represents the memory currently used (in MB), the second (always larger) the memory currently allocated by the JVM. And the little trash icon allows to \"garbage collect\" the memory still used by agents that are not used anymore (if any). If GAMA appears to hang or crash and if you can see that the two numbers are very close, it means that the memory required by GAMA exceeds the memory allocated.\n\nThere are two ways to circumvent this problem: the first one is to increase the memory allocated to GAMA by the Java Virtual Machine. The second, detailed on this page is to try to optimize your models to reduce their memory footprint at runtime.\nTo increase the memory allocated, first locate the file called Gama.ini. On Windows and Ubuntu, it is located next to the executable. On Mac OS X, you have to right-click on Gama.app, choose \"Display Package Contents...\", and you will find Gama.ini in Contents/Eclipse.\nThis file typically looks like the following (some options/keywords may vary depending on the system), and we are interested in two JVM arguments:\n\n-Xms supplies the minimal amount of memory the JVM should allocate to GAMA, -Xmx the maximal amount. By changing these values (esp. the second one, of course, for example to 4096M, or 4g, or more!), saving the file and relaunching GAMA, you can probably solve your problem. Note that 32 bits versions of GAMA will not accept to run with a value of -Xmx greater than 1500M. See here for additional information on these two options.\nCharting problems​\nBy default the charts of a running experiment are only updated when you are in the experiment view. Therefore if you want to be able to run an experiment and plot its results while still working on the code of a model, you should make sure that the option Continue to draw displays when in Modeling perspective is set to true in the Presentation and Behavior of Graphical Display Views section of the Display tab in the settings.\nInstallation is broken​\nIt may happen that after switching from one GAMA version to another, or after installing a plugin, something breaks your GAMA installation completely and uninstalling/reinstalling won't solve the problem. To fix this, you can go to your home directory and find the .eclipse (hidden) folder. For example on Windows it would be at:\nC:\\Users\\username\\.eclipse\nThere you will find a list of directories all starting with org. and one directory with the name starting with a number followed by the system you are using, for example for Windows it could be : 306334380_win32_win32_x86_64, for linux 1164258503_linux_gtk_x86_64 etc.\nThat directory contains the list of plugins and some config files that are persistent from one version to another, you can rename it (to 306334380_win32_win32_x86_64-backup for example) to keep a track of what was your configuration before, and run GAMA again.\nGAMA should then create a new clean directory with the basic configuration and no plugin installed, which should solve configuration related problems.\nSilent error when saving a file​\nIn certain configurations, when using the save statement an error can happen while the simulation is running and trying to perform the save. To prevent those, make sure that you specified the format in which to save your data (csv, text, json etc.) with the format facet.\nSaving SHP file raises an error​\nIf you encounter a runtime error while trying to save an SHP file multiple times, especially if the message is something like Java error: I/O error ... FileNotFoundException..., you can try going into your gama preferences and go to Data and Operators -> Optimizations -> In-memory shapefile mapping [...] and set it to false.\nRunning some models in headless raises an error​\nIt is possible that running some models using a component of GAMA called serialize in headless mode raises exceptions in GAMA 1.9.2. As far as we know, this mostly (only?) happens with experiments of type record. If the error you get looks similar to this:\njava.lang.reflect.InaccessibleObjectException: Unable to make field private final byte[] java.lang.String.value accessible: module java.base does not \"opens java.lang\" to unnamed module @6ca6fa8b        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:354)        at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:297)        at java.base/java.lang.reflect.Field.checkCanSetAccessible(Field.java:178)        at java.base/java.lang.reflect.Field.setAccessible(Field.java:172)        at org.nustaq.serialization.FSTClazzInfo.createFieldInfo(FSTClazzInfo.java:512)        at org.nustaq.serialization.FSTClazzInfo.createFields(FSTClazzInfo.java:368)        at org.nustaq.serialization.FSTClazzInfo.<init>(FSTClazzInfo.java:129)        at org.nustaq.serialization.FSTClazzInfoRegistry.getCLInfo(FSTClazzInfoRegistry.java:129)        at org.nustaq.serialization.FSTClazzNameRegistry.addClassMapping(FSTClazzNameRegistry.java:98)        at org.nustaq.serialization.FSTClazzNameRegistry.registerClassNoLookup(FSTClazzNameRegistry.java:85)        at org.nustaq.serialization.FSTClazzNameRegistry.registerClass(FSTClazzNameRegistry.java:81)        at org.nustaq.serialization.FSTConfiguration.addDefaultClazzes(FSTConfiguration.java:807)        at org.nustaq.serialization.FSTConfiguration.initDefaultFstConfigurationInternal(FSTConfiguration.java:477)        at org.nustaq.serialization.FSTConfiguration.createDefaultConfiguration(FSTConfiguration.java:472)        at org.nustaq.serialization.FSTConfiguration.createUnsafeBinaryConfiguration(FSTConfiguration.java:536)        at org.nustaq.serialization.FSTConfiguration.createUnsafeBinaryConfiguration(FSTConfiguration.java:530)        at ummisco.gama.serializer.implementations.FSTBinaryImplementation.<init>(FSTBinaryImplementation.java:36)        at ummisco.gama.serializer.experiment.ExperimentBackwardAgent._init_(ExperimentBackwardAgent.java:116)        at msi.gama.metamodel.agent.MinimalAgent.init(MinimalAgent.java:243)        at msi.gama.kernel.experiment.ExperimentAgent.init(ExperimentAgent.java:371)        at msi.gama.runtime.ExecutionScope.init(ExecutionScope.java:602)        at msi.gama.headless.listener.ServerExperimentController.schedule(ServerExperimentController.java:407)        at msi.gama.kernel.experiment.ExperimentAgent.schedule(ExperimentAgent.java:418)        at msi.gama.kernel.experiment.ExperimentPlan.open(ExperimentPlan.java:704)        at msi.gama.headless.core.Experiment.loadCurrentExperiment(Experiment.java:128)        at msi.gama.headless.core.Experiment.setup(Experiment.java:92)        at msi.gama.headless.job.ManualExperimentJob.loadAndBuildWithJson(ManualExperimentJob.java:140)        at msi.gama.headless.listener.ServerExperimentController.processUserCommand(ServerExperimentController.java:209)        at msi.gama.headless.listener.ServerExperimentController.directOpenExperiment(ServerExperimentController.java:320)        at msi.gama.headless.listener.LoadCommand.launchGamlSimulation(LoadCommand.java:119)        at msi.gama.headless.listener.LoadCommand.execute(LoadCommand.java:44)        at msi.gama.headless.listener.LoadCommand.execute(LoadCommand.java:1)        at msi.gama.headless.listener.CommandExecutor.lambda$1(CommandExecutor.java:73)        at java.base/java.lang.Thread.run(Thread.java:833)java.lang.NullPointerException: Cannot invoke \"ummisco.gama.serializer.implementations.AbstractSerialisationImplementation.save(msi.gama.kernel.simulation.SimulationAgent)\" because \"this.conf\" is null        at ummisco.gama.serializer.experiment.ExperimentBackwardAgent.step(ExperimentBackwardAgent.java:127)        at msi.gama.headless.core.Experiment.step(Experiment.java:151)        at msi.gama.headless.job.ManualExperimentJob.doStep(ManualExperimentJob.java:103)        at msi.gama.headless.listener.ServerExperimentController.step(ServerExperimentController.java:445)        at msi.gama.headless.listener.ServerExperimentController$MyRunnable.run(ServerExperimentController.java:100)        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)        at java.base/java.lang.Thread.run(Thread.java:833)java.lang.NullPointerException: Cannot invoke \"ummisco.gama.serializer.implementations.AbstractSerialisationImplementation.save(msi.gama.kernel.simulation.SimulationAgent)\" because \"this.conf\" is nullSocket closed        at ummisco.gama.serializer.experiment.ExperimentBackwardAgent.step(ExperimentBackwardAgent.java:127)        at msi.gama.headless.core.Experiment.step(Experiment.java:151)        at msi.gama.headless.job.ManualExperimentJob.doStep(ManualExperimentJob.java:103)        at msi.gama.headless.listener.ServerExperimentController.step(ServerExperimentController.java:445)        at msi.gama.headless.listener.ServerExperimentController$MyRunnable.run(ServerExperimentController.java:100)        at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)        at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)        at java.base/java.lang.Thread.run(Thread.java:833)\nThen you can fix it by modifying a bit the script you use to run gama-headless.\nFirst, at the end of your Gama.ini file, add the following lines:\n--add-exports=java.base/java.lang=ALL-UNNAMED--add-exports=java.desktop/sun.awt=ALL-UNNAMED--add-exports=java.desktop/sun.java2d=ALL-UNNAMED--add-exports=java.desktop/sun.awt.image=ALL-UNNAMED--add-exports=java.base/java.math=ALL-UNNAMED--add-exports=java.base/java.lang=ALL-UNNAMED--add-exports=java.base/sun.nio.ch=ALL-UNNAMED--add-opens=java.base/java.lang=ALL-UNNAMED--add-opens=java.base/jdk.internal.loader=ALL-UNNAMED--add-opens=java.base/java.math=ALL-UNNAMED--add-opens=java.base/java.util=ALL-UNNAMED--add-opens=java.base/java.util.concurrent=ALL-UNNAMED--add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED--add-opens=java.base/java.net=ALL-UNNAMED--add-opens=java.base/java.security=ALL-UNNAMED--add-opens=java.desktop/java.awt=ALL-UNNAMED--add-opens=java.base/java.io=ALL-UNNAMED--add-opens=java.base/java.time=ALL-UNNAMED--add-opens=java.base/java.util.concurrent.locks=ALL-UNNAMED--add-opens=java.base/java.text=ALL-UNNAMED--add-opens=java.base/java.lang.ref=ALL-UNNAMED--add-opens=java.sql/java.sql=ALL-UNNAMED-Djava.awt.headless=true\nThen you will have to replace the script you use run to gama-headless by another one described in the following parts.\nSee fixed script per OSWindowsMacOSMacOS (no JDK)LinuxLinux (no JDK)replace the gama-headless.bat script by this one:echo offclssetLocal EnableDelayedExpansionset inputFile=\"\"set outputFile=\"\" REM memory is defined in the ../Gama.ini fileset \"memory=-1m\"set workDir=.work%RANDOM%SETLOCAL enabledelayedexpansion:TOPIF (%1) == () GOTO NEXT_CODE        if %1 EQU -m (                 set  comm=%1                set  next=%2                set memory=!next!                SHIFT                GOTO DECALE        )        set param=%param% %1        GOTO DECALE:DECALESHIFTGOTO TOP:NEXT_CODEecho ******************************************************************echo * GAMA version 1.9.2                                             *echo * http://gama-platform.org                                       *echo * (c) 2007-2023 UMI 209 UMMISCO IRD/SU and Partners              *echo ******************************************************************set FILENAME=\"..\\plugins\\\"FOR /F %%e in ('dir /b %FILENAME%') do (         SET result=%%e        if \"!result:~0,29!\" == \"org.eclipse.equinox.launcher_\" (                  goto END        )):END@echo !result!set \"result=..\\plugins\\%result%\"echo %result%echo %JAVA_HOME%REM We don't want to use the options before the `-server` options in the GAMA.ini fileREM because they are not compatible with the headless modeset \"ini_arguments=\"set \"skip_until_line=-server\"set \"skipping=true\"for /f \"usebackq delims=\" %%a in (..\\GAMA.ini) do (        set \"line=%%a\"        if !skipping!==true (                if !skip_until_line!==%%a (                        set \"skipping=false\"                        set \"ini_arguments=!ini_arguments!!line! \"                )        ) else (                if \"!line:~0,4!\"==\"-Xmx\" (                         if \"!memory!\"==\"-1m\" ( set \"memory=!line:~4!\" )                ) else (                         set \"ini_arguments=!ini_arguments!!line! \"                 )        ))@echo Will run with these options:@echo %ini_arguments%@echo workDir = %workDir% @echo memory = %memory% if exist ..\\jdk\\ (        echo \"JDK\"        call ..\\jdk\\bin\\java -cp !result! -Xms512m -Xmx%memory% !ini_arguments! -Djava.awt.headless=true org.eclipse.core.launcher.Main -configuration ./configuration -application msi.gama.headless.product -data \"%workDir%\" !param! ) else (        echo \"JAVA_HOME\"        call \"%JAVA_HOME%\\bin\\java.exe\" -cp !result! -Xms512m -Xmx%memory% !ini_arguments! -Djava.awt.headless=true org.eclipse.core.launcher.Main -configuration ./configuration -application msi.gama.headless.product -data \"%workDir%\" !param! )replace the gama-headless.sh script by this one:#!/bin/bashmemory=\"0\"for arg do  shift  case $arg in    -m)     memory=\"${1}\"     shift     ;;    *)     set -- \"$@\" \"$arg\"     ;;  esacdoneif [ $memory == \"0\" ]; then  memory=$(grep Xmx \"$( dirname \"${BASH_SOURCE[0]}\" )\"/../Eclipse/Gama.ini || echo \"-Xmx4096m\")else  memory=-Xmx$memoryfiworkspaceCreate=0case \"$@\" in   *-help*|*-version*|*-validate*|*-test*|*-xml*|*-batch*|*-write-xmi*)    workspaceCreate=1    ;;esacfunction read_from_ini {  start_line=$(grep -n -- '-server' \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Eclipse/Gama.ini | cut -d ':' -f 1)  tail -n +$start_line \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Eclipse/Gama.ini | tr '\\n' ' '}echo \"******************************************************************\"echo \"* GAMA version 1.9.3                                             *\"echo \"* http://gama-platform.org                                       *\"echo \"* (c) 2007-2023 UMI 209 UMMISCO IRD/SU & Partners                *\"echo \"******************************************************************\"passWork=.workspace# w/ output folderif [ $workspaceCreate -eq 0 ]; then  # create output folder if not existing  if [ ! -d \"${@: -1}\" ]; then      mkdir ${@: -1}  fi  # create workspace in output folder  # `expr` use is to remove whitespace from MacOS's result  passWork=${@: -1}/.workspace$(find ${@: -1} -name \".workspace*\" | expr $(wc -l))  mkdir -p $passWork# w/o output folderelse  # create workspace in current folder  passWork=.workspace$(find ./ -maxdepth 1 -name \".workspace*\" | expr $(wc -l))fiini_arguments=$(read_from_ini)if ! \"$( dirname \"${BASH_SOURCE[0]}\" )\"/../jdk/Contents/Home/bin/java -cp \"$( dirname \"${BASH_SOURCE[0]}\" )\"/../Eclipse/plugins/org.eclipse.equinox.launcher*.jar -Xms512m $memory ${ini_arguments[@]} -Djava.awt.headless=true org.eclipse.core.launcher.Main -configuration \"$( dirname \"${BASH_SOURCE[0]}\" )\"/configuration -application msi.gama.headless.product -data $passWork \"$@\"; then    echo \"Error in you command, here's the log :\"    cat $passWork/.metadata/.log    exit 1fireplace the gama-headless.sh script by this one:#!/bin/bashjavaVersion=$(java -version 2>&1 | head -n 1 | cut -d \"\\\"\" -f 2)# Check if good Java version before everythingif [[ ${javaVersion:2} == 17 ]]; then  echo \"You should use Java 17 to run GAMA\"  echo \"Found you using version : $javaVersion\"  exit 1fimemory=\"0\"for arg do  shift  case $arg in    -m)     memory=\"${1}\"     shift     ;;    *)     set -- \"$@\" \"$arg\"     ;;  esacdoneif [[ $memory == \"0\" ]]; then  memory=$(grep Xmx \"$( dirname \"${BASH_SOURCE[0]}\" )\"/../Eclipse/Gama.ini || echo \"-Xmx4096m\")else  memory=-Xmx$memoryfiworkspaceCreate=0case \"$@\" in   *-help*|*-version*|*-validate*|*-test*|*-xml*|*-batch*|*-write-xmi*|*-socket*)    workspaceCreate=1    ;;esacfunction read_from_ini {  start_line=$(grep -n -- '-server' \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Eclipse/Gama.ini | cut -d ':' -f 1)  tail -n +$start_line \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Eclipse/Gama.ini | tr '\\n' ' '}echo \"******************************************************************\"echo \"* GAMA version 1.9.2                                             *\"echo \"* http://gama-platform.org                                       *\"echo \"* (c) 2007-2023 UMI 209 UMMISCO IRD/SU & Partners                *\"echo \"******************************************************************\"passWork=.workspace# w/ output folderif [ $workspaceCreate -eq 0 ]; then  # create output folder if not existing  if [ ! -d \"${@: -1}\" ]; then      mkdir ${@: -1}  fi  # create workspace in output folder  # `expr` use is to remove whitespace from MacOS's result  passWork=${@: -1}/.workspace$(find ${@: -1} -name \".workspace*\" | expr $(wc -l))  mkdir -p $passWork# w/o output folderelse  # create workspace in current folder  passWork=.workspace$(find ./ -maxdepth 1 -name \".workspace*\" | expr $(wc -l))fiini_arguments=$(read_from_ini)if ! java -cp \"$( dirname \"${BASH_SOURCE[0]}\" )\"/../Eclipse/plugins/org.eclipse.equinox.launcher*.jar -Xms512m $memory ${ini_arguments[@]} -Djava.awt.headless=true org.eclipse.core.launcher.Main -configuration \"$( dirname \"${BASH_SOURCE[0]}\" )\"/configuration -application msi.gama.headless.product -data $passWork \"$@\"; then    echo \"Error in you command, here's the log :\"    cat $passWork/.metadata/.log    exit 1fireplace the gama-headless.sh script by this one:#!/bin/bashmemory=\"0\"for arg do  shift  case $arg in    -m)     memory=\"${1}\"     shift     ;;    *)     set -- \"$@\" \"$arg\"     ;;  esacdoneif [ $memory == \"0\" ]; then  memory=$(grep Xmx \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Gama.ini || echo \"-Xmx4096m\")else  memory=-Xmx$memoryfiworkspaceCreate=0case \"$@\" in   *-help*|*-version*|*-validate*|*-test*|*-xml*|*-batch*|*-write-xmi*)    workspaceCreate=1    ;;esacfunction read_from_ini {  start_line=$(grep -n -- '-server' \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Gama.ini | cut -d ':' -f 1)  tail -n +$start_line \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Gama.ini | tr '\\n' ' '}echo \"******************************************************************\"echo \"* GAMA version 1.9.3                                             *\"echo \"* http://gama-platform.org                                       *\"echo \"* (c) 2007-2023 UMI 209 UMMISCO IRD/SU & Partners                *\"echo \"******************************************************************\"passWork=.workspace# w/ output folderif [ $workspaceCreate -eq 0 ]; then  # create output folder if not existing  if [ ! -d \"${@: -1}\" ]; then      mkdir ${@: -1}  fi  # create workspace in output folder  passWork=${@: -1}/.workspace$(find ${@: -1} -name \".workspace*\" | wc -l)  mkdir -p $passWork# w/o output folderelse  # create workspace in current folder  passWork=.workspace$(find ./ -maxdepth 1 -name \".workspace*\" | wc -l)fiini_arguments=$(read_from_ini)if ! \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../jdk/bin/java -cp \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../plugins/org.eclipse.equinox.launcher*.jar -Xms512m $memory ${ini_arguments[@]} -Djava.awt.headless=true org.eclipse.core.launcher.Main -configuration \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/configuration -application msi.gama.headless.product -data $passWork \"$@\"; then    echo \"Error in you command, here's the log :\"    cat $passWork/.metadata/.log    exit 1fireplace the gama-headless.sh script by this one:#!/bin/bashjavaVersion=$(java -version 2>&1 | head -n 1 | cut -d \"\\\"\" -f 2)# Check if good Java version before everythingif [[ ${javaVersion:2} == 17 ]]; then  echo \"You should use Java 17 to run GAMA\"  echo \"Found you using version : $javaVersion\"  exit 1fimemory=\"0\"for arg do  shift  case $arg in    -m)     memory=\"${1}\"     shift     ;;    *)     set -- \"$@\" \"$arg\"     ;;  esacdoneif [[ $memory == \"0\" ]]; then  memory=$(grep Xmx \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Gama.ini || echo \"-Xmx4096m\")else  memory=-Xmx$memoryfiworkspaceCreate=0case \"$@\" in   *-help*|*-version*|*-validate*|*-test*|*-xml*|*-batch*|*-write-xmi*|*-socket*)    workspaceCreate=1    ;;esacfunction read_from_ini {  start_line=$(grep -n -- '-server' \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Gama.ini | cut -d ':' -f 1)  tail -n +$start_line \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../Gama.ini | tr '\\n' ' '}echo \"******************************************************************\"echo \"* GAMA version 1.9.3                                             *\"echo \"* http://gama-platform.org                                       *\"echo \"* (c) 2007-2023 UMI 209 UMMISCO IRD/SU & Partners                *\"echo \"******************************************************************\"passWork=.workspace# w/ output folderif [ $workspaceCreate -eq 0 ]; then  # create output folder if not existing  if [ ! -d \"${@: -1}\" ]; then      mkdir ${@: -1}  fi  # create workspace in output folder  passWork=${@: -1}/.workspace$(find ${@: -1} -name \".workspace*\" | wc -l)  mkdir -p $passWork# w/o output folderelse  # create workspace in current folder  passWork=.workspace$(find ./ -maxdepth 1 -name \".workspace*\" | wc -l)fiini_arguments=$(read_from_ini)if ! java -cp \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/../plugins/org.eclipse.equinox.launcher*.jar -Xms512m $memory ${ini_arguments[@]} org.eclipse.core.launcher.Main -configuration \"$( dirname $( realpath \"${BASH_SOURCE[0]}\" ) )\"/configuration -application msi.gama.headless.product -data $passWork \"$@\"; then    echo \"Error in you command, here's the log :\"    cat $passWork/.metadata/.log    exit 1fi\nOnce done you can just run that new script like you used to do, and everything should be working.\nSubmitting an Issue​\nIf you think you have found a new bug/issue in GAMA, it is time to create an issue report here! Alternatively, you can click the Issues tab on the project site, search if a similar problem has already been reported (and, maybe, solved) and, if not, enter a new issue with as much information as possible:\n\nA complete description of the problem and how it occurred.\nThe GAMA model or code you are having trouble with. If possible, attach a complete model.\nScreenshots or other files that help describe the issue.\n\nTwo files may be particularly interesting to attach to your issue: the configuration details and the error log. Both can be obtained quite easily from within GAMA itself in a few steps. First, click the \"About GAMA...\" menu item (under the \"Gama Platform\" menu on Mac OS X, \"Help\" menu on Linux & Windows)\n\nIn the dialog that appears, you will find a button called \"Installation Details\".\n\nClick this button and a new dialog appears with several tabs.\n\nTo provide complete information about the status of your system at the time of the error, you can\n(1) copy and paste the text found in the tab \"Configuration\" into your issue. Although, it is preferable to attach it as a text file (using TextEdit, Notepad or Emacs e.g.) as it may be too long for the comment section of the issue form.\n(2) click the \"View error log\" button, which will bring you to the location, in your file system, of a file called \"log\", which you can then attach to your issue as well.\n"},{"filePath":"https:--gama-platform.org--wiki-Tutorials.txt","text":"TutorialsWe propose some tutorials that are designed to allow modelers to become progressively autonomous with the GAMA platform. These tutorials cover different aspects of GAMA (Grid environment, GIS integration, 3D, multi-level modeling, equation-based models...). It is a good idea to keep a copy of the reference of the GAML language around when undertaking one of these tutorials.\n\nPredator Prey\nRoad Traffic\n3D Tutorial\nLuneray's flu\nIncremental Model\nBDI architecture\n\nPredator Prey tutorial​\n\nThis tutorial introduces the basic concepts of GAMA and the use of grids. It is based on the classic predator prey model (see for instance a formal definition here). It is particularly adapted to beginners that want to quickly learn how to build a simple model in GAMA.\nRoad Traffic​\n\nThis tutorial introduces the use of GIS data. It is based on a mobility and daily activity model. It is particularly adapted to modelers that want to quickly learn how to integrate GIS data in their model and to use a road shapefile for the movement of their agents.\n3D Tutorial​\nThis tutorial introduces the use of 3D in GAMA. In particular, it offers a quick overview of the 3D capabilities of the platform and how to integrate 3D features in models.\nLuneray's flu tutorial​\n\nThis tutorial dedicated to beginners introduces the basic concepts of GAMA and proposes a brief overview of many features.  It concerns a model of disease spreading in the small city of Luneray. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, and to define a 3D display.\nIncremental Model​\n\nThis tutorial proposes is an advance version of the Luneray's tutorial. It concerns a model of disease spreading in a small city. In particular, it presents how to integrate GIS data and use GIS, to use a road shapefile for the movement of agents, to define a 3D display, to define a multi-level model and use differential equations.\nBDI Architecture​\nThis tutorial introduces the use of the BDI architecture (named BEN provided with the GAMA platform. It is particularly adapted for advanced users who want to integrate reasoning capabilities in theirs agents, taking into account their emotions and social relationships."},{"filePath":"https:--gama-platform.org--wiki-UnitsAndConstants.txt","text":"Units and constants\nThis file is automatically generated from java files. Do Not Edit It.\n\nIntroduction​\nUnits can be used to qualify the values of numeric variables. By default, unqualified values are considered as:\n\nmeters for distances, lengths...\nseconds for durations\ncubic meters for volumes\nkilograms for masses\n\nSo, an expression like:\nfloat foo <- 1;\nwill be considered as 1 meter if foo is a distance, or 1 second if it is a duration, or 1 meter/second if it is a speed. If one wants to specify the unit, it can be done very simply by adding the unit symbol (° or #) followed by an unit name after the numeric value, like:\nfloat foo <- 1 °centimeter;\nor\nfloat foo <- 1 #centimeter;\nIn that case, the numeric value of foo will be automatically translated to 0.01 (meter). It is recommended to always use float as the type of the variables that might be qualified by units (otherwise, for example in the previous case, they might be truncated to 0).\nSeveral units names are allowed as qualifiers of numeric variables.\nThese units represent the basic metric and US units. Composed and derived units (like velocity, acceleration, special volumes or surfaces) can be obtained by combining these units using the * and / operators. For instance:\nfloat one_kmh <- 1 °km / °h const: true;float one_millisecond <-1 °sec / 1000;float one_cubic_inch <- 1 °sqin * 1 °inch;... etc ...\n\n3D​\n\n#ambient, value= Ambient light, Comment: Represent the 'ambient' type of light\n#direction, value= Directional light, Comment: Represent the 'direction' type of light\n#from_above, value= From above, Comment: Represent the position of the camera, above the scene\n#from_front, value= From front, Comment: Represent the position of the camera, in front of the scene\n#from_left, value= From left, Comment: Represent the position of the camera, on the left of the scene\n#from_right, value= From right, Comment: Represent the position of the camera, on the right of the scene\n#from_up_front, value= From up front, Comment: Represent the position of the camera, in front and slightly above the scene\n#from_up_left, value= From up left, Comment: Represent the position of the camera, on the left, slightly above the scene\n#from_up_right, value= From up right, Comment: Represent the position of the camera on the right, slightly above the scene\n#isometric, value= Isometric, Comment: Represent the position of the camera, on the left of the scene\n#point, value= Point light, Comment: Represent the 'point' type of light\n#spot, value= Spot light, Comment: Represent the 'spot' type of light\n\n\nConstants​\n\n#AdamsBashforth, value= AdamsBashforth, Comment: AdamsBashforth solver\n#AdamsMoulton, value= AdamsMoulton, Comment: AdamsMoulton solver\n#AStar, value= AStar, Comment: AStar shortest path computation algorithm\n#BellmannFord, value= BellmannFord, Comment: BellmannFord shortest path computation algorithm\n#Bhandari, value= Bhandari, Comment: Bhandari K shortest paths computation algorithm\n#BidirectionalDijkstra, value= BidirectionalDijkstra, Comment: BidirectionalDijkstra shortest path computation algorithm\n#CHBidirectionalDijkstra, value= CHBidirectionalDijkstra, Comment: CHBidirectionalDijkstra shortest path computation algorithm\n#current_error, value= , Comment: The text of the last error thrown during the current execution\n#DeltaStepping, value= DeltaStepping, Comment: DeltaStepping shortest path computation algorithm\n#Dijkstra, value= Dijkstra, Comment: Dijkstra shortest path computation algorithm\n#DormandPrince54, value= DormandPrince54, Comment: DormandPrince54 solver\n#dp853, value= dp853, Comment: dp853 solver\n#e, value= 2.718281828459045, Comment: The e constant\n#Eppstein, value= Eppstein, Comment: Eppstein K shortest paths computation algorithm\n#Euler, value= Euler, Comment: Euler solver\n#FloydWarshall, value= FloydWarshall, Comment: FloydWarshall shortest path computation algorithm\n#Gill, value= Gill, Comment: Gill solver\n#GraggBulirschStoer, value= GraggBulirschStoer, Comment: GraggBulirschStoer solver\n#HighamHall54, value= HighamHall54, Comment: HighamHall54 solver\n#infinity, value= Infinity, Comment: A constant holding the positive infinity of type float (Java Double.POSITIVE_INFINITY)\n#Luther, value= Luther, Comment: Luther solver\n#max_float, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)\n#max_int, value= 2147483647, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)\n#Midpoint, value= Midpoint, Comment: Midpoint solver\n#min_float, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)\n#min_int, value= -2147483648, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)\n#nan, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)\n#NBAStar, value= NBAStar, Comment: NBAStar shortest path computation algorithm\n#NBAStarApprox, value= NBAStarApprox, Comment: NBAStarApprox shortest path computation algorithm\n#pi, value= 3.141592653589793, Comment: The PI constant\n#rk4, value= rk4, Comment: rk4 solver\n#Suurballe, value= Suurballe, Comment: Suurballe K shortest paths computation algorithm\n#ThreeEighthes, value= ThreeEighthes, Comment: ThreeEighthes solver\n#to_deg, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees\n#to_rad, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radians\n#TransitNodeRouting, value= TransitNodeRouting, Comment: TransitNodeRouting shortest path computation algorithm\n#Yen, value= Yen, Comment: Yen K shortest paths computation algorithm\n\n\nConstants​\n\n#AdamsBashforth, value= AdamsBashforth, Comment: AdamsBashforth solver\n#AdamsMoulton, value= AdamsMoulton, Comment: AdamsMoulton solver\n#AStar, value= AStar, Comment: AStar shortest path computation algorithm\n#BellmannFord, value= BellmannFord, Comment: BellmannFord shortest path computation algorithm\n#Bhandari, value= Bhandari, Comment: Bhandari K shortest paths computation algorithm\n#BidirectionalDijkstra, value= BidirectionalDijkstra, Comment: BidirectionalDijkstra shortest path computation algorithm\n#CHBidirectionalDijkstra, value= CHBidirectionalDijkstra, Comment: CHBidirectionalDijkstra shortest path computation algorithm\n#current_error, value= , Comment: The text of the last error thrown during the current execution\n#DeltaStepping, value= DeltaStepping, Comment: DeltaStepping shortest path computation algorithm\n#Dijkstra, value= Dijkstra, Comment: Dijkstra shortest path computation algorithm\n#DormandPrince54, value= DormandPrince54, Comment: DormandPrince54 solver\n#dp853, value= dp853, Comment: dp853 solver\n#e, value= 2.718281828459045, Comment: The e constant\n#Eppstein, value= Eppstein, Comment: Eppstein K shortest paths computation algorithm\n#Euler, value= Euler, Comment: Euler solver\n#FloydWarshall, value= FloydWarshall, Comment: FloydWarshall shortest path computation algorithm\n#Gill, value= Gill, Comment: Gill solver\n#GraggBulirschStoer, value= GraggBulirschStoer, Comment: GraggBulirschStoer solver\n#HighamHall54, value= HighamHall54, Comment: HighamHall54 solver\n#infinity, value= Infinity, Comment: A constant holding the positive infinity of type float (Java Double.POSITIVE_INFINITY)\n#Luther, value= Luther, Comment: Luther solver\n#max_float, value= 1.7976931348623157E308, Comment: A constant holding the largest positive finite value of type float (Java Double.MAX_VALUE)\n#max_int, value= 2147483647, Comment: A constant holding the maximum value an int can have (Java Integer.MAX_VALUE)\n#Midpoint, value= Midpoint, Comment: Midpoint solver\n#min_float, value= 4.9E-324, Comment: A constant holding the smallest positive nonzero value of type float (Java Double.MIN_VALUE)\n#min_int, value= -2147483648, Comment: A constant holding the minimum value an int can have (Java Integer.MIN_VALUE)\n#nan, value= NaN, Comment: A constant holding a Not-a-Number (NaN) value of type float (Java Double.POSITIVE_INFINITY)\n#NBAStar, value= NBAStar, Comment: NBAStar shortest path computation algorithm\n#NBAStarApprox, value= NBAStarApprox, Comment: NBAStarApprox shortest path computation algorithm\n#pi, value= 3.141592653589793, Comment: The PI constant\n#rk4, value= rk4, Comment: rk4 solver\n#Suurballe, value= Suurballe, Comment: Suurballe K shortest paths computation algorithm\n#ThreeEighthes, value= ThreeEighthes, Comment: ThreeEighthes solver\n#to_deg, value= 57.29577951308232, Comment: A constant holding the value to convert radians into degrees\n#to_rad, value= 0.017453292519943295, Comment: A constant holding the value to convert degrees into radians\n#TransitNodeRouting, value= TransitNodeRouting, Comment: TransitNodeRouting shortest path computation algorithm\n#Yen, value= Yen, Comment: Yen K shortest paths computation algorithm\n\n\nGraphics units​\n\n#bold, value= 1, Comment: This constant allows to build a font with a bold face. Can be combined with #italic\n#bottom_center, value= No Default Value, Comment: Represents an anchor situated at the center of the bottom side of the text to draw\n#bottom_left, value= No Default Value, Comment: Represents an anchor situated at the bottom left corner of the text to draw\n#bottom_right, value= No Default Value, Comment: Represents an anchor situated at the bottom right corner of the text to draw\n#camera_location, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current position of the camera as a point\n#camera_orientation, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current orientation of the camera as a point\n#camera_target, value= No Default Value, Comment: This unit, only available when running aspects or declaring displays, returns the current target of the camera as a point\n#center, value= No Default Value, Comment: Represents an anchor situated at the center of the text to draw\n#display_height, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...\n#display_width, value= 1.0, Comment: This constant is only accessible in a graphical context: display, graphics...\n#flat, value= 2, Comment: This constant represents a flat line buffer end cap style\n#fullscreen, value= false, Comment: This unit, only available when running aspects or declaring displays, returns whether the display is currently fullscreen or not\n#hidpi, value= false, Comment: This unit, only available when running aspects or declaring displays, returns whether the display is currently in HiDPI mode or not\n#horizontal, value= 3, Comment: This constant represents a layout where all display views are aligned horizontally\n#italic, value= 2, Comment: This constant allows to build a font with an italic face. Can be combined with #bold\n#left_center, value= No Default Value, Comment: Represents an anchor situated at the center of the left side of the text to draw\n#none, value= 0, Comment: This constant represents the absence of a predefined layout\n#pixels (#px), value= 1.0, Comment: This unit, only available when running aspects or declaring displays,  returns a dynamic value instead of a fixed one. px (or pixels), returns the value of one pixel on the current view in terms of model units.\n#plain, value= 0, Comment: This constant allows to build a font with a plain face\n#right_center, value= No Default Value, Comment: Represents an anchor situated at the center of the right side of the text to draw\n#round, value= 1, Comment: This constant represents a round line buffer end cap style\n#split, value= 2, Comment: This constant represents a layout where all display views are split in a grid-like structure\n#square, value= 3, Comment: This constant represents a square line buffer end cap style\n#stack, value= 1, Comment: This constant represents a layout where all display views are stacked\n#top_center, value= No Default Value, Comment: Represents an anchor situated at the center of the top side of the text to draw\n#top_left, value= No Default Value, Comment: Represents an anchor situated at the top left corner of the text to draw\n#top_right, value= No Default Value, Comment: Represents an anchor situated at the top right corner of the text to draw\n#user_location, value= No Default Value, Comment: This unit contains in permanence the location of the mouse on the display in which it is situated. The latest location is provided when it is out of a display\n#vertical, value= 4, Comment: This constant represents a layout where all display views are aligned vertically\n#zoom, value= 1.0, Comment: This unit, only available when running aspects or declaring displays, returns the current zoom level of the display as a positive float, where 1.0 represent the neutral zoom (100%)\n\n\nLength units​\n\n#µm (#micrometer,#micrometers), value= 1.0E-6, Comment: micrometer unit\n#cm (#centimeter,#centimeters), value= 0.01, Comment: centimeter unit\n#dm (#decimeter,#decimeters), value= 0.1, Comment: decimeter unit\n#foot (#feet,#ft), value= 0.3048, Comment: foot unit\n#inch (#inches), value= 0.025400000000000002, Comment: inch unit\n#km (#kilometer,#kilometers), value= 1000.0, Comment: kilometer unit\n#m (#meter,#meters), value= 1.0, Comment: meter: the length basic unit\n#mile (#miles), value= 1609.344, Comment: mile unit\n#mm (#milimeter,#milimeters), value= 0.001, Comment: millimeter unit\n#nm (#nanometer,#nanometers), value= 9.999999999999999E-10, Comment: nanometer unit\n#yard (#yards), value= 0.9144, Comment: yard unit\n\n\nSurface units​\n\n#m2, value= 1.0, Comment: square meter: the basic unit for surfaces\n#sqft (#square_foot,#square_feet), value= 0.09290304, Comment: square foot unit\n#sqin (#square_inch,#square_inches), value= 6.451600000000001E-4, Comment: square inch unit\n#sqmi (#square_mile,#square_miles), value= 2589988.110336, Comment: square mile unit\n\n\nTime units​\n\n#custom, value= CUSTOM, Comment: custom: a custom date/time pattern that can be defined in the preferences of GAMA and reused in models\n#cycle (#cycles), value= 1, Comment: cycle: the discrete measure of time in the simulation. Used to force a temporal expression to be expressed in terms of cycles rather than seconds\n#day (#d,#days), value= 86400.0, Comment: day time unit: defines an exact duration of 24 hours\n#epoch, value= No Default Value, Comment: The epoch default starting date as defined by the ISO format (1970-01-01T00:00Z)\n#h (#hour,#hours), value= 3600.0, Comment: hour time unit: defines an exact duration of 60 minutes\n#iso_local, value= ISO_LOCAL_DATE_TIME, Comment: iso_local: the standard ISO 8601 output / parsing format for local dates (i.e. with no time-zone information)\n#iso_offset, value= ISO_OFFSET_DATE_TIME, Comment: iso_offset: the standard ISO 8601 output / parsing format for dates with a time offset\n#iso_zoned, value= ISO_ZONED_DATE_TIME, Comment: iso_zoned: the standard ISO 8601 output / parsing format for dates with a time zone\n#minute (#minutes,#mn), value= 60.0, Comment: minute time unit: defined an exact duration of 60 seconds\n#month (#months), value= 2592000.0, Comment: month time unit: an approximate duration of 30 days. The number of days of each #month depend of course on the current_date of the model and cannot be constant\n#msec (#millisecond,#milliseconds,#ms), value= 0.001, Comment: millisecond time unit: defines an exact duration of 0.001 second\n#now, value= 1.0, Comment: This value represents the current date\n#sec (#second,#seconds,#s), value= 1.0, Comment: second: the time basic unit, with a fixed value of 1. All other durations are expressed with respect to it\n#week (#weeks), value= 604800.0, Comment: week time unit: defines an exact duration of 7 days\n#year (#years,#y), value= 3.1536E7, Comment: year time unit: an approximate duration of 365 days. The value of #year in number of days varies depending on leap years, etc. and is dependend on the current_date of the model\n\n\nUser control operators​\n\nVolume units​\n\n#cl (#centiliter,#centiliters), value= 1.0E-5, Comment: centiliter unit\n#dl (#deciliter,#deciliters), value= 1.0E-4, Comment: deciliter unit\n#hl (#hectoliter,#hectoliters), value= 0.1, Comment: hectoliter unit\n#l (#liter,#liters,#dm3), value= 0.001, Comment: liter unit\n#m3, value= 1.0, Comment: cube meter: the basic unit for volumes\n\n\nWeight units​\n\n#gram (#grams), value= 0.001, Comment: gram unit\n#kg (#kilo,#kilogram,#kilos), value= 1.0, Comment: second: the basic unit for weights\n#longton (#lton), value= 1016.0469088000001, Comment: short ton unit\n#ounce (#oz,#ounces), value= 0.028349523125, Comment: ounce unit\n#pound (#lb,#pounds,#lbm), value= 0.45359237, Comment: pound unit\n#shortton (#ston), value= 907.18474, Comment: short ton unit\n#stone (#st), value= 6.35029318, Comment: stone unit\n#ton (#tons), value= 1000.0, Comment: ton unit\n\n\nColors​\nIn addition to the previous units, GAML provides a direct access to the 147 named colors defined in CSS (see http://www.cssportal.com/css3-color-names/). E.g,\nrgb my_color <- °teal;"},{"filePath":"https:--gama-platform.org--wiki-Updating.txt","text":"Updating GAMAUnless you are using the version of GAMA built from the sources available in the GIT repository of the project (see here), you are normally running a specific release of GAMA that sports a given version number (e.g. GAMA 1.8.1, GAMA 1.7, GAMA 1.6.1, etc.). When new features were developed, or when serious issues were fixed, the release you had on your disk, prior to GAMA 1.6.1, could not benefit from them. Since the version 1.6.1, however, GAMA has been enhanced to support a self_update mechanism, which allows you to import from the GAMA update site additional plugins (offering new features) or updated versions of the plugins that constitute the core of GAMA.\nThe update of GAMA will be detailed on this page; to install new additional plugins (from the GAMA community or third-party developers) see the page dedicated to the installation of new plugins.\nTable of contents​\n\nUpdating GAMA\n\nManual Update\nAutomatic Update\n\n\n\nManual Update​\nTo activate this feature, you have to invoke the \"Check for Updates\" or \"Install New Software...\" menu commands in the \"Help\" menu.\nThe first one will only check if the existing plugins have any updates available, while the second will, in addition, scan the update site to detect any new plugins that might be added to the current installation.\n\nIn general, it is preferable to use the second command, as more options (including that of uninstalling some plugins) are provided. Once invoked, it makes the following dialog appear:\n\nGAMA expects the user to enter a so-called update site. You can copy and paste the following line (or choose it from the drop-down menu as this address is built inside GAMA):\nhttp://updates.gama-platform.org\nGAMA will then scan the entire update site, looking both for new plugins of the GAMA kernel and updates to existing plugins. The list available in your installation will, of course, be different from the one displayed here.\nIn order to make the plugins appear, you need to uncheck the option \"Group items by category\". Choose the ones you want to update (or install) and click \"Next >\".\n\nA summary page will appear, indicating which plugins will actually be installed (since some plugins might require additional plugins to run properly). Click on the \"Next >\" button.\n\nA license page will then appear: you have to accept all of them. Click on \"Finish\".\n\nGAMA will then proceed to the installation (that can be canceled at any time) of the chosen plugins.\nDuring the course of the installation, you might receive the following warning, that you can dismiss by clicking \"OK\". You can click on the \"Details\" button to see which plugins contain unsigned contents.\n\nOnce the plugins are installed, GAMA will ask you whether you want to restart or not. It is always safer to do so, so select \"Restart now\" and let it close by itself, register the new plugins and restart.\n\nAutomatic Update​\nGAMA offers a mechanism to monitor the availability of updates to the plugins already installed. To activate this feature, open the preferences of GAMA and choose the button \"Advanced...\", which gives access to additional preferences.\n\nIn the dialog that appears, navigate to \"Install/Update > Automatic Updates\". Then, enable the option using the check-box in the top of the dialog and choose the best settings for your workflow. Clicking on \"Apply and close\" will save these preferences and dismiss the dialog.\n\nFrom now on, GAMA will continuously support you in having an up-to-date version of the platform, provided you accept the updates."},{"filePath":"https:--gama-platform.org--wiki-Using-BEN-simple-bdi.txt","text":"Using BEN (simple_bdi)Introduction to BEN​\nBEN (Behavior with Emotions and Norms) is an agent architecture providing social agents with cognition, emotions, emotional contagion, personality, social relations, and norms. This work has been done during the Ph.D. of Mathieu Bourgais, funded by the ANR ACTEUR.\nThe BEN architecture is accessible in GAMA through the use of the simple_bdi architecture when defining agents. This page indicates the theoretical running of BEN as well as the practical way it has been implemented in GAMA.\nThis page features all the descriptions for the running of the BEN architecture. This page is updated with the version of BEN implemented in GAMA. To get more details on its implementation in GAMA, see operators related to BDI, BDI tutorial or BDI built-in architecture reference.\nThe BEN architecture​\nThe BEN Architecture used by agents to make a decision at each time step is represented by the image right below:\n\nEach social agent has its own instance of the BEN architecture to make a decision. The architecture is composed of 4 main parts connected to the agent's knowledge bases, seated on the agent's personnality. Each part is made up of processes that are automatically computed (in blue) or which need to be manually defined by the modeler (in pink). Some of these processes are mandatory (in solid line) and some others are optional (in dotted line). This modularity enables each modeler to only use components that seem pertinent to the studied situation without creating heavy and useless computations.\nThe Activity diagram bellow shows the order in which each module and each process is activated. The rest of this page explains in details how each process from each module works and what is the difference between the theoretical architecture and its implementation.\n\nPredicates, knowledge and personality​\nIn BEN, an agent represents its environment through the concept of predicates.\nA predicate represents information about the world. This means it may represent a situation, an event or an action, depending on the context. As the goal is to create behaviors for agents in a social environment, that is to say taking actions performed by other agents into account with facts from the environment in the decision making process, an information P caused by an agent j with an associated list of value V is represented by Pj(V). A predicate P represents an information caused by any or none agent, with no particular value associated. The opposite of a predicate P is defined as not P.\nIn GAML, the simple_bdi architecture adds a new type called predicate which is made of a name (mandatory), a map of values (optional) an agent causing it (optional) and a truth value (optional, by default at true). To manipulate these predicates, there are operators like set_agent_cause, set_truth, with_values and add_values to modify the corresponding attribute of a given predicate (with_values changes all the map of values while add_values enables to add a new value without changing the rest of the map). These values can be accessed with operators get_agent_cause, get_truth, get_values. An operator not is also defined for predicates.\nBelow is an example of how to define predicates in GAML:\npredicate a <- new_predicate(\"test\");predicate b <- new_predicate(\"test\",[\"value1\"::10]);predicate c <- new_predicate(\"test\",agentBob);predicate d <- new_predicate(\"test\",false);predicate e <- new_predicate(\"test\",agenBob,false);\nCognitive mental states​\nThrough the architecture, an agent manipulates cognitive mental states to make a decision; they constitute the agent's mind. A cognitive mental state possessed by the agent $i$ is represented by Mi(PMEm,Val,Li) with the following meaning:\n\nM: the modality indicating the type of the cognitive mental state (e.g. a belief).\nPMEm: the object with which the cognitive mental state relates. It can be a predicate, another cognitive mental state, or an emotion.\nVal: a real value which meaning depends on the modality.\nLi: a lifetime value indicating the time before the cognitive mental state is forgotten.\n\nA cognitive mental state with no particular value and no particular lifetime is written Mi(PMEm). Val[Mi(PMEm)] represents the value attached to a particular cognitive mental state and Li[Mi(PMEm)] represents its lifetime.\nThe cognitive part of BEN is based on the BDI paradigm (Bratman, 1987) in which agents have a belief base, a desire base and an intention base to store the cognitive mental states about the world. In order to connect cognition with other social features, the architecture outlines a total of 6 different modalities which are defined as follows:\n\nBelief: represents what the agent knows about the world. The value attached to this mental state indicates the strength of the belief.\nUncertainty: represents an uncertain information about the world. The value attached to this mental state indicates the importance of the uncertainty.\nDesire: represents a state of the world the agent wants to achieve. The value attached to this mental state indicates the priority of the desire.\nIntention: represents a state of the world the agent is committed to achieve. The value attached to this mental state indicates the priority of the intention.\nIdeal: represents an information socially judged by the agent. The value attached to this mental state indicates the praiseworthiness value of the ideal about P. It can be positive (the ideal about P is praiseworthy) or negative (the ideal about P is blameworthy).\nObligation: represents a state of the world the agent has to achieve. The value attached to this mental state indicates the priority of the obligation.\n\nIn GAML, mental states are manipulated thanks to add, remove and get actions related to each modality: add_belief, remove_belief, get_belief, add_desire, remove_desire ...\nThen, operators enables to acces or modify each attribute of a given mental state: get_predicate, set_predicate, get_strength, set_strength, get_lifetime, set_lifetime, etc.\nBelow is an exemple of code in GAML concerning cognitive mental states:\nreflex testCognition{    predicate a <- new_predicate(\"test\");    do add_belief(a,strength1,lifetime1);    mental_state b <- get_uncertainty(a);    int c <- get_lifetime(b);}\nEmotions​\nIn BEN, the definition of emotions is based on the OCC theory of emotions (Ortony, 90). According to this theory, an emotion is a valued answer to the appraisal of a situation. Once again, as the agents are taken into consideration in the context of a society and should act depending on it, the definition of an emotion needs to contain the agent causing it.\nThus, an emotion is represented by Emi(P,Ag,I,De) with the following elements :\n\nEmi: the name of the emotion felt by agent i.\nP: the predicate representing the fact about which the emotion is expressed.\nAg: the agent causing the emotion.\nI: the intensity of the emotion.\nDe: the decay withdrawal from the emotion's intensity at each time step.\n\nAn emotion with any intensity and any decay is represented by Emi(P,Ag) and an emotion caused by any agent is written Emi(P). I[Emi(P,Ag)] stands for the intensity of a particular emotion and De[Emi(P,Ag)] stands for its decay value.\nIn GAML, emotions are manipulated thanks to add_emotion, remove_emotion and get_emotion actions and attributes of an emotion are manipulated with set and get operators (set_intensity, set_about, set_decay, set_agent_cause, get_intensity, get_about, get_decay, get_agent_cause).\nBelow is an exemple of code in GAML concerning emotions:\nreflex testEmotion{    predicate a <- new_predicate(\"test\");    do add_emotion(new_emotion(\"hope\",a));    do add_emotion(new_emotion(\"joy\",intesity1,a, decay1));    float c <- get_intensity(get_emotion(new_emotion(\"joy\",a)));}\nSocial relations​\nAs people create social relations when living with other people and change their behavior based on these relationships, BEN architecture makes it possible to describe social relations in order to use them in agents' behavior. Based on the research carried out by (Svennevig, 2000), a social relation is described by using a finite set of variables. Svennevig identifies a minimal set of four variables: liking, dominance, solidarity, and familiarity. A trust variable is added to interact with the enforcement of social norms. Therefore, in BEN, a social relation between agent i and agent j is expressed as Ri,j(L,D,S,F,T) with the following elements:\n\nR: the identifier of the social relation.\nL: a real value between -1 and 1 representing the degree of liking with the agent concerned by the link. A value of -1 indicates that agent j is hated, a value of 1 indicates that agent j is liked.\nD: a real value between -1 and 1 representing the degree of power exerted on the agent concerned by the link. A value of -1 indicates that agent j is dominating, a value of 1 indicates that agent j is dominated.\nS: a real value between 0 and 1 representing the degree of solidarity with the agent concerned by the link. A value of 0 indicates that there is no solidarity with agent j, a value of 1 indicates a complete solidarity with agent j.\nF: a real value between 0 and 1 representing the degree of familiarity with the agent concerned by the link. A value of 0 indicates that there is no familiarity with agent j, a value of 1 indicates a complete familiarity with agent j.\nT: a real value between -1 and 1 representing the degree of trust with the agent j. A value of -1 indicates doubts about agent j while a value of 1 indicates complete trust with agent j. The trust value does not evolve automatically in accordance with emotions.\n\nWith this definition, a social relation is not necessarily symmetric, which means Ri,j(L,D,S,F,T) is not equal by definition to Rj,i(L,D,S,F,T). L[Ri,j] stands for the liking value of the social relation between agent i and agent j, D[i,j] stands for its dominance value, S[Ri,j] for its solidarity value, F[Ri,j] represents its familiarity value and T[Ri,j] its trust value.\nIn GAML, social relations are manipulated with add_social_link, remove_social_link and get_social_link actions. Each feature of a social link is accessible with set and gt operators (set_agent, get_agent, set_liking, get_liking, set_dominance, etc.)\nBelow is an exemple of code to manipulates social relations in GAML:\nreflex testSocialRelations{   do add_social_link(new_social_link(agentAlice));   do add_social_link(new_social_link(agentBob,0.5,-0.3,0.2,0.1));   float val <- get_liking(get_social_link(new_social_link(agentBob)));   social_link sl <- set_dominance(get_social_link(new_social_link(agentBob)),0.3);}\nPersonality and additional variables​\nIn order to define personality traits, BEN relies on the OCEAN model (McCrae, 1992), also known as the big five factors model.\nIn the BEN architecture, this model is represented through a vector of five values between 0 and 1, with 0.5 as the neutral value. The five personality traits are:\n\nO: represents the openness of someone. A value of 0 stands for someone narrow-minded, a value of 1 stands for someone open-minded.\nC: represents the consciousness of someone. A value of 0 stands for someone impulsive, a value of 1 stands for someone who acts with preparations.\nE: represents the extroversion of someone. A value of 0 stands for someone shy, a value of 1 stands for someone extrovert.\nA: represents the agreeableness of someone. A value of 0 stands for someone hostile, a value of 1 stands for someone friendly.\nN: represents the degree of control someone has on his/her emotions, called neurotism. A value of 0 stands for someones neurotic, a value of 1 stands for someone calm.\n\nIn GAML, these variables are build-in attributes of agents using the simple_bdi control architecture. They are called openness, conscientiousness, extroversion, agreeableness and neurotism. To use this personality to automaticaly parametrize the other modules, a modeler needs to indicate it as shown in the GAML example below:\nspecies miner control:simple_bdi {    ...    bool use_personality <- true;    float openness <- 0.1;    float conscientiousness <- 0.2;    float extroversion <- 0.3;    float agreeableness <- 0.4;    float neurotism <- 0.5;    ...}\nWith BEN, the agent has variables related to some of the social features. The idea behind the BEN architecture is to connect these variables to the personality module and in particular to the five dimensions of the OCEAN model in order to reduce the number of parameters which need to be entered by the user. These additional variables are:\n\nThe probability to keep the current plan.\nThe probability to keep the current intention.\nA charisma value linked to the emotional contagion process.\nAn emotional receptivity value linked to the emotional contagion.\nAn obedience value used by the normative engine.\n\nWith the cognition, the agent has two parameters representing the probability to randomly remove the current plan or the current intention in order to check whether there could be a better plan or a better intention in the current context. These two values are connected to the consciousness components of the OCEAN model as it describes the tendency of the agent to prepare its actions (with a high value) or act impulsively (with a low value).\n\nProbability Keeping Plans = C1/2\nProbability Keeping Intentions = C1/2\n\nFor the emotional contagion, the process (presented later) requires charisma (Ch) and emotional receptivity (R) to be defined for each agent. In BEN, charisma is related to the capacity of expression, which is related to the extroversion of the OCEAN model, while the emotional receptivity is related to the capacity to control the emotions, which is expressed with the neurotism value of OCEAN.\n\nCh = E\nR = 1 - N\n\nWith the concept of norms, the agent has a value of obedience between 0 and 1, which indicates its tendency to follow laws, obligations, and norms. According to research in psychology, which tried to explain the behavior of people participating in a recreation of the Milgram's experiment (Begue, 2015), obedience is linked with the notions of consciousness and agreeableness which gives the following equation:\n\nobedience = ((C+A)/2)1/2\n\nWith the same idea, all the parameters required by each process are linked to the OCEAN model.\nIf a modeler wants to put a different value to one of these variables, he/she just need to indicate a new value manualy. For the probability to keep the current plan and the probability to keep the current intention, he/she also has to indicates it with a particular boolean value, as shown in the GAML example below:\nspecies miner control: simple_bdi {    ...    bool use_personality <- true;    bool use_persistence <- true;    float plan_persistence <- 0.3;    float intention_persistence <- 0.4;    float obedience <- 0.2;    float charisma <- 0.3;    float receptivity <- 0.6;    ...}\nPerception​\nThe first step of BEN is the perception of the environment. This module is used to connect the environment to the knowledge of the agent, transforming information from the world into cognitive mental states, emotions or social links but also used to apply sanctions during the enforcement of norms from other agents.\nBelow is an example of code to define a perception in GAML:\nperceive target: fireArea in: 10{    ...}\nThe first process in this perception consists of adding beliefs about the world. During this phase, information from the environment is transformed into predicates which are included in beliefs or uncertainties and then added to the agent's knowledge bases. This process enables the agent to update its knowledge about the world. From the modeler's point of view, it is only necessary to specify which information is transformed into which predicate. The addition of a belief BeliefA(X) triggers multiple processes :\n\nit removes BeliefA(not X).\nit removes IntentionA(X).\nit removes DesireA(X) if IntentionA(X) has just been removed.\nit removes UncertaintyA(X) or UncertaintyA(not X).\nit removes ObligationA(X).\n\\end{itemize}\n\nIn GAML, the focus statement eases the use of this process. Below is an example that adds a belief and an uncertainty with the focus statement during a perception:\nperceive target: fireArea in: 10{    focus id:\"fireLocation\" var:location strength:10.0;    //is equivalent to ask myself {do add_belief(new_predicate(\"fireLocation\",[\"location_value\"::myself.location],10.0);}    focus id:\"hazardLocation\" var:location strength:1.0 is_uncertain:true;    //is equivalent to ask myself {do add_uncertainty(new_predicate(\"hazardLocation\",[\"location_value\"::myself.location],1.0);}}\nThe emotional contagion enables the agent to update its emotions according to the emotions of other agents perceived. The modeler has to indicate the emotion triggering the contagion, the emotion created in the perceiving agent and the threshold of this contagion; the charisma (Ch) and receptivity (R) values are automatically computed as explained previously. The contagion from agent i to agent j occurs only if Chi x Rj is superior or equal to the threshold, which value is 0.25 by default. Then, the presence of the trigger emotion in the perceived agent is checked in order to create the emotion indicated.\nThe intensity and decay value of the emotion acquired by contagion are automatically computed.\n\nIf Emj(P) already exists:\n\nI[Emj(P)] = I[Emj(P)] + I[Emi(P)] x Chi x Rj\nif pEmi(P)] > I[Emj(P)]:\n\nDe[Emj(P)] = De[Emi(P)]\n\n\nif I[Emj(P)] > I[Emi(P)]:\n\nDe[Emj(P)] = De[Emj(P)]\n\n\n\n\nIf Emj(P) does not already exist:\n\nI[Emj(P)] = I[Emi(P)] x Chi x Rj\nDe[Emj(P)] = De[Emi(P)].\n\n\n\nIn GAML, emotional_contagion statement helps to define an emotional contagion during a perception, as shown below:\nperceive target: otherHumanAgents in: 10{    emotional_contagion emotion_detected:fearFire threshold:contagionThreshold;    //creates the detected emotion, if detected, in the agent doing the perception.    emotional_contagion emotion_detected:joyDance emotion_created:joyPartying;    //creates the emotion \"joyPartying\", if emotion \"joyDance\" is detected in the perceived agent.}\nDuring the perception, the agent has the possibility of creating social relations with other perceived agents. The modeler indicates the initial value for each component of the social link, as explained previously. By default, a neutral relation is created, with each value of the link at 0.0. Social relations can also be defined before the start of the simulation, to indicate that an agent has links with other agents at the start of the simulation, like links with friends or family members.\nIn GAML, the socialize statement help creating dynamicaly new social relations, as shown below:\nperceive target:otherHumanAgents in: 10{    socialize;    //creates a neutral relation    socialize dominance: -0.8 familiarity:0.2 when: isBoss;    //example of a social link with precise values for some of its dimensions in a certain context}\nFinally, the agent may apply sanctions through the norm enforcement of other agents perceived. The modeler needs to indicate which modality is enforced and the sanction and reward used in the process. Then, the agent checks if the norm, the obligation, or the law, is violated, applied or not activated by the perceived agent. Notions of norms laws and obligations and how they work are explained later in this ocument.\nA norm is considered violated when its context is verified, and yet the agent chose another norm or another plan to execute because it decided to disobey. A law is considered violated when its context is verified, but the agent disobeyed it, not creating the corresponding obligation. Finally, an obligation is considered violated if the agent did not execute the corresponding norm because it chose to disobey.\nBelow is an example of how to define an enforcement in GAML:\nspecies miner skills: [moving] control:simple_bdi {    ...    perceive target: miner in: viewdist {\tmyself.agent_perceived<-self;\tenforcement norm:\"share_information\" sanction:\"sanctionToNorm\" reward:\"rewardToNorm\";    }\t\t    sanction sanctionToNorm{\tdo change_liking(agent_perceived,-0.1);    }\t\t    sanction rewardToNorm{\tdo change_liking(agent_perceived,0.1);    }}\nManaging knowledge bases​\nThe second step of the architecture, corresponding to the module number 2, consists of managing the agent's knowledge. This means updating the knowledge bases according to the latest perceptions, adding new desires, new obligations, new emotions or updating social relations, for example.\nModelers have to use inference rules for this purpose. Theses rules are triggered by a new belief, a new uncertainty or a new emotion, in a certain context, and may add or remove any cognitive mental state or emotion indicated by the user. Using multiple inference rules helps the agent to adapt its mind to the situation perceived without removing all its older cognitive mental states or emotions, thus enabling the creation of a cognitive behavior. These inference rules enable to link manually the various dimensions of an agent, for example creating desires depending on emotions, social relations and personality.\nIn GAML, the rule statement enables to define inference rules:\nspecies miner skills: [moving] control: simple_bdi {    ...    perceive target: miner in: viewdist {\t...    }    ...    rule belief: new_predicate(\"testA\") new_desire: new_predicate(\"testB\");}\nUsing the same idea, modelers can define laws. These laws enable the creation of obligations in a given context based on the newest beliefs created by the agent through its perception or its inference rules. The modeler also needs to indicate an obedience threshold and if the agent's obedience value is below that threshold, the law is violated. If the law is activated, the obligation is added to the agent's cognitive mental state bases. The definition of laws makes it possible to create a behavior based on obligations imposed upon the agent.\nBelow is an example of the definition of a law statement in GAML:\nlaw belief: new_predicate(\"testA\") new_obligation:new_predicate(\"testB\") threshold:thresholdLaw;\nEmotional engine​\nBEN enables the agent to get emotions about its cognitive mental states. This addition of emotions is based on the OCC model (Ortony, 1990) and its logical formalism (Adam, 2007), which has been proposed to integrate the OCC model in a BDI formalism.\nAccording to the OCC theory, emotions can be split into three groups: emotions linked to events, emotions linked to people and actions performed by people, and emotions linked to objects.\nIn BEN, as the focus is on relations between social agents, only the first two groups of emotions (emotions linked to events and people) are considered.\nThe twenty emotions defined in this paper can be divided into seven groups depending on their relations with mental states: emotions about beliefs, emotions about uncertainties, combined emotions about uncertainties, emotions about other agents with a positive liking value, emotions about other agents with a negative liking value, emotions about ideals and combined emotions about ideals.\nAll the initial intensities and decay value are computed using the OCEAN model and the value attached to the concerned mental states.\nThe emotions about beliefs are joy and sadness and are expressed this way:\n\n\nJoyi(Pj,j) = Beliefi(Pj) & Desirei(P)\n\n\nSadnessi(Pj,j) = Beliefi(Pj) & Desirei(not P)\n\n\nTheir initial intensity is computed according to the following equation with N the neurotism component from the OCEAN model:\n\nI[Emi(P)] = V[Beliefi(P)] x V[Desirei(P)] x (1+(0,5-N))\n\nThe emotions about uncertainties are fear and hope and are defined this way:\n\nHopei(Pj,j) = Uncertaintyi(Pj) & Desirei(P)\nFeari(Pj,j) = Uncertaintyi(Pj) & Desirei(not P)\n\nTheir initial intensity is computed according to the following equation:\n\nI[Emi(P)] = V[Uncertaintyi(P)] x V[Desirei(P)] x (1+(0,5-N))\n\nCombined emotions about uncertainties are emotions built upon fear and hope. They appear when an uncertainty is replaced by a belief, transforming fear and hope into satisfaction, disappointment, relief or fear confirmed and they are defined this way:\n\nSatisfactioni(Pj,j) = Hopei(Pj,j) & Beliefi(Pj)\nDisappointmenti(Pj,j) = Hopei(Pj,j) & Beliefi(not Pj)\nReliefi(Pj,j) = Feari(Pj,j) & Beliefi(not Pj)\nFear confirmedi(Pj,j) = Feari(Pj,j) & Beliefi(Pj)\n\nTheir initial intensity is computed according to the following equation with Em'i(P) the emotion of fear/hope.\n\nI[Emi(P)] = V[Beliefi(P)] x I[Em'i(P)]\n\nOn top of that, according to the logical formalism (Adam, 2007), four inference rules are triggered by these emotions:\n\nThe creation of fear confirmed or the creation of relief will replace the emotion of fear.\nThe creation of satisfaction or the creation of disappointment will replace a hope emotion.\nThe creation of satisfaction or relief leads to the creation of joy.\nThe creation of disappointment or fear confirmed leads to the creation of sadness.\n\nThe emotions about other agents with a positive liking value are emotions related to emotions of other agents which are in a the social relation base with a positive liking value on that link. They are the emotions called \"happy for\" and \"sorry for\" which are defined this way :\n\nHappy fori(P,j) = L[Ri,j]>0 & Joyj(P)\nSorry fori(P,j) = L[Ri,j]>0 & Sadnessj(P)\n\nTheir initial intensity is computed according to the following equation with A the agreeableness value from the OCEAN model.\n\nI[Emi(P)] = I[Emj(P)] x L[Ri,j] x (1-(0,5-A))\n\nEmotions about other agents with a negative liking value are close to the previous definitions, however, they are related to the emotions of other agents which are in the social relation base with a negative liking value. These emotions are resentment and gloating and have the following definition:\n\nResentmenti(P,j) = L[Ri,j]<0 & Joyj(P)\nGloatingi(P,j) = L[Ri,j]<0 & Sadnessj(P)\n\nTheir initial intensity is computed according to the following equation. This equation can be seen as the inverse of Equation \\eqref{eqIntensEmo4}, and means that the intensity of resentment or gloating is greater if the agent has a low level of agreeableness contrary to the intensity of \"happy for\" and \"sorry for\".\n\nI[Emi(P)] = I[Emj(P)] x |L[Ri,j]| x (1+(0,5-A))\n\nEmotions about ideals are related to the agent's ideal base which contains, at the start of the simulation, all the actions about which the agent has a praiseworthiness value to give. These ideals can be praiseworthy (their praiseworthiness value is positive) or blameworthy (their praiseworthiness value is negative). The emotions coming from these ideals are pride, shame, admiration and reproach and have the following definition:\n\nPridei(Pi,i) = Beliefi(Pi) & Ideali(Pi) & V[Ideali(Pi)]>0\nShamei(Pi,i) = Beliefi(Pi) & Ideali(Pi) & V[Ideali(Pi)]<0\nAdmirationi(Pj,j) = Beliefi(Pj) & Ideali(Pj) & V[Ideali(Pj)]>0\nReproachi(Pj,j) = Beliefi(Pj) & Ideali(Pj) & V[Ideali(Pj)]<0\n\nTheir initial intensity is computed according to the following equation with O the openness value from the OCEAN model:\n\nI[Emi(P)] = V[Beliefi(P)] x |V[Ideali(P)]| x (1+(0,5-O))\n\nFinally, combined emotions about ideals are emotions built upon pride, shame, admiration and reproach. They appear when joy or sadness appear with an emotion about ideals. They are gratification, remorse, gratitude and anger which are defined as follows:\n\nGratificationi(Pi,i) = Pridei(Pi,i) & Joyi(Pi)\nRemorsei(Pi,i) = Shamei(Pi,i) & Sadnessi(Pi)\nGratitudei(Pj,j) = Admirationi(Pj,j) & Joyi(Pj)\nAngeri(Pj,j) = Reproachi(Pj,j) & Sadnessi(Pj)\n\nTheir initial intensity is computed according to the following equation with Em'i(P) the emotion about ideals and Em\"i(P) the emotion about beliefs.\n\nI[Emi(P)] = I[Em'i(P)] x I[Em\"i(P)]\n\nIn order to keep the initial intensity of each emotion between 0 and 1, each equation is truncated between 0 an 1 if necessary.\nThe initial decay value for each of these twenty emotions is computed according to the same equation with Deltat a time step which enables to define that an emotion does not last more than a given time:\n\nDe[Emi(P)] = N x I[Emi(P)] x Deltat\n\nTo use this automatic computation of emotion, a modeler need to activate it as shown in the GAML example below :\nspecies miner control:simple_bdi {    ...    bool use_emotions_architecture <- true;    ...}\nSocial Engine​\nWhen an agent already known is perceived (i.e. there is already a social link with it), the social relationship with this agent is updated automatically by BEN. This update is based on the work of (Ochs, 2009) and takes the agent's cognitive mental states and emotions into account. In this section, the automatic update of each variable of a social link Ri,j(L,D,S,F,T) by the architecture is described in details; the trust variable of the link is however not updated automatically.\n\nLiking: according to (Ortony, 1991), the degree of liking between two agents depends on the valence (positive or negative) of the emotions induced by the corresponding agent. In the emotional model of the architecture, joy and hope are considered as positive emotions (satisfaction and relief automatically raise joy with the emotional engine) while sadness and fear are considered as negative emotions (fear confirmed and disappointment automatically raise sadness with the emotional engine). So, if an agent i has a positive (resp. negative) emotion caused by an agent j, this will increase (resp. decrease) the value of appreciation in the social link from i concerning j.\n\nMoreover, research has shown that the degree of liking is influenced by the solidarity value \\cite{smith2014social}. This may be explained by the fact that people tend to appreciate people similar to them.\nThe computation formula is described with the following equation with mPos the mean value of all positive emotions caused by agent j, mNeg the mean value of all negative emotions caused by agent j and aL a coefficient depending of the agent's personality, indicating the importance of emotions in the process, and which is described below.\n\n\nL[Ri,j]=L[Ri,j]+|L[Ri,j]|(1-|L[Ri,j]|)S[Ri,j] + aL (1-|L[Ri,j]|)(mPos-mNeg)\n\n\naL = 1-N\n\n\nDominance :  (Keltner, 2001) and  (Shiota, 2004) explain that an emotion of fear or sadness caused by another agent represent an inferior status. But (Knutson, 1996) explains that perceiving fear and sadness in others increases the sensation of power over those persons.\n\n\nThe computation formula is described by the following equation with mSE the mean value of all negative emotions caused by agent i to agent j, mOE the mean value of all negative emotions caused by agent j to agent i and aD a coefficient depending on the agent's personality, indicating the importance of emotions in the process.\n\n\nD[Ri,j]=D[Ri,j] + aD (1-|D[Ri,j]|)(mSE-mOE)\n\n\naD = 1-N\n\n\nSolidarity: The solidarity represents the degree of similarity of desires, beliefs, and uncertainties between two agents. In BEN, the evolution of the solidarity value depends on the ratio of similarity between the desires, beliefs, and uncertainties of agent i and those of agent j.\nTo compute the similarities and oppositions between agent i and agent j, agent i needs to have beliefs about agent j's cognitive mental states. Then it compares these cognitive mental states with its own to detect similar or opposite knowledge.\n\n\nOn top of that, negative emotions tend to decrease the value of solidarity between two people. The computation formula is described by the following equation with sim the number of cognitive mental states similar between agent i and agent j, opp the number of opposite cognitive mental states between agent i and agent j, NbKnow the number of cognitive mental states in common between agent i and agent j, mNeg the mean value of all negative emotions caused by agent j, aS1 a coefficient depending of the agent's personality, indicating the importance of similarities and oppositions in the process, and aS2 a coefficient depending of the agent's personality, indicating the importance of emotions in the process.\n\n\nS[Ri,j]=S[Ri,j] + S[Ri,j] x (1-S[Ri,j]) x (aS1 (sim-opp)/(NbKnow) - aS2 mNeg))\n\n\naS1 = 1-O\n\n\naS2 = 1-N\n\n\nFamiliarity: In psychology, emotions and cognition do not seem to impact the familiarity. However, (Collins, 1994) explains that people tend to be more familiar with people whom they appreciate. This notion is modeled by basing the evolution of the familiarity value on the liking value between two agents. The computation formula is defined by the following equation.\n\n\nF[Ri,j]=F[Ri,j] x (1+L[Ri,j])\n\n\nThe trust value is not evolving automatically in BEN, as there is no clear and automatic link with cognition or emotions. However, this value can evolve manually, especially with sanctions and rewards to social norms where the modeler can indicate a modification of the trust value during the enforcement process.\nTo use this automatic update of social relations, a modeler need to activate it as shown in the GAML example below:\nspecies miner control: simple_bdi {    ...    bool use_social_architecture <- true;    ...}\nMaking Decision​\nThe third part of the architecture is the only one mandatory as it is where the agent makes a decision. A cognitive engine can be coupled with a normative engine to chose an intention and a plan to execute. The complete engine is summed up in  the figure below:\n\nThe decision-making process can be divided into seven steps:\n\nStep 1: the engine checks the current intention. If it is still valid, the intention is kept so the agent may continue to carry out its current plan.\nStep 2: the engine checks if the current plan/norm is still usable or not, depending on its context.\nStep 3: the engine checks if the agent obeys an obligation taken from the obligations corresponding to a norm with a valid context in the current situation and with a threshold level lower than the agent's obedience value as computed in Section 4.1.\nStep 4: the obligation with the highest priority is taken as the current intention.\nStep 5: the desire with the highest priority is taken as the current intention.\nStep 6: the plan or norm with the highest priority is selected as the current plan/norm, among the plans or norms corresponding to the current intention with a valid context.\nStep 7: the behavior associated with the current plan/norm is executed.\n\nSteps 4, 5 and 6 do not have to be deterministic; they may be probabilistic. In this case, the priority value associated with obligations, desires, plans, and norms serves as a probability.\nIn GAML, a modeler may indicate the use of a probabilistic or deterministic cognitive engine with the variable probabilistic_choice, as shown in the example code below:\nspecies miner control: simple_bdi {    ...    bool probabilistic_choice <- true;    ...}\nDefining plans​\nThe modeler needs to define action plans which are used by the cognitive engine, as explained earlier. These plans are a set of behaviors executed in a certain context in response to an intention. In BEN, a plan owned by agent i is represented by Pli(Int,Cont,Pr,B) with:\n\nPl: the name of the plan.\nInt: the intention triggering this plan.\nCont: the context in which this plan may be applied.\nPr: a priority value used to choose between multiple plans relevant at the same time. If two plans are relevant to the same priority, one is chosen at random.\nB: the behavior, as a sequence of instructions, to execute if the plan is chosen by the agent.\n\nThe context of a plan is a particular state of the world in which this plan should be considered by the agent making a decision. This feature enables to define multiple plans answering the same intention but activated in various contexts.\nBelow is an example for the definition of two plans answering the same intention in different contexts in GAML:\nspecies miner control: simple_bdi skills: [moving]{    ...    plan evacuationFast intention: in_shelter emotion: fearConfirmed priority:2 {\tcolor <- #yellow;\tspeed <- 60 #km/#h;\tif (target = nil or noTarget) {\t    target <- (shelter with_min_of (each.location distance_to location)).location;\t    noTarget <- false;\t} else  {\t    do goto target: target on: road_network move_weights: current_weights recompute_path: false;\t    if (target = location)  {\t\tdo die;\t    }\t\t\t}    }\t\t    plan evacuation intention: in_shelter finished_when: has_emotion(fearConfirmed){\tcolor <-#darkred;\tif (target = nil or noTarget) {\t    target <- (shelter with_min_of (each.location distance_to location)).location;\t    noTarget <- false;\t} else  {\t    do goto target: target on: road_network move_weights: current_weights recompute_path: false;\t    if (target = location)  {\t\tdo die;\t    }\t\t\t}    }    ...}\nDefining norms​\nA normative engine may be used within the cognitive engine, as it has been explained above. This normative engine means choosing an obligation as the current intention and selecting a set of actions to answer this intention. Also, the concept of social norms is modeled as a set of action answering an intention, which an agent could disobey.\ntention and selecting a set of actions to answer this intention. Also, the concept of social norms is modeled as a set of action answering an intention, which an agent could disobey.\nIn BEN, this concept of behavior which may be disobeyed is formally represented by a norm possessed by agent i  Noi(Int,Cont,Ob,Pr,B,Vi) with:\n\nNo: the name of the norm.\nInt: the intention which triggers this norm.\nCont: the context in which this norm can be applied.\nOb: an obedience value that serves as a threshold to determine whether or not the norm is applied depending on the agent's obedience value (if the agent's value is above the threshold, the norm may be executed).\nPr: a priority value used to choose between multiple norms applicable at the same time.\nB: the behavior, as a sequence of instructions, to execute if the norm is followed by the agent.\nVi: a violation time indicating how long the norm is considered violated once it has been violated.\n\nIn GAML, a norm is defined as follows:\nspecies miner control: simple_bdi {    ...//this first norm answer an intention coming from an obligation    norm doingJob obligation:has_gold finished_when: has_belief(has_gold) threshold:thresholdObligation{        if (target = nil) {\t    do add_subintention(has_gold,choose_goldmine, true);\t    do current_intention_on_hold();        } else {\t    do goto target: target ;\t    if (target = location)  {\t\tgoldmine current_mine<- goldmine first_with (target = each.location);\t\tif current_mine.quantity > 0 {\t\t    gold_transported <- gold_transported+1;\t \t    do add_belief(has_gold);\t\t    ask current_mine {quantity <- quantity - 1;}\t\t\t} else {\t\t    do add_belief(new_predicate(empty_mine_location, [\"location_value\"::target]));\t\t    do remove_belief(new_predicate(mine_at_location, [\"location_value\"::target]));\t\t}\t\ttarget <- nil;\t    }\t}\t    }//this norm may be seen as a \"social norm\" as it answers an intention not coming from an obligation but may be disobeyed    norm share_information intention:share_information threshold:thresholdNorm instantaneous: true{\tlist<miner> my_friends <- list<miner>((social_link_base where (each.liking > 0)) collect each.agent);\tloop known_goldmine over: get_beliefs_with_name(mine_at_location) {\t    ask my_friends {\t\tdo add_belief(known_goldmine);\t    }\t}\tloop known_empty_goldmine over: get_beliefs_with_name(empty_mine_location) {\t    ask my_friends {\t\tdo add_belief(known_empty_goldmine);\t    }\t}\t\t\tdo remove_intention(share_information, true);     }    ...}\nDynamic knowledge​\nThe final part of the architecture is used to create a temporal dynamic to the agent's behavior, useful in a simulation context. To do so, this module automatically degrades mental states and emotions and updates the status of each norm.\nThe degradation of mental states consists of reducing their lifetime. When the lifetime is null, the mental state is removed from its base. The degradation of emotions consists of reducing the intensity of each emotion stored by its decay value. When the intensity of an emotion is null, the emotion is removed from the emotional base.\nIn GAML, if a mental state has a lifetime value or if an emotion has an intensity and a decay value, this degradation process is done automatically.\nFinally, the status of each norm is updated to indicate if the norm was activated or not (if the context was right or wrong) and if it was violated or not (the norm was activated but the agent disobeyed it). Also, a norm can be violated for a certain time which is updated and if it becomes null, the norm is not violated anymore.\nThese last steps enable the agent's behavior's components to automatically evolve through time, leading the agents to forget a piece of knowledge after a certain amount of time, creating dynamics in their behavior.\nConclusion​\nThe BEN architecture is already implemented in GAMA and may be accessed by adding the simple_bdi control architecture to the definition of a species.\nA tutorial may be found with the BDI Tutorial."},{"filePath":"https:--gama-platform.org--wiki-Using-extensions.txt","text":"Using extensionsThe core GAMA software can be extended with some additional plugins, allowing the model to give more capabilities to agents (negotiation, using fuzzy logic, or Bayesian network) or providing connections to external softwares such as R or Matlab.\nFor instructions to install these additional plugins, interested readers can refer to the dedicated page.\nSelected plugins provided by the GAMA community​\nThe update site located at the address http://updates.gama-platform.org/experimental contains new plugins for GAMA mainly developed by the GAMA community (its Github repository is available here). As the name of the repository highlights it, these plugins are for most of them still in development, before integration in the kernel of GAMA..\nIn addition, there are a few eclipse plugins that also work with GAMA.\nThe following plugins have been tested and  are still supported:\n\nRJava: to connect GAMA and R\nWeka: to connect GAMA and Weka\nMatlab: to connect GAMA and Matlab\nArgumentation feature: to allow agents to reason on an argument system\nBayesian Network feature: to use Bayesian Network to make decision\nFuzzy logic: to use fuzzy logic model to make decision\nLaunchpad:\nCamisole:\nImageAnalysis: to add image processing algorithms to gama\nMike and Hecras:\nMPI:\nQRCode: to add primitives to encode/decode QRCodes in gaml\nSwitch project:\nUml Generator: to be able to generate uml from gaml models inside the GAMA IDE\nUnity: to connect GAMA to Unity\nVR:\nGaming: to add more interactive types of displays\nRemote.Gui: to allow exposing some model parameters in order to interact with external application through a network communication\nifcfile: to add support for ifc files in gaml\nNetcdf: to add support for the NetCDF file format in gaml\nWebcam: to add webcam handling primitives in gaml\nGraphical editor: to edit gaml models with graphical blocks instead of code\nMarkdown documentation: to add the possibility to generate the markdown documentation of a model\nEasy shell: to add the eclipse Easy shell plugin to the GAMA IDE\ngit client: to add the eclipse git client into the GAMA IDE\n\nRJava plugin​\nThis plugin allows the modeler to launch some computation on the R software. To this purpose, R should be installed on your computer and GAMA should be properly configured.\nThis possible connection to R opens thus the possibility for the modeler to use all the statistical functions and libraries developed in this tool of reference. In addition, R scripts defined by the modeler can also be used directly from their GAMA model.\nToward participative simulations with Remote.Gui and Gaming plugins​\nThere are more and more applications of GAMA for participative simulations (LittoSim, MarakAir, HoanKiemAir...). There was thus a need for new features to improve the possible interactions with simulations and the definition of the Graphical User Interface. The two plugins Remote.Gui and Gaming (available in the \"Participative simulation\" category) attempts to fill this need.\n\nRemote.Gui allows exposing some model parameters, in order that they can be modified through a network. This allows, for example, to develop a remote application (e.g. Android application) to control the parameters' values during the simulation.\nGaming allows the modeler to define displays that are much more interactive. This is used to define serious games in which the users can have a wide range of possible interactions with the simulation.\n\nWeka and Matlab plugins​\nSimilarly to RJava, Matlab and Weka plugins allow the modeler to run computations on the Matlab and Weka software, taking advantages of all the possibilities of these softwares and of scripts defined by themselves.\nNotice that the Matlab plugin requires MATLAB 2019a to be installed and activated on your computer.\nThe graphical editor​\nThe graphical editor allows to create or edit existing GAMA models using only graphical elements, in a similar way to the scratch programming language. You can find a complete overview of the plugin here.\nThe Git client​\nThis plugin gives you the possibility to have the same git integration in GAMA than in eclipse, with dedicated views and contextual menus directly in the IDE. For more information you can go to it's dedicated documentation."},{"filePath":"https:--gama-platform.org--wiki-UsingDatabase.txt","text":"Using Database AccessDatabase features of GAMA provide a set of actions on Database Management Systems (DBMS). Database features are implemented in the irit.gaml.extensions.database plug-in with these features:\n\nAgents can execute SQL queries (create, Insert, select, update, drop, delete) to various kinds of DBMS.\n\nThese features are implemented in two kinds of components: skill (SQLSKILL) and agent (AgentDB).\nSQLSKILL and AgentDB provide almost the same features (the same set of actions on DBMS) but with certain slight differences:\n\nAn agent of species AgentDB will maintain a unique connection to the database during the whole simulation. The connection is thus initialized when the agent is created and destroyed when it is killed.\nIn contrast, an agent of a species with the SQLSKILL skill will open a connection each time it wants to execute a query. This means that each action will be composed of three running steps:\n\nMake a database connection.\nExecute an SQL statement.\nClose database connection.\n\n\n\n\nAn agent with the SQLSKILL spends a lot of time to create/close the connection each time it needs to send a query; it saves the database connection (a DBMS often limits the number of simultaneous connections). In contrast, an AgentDB agent only needs to establish one database connection that can be used for any action. Because it does not need to create and close the database connection for each action, therefore actions of AgentDB agents are executed faster than the actions of SQLSKILL ones but we must pay a connection for each agent.\n\nWith an inheritance agent of species AgentDB or an agent of a species using SQLSKILL, we can query data from relational database to create agents, define the environment, or analyze or store simulation results in RDBMS. The database features help us to have more flexibility in the management of simulation models and analysis of simulation results.\nDescription​\n\nPlug-in: irit.gaml.extensions.database\nAuthor: TRUONG Minh Thai, Frederic AMBLARD, Benoit GAUDOU, Christophe SIBERTIN-BLANC\n\nSupported DBMS​\nThe following DBMS are currently supported:\n\nSQLite\nMySQL\nPostgreSQL: The GIS extension needs to be installed and activated in the database.\n\nNote that, MySQL and Postgres DBMSs require a dedicated server to work while SQLite only needs a file to be accessed.\nAll the actions are independent from the chosen DBMS. Only the connection parameters are DBMS-dependent.\nWe chose to implement 3 main query actions:\n\nselect: that will execute the SELECT SQL queries. It will return a result dataset.\ninsert: that will execute the INSERT SQL queries. It will return the number of records that are affected by the SQL query.\nexecuteUpdate: that can execute any CREATE/INSERT/DROP/DELETE SQL queries (basically all the queries that do not return a dataset. It generalizes the insert action.\n\nSQLSKILL skill​\nDefine a species that uses the SQLSKILL skill​\nExample of declaration:\nspecies toto skills: [SQLSKILL] {\t//insert your descriptions here}\nAgents with such a skill can use new actions defined in the skill. All these actions need information for the database connection.\nMap of connection parameters for SQL​\nIn the actions defined in the SQLSKILL, a parameter containing the connection parameters is required. It is a map with key::value pairs with the following keys:\n\ndbtype (mandatory): DBMS type value. Its value is a string. We must use \"mysql\" when we want to connect to a MySQL. That is the same for \"postgres\", \"sqlite\" (ignore case sensitive)\nhost (optional): Host name or IP address of data server. It is absent when we work with SQlite.\nport (optional): Port of connection. It is not required when we work with SQLite.\ndatabase  (mandatory): Name of database. It is the file name including the path when we work with SQLite.\nuser (optional): Username. It is not required when we work with SQLite.\npasswd  (optional): Password. It is not required when we work with SQLite.\nsrid (optional): srid (Spatial Reference Identifier) corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences->External configuration.\n\nExample: Definitions of connection parameters\n// POSTGRES connection parametermap <string, string>  POSTGRES <- [     'host'::'localhost',     'dbtype'::'postgres',     'database'::'BPH',     'port'::'5432',     'user'::'postgres',     'passwd'::'abc'];//SQLitemap <string, string>  SQLITE <- [    'dbtype'::'sqlite',    'database'::'../includes/meteo.db'];// MySQL connection parametermap <string, string>  MySQL <- [    'host'::'localhost',    'dbtype'::'MySQL',    'database'::'', // it may be a empty string    'port'::'3306',    'user'::'root',    'passwd'::'abc'];\nAction testConnection: test a connection to a database​\nSyntax:\n\ntestConnection (params: map <string, string>)\nThe action tests the connection to a given database.\n\n\nReturn: boolean. It is:\n\ntrue: the agent can connect to the DBMS (to the given Database with the given name and password).\nfalse: the agent cannot connect (either the server is not started, the database does not exist or the user/password are not correct).\n\n\nArguments:\n\nparams (type = map <string, string>): map of connection parameters\n\n\nExceptions: GamaRuntimeException\n\nExample: Check a connection to a MySQL database.\n// Needs to be executed in the context of an agent with the SQLSKILL skill.// MySQL is the connection parameters map defined above.if (testConnection(MySQL)){\twrite \"Connection is OK\" ;}else{\twrite \"Connection is false\" ;}\t\nAction select: select data from a database​\nSyntax:\n\nselect (params: map <string, string>, select: string, values: list)\nThe action creates a connection to a DBMS and executes the select statement. If the connection or selection fails then it throws a GamaRuntimeException.\n\n\nReturn: list<list>. If the selection succeeds, it returns a list with three elements:\n\nThe first element is a list of column names.\nThe second element is a list of column types.\nThe third element is a data set.\n\n\nArguments:\n\nparams (type = map<string,string>): map containing the connection parameters\nselect (type = string): A SQL query returning values, i.e. a SELECT query. The selection query can be a parametric query (i.e. it can contain question marks).\nvalues (type = list): List of values that are used to replace question marks. This is an optional parameter.\n\n\nExceptions: GamaRuntimeException\n\nExample: select data from table points.\nmap <string, string>   PARAMS <- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db'];list<list> t <- select(PARAMS, \"SELECT * FROM points ;\");\nExample: select data from table point with question marks from table points.\nmap <string, string> PARAMS <- ['dbtype'::'sqlite', 'database'::'../includes/meteo.db'];list<list> t <- select(params: PARAMS,                        select: \"SELECT temp_min FROM points where (day>? and day<?);\",                       values: [10,20] );\nAction insert: Insert data into a database​\nSyntax:\n\ninsert (param: map<string,string>,  into:  string, columns: list<string>, values: list)\nThe action creates a connection to a DBMS and executes the insert statement. If the connection or insertion fails then it throws a_GamaRuntimeException_.\n\n\nReturn: int\n\n\nIf the insertion succeeds, it returns a number of records inserted by the insert.\n\n\nArguments:\n*params (type = map<string,string>): map containing the connection parameters.\n*into (type = string): the table name.\n*columns (type=list<string>): list of column names of the table. It is an optional argument. If it is not specified then all columns of table are selected.\n*values (type=list): list of values that are used to insert into the table chosen columns. Hence the columns and values must have same size.\nExceptions:_GamaRuntimeException\n\nExample: Insert data into table registration.\nmap<string, string> PARAMS <- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db'];do insert (params: PARAMS,            into: \"registration\",            values: [102, 'Mahnaz', 'Fatma', 25]);do insert (params: PARAMS,                 into: \"registration\",                 columns: [\"id\", \"first\", \"last\"],                 values: [103, 'Zaid tim', 'Kha']);int n <- insert (params: PARAMS,                  into: \"registration\",                  columns: [\"id\", \"first\", \"last\"],                  values: [104, 'Bill', 'Clark']);\nAction executeUpdate: Execution update commands​\nSyntax:\n\nexecuteUpdate (param: map<string,string>, updateComm:  string, columns: list<string>, values: list)\nThe action executeUpdate executes an update command (create/insert/delete/drop) by using the current database connection of the agent. If the database connection or the update command fails then it throws a GamaRuntimeException. Otherwise, it returns an integer value.\n\n\nReturn: int. It returns a number of records affected by the SQL query.\nArguments:\n\nparams (type = map<string,string>): map containing the connection parameters,\nupdateComm (type = string): SQL query string. It may be one of the SQL commands: create, update, delete and drop with or without question marks.\ncolumns (type=list<string>):  list of column names of the table.\nvalues (type=list): list of values that are used to replace question marks if appropriate. This is an optional parameter.\n\n\nExceptions: GamaRuntimeException\n\nExamples: Using action executeUpdate to execute some SQL commands (create, insert, update, delete and drop).\nmap<string, string> PARAMS <- ['dbtype'::'sqlite',  'database'::'../../includes/Student.db'];// Create tabledo executeUpdate (params: PARAMS,                   updateComm: \"CREATE TABLE registration\"                               + \"(id INTEGER PRIMARY KEY, \"                               + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \"                               + \" age INTEGER);\");// Insert into do executeUpdate (params: PARAMS,                    updateComm: \"INSERT INTO registration \" + \"VALUES(100, 'Zara', 'Ali', 18);\");do insert (params: PARAMS, into: \"registration\",            columns: [\"id\", \"first\", \"last\"],            values: [103, 'Zaid tim', 'Kha']);// executeUpdate with question marksdo executeUpdate (params: PARAMS,                  updateComm: \"INSERT INTO registration \" + \"VALUES(?, ?, ?, ?);\",                   values: [101, 'Mr', 'Mme', 45]);//update int n <-  executeUpdate (params: PARAMS,                           updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\" );// deleteint n <- executeUpdate (params: PARAMS,                         updateComm: \"DELETE FROM registration where id=? \",                          values: [101] );// Drop tabledo executeUpdate (params: PARAMS, updateComm: \"DROP TABLE registration\");\nAgentDB​\nAgentBD is a built-in species, which supports behaviors that look like actions in SQLSKILL but differs in that it uses only one connection for several actions. It means that AgentDB creates a connection to the database and keeps that connection open for its later operations.\nDefine a species that is an inheritance of AgentDB​\nExample of declaration:\nspecies agtDB parent: AgentDB {  \t//insert your descriptions here} \nAction connect: Connect to a database​\nSyntax:\n\nconnect (params: map<string,string>)\nThis action makes a connection to the database. If a connection is established then it will assign the connection object into a built-in attribute of the species (conn) otherwise it throws a GamaRuntimeException.\n\n\nReturn: connection\nArguments:\n\nparams (type = map<string,string>): map containing the connection parameters\n\n\nExceptions: GamaRuntimeException\n\nExample: Connect to PostgreSQL\n// POSTGRES connection parametermap <string, string>  POSTGRES <- [                                        'host'::'localhost',                                        'dbtype'::'postgres',                                        'database'::'BPH',                                        'port'::'5433',                                        'user'::'postgres',                                        'passwd'::'abc'];ask agtDB {      do connect (params: POSTGRES);}\nAction isConnected: Check whether an agent is connected to a database​\nSyntax:\n\nisConnected (params: map<string,string>)\nThis action checks if an agent is connected to a database.\n\n\nReturn: Boolean.  If the agent is connected to a database then isConnected returns true; otherwise it returns false.\nArguments:\n\nparams (type = map<string,string>): map containing the connection parameters\n\n\n\nExample: Check whether the agents agtDB are connected.\nask agtDB {\tif (self isConnected){              write \"It already has a connection\";\t}else{              do connect (params: POSTGRES);        } }\nAction close: Close the current connection​\nSyntax:\n\nclose\nThis action closes the current database connection of the current agent. If the agent does not have any database connection then it throws a GamaRuntimeException.\n\nExample: close the connection of all the agtDB agents.\nask agtDB {\tif (self.isConnected()){\t      do close;\t}}\nAction getParameter: Get connection parameters​\nSyntax:\n\ngetParameter\nThis action returns the connection parameters of the current agent.\n\n\nReturn: map<string,string>\n\nExample:\nask agtDB {\tif (self.isConnected()){\t\twrite \"the connection parameter: \" +self.getParameter();        }}\nSet connection parameters​\nSyntax:\n\nsetParameter (params: map<string,string>)\nThis action sets new values for connection parameters and closes the current connection of the agent. If it can not close the current connection then it will throw GamaRuntimeException. If the species wants to make the connection to database with the new values then action connect must be called.\n\n\nReturn: null\nArguments:\n\nparams (type = map<string,string>): map containing the connection parameters\n\n\nExceptions: GamaRuntimeException\n\nExample:\nask agtDB {\tif (self.isConnected()){             do setParameter params: MySQL;             do connect params: self.getParameter();        }}\nRetrieve data from a database by using AgentDB​\nBecause AgentDB's connection to the database is kept alive, it can execute several SQL queries using only the connect action once. Hence AgentDB can do actions such as select, insert, executeUpdate with the same parameters as those of SQLSKILL except for the params parameter which is always absent.\nExamples:\nmap<string, string> PARAMS <- ['dbtype'::'sqlite', 'database'::'../../includes/Student.db'];ask agtDB {   do connect params: PARAMS;   // Create table   do executeUpdate updateComm: \"CREATE TABLE registration\" \t+ \"(id INTEGER PRIMARY KEY, \"         + \" first TEXT NOT NULL, \" + \" last TEXT NOT NULL, \"         + \" age INTEGER);\";   // Insert into    do executeUpdate updateComm: \"INSERT INTO registration \"         + \"VALUES(100, 'Zara', 'Ali', 18);\";   do insert into: \"registration\" columns: [\"id\", \"first\", \"last\"]\t     values: [103, 'Zaid tim', 'Kha'];    // executeUpdate with question marks   do executeUpdate updateComm: \"INSERT INTO registration VALUES(?, ?, ?, ?);\" \t            values: [101, 'Mr', 'Mme', 45];      //select   list<list> t <- self.select(\"SELECT * FROM registration;\");       //update    int n <- self.executeUpdate(updateComm: \"UPDATE registration SET age = 30 WHERE id IN (100, 101)\");        // delete   int n <- executeUpdate ( updateComm: \"DELETE FROM registration where id=? \",  values: [101] );        // Drop table   do executeUpdate updateComm: \"DROP TABLE registration\";}\nUsing database features to define the environment and create agents​\nIn GAMA, it is possible to initialize the simulations from data stored in a database: we can use the results of the select action of SQLSKILL or AgentDB to create agents or to define the boundary of the environment in the same way we do with shape files. Further more, we can also save simulation data that are generated by the simulation including geometry data.\nNote that GAMA only supports PostGIS and MySQL as spatial DBMS.\nDefine the boundary of the environment from the database​\n\n\nStep 1: specify the SELECT query by declaring a map object with keys as below:\n\ndbtype (mandatory): DBMS type value. Its value is a string. We must use \"mysql\" when we want to connect to a MySQL. That is the same for \"postgres\", \"sqlite\" (ignore case sensitive)\nhost (optional): Host name or IP address of data server.\nport (optional): Port of connection.\ndatabase  (mandatory): Name of database.\nuser (optional): Username.\npasswd  (optional): Password.\nsrid (optional): srid (Spatial Reference Identifier) corresponds to a spatial reference system. This value is specified when GAMA connects to spatial database. If it is absent then GAMA uses spatial reference system defined in Preferences->External configuration.\nselect (mandatory): selection query.\n\n\n\nExample:\nmap<string,string> BOUNDS <- [\t\t//'srid'::'32648',\t'host'::'localhost',\t\t\t\t\t\t\t\t        'dbtype'::'postgres',\t'database'::'spatial_DB',\t'port'::'5433',\t\t\t\t\t\t\t\t        'user'::'postgres',\t'passwd'::'tmt',\t'select'::'SELECT ST_AsBinary(geom) as geom FROM bounds;' ];\n\nStep 2: define the boundary of the environment by using the map object defined in the first step (in the global block of the model).\n\ngeometry shape <- envelope(BOUNDS);\nNote: We can do the same way if we work with MySQL and we must convert Geometry format in GIS database to binary format.\nCreate agents from the result of a select action​\nIf we are familiar with how to create agents from a shapefile then it becomes very simple to create agents from datbase data. We can do as below:\n\nStep 1: Define a species with SQLSKILL or AgentDB\n\nspecies DB_accessor skills: SQLSKILL {\t//insert your descriptions here\t}\t\n\nStep 2: Define a connection and selection parameters\n\nglobal {\tmap<string,string> PARAMS <- [\t//'srid'::'32648', // optional\t\t\t\t\t'host'::'localhost',\t\t\t\t\t'dbtype'::'postgis',\t\t\t\t\t'database'::'spatial_db',\t\t\t\t\t'port'::'5432',\t\t\t\t\t'user'::'postgres',\t\t\t\t\t'passwd'::''];\t\tstring QUERY <- \"SELECT type, ST_AsEWKB(geom) as geom FROM buildings;\";}      \n\nStep 3: Create species by using selected results\n\ninit {\tcreate DB_accessor {\t\tcreate buildings from: select(PARAMS, QUERY)\t\t\t\t with:[ nature::\"type\", shape::\"geom\"];\t }   ...}\nSave Geometry data to database​\nSaving agents in a database will be simply a set of insertion into the database. We can do as below:\n\nStep 1: Define a species with SQLSKILL or AgentDB\n\nspecies DB_accessor skills: SQLSKILL {  \t//insert your descriptions here} \n\nStep 2: Define a connection and create GIS database and tables\n\nglobal {\tmap<string,string> PARAMS <-  [//'srid'::'4326', // optional\t\t\t\t\t'host'::'localhost','dbtype'::'postgres','database'::'spatial_db',\t\t\t\t\t'port'::'5432','user'::'postgres','passwd'::''];\tinit {\t   create DB_accessor ;\t   ask DB_accessor {\t\tif (self.testConnection(PARAMS)){\t           // create GIS database\t \t\t   do executeUpdate(params:PARAMS, \t\t      updateComm: \"CREATE DATABASE spatial_db with TEMPLATE = template_postgis;\");  \t\t   remove key: \"database\" from: PARAMS;\t\t   put \"spatial_db\" key:\"database\" in: PARAMS;\t\t                   //create table                   do executeUpdate params: PARAMS \t\t\t\t  updateComm : \"CREATE TABLE buildings \"+\t\t\t\t  \"( \"  +                   \t               \" name character varying(255), \" +                                        \" type character varying(255), \" +                                        \" geom GEOMETRY \" +                                    \")\";\t\t    }else { \t\t\twrite \"Connection to MySQL can not be established \"; \t\t    }\t\t\t}\t}}\n\nStep 3: Insert geometry data to the GIS database\n\nask building {   ask DB_Accessor {\tdo insert(params: PARAMS,                   into: \"buildings\",\t\t  columns: [\"name\", \"type\",\"geom\"],\t\t  values: [myself.name, myself.type, myself.shape];   }}"},{"filePath":"https:--gama-platform.org--wiki-UsingDrivingSkill.txt","text":"Driving SkillThis page aims at presenting how to use the driving skill in models.\nThe use of the driving skill requires to use 3 skills:\n\ndriving skill: dedicated to the definition of the driver species. It provides the driver agents with variables and actions allowing to move an agent on a graph network and to tune its behavior.\nroad skill: dedicated to the definition of roads. It provides the road agents with variables and actions allowing to registers agents on the road.\nintersection skill: dedicated to the definition of nodes. It provides the node agents with variables allowing to take into account the intersection of roads and the traffic signals.\n\nTable of contents​\n\nDriving Skill\n\nStructure of the network: road and road node skills\nDriving skill\nApplication example\n\n\n\nStructure of the network: road and road_node skills​\nThe driving skill is versatile enough to be usable with most of classic road GIS data, in particular, OSM data. We use a classic format for the roads and intersections. Each road is a polyline composed of road sections (segments). Each road has a target intersection and a source intersection. Each intersection knows all its input and output roads. A road is considered as directed. For bidirectional roads, 2 roads have to be defined corresponding to both directions. Each road will be the linked_road of the other. Note that for some GIS data, only one road is defined for bidirectional roads, and the intersections are not explicitly defined. In this case, it is very easy, using the GAML language, to create the reverse roads and the corresponding intersections (it only requires a few lines of GAML).\n\nA road can be composed of several lanes and the vehicles will be able to change at any time its lane. What a lane represents will depend a lot on the context of application. Typically, if in developed countries, the lanes are most of times well defined, in many other countries this notion is much more abstract. For example in Vietnam where the main means of locomotion is the motorcycle, a lane can designate a \"place\" for a motorcycle and thus be much narrower than classical lanes. Another property of the road that will be taken into account is the maximal authorized speed on it. Note that even if the user of the plug-in has no information about these values for some of the roads (the OSM data are often incomplete), it is very easy using the GAML language to fill the missing value by a default value. It is also possible to change these values dynamically during the simulation (for example, to take into account that after an accident, a lane of a road is closed or that the speed of a road is decreased by the authorities).\n\nThe road skill (road_skill) provides the road agents with several variables that will define the road properties:\n\nnum_lanes: integer, number of lanes.\nmaxspeed: float; maximal authorized speed on the road.\nlinked_road: road agent; reverse road (if there is one).\nsource_node: intersection agent; source intersection of the road.\ntarget_node: intersection agent; target intersection of the road.\n\nIt provides as well the road agents with read-only variables:\n\nagents_on: list of list (of driver agents); for each lane, the list of driver agents on the road.\nall_agents: list (of driver agents): the list of agents on the road.\n\nThe intersection skill (intersection_skill) provides the road node agents with several variables that will define the road node properties:\n\nroads_in: list of road agents; the list of road agents that have this node for target node.\nroads_out: list of road agents; the list of road agents that have this node for source node.\nstop: list of list of road agents; list of stop signals, and for each stop signal, the list of concerned roads.\npriority_roads: list of road agents: the list of priority roads.\n\nIt provides as well the road agents with one read-only variable:\n\nblock: map: key: driver agent, value: list of road agents; the list of driver agents blocking the node, and for each agent, the list of concerned roads.\n\nDriving skill​\nA vehicle is first characterized by its location, a 3D-point (coordinate) that represents the centroid of the vehicle. The actual geometry of the vehicle is not taken into account. However, the size of a vehicle is determined by two attributes: vehicle_length and num_lanes_occupied. Indeed, if we go back to our Vietnamese example where the lanes are defined according to the size of the motorcycles, we can consider that a motorcycle will occupy one lane, but that a car, which is much wider, will occupy two.\nEach vehicle agent has also a planned trajectory that consists of a succession of edges. When the vehicle agent enters a new edge, it first chooses its lane according to the traffic density, with a bias for the rightmost lane. The movement on an edge is inspired by the Intelligent Driver Model. The drivers have the possibility to change their lane at any time (and not only when entering a new edge). The lane-changing model is inspired from the MOBIL model.\nThe driving skill (driving) provides the driver agents with several variables that will define the car properties and the personality of the driver:\n\nfinal_target: point; final location that the agent wants to reach (its goal).\nvehicle_length: float; length of the vehicle.\nnum_lanes_occupied: float; the number of lanes occupied by the vehicle.\nmax_acceleration: float; maximal acceleration of the vehicle.\nmax_speed: float; maximal speed of the vehicle.\nright_side_driving: boolean; do drivers drive on the right side of the road?\nspeed_coeff: float; coefficient that defines if the driver will try to drive above or below the speed limits.\nsafety_distance_coeff: float; coefficient for the security distance. The security distance will depend on the driver speed and on this coefficient.\nproba_lane_change_up: float; probability to change lane to an upper lane if necessary (and if possible).\nproba_lane_change_down: float; probability to change lane to a lower lane if necessary (and if possible).\nproba_use_linked_road: float; probability to take the reverse road if necessary (if there is a reverse road).\nproba_respect_priorities: float; probability to respect left/right (according to the driving side) priority at intersections.\nproba_respect_stops: list of float; probabilities to respect each type of stop signals (traffic light, stop sign...).\nproba_block_node: float; probability to accept to block the intersecting roads to enter a new road.\nlane_change_cooldown: float;  the duration that a vehicle must wait before changing lanes again\nmax_safe_deceleration: float;  the maximum deceleration that the vehicle is willing to induce on its back vehicle when changing lanes. Known as the parameter 'b_save' in the MOBIL lane changing model\nmin_safety_distance: float; the minimum distance of the vehicle's front bumper to the leading vehicle's rear bumper, known as the parameter\ns0 in the Intelligent Driver Model\nlane_change_limit: int; the maximum number of lanes that the vehicle can change during a simulation step\nacc_gain_threshold: float; the minimum acceleration gain for the vehicle to switch to another lane, introduced to prevent frantic lane changing. Known as the parameter 'a_th' in the MOBIL lane changing model\nlinked_lane_limit: int; the maximum number of linked lanes that the vehicle can use; the default value is -1, i.e. the vehicle can use all available linked lanes\nignore_oneway: bool; if set to true, the vehicle will be able to violate one-way traffic rule\nlowest_lane: int; the lane with the smallest index that the vehicle is in\nacc_bias: float; the bias term used for asymmetric lane changing, parameter 'a_bias' in MOBIL\nallowed_lanes: list of int; a list containing possible lane index values for the attribute lowest_lane\ntime_headway: float; the time gap that to the leading vehicle that the driver must maintain. Known as the parameter 'T' in the Intelligent Driver Model\ndelta_idm: float; the exponent used in the computation of free-road acceleration in the Intelligent Driver Model\nmax_deceleration: float; the maximum deceleration of the vehicle. Known as the parameter 'b' in the Intelligent Driver Model\npoliteness_factor: float; determines the politeness level of the vehicle when changing lanes. Known as the parameter 'p' in the MOBIL lane changing model\n\nIt provides as well the driver agents with several read-only variables:\n\nspeed: float; speed expected according to the road max_value, the car properties, the personality of the driver and its real_speed.\nreal_speed: float; real speed of the car (that takes into account the other drivers and the traffic signals).\ncurrent_path: path (list of roads to follow); the path that the agent is currently following.\ncurrent_road: agent; the road on which the agent is driving on.\nlowest_lane: agent; the index of the lowest lane occupied.\ncurrent_target: point; the next target to reach (sub-goal). It corresponds to a node.\ntargets: list of points; list of locations (sub-goals) to reach the final target.\ncurrent_index: integer; the index of the current goal the agent has to reach.\nusing_linked_road: boolean; is the agent on the linked road?\n\nOf course, the values of these variables can be modified at any time during the simulation. For example, the probability to take a reverse road (proba_use_linked_road) can be increased if the driver is stuck for several minutes behind a slow vehicle.\nIn addition, the driving skill provides driver agents with several actions:\n\ncompute_path: arguments: a graph and a target node. This action computes from a graph the shortest path to reach a given node.\ndrive: no argument. This action moves the driver on its current path according to the traffic condition and the driver properties (vehicle properties and driver personality). The drive_random make the agent drives on a road and chooses randomly a new road at each intersection.\n\nThe drive action works as follow: while the agent has the time to move (remaining_time > 0), it first defines the speed expected. This speed is computed from the max_speed of the road, the current real_speed, the max_speed, the max_acceleration and the speed_coef of the driver.\nThen, the agent moves toward the current target and compute the remaining time. During the movement, the agents can change lanes. If the agent reaches its final target, it stops; if it reaches its current target (that is not the final target), it tests if it can cross the intersection to reach the next road of the current path. If it is possible, it defines its new target (target node of the next road) and continues to move.\nThe function that defines if the agent crosses or not the intersection to continue to move works as follow: first, it tests if the road is blocked by a driver at the intersection (if the road is blocked, the agent does not cross the intersection). Then, if there is at least one stop signal at the intersection (traffic signal, stop sign...), for each of these signals, the agent tests its probability to respect or not the signal (note that the agent has a specific probability to respect each type of signals). If there is no stopping signal or if the agent does not respect it, the agent checks if there is at least one vehicle coming from a right (or left if the agent drives on the left side) road at a distance lower than its security distance. If there is one, it tests its probability to respect this priority. If there is no vehicle from the right roads or if it chooses to do not respect the right priority, it tests if it is possible to cross the intersection to its target road without blocking the intersection (i.e. if there is enough space in the target road). If it can cross the intersection, it crosses it; otherwise, it tests its probability to block the node: if the agent decides nevertheless to cross the intersection, then the perpendicular roads will be blocked at the intersection level (these roads will be unblocked when the agent is going to move).\nConcerning the movement of the driver agents on the current road, the agent moves from a section of the road (i.e. segment composing the polyline) to another section according to the maximal distance that the agent can moves (that will depend on the remaining time). For each road section, the agent first computes the maximal distance it can travel according to the remaining time and its speed. Then, the agent computes its security distance according to its speed and its safety_distance_coeff. While its remaining distance is not null, the agent computes the maximal distance it can travel (and the corresponding lane), then it moves according to this distance (and update its current lane if necessary). If the agent is not blocked by another vehicle and can reach the end of the road section, it updates its current road section and continues to move.\nThe computation of the maximal distance an agent can move on a road section consists of computing for each possible lane the maximal distance the agent can move. First, if there is a lower lane, the agent tests the probability to change its lane to a lower one. If it decides to test the lower lane, the agent computes the distance to the next vehicle on this lane and memorizes it. If this distance corresponds to the maximal distance it can travel, it chooses this lane; otherwise, it computes the distance to the next vehicle on its current lane and memorizes it if it is higher than the current memorized maximal distance. Then if the memorized distance is lower than the maximal distance the agent can travel and if there is an upper lane, the agents test the probability to change its lane to an upper one. If it decides to test the upper lane, the agent computes the distance to the next vehicle on this lane and memorizes it if it is higher than the current memorized maximal distance. At last, if the memorized distance is still lower than the maximal distance it can travel if the agent is on the highest lane and if there is a reverse road, the agent tests the probability to use the reverse road (linked road). If it decides to use the reverse road, the agent computes the distance to the next vehicle on the lane 0 of this road and memorizes the distance if it is higher than the current memorized maximal distance.\nMore details about the driving skill can be found here"},{"filePath":"https:--gama-platform.org--wiki-UsingFIPAACL.txt","text":"Using FIPA ACLGAMA allows modelers to provide agents the capability to communicate with other agents using FIPA Communication Acts (such as inform, request, call for proposal...) and Interaction Protocols (such Contract Net Interaction Protocol, Request Interaction Protocol).\nTo add these capabilities to the chosen species, the modeler needs to attach the fipa skill: it adds to agents of the species some additional attributes (e.g. the list of messages received) and available actions (e.g. the possibility to send messages given the chosen Communication Act).\nThe exhaustive list of available Communication Acts and Interaction Protocols is available from the technical description of the fipa skill page.\nExamples can be found in the model library bundled with GAMA (Plugin models / FIPA Skill).\nTable of Contents​\n\nMain steps to create a conversation using FIPA Communication Acts and Interaction Protocols\nAttach the fipa skill to a species\nInitiate a conversation\nReceive messages\nReply to a received message\nThe message data type\nThe conversation data type\n\nMain steps to create a conversation using FIPA Communication Acts and Interaction Protocols​\n\nAttach the skill fipa to the agents' species that need to use Communication Acts\nAn initiator agent starts a conversation with some agents: it chooses the Interaction Protocol and starts it by sending the first Communication Acts of the protocol\nEach agent involved in the conversation needs to check its received messages and respond to them by choosing the appropriate Communication Act.\n\nAttach the fipa skill to a species​\nTo attach the fipa skill to a species, the modeler has to add it in the skills facet of  the species statement (in a way similar to any other skill).\nspecies any_species skills: [fipa] {   ...}\nAgents of any species can communicate in the same conversation. The only constraint is that they need to have the capabilities to receive and send messages, i.e. to have the skill fipa.\nSpecies can have several attached skills: a single species can be provided with both the moving and fipa skills (and any other ones).\nThis skill adds to every agent of the species:\n\nsome additional attributes:\n\nconversations is the list of the agent's current conversations,\nmailbox is the list of messages of all types of performatives,\nrequests, informs, proposes... are respectively the list of the 'request', 'inform', 'propose' performative messages.\n\n\nsome additional actions, such as:\n\ninform, accept_proposal... that replies a message with an 'inform' (respectively 'accept_proposal' performative message).\nstart_conversation that starts a conversation with a chosen interaction protocol.\nend_conversation that replies a message with an 'end_conversation' performative message. This message marks the end of a conversation. In a 'no-protocol' conversation, it is the responsibility of the modeler to explicitly send this message to mark the end of a conversation/interaction protocol.\nreply that replies a message. This action should be only used to reply a message in a 'no-protocol' conversation and with a 'user-defined performative'. For performatives supported by GAMA, please use the 'action' with the same name as the 'performative'. For example, to reply a message with a 'request' performative message, the modeler should use the 'request' action.\n\n\n\nInitiate a conversation​\nAn interaction using an Interaction Protocol starts with the creation of a conversation by an agent, using the start_conversation action.\nThe modeler specifies the chosen protocol (facet protocol), list of participants (facet to), communication act (facet performative) and message (facet contents).\nspecies Initiator skills: [fipa] {\treflex send_propose_message when: (time = 1) {\t\tdo start_conversation to: [p] protocol: 'fipa-propose' performative: 'propose' contents: ['Go swimming?'] ;\t}\nReceive messages​\nEach agent (with the fipa skill) is provided with several \"mailbox\" attributes filtering the various received messages by communication act: e.g. proposes contains the list of the received messages with the \"Propose\" communication act.\nReceiving a message consists thus in looking at each message from the mailbox, and acting in accordance with its contents, participants...\nImportant remark: once the contents field of a received message has been read, it is removed from all the lists it appears in.\nspecies Initiator skills: [fipa] {\t\treflex read_accept_proposals when: !(empty(accept_proposals)) {\t\twrite name + ' receives accept_proposal messages';\t\tloop i over: accept_proposals {\t\t\twrite 'accept_proposal message with content: ' + string(i.contents);\t\t}\t}}species Participant skills: [fipa] {\treflex accept_proposal when: !(empty(proposes)) {\t\tmessage proposalFromInitiator <- proposes at 0;\t\t\t\tdo accept_proposal message: proposalFromInitiator contents: ['OK! It \\'s hot today!'] ;\t}}\nRemark:\n\nTo test that the agent has received a new message is simply done by testing whether the dedicated mailing box contains messages.\nTo get a message, the modeler can either loop over the message list to get all the messages or get a message by its index in the message box.\n\nReply to a received message​\nGiven the message it has received, an agent can reply using the appropriate Communication Act (using the appropriate action).\nIt simply has to specify the message to which it replies and the content of the reply.\nNote that it does not need to specify the receiver as it is contained in the message.\nspecies Participant skills: [fipa] {\treflex accept_proposal when: !(empty(proposes)) {\t\tmessage proposalFromInitiator <- proposes at 0;\t\t\t\tdo accept_proposal message: proposalFromInitiator contents: ['OK! It \\'s hot today!'] ;\t}}\nEnd a conversation​\nWhen a conversation is made in the scope of an Interaction Protocol, it is ended automatically when the last Communicative Act has been sent.\nIn the case of a 'no-protocol conversation', it is the responsibility of the modeler to explicitly send the end_conversation message to mark the end of a conversation/interaction protocol.\nWhen a conversation ends, it is automatically removed from the list conversations.\nThe message type​\nThe agents' mailbox is defined as a list of messages. Each message is a GAML object of type message. An exhaustive description of this type is provided in the dedicated GAML Data Types page.\nA message object is defined by a set of several fields, such as:\n\ncontents (type unknown): the content of the message\nsender  (type unknown): the sender of the message. In the case where the sender is an agent, it is possible to get the corresponding agent with agent(m.sender) (where m is the considered message).\nunread (type bool): specify whether the message has been read.\nemission_timestamp (type int)\nrecention_timestamp (type int)\n\nThe conversation data type​\nThe agents' conversations contain the list of the conversations in which the agent takes part.  Each conversation is a GAML object of type conversation that contains the list of messages exchanged, the protocol, initiator... An exhaustive description of this type is provided in the dedicated GAML Data Types page.\nA conversation object is defined by a set of several fields, such as:\n\nmessages (type = list of messages): the list of messages that compose this conversation\nprotocol (type = string): the name of the protocol followed by the conversation\ninitiator (type = agent): the agent that has initiated this conversation\nparticipants (type = list of agents): the list of agents that participate in this conversation\nended (type = bool): whether this conversation has ended or not\n"},{"filePath":"https:--gama-platform.org--wiki-UsingGamaFlags.txt","text":"Using GAMA flagsWhat are flags​\nGAMA and some of its components (software libraries) make it possible to change some of the software behaviors by setting up \"flags\". Those are mainly for advanced users and should not be much of a concern for most users.\nGama flags​\nGAMA flags are flags that are build directly by GAMA developers, they have to be set in the Gama.ini file as a new line item (or as a VM argument) like this -D<FLAGNAME>=true/false. For example :\n-Denable_logging=false\nAvailable flags​\n\nenable_debug: Set to true by default, it enable logging the debug messages (DEBUG.OUT(...), DEBUG.ERR(...) which will follow the declaration of DEBUG.ON() on the classes). Set to false to suppress all debug logging (but regular logging using DEBUG.LOG(...) or DEBUG.TIMER(...) will still operate).\nenable_logging: Set to true by default, it enables simple logging activities using DEBUG.LOG(...), DEBUG.TIMER(...). Set to false to prevent all logging activities (incl. debug ones)\nuse_global_preference_store: set to true by default, it saves the preferences in the global (managed by the JRE) preference store. Set to false to save them in each GAMA instance preference store.\nread_only: set to false by default, set to true if you want the files in the gaml editor to be read-only (impossible to modify them)\n\nUsing Eclipse and SWT flags​\nGAMA 1.9.2 uses Eclipse 2022-12 as the based component for the IDE.\nMore precisely, GAMA uses the Eclipse Runtime which provides the foundational support for plug-ins, extension points and extensions (among other facilities), it's the application structure and is built on top of the OSGi framework.\nGAMA also uses the Standard Widget Toolkit (or SWT for short). SWT is designed to provide efficient, portable access to the user-interface facilities of the operating systems on which it is implemented.\nAvailable flags​\nBoth components can be tweaked thanks to the eclipse's Rich Client Platform interface using some flags and parameters documented in the official documentation for Eclipse 2022-12.\nHere are some links to more detailed explanations about both components and their respective flags:\n\nEclipse Runtime\nSWT\n\nUsing JOGL flags​\nJOGL in addition with Glugen (both from JOGAMP) are the two libraries used in GAMA for 3D Graphics, Multimedia and Processing.\nAvailable flags​\nMost of them are documented on the official documentation website."},{"filePath":"https:--gama-platform.org--wiki-UsingNetwork.txt","text":"Using networkIntroduction​\nGAMA provides features to allow agents to communicate with other agents (and other applications) through network and to exchange messages of various types (from simple number to agents). To this purpose, the network skill should be used on agents intending to use these capabilities.\nNotice that in this communication, roles are asymetric: the simulations should contain a server and some clients to communicate. Message exchanges are made between agents through this server. 6 protocols are supported (TCP, UDP, MQTT, HTTP, Websocket, Arduino):\n\nwhen TCP, UDP or Websocket protocols are used: Agents can be either clients or server depending on the needs of the simulation.\nwhen the MQTT protocol is used: all the agents are clients and the server is an external software. A free solution (ActiveMQ) can be freely downloaded from: http://activemq.apache.org.\nwhen HTTP is used: the agents can interact with webpages/webservices through raw GET, POST, PUT, and DELETE requests\nwhen arduino is used: one agent of the simulation can connect to an Arduino as a client.\n\nWhich protocol to use ?​\nIn the GAMA network, 6 kinds of protocol can be used. Each of them has a particular purpose.\n\nMQTT: this is the default protocol that should be used to make agents of various GAMA instances to communicate through a MQTT server (that should be run as an external application, e.g. ActiveMQ that can be downloaded from: http://activemq.apache.org/),\nUDP: this protocol should be limited to fast (and unsecured) exchanges of small pieces of data from GAMA to an external application (for example, mouse location from a Processing application to GAMA, c.f. model library),\nTCP and Websocket: these protocols can be used both to communicate between GAMA agents in a simulation or between GAMA and an external application.\nHTTP requests: this protocol should be used to communicate with an external webservice.\nArduino: this protocol should be used to communicate with an arduino device\n\nDisclaimer​\nIn all the models using any network communication, the server should be launched before the clients.\nAs a consequence, when TCP, Websocket or UDP protocols are used, a model creating a server agent should always be run first. Using MQTT protocol, the external software server should be launched before running any model using it.\nDeclaring a network species​\nTo create agents able to communicate through a network, their species should have the skill network:\nspecies Networking_Client skills: [network] {    ...}\nA list exhaustive of the additional attributes and available actions provided by this skill are described here:\nnetwork skill preference page.\nCreation of a network agent​\nThe network agents are created as any other agents, but (in general) at the creation of the agents, the connection is also created, using the connect built-in action:\ncreate Networking_Client {    do connect to: \"localhost\" protocol: \"tcp_client\" port: 3001 with_name: \"Client\";}\nEach protocol has its specificities regarding the connection:\n\nTCP:\n\nprotocol: the 2 possibles keywords are tcp_server or tcp_client, depending on the wanted role of the agent in the communication.\nport: traditionally the port 3001 is used.\nraw: false by default, it is better to turn it to true when communicating with external applications as it will remove all the wrapper informations used for communication inside gama.\n\n\nWebsocket:\n\nprotocol: the 2 possibles keywords are websocket_server or websocket_client, depending on the wanted role of the agent in the communication.\nport: traditionally the port 3001 is used.\nraw: false by default, it is better to turn it to true when communicating with external applications as it will remove all the wrapper informations used for communication inside gama.\n\n\nUDP:\n\nprotocol: the 2 possibles keywords are udp_server or udp_emitter, depending on the wanted role of the agent in the communication.\nport: traditionally the port 9876 is used.\n\n\nMQTT:\n\nprotocol: MQTT is the default protocol value (if no value is given, MQTT will be used)\nport: traditionally the port 1883 is used (when ActiveMQ is used as the server application)\nadmin and password: traditionally the default login and password are \"admin\" (when ActiveMQ is used as the server application)\n\n\nHTTP requests:\n\nprotocol: the only keyword to use is http.\nport: traditionally the port 80 is used for http connections and 443 for https.\n\n\n\nNote: if no connection information is provided with the MQTT protocol (no port), then GAMA connects to an MQTT server provided by the GAMA community (for test purpose only!).\nSending messages​\nTo send any message, the agent has to use the send action:\ndo send to: \"server\" contents: name + \" \" + cycle + \" sent to server\";\nThe network skill in GAMA allows the modeler to send simple string messages between agents but also to send more complex objects (and in particular agents). In this case, the use of the MQTT protocol is highly recommended.\ndo send to: \"receiver\" contents: (9 among NetworkingAgent);\t\nReceiving messages​\nAsynchronous reading​\nThe messages sent by other agents are received in the mailbox attribute of each agent. So to get its new message, the agent has simply to check whether it has a new message (with action has_more_message() ) and fetch it (that gets it and remove it from the mailing box) with the action fetch_message().\nreflex fetch when: has_more_message() {\t    message mess <- fetch_message();    write name + \" fecth this message: \" + mess.contents;\t}\nNote that when an agent is received, the fetch of the message will recreate the agent in the current simulation.\nAlternatively, the mailbox attribute can be directly accessed (notice that the mailbox is a list of messages):\nreflex receive {      if (length(mailbox) > 0) {        write mailbox;    }}\nSynchronous reading​\nIn certain cases you need to wait for a message from another application to continue the execution of your simulation.\nTo do so, you can use the fetch_message_from_network action to force the mailbox to refresh (which normally is only done once per cycle) until you receive a message:\nreflex fetch {\twrite \"waiting for server to send data\"; \tloop while: !has_more_message()  { \t\tdo fetch_message_from_network;\t}\t\t//This second loop will only be reached once a message has been found into the agent's mailbox\tloop while: has_more_message() {\t\tmessage s <- fetch_message();\t\twrite \"at cycle: \" + cycle + \", received from server: \" + s.contents;\t}}\nBroadcasting a message to all the agents' members of a given group​\nEach time an agent creates a connection to another agent as a client, a way to communicate with it is stored in the network_groups attribute.\nSo an agent can use this attribute to broadcast messages to all the agents with whose it can communicate:\nreflex broad {    loop id over: network_groups {        do send to: id contents: \"I am Server \" + name + \" I give order to \" + id;    }}\nTo go further:\n\nnetwork skill reference page.\nexample models can be found in the GAMA model library, in: Plugin models > Network.\n"},{"filePath":"https:--gama-platform.org--wiki-Using_Git.txt","text":"Using Git from GAMA to version and share modelsInstall the Git client [Tested on the GAMA 1.9.0]​\nThe Git client for GAMA needs to be installed as an external plugin.\n\nHelp > Install new plugins...\nAdd the following address in the text field \"Work with\": https://download.eclipse.org/egit/updates. (press Enter key)\nIn the available plugins to install, choose Git integration for Eclipse > Git integration for Eclipse\nClick on the Next button and follow the instructions (GAMA will be relaunched).\n\nOpen the Git view​\nTo use Git in GAMA select Views -> Other... -> Show View -> Other...\nIn the Show view window that appears select Git -> Git Repositories and click on Open.\n\nCreate a Local Repository​\nWith Git you can easily create local repositories to version your work locally. First, you have to create a GAMA project (e.g GitNewProject) that you want to share via your local repository.\nAfter you have created your GAMA project, go to the Git Repository view and click on Create a new local Git repository.\n\nIn the following window specify the directory for the new repository (select the folder of the created GAMA project - GitNewProject -), throught the button Browse...\n\nthen hit the Create button.\n\nNow your local repository is created, you can add models and files into your GAMA project. As you  selected the folder of the new created GAMA Project, the repository will not be empty. So, it will be initialized with all the folders and files of the GAMA project. Note the changed icons: the project node will have a repository icon, the child nodes will have an icon with a question mark.\n\nBefore you can commit the files to your repository, you need to add them. Simply right click the shared project's node and navigate to Team -> Add to Index.\n\nAfter this operation, the question mark should change to a plus symbol.\n\nTo set certain folders or files to be ignored by Git, right click them and select Team -> Ignore. The ignored items will be stored in a file called .gitignore, which you should add to the repository.\nCommit​\nNow you can modify files in your project, save changes made in your workspace to your repository and commit them. You can do commit the project by right clicking the project node and selecting Team -> Commit... from the context menu. In the Commit wizard, all files should be selected automatically. Enter a commit message and hit the Commit button.\n\nIf the commit was successful, the plus symbols will have turned into repository icons.\n\nAfter changing files in your project, a \">\" sign will appear right after the icon, telling you the status of these files is dirty. Any parent folder of this file will be marked as dirty as well.\n\nIf you want to commit the changes to your repository, right click the project (or the files you want to commit) and select Team -> Commit... . Enter a commit message and click Commit to commit the selected files to your repository.\nAdd Files​\nTo add a new file to the repository, you need to create it in your shared GAMA project first. Then, the new file will appear with a question mark.\n\nRight click it and navigate to Team -> Add to Index. The question mark will turn into a plus symbol and the file will be tracked by Git, but it is not yet committed. In the next commit, the file will be added to the repository and the plus symbol will turn into a repository icon.\n\nRevert Changes​\nIf you want to revert any changes, there are two options. You can compare each file you want to revert with the HEAD revision (or the index, or the previous version) and undo some or all changes done. Second, you can hard reset your project, causing any changes to be reverted.\nRevert via Compare​\nRight click the file you want to revert and select Compare With -> HEAD Revision. This will open a comparison with the HEAD Revision, highlighting any changes done. You can revert several lines.  select the line you want to revert and hit the Copy Current Change from Right to Left button (in the toolbar).\n\nRevert via Reset​\nTo reset all changes made to your project, right click the project node and navigate to Team -> Reset... . Select the branch you want to reset to (if you haven't created any other branches, there will be just one). Click the reset button. All changes will be reset to this branch's last commit. Be careful with this option as all last changes in your Gama Project will be lost.\n\nClone Repositories​\nTo checkout a remote project, you will have to clone its repository first. Open the GAMA Import wizard: right click the User models node -> Import... -> Other...\n\nSelect Git -> Projects from Git and click Next.\n\nSelect \"Clone URI\" and click Next.\n\nNow you will have to enter the repository's location. Entering the URI will automatically fill some fields. Complete any other required fields and hit Next (e.g, Authentification fields). If you use GitHub, you can copy the URI from the web page.\n\nSelect all branches you wish to clone and hit Next again.\n\nHit next, then choose a local storage location to save the repository in.\n\nTo import the projects, select the cloned repository and hit Next.\nSelect Import Existing Projects and hit Next.\n\nIn the following window, select all projects you want to import and click Finish.\n\nThe projects should now appear in the Models Explorer. (Note the repository symbol in the icons indicating that the projects are already shared.)\n\nCreate Branches​\nTo create a new branch in your repository, right click your project and navigate to Team -> Switch to -> New Branch... from the context menu. Select the branch you want to create a new branch from, hit New branch and enter a name for the new branch.\n\nThe new branch (NewBranch) should appear in the branch selection window.\n\nYou can see all the branches in the Git Repositories view.\n\nIf you would like to checkout the a branch, select it and click Checkout.\n\nMerge​\nTo merge one branch into another, right click the project node and navigate to Team -> Merge...\n\nThe merge will execute and a window will pop-up with the results. The possible results are Already-up-to-date, Fast-forward, Merged, Conflicting, Failed.\n\nNote that a conflicting result will leave the merge process incomplete. You will have to resolve the conflicts and try again. When there are conflicting changes in the working project, the merge will fail.\nFetch and Pull​\nTo update the remote branches when cloning remote repositories (Git creates copies of the branches as local branches and as remote branches) you will have to use Fetch. To perform a Fetch, select Team -> Fetch From... from the project's context menu.\nTo update your local branches, you will have to perform a Merge operation after fetching.\nPull​\nPull combines Fetch and Merge. Select Team -> Pull.\nPush​\nLocal changes made to your local branches can be pushed to remote repositories causing a merge from your branches into the branches of the remote repository (X pulls from Y is the same as Y pushes to X). The Push wizard is pretty much the same as the Fetch wizard.\n\nHistory View​\nTo show the repository history, right click it and select Team -> Show in History. This will open the History View, giving an overview of the commits and allowing you to perform several actions (creating branches/tags, revert, reset...).\n"},{"filePath":"https:--gama-platform.org--wiki-ValidationOfModels.txt","text":"Validation of ModelsWhen editing a model, GAMA will continuously validate (i.e. compile) what the modeler is entering and indicate, with specific visual affordances, various information on the state of the model. This information ranges from documentation items to errors indications. We will review some of them in this section.\nTable of contents​\n\nValidation of Models\n\nSyntactic errors\nSemantic errors\nSemantic warnings\nSemantic information\nSemantic documentation\nChanging the visual indicators\nErrors in imported files\nCleaning models\n\n\n\nSyntactic errors​\nThese errors are produced when the modeler enters a sentence that has no meaning in the grammar of GAML (see the documentation of the language). It can either be a non-existing symbol (like \"globals\" (instead of global) in the example below), a wrong punctuation scheme, or any other construct that puts the parser in the incapacity of producing a correct syntax tree. These errors are extremely common when editing models (since incomplete keywords or sentences are continuously validated). GAMA will report them using several indicators: the icon of the file in the title of the editor will sport an error icon and the gutter of the editor (i.e. the vertical space beside the line numbers) will use error markers to report two or more errors: one on the statement defining the model, and one (or more) in the various places where the parser has failed to produce the syntax tree. In addition, the toolbar over the editor will turn red and indicate that errors have been detected. Finally, the validation view gathers all the errors of the workspace.\n\nHovering over one of these markers indicates what went wrong during the syntactic validation. Note that these errors are sometimes difficult to interpret since the parser might fail in places that are not precisely those where a wrong syntax is being used (it will usually fail after).\n\nSemantic errors​\nWhen syntactic errors are eliminated, the validation enters a so-called semantic phase, during which it ensures that what the modeler has written makes sense with respect to the various rules of the language. To understand the difference between the two phases, take a look at the following example.\nThis sentence below is syntactically correct:\nspecies my_species parent: my_species;\nBut it is semantically incorrect because a species cannot be parent of itself. No syntactic errors will be reported here, but the validation will fail with a semantic error.\n\nSemantic errors are reported in a way similar to syntactic errors, except that no marker are displayed beside the model statement. The compiler tries to report them as precisely as possible, underlining the places where they have been found and outputting hopefully meaningful error messages. In the example below, for instance, we use the wrong number of arguments for defining a square geometry. Although the sentence is syntactically correct, GAMA will nevertheless issue an error and prevent the model from being experimentable. The message accompanying this error can be obtained by hovering over the error marker found in the gutter (multiple messages can actually be produced for the same error, see below).\n\nSemantic warnings​\nThe semantic validation phase does not only report errors. It also outputs various indicators that can help the modeler in verifying the correctness of his/her model. Among them are warnings. A warning is an indication that something is not completely right in the way the model is written, although it can probably be worked around by GAMA when the model will be executed. For instance, in the example below, we pass a string argument to the facet \"number:\" of the \"create\" statement.\ncreate people number: \"10\";\nGAMA will emit a warning in such a case, indicating that number: expects an integer and that the string passed will be cast to int when the model will be executed. Warnings are to be considered seriously, as they usually indicate some flaws in the logic of the model.\n\nHovering over the warning marker will allow the modeler to have access to the explanation and hopefully fix the cause of the warning.\n\nSemantic information​\nBesides warnings, another type of harmless feedback is produced by the semantic validation phase: information markers. They are used to indicate useful information to the modeler, for example, that an attribute has been redefined in a sub-species, or that some operation will take place when running the model (for instance, the truncation of a float to an int). The visual affordance used in this case is voluntarily discrete (a small \"i\" in the editor's gutter).\n\nAs with the other types of markers, information markers unveil their messages when being hovered.\n\nSemantic documentation​\nThe last type of output of the semantic validation phase consists of a complete documentation of the various elements present in the model, which the user can retrieve by hovering over the different symbols. Note that although the best effort is being made in producing a complete and consistent documentation, it may happen that some symbols do not produce anything. In that case, please report a new Issue here.\n\nChanging the visual indicators​\nThe default visual indicators depicted in the examples above to report errors, warnings and information can be customized to be less (or more) intrusive. This can be done by choosing the \"Preferences...\" item of the editor contextual menu and navigating to \"General > Editors > Text Editors > Annotations\". There, you will find the various markers used, and you will be able to change how they are displayed in the editor's view. For instance, if you prefer to highlight errors in the text, you can change it here.\n\nWhich will result in the following visual feedback for errors:\n\nErrors in imported files​\nFinally, even if your model has been cleansed of all errors, it may happen that it refuses to launch because it imports another model that cannot be compiled. In the following screenshot, MyFirstModel.gaml imports Imported Model.gaml, which sports an error.\n\nIn such a case, the importing model refuses to compile (although it is itself valid), showing an error in the import statement of the model with errors. There are cases, however, where the same importation can work. Consider the previous example, where Imported Model.gaml sports a semantic error in the definition of the global 'shape' attribute.\n\nHowever, if MyFirstModel.gaml happens to redefine the shape attribute (in global), it is now considered as valid. All the valid sections of Imported Model.gaml are effectively imported, while the erroneous definition is superseded by the new one.\n\nThis process is described by the information marker next to the redefinition.\n\nCleaning models​\nIt may happen that the metadata that GAMA maintains about the different projects (which includes the various markers on files in the workspace, etc.) becomes corrupted from time to time. This especially happens if you frequently switch workspaces, but not only. In those (hopefully rare) cases, GAMA may report incorrect errors for perfectly legible files.\nWhen such odd behaviors are detected, or if you want to regularly keep your metadata in a good shape, you can clean all your project, by clicking on the button \"Clear and validate all projects\" (in the syntax errors view).\n"},{"filePath":"https:--gama-platform.org--wiki-VariablesAndAttributes.txt","text":"Variables and AttributesVariables and attributes represent named data that can be used in an expression. They can be accessed depending on their scope:\n\nthe scope of attributes declared in a species is itself, its child species and its micro-species.\nthe scope of temporary variables is the one in which they have been declared, and all its sub-scopes.\nOutside its scope of validity, an expression cannot use a variable or an attribute directly. However, attributes can be used in a remote fashion by using a dotted notation on a given agent (see here).\n\nTable of contents​\n\nVariables and Attributes\n\nDirect Access\nRemote Access\n\n\n\nDirect Access​\nWhen an agent wants to use either one of the variables declared locally, one of the attributes declared in its species (or parent species), one of the attributes declared in the macro-species of its species, it can directly invoke its name and the compiler will do the rest (i.e. finding the variable or attribute in the right scope).\nFor instance, we can have a look at the following example:\nspecies animal {   float energy <- 1000 min: 0 max: 2000 update: energy - 0.001;   int age_in_years <- 1 update: age_in_years + int (time / 365);      action eat (float amount <- 0) {       float gain <- amount / age_in_years;       energy <- energy + gain;   }   reflex feed {      int food_found <- rnd(100);      do eat (amount: food_found);    }}\nSpecies declaration​\nEverywhere in the species declaration, we are able to directly name and use:\n\ntime, a global built-in variable,\nenergy and age_in_years, the two species attributes.\n\nNevertheless, in the species declaration, but outside of the action eat and the reflex feed, we cannot name the variables:\n\namount, the argument of eat action,\ngain, a local variable defined into the eat action,\nfood_found, the local variable defined into the feed reflex.\n\nEat action declaration​\nIn the eat action declaration, we can directly name and use:\n\ntime, a global built-in variable,\nenergy and age_in_years, the two species attributes,\namount, which is an argument to the action eat,\ngain, a temporary variable within the action.\n\nWe cannot name and use the variables:\n\nfood_found, the local variable defined into the feed reflex.\n\nfeed reflex declaration​\nSimilarly, in the feed reflex declaration, we can directly name and use:\n\ntime, a global built-in variable,\nenergy and age_in_years, the two species variables,\nfood_found, the local variable defined into the reflex.\n\nBut we cannot access to variables:\n\namount, the argument of eat action,\ngain, a local variable defined into the eat action.\n\nRemote Access​\nWhen an expression needs to get access to the attribute of an agent which does not belong to its scope of execution, a special notation (similar to that used in Java) has to be used:\nremote_agent.variable\nwhere remote_agent can be the name of an agent, an expression returning an agent, self, myself or each. For instance, if we modify the previous species by giving its agents the possibility to feed another agent found in its neighborhood, the result would be:\nspecies animal {   float energy <- 1000 min: 0 max: 2000 update: energy - 0.001;   int age_in_years <- 1 update: age_in_years + int (time / 365);   action eat (float amount <- 0.0) {       float gain <- amount / age_in_years;       energy <- energy + gain;   }   action feed (animal target){       if (agent_to_feed != nil) and (agent_to_feed.energy < energy { // verifies that the agent exists and that it need to be fed            ask agent_to_feed {                do eat amount: myself.energy / 10; // asks the agent to eat 10% of our own energy            }            energy <- energy - (energy / 10); // reduces the energy by 10%       }   }   reflex {       animal candidates <- agents_overlapping (10 around agent.shape); gathers all the neighbors       agent_to_feed value: candidates with_min_of (each.energy); //grabs one agent with the lowest energy        do feed target: agent_to_feed; // tries to feed it   }}\nIn this example, agent_to_feed.energy, myself.energy and each.energy show different remote accesses to the attribute energy. The dotted notation used here can be employed in assignments as well. For instance, an action allowing two agents to exchange their energy could be defined as:\naction random_exchange {//exchanges our energy with that of the closest agent     animal one_agent <- agent_closest_to (self);     float temp <- one_agent.energy; // temporary storage of the agent's energy     one_agent.energy <- energy; // assignment of the agent's energy with our energy     energy <- temp;}"},{"filePath":"https:--gama-platform.org--wiki-WorkspaceProjectsAndModels.txt","text":"Workspace, Projects and ModelsThe workspace is a directory in which GAMA stores all the current projects on which the user is working, links to other projects, as well as some meta-data like preference settings, the current status of the different projects, error markers, and so on.\nExcept when running in headless mode, GAMA cannot function without a valid workspace.\nThe workspace is organized in 4 categories, which are themselves organized into projects.\nThe projects present in the workspace can be either directly stored within it (as sub-directories), which is usually the case when the user creates a new project, or linked from it (so the workspace will only contain a link to the directory of the project, supposed to be somewhere in the filesystem or on the network). A same project can be linked from different workspaces.\nGAMA models files are stored in these projects, which may contain also other files (called resources) necessary for the models to function. A project may, of course, contain several model files, especially if they are importing each other, if they represent different views on the same topic, or if they share the same resources.\nLearning how to navigate in the workspace, how to switch workspace or how to import, export is a necessity to use GAMA correctly. It is the purpose of the following sections.\n\nNavigating in the Workspace\nChanging Workspace\nImporting Models\n"},{"filePath":"https:--gama-platform.org--wiki-Writing_Tests.txt","text":"Writing Unit Tests in GAMLUnit testing is an essential instrument to ensure the quality of any software and it has been implemented in GAMA: this allows in particular that parts of the model are behaving as expected and that evolutions in the model do not introduce unexpected changes. To these purposes, the modeler can define a set of assertions that will be tested. Before the execution of the embedded set of instructions, if a setup is defined in the species, model or experiment, it is executed. In a test, if one assertion fails, the evaluation of other assertions continue.\nWriting tests in GAML involves the use of 4 keywords:\n\nassert statement,\ntest statement,\nsetup statement,\ntype: test facet of experiment.\n\nIn this unit testing tutorial, we intend to show how to write unit tests in GAML using the statement test.\nWhat is test in GAML?​\nIn GAML, the statement test allows the modeler to write a part of code lines to verify if portions of our GAML model are doing exactly what they are expected to do: this is done through the use of several assertions (using assert statements). This is done independently from other parts of the model.\nTo write a typical GAML unit test, we can follow three steps:\n\nDefine a set of attributes to use within the test,\nWrite initialization instructions,\nWrite assertions.\n\nThe aim of using unit testing is to observe the resulting behavior of some parts of our model. If the observed behavior is consistent with the expectations, the unit test passes, otherwise, it fails, indicating that there is a problem concerning the tested part of the model.\nIntroduction to assertions​\nThe basis of Unit tests is to check that given pieces of codes provide expected results. To this purpose, the modeler can write some basic tests that should be true: s/he thus asserts that such expression can be evaluated to true using the assert statement. Here are some examples of assert uses:\nassert 1 + 1 = 2;assert isGreater(5, 6) = false;assert rnd(1.0) <= 1.0;\nWith the above statements, the modeler states the 1+1 is equal to 2, isGreater(5,6) is false (given the fact that isGreater is an action defined in a species) and rnd(1.0) always returns a value below 1.0.\nassert can be used in any behavior statement (as an example in a reflex, a state or in a test. Note that, if they are written outside of a test and that the test is not fulfilled, then an exception is thrown during their execution.\nAs an example, the following model throws the exception: Assert failed 3>4 (as obviously 3 is not greater than 4 and that the GAML > operator is properly implemented on this case).\nmodel NewModelglobal {    init {\tassert 3 > 4;    }}experiment NewModel type: gui {}\nTo be able to have a dashboard of the state of your model w.r.t. the unit tests, they need to be written in a test and the model launched with an experiment of type test.\nHow to write a GAML test?​\nA test statement can be used in any species (regular species, global or experiment species) everywhere a reflex can be used. Its aim is to gather several asserts in one block. If the tests are executed with any kind of experiment but test, they will be executed, but nothing is reported. With a test experiment, a kind of dashboard will be displayed.\nSo we will consider that we start by adding an experiment with type set to test. The following code shows an example.\nexperiment MyTest type: test autorun: true {     ...}\nLet's consider the following GAML code:\nmodel TestModelglobal {    init {\tcreate test_agent number: 1;    }}species test_agent {    bool isGreater (int p1, int p2) {\tif (p1 >= p2) {\t    return true;\t} else {\t    return false;\t}    }    test testsOK {\tassert isGreater(5, 6) = false;\tassert isGreater(6, 5) = true;    }        test failingTests {\tassert ! isGreater(6, 6);    }        }experiment MyTest type: test autorun: true { }\nIn this example, the defined action, isGreater, returns true if a parameter p1 is greater than a parameter p2 and false if not. So to test it, we declare a unit test using test and add inside several assert statements. For instance, assert isGreater(5, 6) = false; will return true if the result of isGreater(5, 6) is really false and false if not. So, if the action isGreater is well-defined, it should return false. Considering that \"greater\" and \"greater and equal\" should be two different functions, we add a test to check that isGreater does not return true in case of equality of its 2 operands. In this case, as the action is not-well implemented the test fails.\nThe following picture illustrates the GUI dashboard for unit tests, showing for each test and even each assert whether it passes or fails. Clicking on the button will display in the GAML editor the code line.\n\nUse of the setup statement​\nIn a species where we want to execute several tests, it is common to want to have the same initial states, in order to prevent the previous tests to have modified the tested object and thus altering the unit test results. To this purpose, we can add the setup statement in the species and use it to set the expected initial state of the object to be tested. It will be called before every test.\nAs an example, in the following model, we want to test the operator translated_by and translated_to on a point. As each of them will modify the point object to be tested, wed add a setup to reinitialize it.\nmodel TestModelglobal {    geometry loc <- {0,0};\t    setup {\tloc <- {0,0};\t    }    test translate_to {\tloc <- loc translated_to {10,10};\tloc <- loc translated_to {10,10};\tassert loc.location = {10,10};    }\t    test translated_by {\tloc <- loc translated_by {10,10};\tloc <- loc translated_by {10,10};\tassert loc.location = {20,20};    }}experiment MyTest type: test autorun: true { }\nThe test experiment​\nIt is also possible to write tests in the experiment. The main idea is here to totally separate the model and its tests.\nAs an example let's consider the following GAML code, which aims to test several GAML operators, related to the graph datatype:\nmodel TestGraphsglobal {    graph the_graph;    init {\tint i <- 10;\tcreate node_agent number: 7 {\t    location <- {i, i + ((i / 10) mod 2) * 10};\t    i <- i + 10;\t}\tthe_graph <- as_distance_graph(node_agent, 30.0);    }}species edge_agent {    aspect default {\tdraw shape color: #black;    }}species node_agent {    aspect default {\tdraw circle(1) color: #red;\tloop neigh over: the_graph neighbors_of self {\t    draw line([self.location, agent(neigh).location]) color: #black;\t}    }}experiment loadgraph type: gui {    output {\tdisplay map type: opengl {\t    species edge_agent;\t    species node_agent;\t}    }}experiment MyTest type: test autorun: true {    test \"MyFirstTest\" {\twrite the_graph;\twrite (node_agent[2]);\twrite (\"Degrees\");\twrite (the_graph in_degree_of (node_agent[2]));\twrite (the_graph out_degree_of (node_agent[2]));\twrite (the_graph degree_of (node_agent[2]));\tassert the_graph in_degree_of (node_agent[2]) = 4;\twrite (the_graph out_degree_of (node_agent[2]));\tassert the_graph out_degree_of (node_agent[2]) = 4;\tassert the_graph degree_of (node_agent[2]) = 8;    }}"},{"filePath":"https:--gama-platform.org--wiki-developingGAMA.txt","text":"Get into the GAMA Java APIGAMA is written in Java and made of tens of Eclipse plugins and projects, thousand of classes, methods and annotations. This section of the wiki should help you have a general idea on how to manipulate GAMA Java API and where to find the proper classes and methods. A general introduction to the GAMA architecture gives a general overview of the organization of Java packages and Eclipse plugins, and should be read first. In the following sub-sections we give a more practical introduction.\n\nIntroduction to GAMA Java API\n\nInstalling the GIT version\nArchitecture of GAMA\nIScope\n\n\nDeveloping Extensions\n\nDeveloping Plugins\nDeveloping Skills\nDeveloping Statements\nDeveloping Operators\nDeveloping Types\nDeveloping Species\nDeveloping Control Architectures\nIndex of annotations\n\n\nCreate a release of Gama\nGeneration of the documentation\n"}]